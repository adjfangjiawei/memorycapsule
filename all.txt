// cpporm/builder_parts/query_builder_core.cpp
#include "cpporm/query_builder_core.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h" // For Session::anyToQueryValueForSessionConvenience

#include <QDebug>
#include <QMetaType>
#include <sstream>
#include <variant>

namespace cpporm {

// Non-template member function definitions for QueryBuilder have been moved to:
// - query_builder_lifecycle.cpp (constructors, destructor, assignments)
// - query_builder_setters_core.cpp (Model, Table, From, With, OnConflict,
// SelectSubquery, QB-specific Where/Or/Not)
// - query_builder_execution_non_template.cpp (First(ModelBase&), Find, Create,
// Updates, Delete, Save, Count)
// - query_builder_utils.cpp (getFromSourceName, AsSubquery, static
// quoteSqlIdentifier, static toQVariant, toSqlDebug)
// - query_builder_helpers.cpp (internal SQL build helpers)

// This file (query_builder_core.cpp) is now primarily for any potential future
// non-template, non-static QueryBuilder methods that don't fit into the above
// categories, or if some specific core logic needed a central, non-header
// definition point. Currently, based on the linker errors, it seems all
// problematic definitions were duplicated from their intended separate files.

} // namespace cpporm// cpporm/builder_parts/query_builder_execution_non_template.cpp
#include "cpporm/i_query_executor.h"   // For IQueryExecutor
#include "cpporm/query_builder_core.h" // For QueryBuilder definition
#include "cpporm/session.h" // For Session::anyToQueryValueForSessionConvenience

namespace cpporm {

Error QueryBuilder::First(ModelBase &result_model) {
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

  const ModelMeta &meta = result_model._getOwnModelMeta();
  if (this->state_.model_meta_ != &meta) {
    this->Model(meta);
  }

  std::map<std::string, QueryValue> pk_conditions;
  bool all_pks_set_in_model = true;
  if (meta.primary_keys_db_names.empty()) {
    all_pks_set_in_model = false;
  } else {
    for (const std::string &pk_db_name : meta.primary_keys_db_names) {
      const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
      if (!pk_field) {
        all_pks_set_in_model = false;
        break;
      }
      std::any pk_val_any = result_model.getFieldValue(pk_field->cpp_name);
      if (!pk_val_any.has_value()) {
        all_pks_set_in_model = false;
        break;
      }
      // Use Session's public static helper for conversion
      QueryValue qv = Session::anyToQueryValueForSessionConvenience(pk_val_any);

      bool use_this_pk_value = false;
      if (std::holds_alternative<int>(qv) && std::get<int>(qv) != 0)
        use_this_pk_value = true;
      else if (std::holds_alternative<long long>(qv) &&
               std::get<long long>(qv) != 0)
        use_this_pk_value = true;
      else if (std::holds_alternative<std::string>(qv) &&
               !std::get<std::string>(qv).empty())
        use_this_pk_value = true;
      // Add other QueryValue types if they can be PKs and have non-default
      // "empty" states

      if (use_this_pk_value) {
        pk_conditions[pk_db_name] = qv;
      } else {
        all_pks_set_in_model = false;
        break;
      }
    }
  }

  if (all_pks_set_in_model && !pk_conditions.empty()) {
    this->Where(
        pk_conditions); // This calls the mixin's Where or QB's own Where
  } else {
    // If not searching by PKs from the model, or if PKs were empty/default,
    // apply default ordering by PK for "First" if not already ordered.
    // This matches GORM's behavior of ordering by primary key when finding the
    // first record without explicit conditions.
    if (!meta.primary_keys_db_names.empty() &&
        this->state_.order_clause_.empty()) {
      std::string order_by_pk_clause;
      for (size_t i = 0; i < meta.primary_keys_db_names.size(); ++i) {
        order_by_pk_clause +=
            quoteSqlIdentifier( // Uses static QB::quoteSqlIdentifier
                meta.primary_keys_db_names[i]);
        if (i < meta.primary_keys_db_names.size() - 1)
          order_by_pk_clause += ", ";
      }
      if (!order_by_pk_clause.empty()) {
        this->Order(order_by_pk_clause); // Calls mixin's Order
      }
    }
  }
  return executor_->FirstImpl(*this, result_model);
}

Error QueryBuilder::Find(
    std::vector<std::unique_ptr<ModelBase>> &results_vector,
    std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

  if (!this->state_.model_meta_ && element_type_factory) {
    auto temp_instance = element_type_factory();
    if (temp_instance) {
      this->Model(temp_instance->_getOwnModelMeta()); // Calls QB's Model
    } else {
      return Error(ErrorCode::InternalError,
                   "Model factory returned nullptr for Find.");
    }
  } else if (!this->state_.model_meta_ && !element_type_factory) {
    return Error(ErrorCode::InvalidConfiguration,
                 "Find requires ModelMeta or an element factory.");
  }

  return executor_->FindImpl(*this, results_vector, element_type_factory);
}

std::expected<QVariant, Error>
QueryBuilder::Create(ModelBase &model,
                     const OnConflictClause *conflict_options_override) {
  if (!executor_)
    return std::unexpected(
        Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &model._getOwnModelMeta()) {
    this->Model(model._getOwnModelMeta());
  }
  const OnConflictClause *final_conflict_options = conflict_options_override;
  if (!final_conflict_options && this->state_.on_conflict_clause_) {
    final_conflict_options = this->state_.on_conflict_clause_.get();
  }
  return executor_->CreateImpl(*this, model, final_conflict_options);
}

std::expected<long long, Error>
QueryBuilder::Updates(const std::map<std::string, QueryValue> &updates) {
  if (!executor_)
    return std::unexpected(
        Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
  if (!this->state_.model_meta_ &&
      (this->state_.from_clause_source_.index() == 0 &&
       std::get<std::string>(this->state_.from_clause_source_).empty())) {
    return std::unexpected(
        Error(ErrorCode::InvalidConfiguration,
              "Updates requires a Model or Table to be set."));
  }
  return executor_->UpdatesImpl(*this, updates);
}

std::expected<long long, Error> QueryBuilder::Delete() {
  if (!executor_)
    return std::unexpected(
        Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
  if (!this->state_.model_meta_ &&
      (this->state_.from_clause_source_.index() == 0 &&
       std::get<std::string>(this->state_.from_clause_source_).empty())) {
    return std::unexpected(
        Error(ErrorCode::InvalidConfiguration,
              "Delete requires a Model or Table to be set."));
  }
  return executor_->DeleteImpl(*this);
}

std::expected<long long, Error> QueryBuilder::Save(ModelBase &model) {
  if (!executor_)
    return std::unexpected(
        Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &model._getOwnModelMeta()) {
    this->Model(model._getOwnModelMeta());
  }
  return executor_->SaveImpl(*this, model);
}

std::expected<int64_t, Error> QueryBuilder::Count() {
  if (!executor_)
    return std::unexpected(
        Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
  if (!this->state_.model_meta_ &&
      (this->state_.from_clause_source_.index() == 0 &&
       std::get<std::string>(this->state_.from_clause_source_).empty())) {
    return std::unexpected(Error(ErrorCode::InvalidConfiguration,
                                 "Count requires a Model or Table to be set."));
  }
  return executor_->CountImpl(*this);
}

} // namespace cpporm// cpporm/builder_parts/query_builder_helpers.cpp
#include "cpporm/model_base.h" // For ModelMeta related logic
#include "cpporm/query_builder.h" // For QueryBuilder class and its members like quoteSqlIdentifier, toQVariant

#include <QDebug>
#include <QMetaType> // For QMetaType::UnknownType
#include <QVariant>
#include <sstream>
#include <variant> // For std::visit

namespace cpporm {

// --- Private SQL Building Helper Implementations for QueryBuilder ---

void QueryBuilder::build_ctes_sql_prefix(
    std::ostringstream &sql_stream,
    QVariantList &bound_params_accumulator) const {
  if (state_.ctes_.empty()) {
    return;
  }

  sql_stream << "WITH ";
  bool has_recursive_cte = false;
  for (const auto &cte_state : state_.ctes_) {
    if (cte_state.recursive) {
      has_recursive_cte = true;
      break;
    }
  }
  if (has_recursive_cte) {
    sql_stream << "RECURSIVE ";
  }

  for (size_t i = 0; i < state_.ctes_.size(); ++i) {
    const auto &cte = state_.ctes_[i];
    sql_stream << quoteSqlIdentifier(cte.name) << " AS (";
    sql_stream << cte.query.sql_string;
    sql_stream << ")";

    for (const auto &binding_variant : cte.query.bindings) {
      std::visit(
          [&bound_params_accumulator](auto &&arg_val) {
            using ArgT = std::decay_t<decltype(arg_val)>;
            if constexpr (std::is_same_v<ArgT, std::nullptr_t>) {
              bound_params_accumulator.append(
                  QVariant(QMetaType(QMetaType::UnknownType)));
            } else if constexpr (std::is_same_v<ArgT, std::string>) {
              bound_params_accumulator.append(QString::fromStdString(arg_val));
            } else if constexpr (std::is_same_v<ArgT, int> ||
                                 std::is_same_v<ArgT, long long> ||
                                 std::is_same_v<ArgT, double> ||
                                 std::is_same_v<ArgT, bool> ||
                                 std::is_same_v<ArgT, QDateTime> ||
                                 std::is_same_v<ArgT, QDate> ||
                                 std::is_same_v<ArgT, QTime> ||
                                 std::is_same_v<ArgT, QByteArray>) {
              bound_params_accumulator.append(QVariant::fromValue(arg_val));
            } else {
              qWarning() << "QueryBuilder::build_ctes_sql_prefix: Unhandled "
                            "native type in "
                            "CTE binding for QVariant conversion:"
                         << typeid(ArgT).name();
            }
          },
          binding_variant);
    }
    if (i < state_.ctes_.size() - 1) {
      sql_stream << ", ";
    }
  }
  sql_stream << " ";
}

bool QueryBuilder::build_one_condition_block_internal_static_helper(
    std::ostringstream &to_stream, QVariantList &bindings_acc,
    const std::vector<Condition> &conditions_group,
    const std::string &op_within_group, bool is_not_group) {

  if (conditions_group.empty()) {
    return false;
  }

  if (is_not_group) {
    to_stream << "NOT ";
  }

  to_stream << "(";

  for (size_t i = 0; i < conditions_group.size(); ++i) {
    if (i > 0) {
      to_stream << " " << op_within_group << " ";
    }

    const std::string &local_query_string = conditions_group[i].query_string;
    const std::vector<QueryValue> &local_args = conditions_group[i].args;

    std::string::size_type last_pos = 0;
    std::string::size_type find_pos = 0;
    int arg_idx = 0;

    while ((find_pos = local_query_string.find('?', last_pos)) !=
           std::string::npos) {
      to_stream << local_query_string.substr(last_pos, find_pos - last_pos);
      if (arg_idx < static_cast<int>(local_args.size())) {
        const auto &arg_value = local_args[arg_idx++];
        QVariant qv_arg = QueryBuilder::toQVariant(arg_value, bindings_acc);
        if (std::holds_alternative<SubqueryExpression>(arg_value)) {
          to_stream << qv_arg.toString().toStdString();
        } else {
          to_stream << "?";
          bindings_acc.append(qv_arg);
        }
      } else {
        qWarning() << "cpporm: Not enough arguments for placeholders in "
                      "condition string:"
                   << QString::fromStdString(local_query_string);
        to_stream << "?";
      }
      last_pos = find_pos + 1;
    }
    to_stream << local_query_string.substr(last_pos);

    if (arg_idx < static_cast<int>(local_args.size())) {
      bool only_subqueries_left = true;
      for (size_t k = arg_idx; k < local_args.size(); ++k) {
        if (!std::holds_alternative<SubqueryExpression>(local_args[k])) {
          only_subqueries_left = false;
          break;
        }
      }
      if (!only_subqueries_left) {
        qWarning() << "cpporm: Too many non-subquery arguments for "
                      "placeholders in condition string:"
                   << QString::fromStdString(local_query_string);
      }
    }
  }
  to_stream << ")";
  return true;
}

void QueryBuilder::build_condition_logic_internal(
    std::ostringstream &sql_stream, QVariantList &bound_params_accumulator,
    bool &first_overall_condition_written,
    const std::string &prepended_scope_sql) const {

  std::ostringstream user_conditions_builder_ss;
  QVariantList user_conditions_bindings_list;
  // bool has_where_conditions = false; // Not used in current logic
  // bool has_or_conditions = false;    // Not used in current logic
  bool any_user_condition_written = false;

  if (!state_.where_conditions_.empty()) {
    if (any_user_condition_written) // Should always be false on first entry
                                    // here
      user_conditions_builder_ss << " AND ";
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_conditions_builder_ss, user_conditions_bindings_list,
        state_.where_conditions_, "AND", false);
    // has_where_conditions = true; // Not used
    any_user_condition_written = true;
  }

  if (!state_.or_conditions_.empty()) {
    if (any_user_condition_written) // Could be true if where_conditions_ was
                                    // processed
      user_conditions_builder_ss << " OR ";
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_conditions_builder_ss, user_conditions_bindings_list,
        state_.or_conditions_, "OR", false);
    // has_or_conditions = true; // Not used
    any_user_condition_written = true;
  }

  if (!state_.not_conditions_.empty()) {
    if (any_user_condition_written) // Could be true if where_conditions_ or
                                    // or_conditions_ was processed
      user_conditions_builder_ss << " AND ";
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_conditions_builder_ss, user_conditions_bindings_list,
        state_.not_conditions_, "AND", true);
    any_user_condition_written = true;
  }

  std::string user_conditions_final_sql = user_conditions_builder_ss.str();
  bool main_clause_keyword_written_this_call = false;

  if (!prepended_scope_sql.empty()) {
    if (first_overall_condition_written) {
      // sql_stream << (state_.having_condition_ ? " HAVING " : " WHERE "); //
      // ORIGINAL BUGGY LINE
      sql_stream
          << " WHERE "; // FIXED: Always use WHERE for row-level conditions
      first_overall_condition_written = false;
      main_clause_keyword_written_this_call = true;
    } else {
      sql_stream << " AND ";
    }
    sql_stream << "(" << prepended_scope_sql << ")";
  }

  if (!user_conditions_final_sql.empty()) {
    if (first_overall_condition_written) {
      // sql_stream << (state_.having_condition_ ? " HAVING " : " WHERE "); //
      // ORIGINAL BUGGY LINE
      sql_stream
          << " WHERE "; // FIXED: Always use WHERE for row-level conditions
      first_overall_condition_written = false;
      main_clause_keyword_written_this_call = true;
    } else {
      // This complex 'else' block tries to decide if "AND" is needed.
      // A simpler approach if main_clause_keyword_written_this_call or
      // !prepended_scope_sql.empty() is true means that a condition (or the
      // "WHERE" keyword) was already written by *this function call* or for
      // *this scope*, thus "AND" is appropriate.
      if (main_clause_keyword_written_this_call ||
          !prepended_scope_sql.empty()) {
        sql_stream << " AND ";
      } else {
        // If neither scope SQL nor main keyword was written *by this call*,
        // but first_overall_condition_written is false (meaning something
        // external already started a WHERE clause), we still need an "AND". The
        // original complex logic might be trying to be too smart. A robust
        // solution might be to ensure `buildSelectSQL` manages the absolute
        // first `WHERE` and subsequent calls to
        // `build_condition_logic_internal` (if any for different groups, though
        // not current design) or internal parts always prepend `AND`. For now,
        // the original logic for this specific 'else' path:
        std::string current_sql = sql_stream.str();
        if (!current_sql.empty()) {
          char last_char = ' ';
          for (auto it = current_sql.rbegin(); it != current_sql.rend(); ++it) {
            if (*it != ' ') {
              last_char = *it;
              break;
            }
          }
          // If the stream doesn't end with an opening parenthesis or a space,
          // it implies we need an AND to connect to previous content.
          if (last_char != '(' && last_char != ' ') {
            sql_stream << " AND ";
          }
          // This condition seems redundant if the above 'if' handles
          // !prepended_scope_sql.empty() else if (last_char == ' ' &&
          // !prepended_scope_sql.empty()) {
          //   sql_stream << " AND ";
          // }
        }
      }
    }
    sql_stream << "(" << user_conditions_final_sql << ")";
    bound_params_accumulator.append(user_conditions_bindings_list);
  }
}

} // namespace cpporm// cpporm/builder_parts/query_builder_lifecycle.cpp
#include "cpporm/query_builder_core.h" // For QueryBuilder definition

namespace cpporm {

QueryBuilder::QueryBuilder(IQueryExecutor *executor, QString connection_name,
                           const ModelMeta *model_meta)
    : executor_(executor), connection_name_(std::move(connection_name)) {
  if (model_meta) {
    this->state_.model_meta_ = model_meta;
    if (!model_meta->table_name.empty()) {
      this->state_.from_clause_source_ = model_meta->table_name;
    }
  }
  // Default select_fields_ is already "*" in QueryBuilderState constructor
}

QueryBuilder::QueryBuilder(const QueryBuilder &other)
    : executor_(other.executor_), connection_name_(other.connection_name_),
      state_(other.state_) {}

QueryBuilder &QueryBuilder::operator=(const QueryBuilder &other) {
  if (this != &other) {
    this->executor_ = other.executor_;
    this->connection_name_ = other.connection_name_;
    this->state_ = other.state_;
  }
  return *this;
}

QueryBuilder::QueryBuilder(QueryBuilder &&other) noexcept
    : executor_(other.executor_),
      connection_name_(std::move(other.connection_name_)),
      state_(std::move(other.state_)) {
  other.executor_ = nullptr;
}

QueryBuilder &QueryBuilder::operator=(QueryBuilder &&other) noexcept {
  if (this != &other) {
    this->executor_ = other.executor_;
    this->connection_name_ = std::move(other.connection_name_);
    this->state_ = std::move(other.state_);
    other.executor_ = nullptr;
  }
  return *this;
}

QueryBuilder::~QueryBuilder() = default;

} // namespace cpporm#include "cpporm/builder_parts/query_builder_conditions_mixin.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder_core.h"
#include <QDebug>

namespace cpporm {

// --- 核心 Model/Table/From 设置器 ---
QueryBuilder &QueryBuilder::Model(const ModelBase *model_instance_hint) {
  if (model_instance_hint) {
    const ModelMeta &meta = model_instance_hint->_getOwnModelMeta();
    this->state_.model_meta_ = &meta;
    if (!meta.table_name.empty()) {
      this->state_.from_clause_source_ = meta.table_name;
    } else {
      this->state_.from_clause_source_ = std::string("");
    }
  } else {
    this->state_.model_meta_ = nullptr;
    this->state_.from_clause_source_ = std::string("");
  }
  return *this;
}

QueryBuilder &QueryBuilder::Model(const ModelMeta &meta) {
  this->state_.model_meta_ = &meta;
  if (!meta.table_name.empty()) {
    this->state_.from_clause_source_ = meta.table_name;
  } else {
    this->state_.from_clause_source_ = std::string("");
  }
  return *this;
}

QueryBuilder &QueryBuilder::Table(std::string table_name) {
  this->state_.from_clause_source_ = std::move(table_name);
  if (this->state_.model_meta_ &&
      this->state_.model_meta_->table_name !=
          std::get<std::string>(this->state_.from_clause_source_)) {
    this->state_.model_meta_ = nullptr;
  }
  return *this;
}

QueryBuilder &QueryBuilder::From(std::string source_name_or_cte_alias) {
  std::string old_from_source_string_if_any;
  if (std::holds_alternative<std::string>(this->state_.from_clause_source_)) {
    old_from_source_string_if_any =
        std::get<std::string>(this->state_.from_clause_source_);
  }

  this->state_.from_clause_source_ = std::move(source_name_or_cte_alias);

  if (this->state_.model_meta_) {
    const std::string &new_from_str =
        std::get<std::string>(this->state_.from_clause_source_);
    bool is_known_cte = false;
    for (const auto &cte_def : this->state_.ctes_) {
      if (cte_def.name == new_from_str) {
        is_known_cte = true;
        break;
      }
    }
    if (is_known_cte || this->state_.model_meta_->table_name != new_from_str) {
      this->state_.model_meta_ = nullptr;
    }
  }
  return *this;
}

QueryBuilder &QueryBuilder::From(const QueryBuilder &subquery_builder,
                                 const std::string &alias) {
  auto sub_expr_expected = subquery_builder.AsSubquery();
  if (!sub_expr_expected.has_value()) {
    qWarning() << "cpporm QueryBuilder::From(QueryBuilder): Failed to create "
                  "subquery expression: "
               << QString::fromStdString(sub_expr_expected.error().message);
    return *this;
  }
  this->state_.from_clause_source_ =
      SubquerySource{std::move(sub_expr_expected.value()), alias};
  this->state_.model_meta_ = nullptr;
  return *this;
}

QueryBuilder &QueryBuilder::From(const SubqueryExpression &subquery_expr,
                                 const std::string &alias) {
  this->state_.from_clause_source_ = SubquerySource{subquery_expr, alias};
  this->state_.model_meta_ = nullptr;
  return *this;
}

// --- Specific Setters ---
QueryBuilder &QueryBuilder::SelectSubquery(const QueryBuilder &subquery_builder,
                                           const std::string &alias) {
  auto sub_expr_expected = subquery_builder.AsSubquery();
  if (!sub_expr_expected.has_value()) {
    qWarning() << "cpporm QueryBuilder::SelectSubquery(QueryBuilder): Failed "
                  "to create subquery expression: "
               << QString::fromStdString(sub_expr_expected.error().message);
    return *this;
  }
  // 使用 AddSelect 将子查询添加到选择列表，它会处理默认的 "*"
  this->QueryBuilderClausesMixin<QueryBuilder>::AddSelect(
      NamedSubqueryField{std::move(sub_expr_expected.value()), alias});
  return *this;
}

QueryBuilder &
QueryBuilder::SelectSubquery(const SubqueryExpression &subquery_expr,
                             const std::string &alias) {
  // 使用 AddSelect 将子查询添加到选择列表
  this->QueryBuilderClausesMixin<QueryBuilder>::AddSelect(
      NamedSubqueryField{subquery_expr, alias});
  return *this;
}

QueryBuilder &QueryBuilder::With(const std::string &cte_name,
                                 const QueryBuilder &cte_query_builder,
                                 bool recursive) {
  auto sub_expr_expected = cte_query_builder.AsSubquery();
  if (!sub_expr_expected.has_value()) {
    qWarning()
        << "cpporm QueryBuilder::With: Failed to create subquery for CTE"
        << QString::fromStdString(cte_name) << ":"
        << QString::fromStdString(sub_expr_expected.error().message);
    return *this;
  }
  state_.ctes_.emplace_back(cte_name, std::move(sub_expr_expected.value()),
                            recursive);
  return *this;
}

QueryBuilder &QueryBuilder::WithRaw(const std::string &cte_name,
                                    const std::string &raw_sql,
                                    const std::vector<QueryValue> &bindings,
                                    bool recursive) {
  std::vector<QueryValueVariantForSubquery> native_bindings;
  native_bindings.reserve(bindings.size());
  for (const auto &qv_arg : bindings) {
    std::visit(
        [&native_bindings](auto &&arg_val) {
          using ArgT = std::decay_t<decltype(arg_val)>;
          if constexpr (std::is_same_v<ArgT, SubqueryExpression>) {
            qWarning()
                << "cpporm QueryBuilder::WithRaw: SubqueryExpression as a "
                   "binding for raw CTE is complex. Only its bindings are "
                   "used.";
            for (const auto &sub_binding : arg_val.bindings) {
              native_bindings.push_back(sub_binding);
            }
          } else if constexpr (std::is_same_v<ArgT, std::nullptr_t> ||
                               std::is_same_v<ArgT, int> ||
                               std::is_same_v<ArgT, long long> ||
                               std::is_same_v<ArgT, double> ||
                               std::is_same_v<ArgT, std::string> ||
                               std::is_same_v<ArgT, bool> ||
                               std::is_same_v<ArgT, QDateTime> ||
                               std::is_same_v<ArgT, QDate> ||
                               std::is_same_v<ArgT, QTime> ||
                               std::is_same_v<ArgT, QByteArray>) {
            native_bindings.push_back(arg_val);
          } else {
            qWarning() << "QueryBuilder::WithRaw: Skipping unsupported "
                          "QueryValue variant type "
                       << typeid(ArgT).name() << " for raw CTE binding.";
          }
        },
        qv_arg);
  }
  state_.ctes_.emplace_back(
      cte_name, SubqueryExpression(raw_sql, native_bindings), recursive);
  return *this;
}

QueryBuilder &QueryBuilder::OnConflictUpdateAllExcluded() {
  if (!state_.on_conflict_clause_) {
    state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  state_.on_conflict_clause_->action =
      OnConflictClause::Action::UpdateAllExcluded;
  state_.on_conflict_clause_->update_assignments.clear();
  return *this;
}

QueryBuilder &QueryBuilder::OnConflictDoNothing() {
  if (!state_.on_conflict_clause_) {
    state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  state_.on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
  state_.on_conflict_clause_->update_assignments.clear();
  return *this;
}

QueryBuilder &QueryBuilder::OnConflictUpdateSpecific(
    std::function<void(OnConflictUpdateSetter &)> updater_fn) {
  if (!state_.on_conflict_clause_) {
    state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  state_.on_conflict_clause_->action = OnConflictClause::Action::UpdateSpecific;
  OnConflictUpdateSetter setter(*state_.on_conflict_clause_);
  updater_fn(setter);
  return *this;
}

// --- Implementations for QueryBuilder's own Where/Or/Not overloads ---

QueryBuilder &QueryBuilder::Where(const QueryBuilder &sub_qb_condition) {
  bool same_table_and_simple_source = false;

  QString this_from_name_qstr = this->getFromSourceName();
  QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

  if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() &&
      this_from_name_qstr == sub_from_name_qstr) {
    if (std::holds_alternative<std::string>(this->state_.from_clause_source_) &&
        std::get<std::string>(this->state_.from_clause_source_) ==
            this_from_name_qstr.toStdString() &&
        std::holds_alternative<std::string>(
            sub_qb_condition.state_.from_clause_source_) &&
        std::get<std::string>(sub_qb_condition.state_.from_clause_source_) ==
            sub_from_name_qstr.toStdString()) {
      same_table_and_simple_source = true;
    } else if (this->state_.model_meta_ &&
               sub_qb_condition.state_.model_meta_ &&
               this->state_.model_meta_ ==
                   sub_qb_condition.state_.model_meta_ &&
               std::holds_alternative<std::string>(
                   this->state_.from_clause_source_) &&
               std::get<std::string>(this->state_.from_clause_source_)
                   .empty() &&
               std::holds_alternative<std::string>(
                   sub_qb_condition.state_.from_clause_source_) &&
               std::get<std::string>(
                   sub_qb_condition.state_.from_clause_source_)
                   .empty()) {
      same_table_and_simple_source = true;
    }
  }

  if (same_table_and_simple_source) {
    auto [sub_cond_sql, sub_cond_args] =
        sub_qb_condition.buildConditionClauseGroup();
    if (!sub_cond_sql.empty()) {
      this->QueryBuilderConditionsMixin<QueryBuilder>::Where(sub_cond_sql,
                                                             sub_cond_args);
    }

    if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
      this->state_.apply_soft_delete_scope_ = false;
    }

  } else {

    auto sub_expr_expected = sub_qb_condition.AsSubquery();
    if (!sub_expr_expected) {
      qWarning() << "QueryBuilder::Where(const QueryBuilder& sub_qb): Failed "
                    "to convert subquery for EXISTS: "
                 << QString::fromStdString(sub_expr_expected.error().message);
      return *this;
    }
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Where(
        "EXISTS (?)",
        std::vector<QueryValue>{std::move(sub_expr_expected.value())});
  }
  return *this;
}

QueryBuilder &QueryBuilder::Or(const QueryBuilder &sub_qb_condition) {
  bool same_table_and_simple_source = false;
  QString this_from_name_qstr = this->getFromSourceName();
  QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

  if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() &&
      this_from_name_qstr == sub_from_name_qstr) {
    if (std::holds_alternative<std::string>(this->state_.from_clause_source_) &&
        std::get<std::string>(this->state_.from_clause_source_) ==
            this_from_name_qstr.toStdString() &&
        std::holds_alternative<std::string>(
            sub_qb_condition.state_.from_clause_source_) &&
        std::get<std::string>(sub_qb_condition.state_.from_clause_source_) ==
            sub_from_name_qstr.toStdString()) {
      same_table_and_simple_source = true;
    } else if (this->state_.model_meta_ &&
               sub_qb_condition.state_.model_meta_ &&
               this->state_.model_meta_ ==
                   sub_qb_condition.state_.model_meta_ &&
               std::holds_alternative<std::string>(
                   this->state_.from_clause_source_) &&
               std::get<std::string>(this->state_.from_clause_source_)
                   .empty() &&
               std::holds_alternative<std::string>(
                   sub_qb_condition.state_.from_clause_source_) &&
               std::get<std::string>(
                   sub_qb_condition.state_.from_clause_source_)
                   .empty()) {
      same_table_and_simple_source = true;
    }
  }

  if (same_table_and_simple_source) {
    auto [sub_cond_sql, sub_cond_args] =
        sub_qb_condition.buildConditionClauseGroup();
    if (!sub_cond_sql.empty()) {
      this->QueryBuilderConditionsMixin<QueryBuilder>::Or(sub_cond_sql,
                                                          sub_cond_args);
    }
    if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
      this->state_.apply_soft_delete_scope_ = false;
    }
  } else {
    auto sub_expr_expected = sub_qb_condition.AsSubquery();
    if (!sub_expr_expected) {
      qWarning() << "QueryBuilder::Or(const QueryBuilder& sub_qb): Failed to "
                    "convert subquery for EXISTS: "
                 << QString::fromStdString(sub_expr_expected.error().message);
      return *this;
    }
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Or(
        "EXISTS (?)",
        std::vector<QueryValue>{std::move(sub_expr_expected.value())});
  }
  return *this;
}

QueryBuilder &QueryBuilder::Not(const QueryBuilder &sub_qb_condition) {
  bool same_table_and_simple_source = false;
  QString this_from_name_qstr = this->getFromSourceName();
  QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

  if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() &&
      this_from_name_qstr == sub_from_name_qstr) {
    if (std::holds_alternative<std::string>(this->state_.from_clause_source_) &&
        std::get<std::string>(this->state_.from_clause_source_) ==
            this_from_name_qstr.toStdString() &&
        std::holds_alternative<std::string>(
            sub_qb_condition.state_.from_clause_source_) &&
        std::get<std::string>(sub_qb_condition.state_.from_clause_source_) ==
            sub_from_name_qstr.toStdString()) {
      same_table_and_simple_source = true;
    } else if (this->state_.model_meta_ &&
               sub_qb_condition.state_.model_meta_ &&
               this->state_.model_meta_ ==
                   sub_qb_condition.state_.model_meta_ &&
               std::holds_alternative<std::string>(
                   this->state_.from_clause_source_) &&
               std::get<std::string>(this->state_.from_clause_source_)
                   .empty() &&
               std::holds_alternative<std::string>(
                   sub_qb_condition.state_.from_clause_source_) &&
               std::get<std::string>(
                   sub_qb_condition.state_.from_clause_source_)
                   .empty()) {
      same_table_and_simple_source = true;
    }
  }

  if (same_table_and_simple_source) {
    auto [sub_cond_sql, sub_cond_args] =
        sub_qb_condition.buildConditionClauseGroup();
    if (!sub_cond_sql.empty()) {
      this->QueryBuilderConditionsMixin<QueryBuilder>::Not(sub_cond_sql,
                                                           sub_cond_args);
    }
    if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
      this->state_.apply_soft_delete_scope_ = false;
    }
  } else {
    auto sub_expr_expected = sub_qb_condition.AsSubquery();
    if (!sub_expr_expected) {
      qWarning() << "QueryBuilder::Not(const QueryBuilder& sub_qb): Failed to "
                    "convert subquery for EXISTS: "
                 << QString::fromStdString(sub_expr_expected.error().message);
      return *this;
    }
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Not(
        "EXISTS (?)",
        std::vector<QueryValue>{std::move(sub_expr_expected.value())});
  }
  return *this;
}

QueryBuilder &QueryBuilder::Where(
    const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
  if (sub_expr_expected.has_value()) {
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Where(
        "EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
  } else {
#ifdef QT_CORE_LIB
    qWarning() << "QueryBuilder::Where(expected<Subquery>): Subquery "
                  "generation failed: "
               << QString::fromStdString(sub_expr_expected.error().message)
               << ". Condition based on this subquery will not be added.";
#endif
  }
  return *this;
}

QueryBuilder &QueryBuilder::Or(
    const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
  if (sub_expr_expected.has_value()) {
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Or(
        "EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
  } else {
#ifdef QT_CORE_LIB
    qWarning()
        << "QueryBuilder::Or(expected<Subquery>): Subquery generation failed: "
        << QString::fromStdString(sub_expr_expected.error().message)
        << ". Condition based on this subquery will not be added.";
#endif
  }
  return *this;
}

QueryBuilder &QueryBuilder::Not(
    const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
  if (sub_expr_expected.has_value()) {
    return this->QueryBuilderConditionsMixin<QueryBuilder>::Not(
        "EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
  } else {
#ifdef QT_CORE_LIB
    qWarning()
        << "QueryBuilder::Not(expected<Subquery>): Subquery generation failed: "
        << QString::fromStdString(sub_expr_expected.error().message)
        << ". Condition based on this subquery will not be added.";
#endif
  }
  return *this;
}

} // namespace cpporm// cpporm/builder_parts/query_builder_sql_delete.cpp
#include "cpporm/model_base.h" // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h"

#include <QDebug>
#include <sstream>
#include <variant> // For std::holds_alternative

namespace cpporm {

std::pair<QString, QVariantList> QueryBuilder::buildDeleteSQL() const {
  if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
    qWarning("cpporm QueryBuilder::buildDeleteSQL: DELETE operation cannot "
             "target a subquery directly.");
    return {QString(), QVariantList()};
  }

  QString table_name_qstr = getFromSourceName(); // Use the helper
  if (table_name_qstr.isEmpty()) {
    qWarning("cpporm QueryBuilder: Table name not set for buildDeleteSQL.");
    return {QString(), QVariantList()};
  }

  std::ostringstream sql_stream;
  QVariantList bound_params_accumulator;
  sql_stream << "DELETE FROM "
             << quoteSqlIdentifier(table_name_qstr.toStdString());

  std::string soft_delete_target_fragment_for_hard_delete;
  if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
    // Check if the FROM source string matches the model's table name
    // or if FROM source string is empty (implying model's table)
    bool apply_sd_on_this_from_source = false;
    if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
      const std::string &from_name_str =
          std::get<std::string>(state_.from_clause_source_);
      if ((!from_name_str.empty() &&
           from_name_str == state_.model_meta_->table_name) ||
          (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
        apply_sd_on_this_from_source = true;
      }
    }
    if (apply_sd_on_this_from_source) {
      if (const FieldMeta *deleted_at_field =
              state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
        soft_delete_target_fragment_for_hard_delete =
            quoteSqlIdentifier(state_.model_meta_->table_name) + "." +
            quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
      }
    }
  }

  bool where_clause_started_by_builder = true;
  build_condition_logic_internal(sql_stream, bound_params_accumulator,
                                 where_clause_started_by_builder,
                                 soft_delete_target_fragment_for_hard_delete);

  if (where_clause_started_by_builder &&
      soft_delete_target_fragment_for_hard_delete.empty() &&
      state_.where_conditions_.empty() && state_.or_conditions_.empty() &&
      state_.not_conditions_.empty()) {
    qWarning() << "cpporm QueryBuilder::buildDeleteSQL: Generating DELETE "
                  "statement without a WHERE clause for table"
               << table_name_qstr
               << ". This will affect ALL rows if not intended.";
  }
  return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
}

} // namespace cpporm// cpporm/builder_parts/query_builder_sql_insert.cpp
#include "cpporm/model_base.h" // For ModelMeta, FieldMeta for OnConflictUpdateAllExcluded
#include "cpporm/query_builder.h"

#include <QDebug>
#include <sstream>
#include <variant> // For std::holds_alternative in QueryBuilder::toQVariant

namespace cpporm {

// This is the SOLE definition of buildInsertSQLSuffix
std::pair<QString, QVariantList> QueryBuilder::buildInsertSQLSuffix(
    const std::vector<std::string> &inserted_columns_db_names_for_values_clause)
    const {
  std::ostringstream sql_suffix_stream;
  QVariantList suffix_bindings_accumulator;

  if (!state_.on_conflict_clause_) {
    return {QString(), QVariantList()}; // No ON CONFLICT clause defined
  }

  QString driver_name_upper;
  // Attempt to get driver name hint from connection_name_ if QueryBuilder
  // stores it. This is a simplification; robust dialect handling is complex for
  // a standalone QB. Session should ideally be the one to finalize
  // dialect-specific parts.
  if (!connection_name_.isEmpty()) {
    if (connection_name_.contains("psql", Qt::CaseInsensitive) ||
        connection_name_.contains("postgres", Qt::CaseInsensitive)) {
      driver_name_upper = "QPSQL";
    } else if (connection_name_.contains("mysql", Qt::CaseInsensitive)) {
      driver_name_upper = "QMYSQL";
    }
    // Add other dialects if needed
  }
  if (driver_name_upper.isEmpty()) {
    // Fallback if connection_name_ doesn't give a hint or isn't
    // checked/available. qWarning() << "QueryBuilder::buildInsertSQLSuffix:
    // Could not reliably determine SQL dialect. Defaulting to MySQL syntax for
    // suffix.";
    driver_name_upper = "QMYSQL";
  }

  if (state_.on_conflict_clause_->action ==
      OnConflictClause::Action::DoNothing) {
    if (driver_name_upper == "QMYSQL") {
      return {QString(),
              QVariantList()}; // MySQL uses INSERT IGNORE, handled by Session
    } else if (driver_name_upper == "QPSQL") {
      sql_suffix_stream << " ON CONFLICT";
      // For PostgreSQL, ON CONFLICT DO NOTHING can be general or targeted.
      // If conflict_target_columns_db_names is set, use it.
      if (!state_.on_conflict_clause_->conflict_target_columns_db_names
               .empty()) {
        sql_suffix_stream << " (";
        for (size_t i = 0; i < state_.on_conflict_clause_
                                   ->conflict_target_columns_db_names.size();
             ++i) {
          sql_suffix_stream << quoteSqlIdentifier(
              state_.on_conflict_clause_->conflict_target_columns_db_names[i]);
          if (i < state_.on_conflict_clause_->conflict_target_columns_db_names
                          .size() -
                      1)
            sql_suffix_stream << ", ";
        }
        sql_suffix_stream << ")";
      }
      // If no specific target columns, it might be ON CONSTRAINT or a general
      // DO NOTHING if the DB implies target from PKs. GORM often requires
      // specifying a target for PG ON CONFLICT. For simplicity here, if no
      // target, assume general (might need specific constraint name in real
      // app).
      sql_suffix_stream << " DO NOTHING";
    }
    // Other dialects might have different syntaxes or no direct "DO NOTHING"
    // via suffix.
  } else if (state_.on_conflict_clause_->action ==
                 OnConflictClause::Action::UpdateAllExcluded ||
             state_.on_conflict_clause_->action ==
                 OnConflictClause::Action::UpdateSpecific) {
    bool first_update_col = true;
    if (driver_name_upper == "QMYSQL") {
      sql_suffix_stream << " ON DUPLICATE KEY UPDATE ";
    } else if (driver_name_upper == "QPSQL") {
      sql_suffix_stream << " ON CONFLICT ";
      // For PG, conflict target is crucial for DO UPDATE.
      // Use specified conflict_target_columns or default to PKs from
      // model_meta.
      std::vector<std::string> pg_conflict_targets;
      if (!state_.on_conflict_clause_->conflict_target_columns_db_names
               .empty()) {
        pg_conflict_targets =
            state_.on_conflict_clause_->conflict_target_columns_db_names;
      } else if (state_.model_meta_ &&
                 !state_.model_meta_->primary_keys_db_names.empty()) {
        pg_conflict_targets = state_.model_meta_->primary_keys_db_names;
      }

      if (!pg_conflict_targets.empty()) {
        sql_suffix_stream << "(";
        for (size_t i = 0; i < pg_conflict_targets.size(); ++i) {
          sql_suffix_stream << quoteSqlIdentifier(pg_conflict_targets[i]);
          if (i < pg_conflict_targets.size() - 1)
            sql_suffix_stream << ", ";
        }
        sql_suffix_stream << ") ";
      } else {
        qWarning("cpporm QueryBuilder: For PostgreSQL ON CONFLICT DO UPDATE, "
                 "conflict target (columns or PK) must be defined.");
        return {QString(), QVariantList()};
      }
      sql_suffix_stream << "DO UPDATE SET ";
    } else {
      // Default to MySQL like behavior or make it an error if dialect unknown
      // for update
      sql_suffix_stream << " ON DUPLICATE KEY UPDATE "; // Fallback
    }

    if (state_.on_conflict_clause_->action ==
        OnConflictClause::Action::UpdateAllExcluded) {
      if (inserted_columns_db_names_for_values_clause.empty() &&
          driver_name_upper !=
              "QPSQL" /*PG can update with empty list using EXCLUDED*/) {
        qWarning("cpporm QueryBuilder: OnConflictUpdateAllExcluded specified "
                 "for non-PG, "
                 "but no columns provided from INSERT part to determine "
                 "VALUES() updates.");
      }
      for (const std::string &db_col_name :
           inserted_columns_db_names_for_values_clause) {
        bool skip_this_column_in_set = false;
        if (state_.model_meta_) {
          for (const auto &pk_name_from_meta :
               state_.model_meta_->primary_keys_db_names) {
            if (pk_name_from_meta == db_col_name) {
              skip_this_column_in_set =
                  true; // Don't update PKs themselves in SET for MySQL
              break;
            }
          }
          if (driver_name_upper ==
              "QPSQL") { // For PG, don't update columns that are part of the
                         // conflict target
            const auto &conflict_targets =
                state_.on_conflict_clause_->conflict_target_columns_db_names
                            .empty() &&
                        state_.model_meta_
                    ? state_.model_meta_->primary_keys_db_names
                    : state_.on_conflict_clause_
                          ->conflict_target_columns_db_names;
            for (const auto &conflict_col : conflict_targets) {
              if (conflict_col == db_col_name) {
                skip_this_column_in_set = true;
                break;
              }
            }
          }
        }
        if (skip_this_column_in_set)
          continue;

        if (!first_update_col)
          sql_suffix_stream << ", ";

        sql_suffix_stream << quoteSqlIdentifier(db_col_name) << " = ";
        if (driver_name_upper == "QMYSQL") {
          sql_suffix_stream << "VALUES(" << quoteSqlIdentifier(db_col_name)
                            << ")";
        } else if (driver_name_upper == "QPSQL") {
          sql_suffix_stream << "EXCLUDED." << quoteSqlIdentifier(db_col_name);
        } else {
          sql_suffix_stream << "?";
          qWarning("QueryBuilder::buildInsertSQLSuffix: UpdateAllExcluded for "
                   "this dialect might need specific value passing or is not "
                   "fully supported by this generic builder.");
        }
        first_update_col = false;
      }
      if (first_update_col &&
          !inserted_columns_db_names_for_values_clause.empty()) {
        qWarning(
            "cpporm QueryBuilder: OnConflictUpdateAllExcluded resulted "
            "in empty SET clause (all conflicting/inserted columns might be "
            "PKs or conflict targets). SQL might be invalid.");
        // For some DBs, an empty SET clause is an error.
        // We return what's built, DB will decide. Or, return empty to signal
        // error. For now, let it pass, but this is a sign of problematic input
        // for some DBs.
      }
    } else if (state_.on_conflict_clause_->action ==
               OnConflictClause::Action::UpdateSpecific) {
      if (state_.on_conflict_clause_->update_assignments.empty()) {
        qWarning("cpporm QueryBuilder: OnConflictUpdateSpecific specified, "
                 "but no update assignments provided.");
      }
      for (const auto &assign_pair :
           state_.on_conflict_clause_->update_assignments) {
        // Ensure the column being set in UpdateSpecific is not part of the
        // conflict target for PG
        if (driver_name_upper == "QPSQL" && state_.model_meta_) {
          const auto &conflict_targets =
              state_.on_conflict_clause_->conflict_target_columns_db_names
                      .empty()
                  ? state_.model_meta_->primary_keys_db_names
                  : state_.on_conflict_clause_
                        ->conflict_target_columns_db_names;
          bool is_conflict_target_col = false;
          for (const auto &ct_col : conflict_targets) {
            if (ct_col == assign_pair.first) {
              is_conflict_target_col = true;
              break;
            }
          }
          if (is_conflict_target_col) {
            qWarning() << "QueryBuilder::buildInsertSQLSuffix (PG): Column '"
                       << QString::fromStdString(assign_pair.first)
                       << "' is part of the conflict target and cannot be in "
                          "the SET clause of ON CONFLICT DO UPDATE. Skipping.";
            continue;
          }
        }

        if (!first_update_col)
          sql_suffix_stream << ", ";
        sql_suffix_stream << quoteSqlIdentifier(assign_pair.first) << " = ";

        if (std::holds_alternative<SubqueryExpression>(assign_pair.second)) {
          sql_suffix_stream
              << QueryBuilder::toQVariant(assign_pair.second,
                                          suffix_bindings_accumulator)
                     .toString()
                     .toStdString();
        } else {
          sql_suffix_stream << "?";
          suffix_bindings_accumulator.append(QueryBuilder::toQVariant(
              assign_pair.second, suffix_bindings_accumulator));
        }
        first_update_col = false;
      }
    }

    if (first_update_col &&
        (state_.on_conflict_clause_->action ==
             OnConflictClause::Action::UpdateAllExcluded ||
         state_.on_conflict_clause_->action ==
             OnConflictClause::Action::UpdateSpecific) &&
        !state_.on_conflict_clause_->update_assignments
             .empty() /* For UpdateSpecific, if assignments were provided but
                         all got skipped */
    ) {
      qWarning("cpporm QueryBuilder::buildInsertSQLSuffix: Resulted in an ON "
               "CONFLICT UPDATE clause with no actual assignments (e.g. all "
               "specific assignments targeted conflict keys for PG). SQL may "
               "be invalid.");
      return {QString(), QVariantList()}; // Return empty string to indicate
                                          // failure to build valid suffix
    }
  }

  return {QString::fromStdString(sql_suffix_stream.str()),
          suffix_bindings_accumulator};
}

} // namespace cpporm#include "cpporm/model_base.h"    // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h" // Includes QueryBuilderState via query_builder.h -> query_builder_core.h -> ..._state.h

#include <QDebug>
#include <QMetaType>
#include <sstream>
#include <variant> // For std::visit

namespace cpporm {

std::pair<QString, QVariantList>
QueryBuilder::buildSelectSQL(bool for_subquery_generation) const {
  std::ostringstream sql_stream;
  QVariantList bound_params_accumulator;

  build_ctes_sql_prefix(sql_stream, bound_params_accumulator);

  sql_stream << "SELECT ";
  if (state_.apply_distinct_) { // Check if Distinct() was called
    sql_stream << "DISTINCT ";
  }

  auto get_field_select_expression =
      [this](const FieldMeta &fm) -> std::string {
    const QString &conn_name = this->getConnectionName();
    bool is_mysql = conn_name.contains("mysql", Qt::CaseInsensitive) ||
                    conn_name.contains("mariadb", Qt::CaseInsensitive);

    if (is_mysql) {
      if (fm.db_type_hint == "POINT") {
        return "ST_AsText(" + quoteSqlIdentifier(fm.db_name) + ") AS " +
               quoteSqlIdentifier(fm.db_name);
      } else if (fm.db_type_hint == "JSON") {
        return "CAST(" + quoteSqlIdentifier(fm.db_name) + " AS CHAR) AS " +
               quoteSqlIdentifier(fm.db_name);
      }
    }
    return quoteSqlIdentifier(fm.db_name);
  };

  if (state_.select_fields_.empty() ||
      (state_.select_fields_.size() == 1 &&
       std::holds_alternative<std::string>(state_.select_fields_[0]) &&
       std::get<std::string>(state_.select_fields_[0]) == "*")) {
    if (state_.model_meta_) {
      bool first_col = true;
      for (const auto &field_meta : state_.model_meta_->fields) {
        if (has_flag(field_meta.flags, FieldFlag::Association) ||
            field_meta.db_name.empty()) {
          continue;
        }
        if (!first_col) {
          sql_stream << ", ";
        }
        sql_stream << get_field_select_expression(field_meta);
        first_col = false;
      }
      if (first_col) {
        sql_stream << "*";
        qWarning("cpporm QueryBuilder::buildSelectSQL: SELECT * expanded to "
                 "no columns for model %s, falling back to literal '*'.",
                 state_.model_meta_->table_name.c_str());
      }
    } else {
      sql_stream << "*";
    }
  } else {
    for (size_t i = 0; i < state_.select_fields_.size(); ++i) {
      std::visit(
          [&sql_stream, &bound_params_accumulator, this](auto &&arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, std::string>) {
              sql_stream << arg;
            } else if constexpr (std::is_same_v<T, NamedSubqueryField>) {
              sql_stream << "(" << arg.subquery.sql_string << ") AS "
                         << quoteSqlIdentifier(arg.alias);
              for (const auto &sub_binding_variant : arg.subquery.bindings) {
                std::visit(
                    [&bound_params_accumulator](auto &&sub_val) {
                      using SubVT = std::decay_t<decltype(sub_val)>;
                      if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                        bound_params_accumulator.append(
                            QVariant(QMetaType(QMetaType::UnknownType)));
                      } else if constexpr (std::is_same_v<SubVT, std::string>) {
                        bound_params_accumulator.append(
                            QString::fromStdString(sub_val));
                      } else if constexpr (std::is_same_v<SubVT, QDateTime> ||
                                           std::is_same_v<SubVT, QDate> ||
                                           std::is_same_v<SubVT, QTime> ||
                                           std::is_same_v<SubVT, QByteArray> ||
                                           std::is_same_v<SubVT, bool> ||
                                           std::is_same_v<SubVT, int> ||
                                           std::is_same_v<SubVT, long long> ||
                                           std::is_same_v<SubVT, double>) {
                        bound_params_accumulator.append(
                            QVariant::fromValue(sub_val));
                      } else {
                        qWarning() << "buildSelectSQL (SelectField): Unhandled "
                                      "native type in NamedSubqueryField "
                                      "binding during QVariant conversion.";
                      }
                    },
                    sub_binding_variant);
              }
            }
          },
          state_.select_fields_[i]);
      if (i < state_.select_fields_.size() - 1) {
        sql_stream << ", ";
      }
    }
  }

  sql_stream << " FROM ";
  std::visit(
      [&sql_stream, &bound_params_accumulator, this](auto &&arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, std::string>) {
          QString table_name_qstr = this->getFromSourceName();
          if (table_name_qstr.isEmpty()) {
            qWarning("cpporm QueryBuilder: Table name is empty for "
                     "buildSelectSQL FROM clause.");
            sql_stream << "__MISSING_TABLE_NAME_IN_FROM__";
          } else {
            sql_stream << quoteSqlIdentifier(table_name_qstr.toStdString());
          }
        } else if constexpr (std::is_same_v<T, SubquerySource>) {
          sql_stream << "(" << arg.subquery.sql_string << ") AS "
                     << quoteSqlIdentifier(arg.alias);
          for (const auto &sub_binding_variant : arg.subquery.bindings) {
            std::visit(
                [&bound_params_accumulator](auto &&sub_val) {
                  using SubVT = std::decay_t<decltype(sub_val)>;
                  if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                    bound_params_accumulator.append(
                        QVariant(QMetaType(QMetaType::UnknownType)));
                  } else if constexpr (std::is_same_v<SubVT, std::string>) {
                    bound_params_accumulator.append(
                        QString::fromStdString(sub_val));
                  } else if constexpr (std::is_same_v<SubVT, QDateTime> ||
                                       std::is_same_v<SubVT, QDate> ||
                                       std::is_same_v<SubVT, QTime> ||
                                       std::is_same_v<SubVT, QByteArray> ||
                                       std::is_same_v<SubVT, bool> ||
                                       std::is_same_v<SubVT, int> ||
                                       std::is_same_v<SubVT, long long> ||
                                       std::is_same_v<SubVT, double>) {
                    bound_params_accumulator.append(
                        QVariant::fromValue(sub_val));
                  } else {
                    qWarning() << "buildSelectSQL (FromClauseSource): "
                                  "Unhandled native type in SubquerySource "
                                  "binding during QVariant conversion.";
                  }
                },
                sub_binding_variant);
          }
        }
      },
      state_.from_clause_source_);

  for (const auto &join : state_.join_clauses_) {
    if (!join.join_type.empty() && !join.table_to_join.empty() &&
        !join.on_condition.empty()) {
      sql_stream << " " << join.join_type << " JOIN "
                 << quoteSqlIdentifier(join.table_to_join) << " ON "
                 << join.on_condition;
    } else if (!join.on_condition.empty()) {
      sql_stream << " " << join.on_condition;
    } else {
      qWarning() << "cpporm QueryBuilder: Invalid join clause for source"
                 << getFromSourceName()
                 << "(type:" << QString::fromStdString(join.join_type)
                 << ", table:" << QString::fromStdString(join.table_to_join)
                 << ").";
    }
  }

  std::string soft_delete_sql_fragment;
  if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
    bool apply_sd_on_this_from_source = false;
    QString current_from_qstr = this->getFromSourceName();
    if (!current_from_qstr.isEmpty() &&
        state_.model_meta_->table_name == current_from_qstr.toStdString()) {
      apply_sd_on_this_from_source = true;
    }

    if (apply_sd_on_this_from_source) {
      if (const FieldMeta *deleted_at_field =
              state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
        soft_delete_sql_fragment =
            quoteSqlIdentifier(state_.model_meta_->table_name) + "." +
            quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
      }
    }
  }

  bool first_condition_written_flag = true;
  build_condition_logic_internal(sql_stream, bound_params_accumulator,
                                 first_condition_written_flag,
                                 soft_delete_sql_fragment);

  if (!state_.group_clause_.empty()) {
    sql_stream << " GROUP BY " << state_.group_clause_;
    if (state_.having_condition_) {
      sql_stream << " HAVING ";
      const std::string &having_query_str =
          state_.having_condition_->query_string;
      const std::vector<QueryValue> &having_args =
          state_.having_condition_->args;
      std::string::size_type last_pos = 0, find_pos = 0;
      int arg_idx = 0;
      while ((find_pos = having_query_str.find('?', last_pos)) !=
             std::string::npos) {
        sql_stream << having_query_str.substr(last_pos, find_pos - last_pos);
        if (arg_idx < static_cast<int>(having_args.size())) {
          const auto &arg_val = having_args[arg_idx++];
          if (std::holds_alternative<SubqueryExpression>(arg_val)) {
            sql_stream << QueryBuilder::toQVariant(arg_val,
                                                   bound_params_accumulator)
                              .toString()
                              .toStdString();
          } else {
            sql_stream << "?";
            bound_params_accumulator.append(
                QueryBuilder::toQVariant(arg_val, bound_params_accumulator));
          }
        } else {
          sql_stream << "?";
          qWarning() << "cpporm: Not enough arguments for placeholders in "
                        "HAVING clause:"
                     << QString::fromStdString(having_query_str);
        }
        last_pos = find_pos + 1;
      }
      sql_stream << having_query_str.substr(last_pos);
      if (arg_idx < static_cast<int>(having_args.size())) {
        bool only_subqueries_left = true;
        for (size_t k = arg_idx; k < having_args.size(); ++k) {
          if (!std::holds_alternative<SubqueryExpression>(having_args[k])) {
            only_subqueries_left = false;
            break;
          }
        }
        if (!only_subqueries_left) {
          qWarning() << "cpporm: Too many non-subquery arguments for "
                        "placeholders in HAVING clause:"
                     << QString::fromStdString(having_query_str);
        }
      }
    }
  }

  if (!state_.order_clause_.empty()) {
    sql_stream << " ORDER BY " << state_.order_clause_;
  }

  if (!for_subquery_generation) {
    if (state_.limit_val_ > 0) {
      sql_stream << " LIMIT ?";
      bound_params_accumulator.append(state_.limit_val_);
      if (state_.offset_val_ >= 0) {
        sql_stream << " OFFSET ?";
        bound_params_accumulator.append(state_.offset_val_);
      }
    } else if (state_.offset_val_ >= 0) {
      if (getConnectionName().contains("mysql", Qt::CaseInsensitive)) {
        sql_stream << " LIMIT 18446744073709551615";
      }
      sql_stream << " OFFSET ?";
      bound_params_accumulator.append(state_.offset_val_);
      if (!getConnectionName().contains("mysql", Qt::CaseInsensitive) &&
          !getConnectionName().contains("sqlite", Qt::CaseInsensitive)) {
        qWarning("cpporm QueryBuilder: OFFSET without LIMIT is used. Behavior "
                 "might vary by RDBMS. MySQL and SQLite require a LIMIT.");
      }
    }
  }
  return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
}

} // namespace cpporm// cpporm/builder_parts/query_builder_sql_update.cpp
#include "cpporm/model_base.h" // For ModelMeta, FieldMeta, FieldFlag (indirectly)
#include "cpporm/query_builder.h"

#include <QDebug>
#include <sstream>
#include <variant>

namespace cpporm {

std::pair<QString, QVariantList> QueryBuilder::buildUpdateSQL(
    const std::map<std::string, QueryValue> &updates) const {

  if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
    qWarning("cpporm QueryBuilder::buildUpdateSQL: UPDATE operation cannot "
             "target a subquery directly.");
    return {QString(), QVariantList()};
  }

  QString table_name_qstr = getFromSourceName(); // Use the helper
  if (table_name_qstr.isEmpty()) {
    qWarning("cpporm QueryBuilder: Table name not set for buildUpdateSQL.");
    return {QString(), QVariantList()};
  }

  if (updates.empty()) {
    qWarning("cpporm QueryBuilder: No update values provided for table %s.",
             table_name_qstr.toStdString().c_str());
    return {QString(), QVariantList()};
  }

  std::ostringstream sql_stream;
  QVariantList bound_params_accumulator;

  sql_stream << "UPDATE " << quoteSqlIdentifier(table_name_qstr.toStdString())
             << " SET ";

  QString driverNameUpper;
  const QString &connName = getConnectionName();
  if (!connName.isEmpty()) {
    if (connName.contains("mysql", Qt::CaseInsensitive) ||
        connName.contains("mariadb", Qt::CaseInsensitive)) {
      driverNameUpper = "QMYSQL";
    } else if (connName.contains("psql", Qt::CaseInsensitive) ||
               connName.contains("postgres", Qt::CaseInsensitive)) {
      driverNameUpper = "QPSQL";
    }
  }

  bool first_set_col = true;
  for (const auto &pair : updates) {
    if (!first_set_col) {
      sql_stream << ", ";
    }
    sql_stream << quoteSqlIdentifier(pair.first) << " = ";

    if (std::holds_alternative<SubqueryExpression>(pair.second)) {
      sql_stream << QueryBuilder::toQVariant(pair.second,
                                             bound_params_accumulator)
                        .toString()
                        .toStdString();
    } else {
      bool use_st_geom_from_text = false;
      if (state_.model_meta_ &&
          (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
        const FieldMeta *fm = state_.model_meta_->findFieldByDbName(pair.first);
        if (fm &&
            (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" ||
             fm->db_type_hint == "LINESTRING" ||
             fm->db_type_hint == "POLYGON" ||
             fm->db_type_hint == "MULTIPOINT" ||
             fm->db_type_hint == "MULTILINESTRING" ||
             fm->db_type_hint == "MULTIPOLYGON" ||
             fm->db_type_hint == "GEOMETRYCOLLECTION")) {
          use_st_geom_from_text = true;
        }
      }

      if (use_st_geom_from_text) {
        sql_stream << "ST_GeomFromText(?)";
      } else {
        sql_stream << "?";
      }
      bound_params_accumulator.append(
          QueryBuilder::toQVariant(pair.second, bound_params_accumulator));
    }
    first_set_col = false;
  }

  std::string soft_delete_where_fragment;
  if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
    // Check if the FROM source string matches the model's table name
    // or if FROM source string is empty (implying model's table)
    bool apply_sd_on_this_from_source = false;
    if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
      const std::string &from_name_str =
          std::get<std::string>(state_.from_clause_source_);
      if ((!from_name_str.empty() &&
           from_name_str == state_.model_meta_->table_name) ||
          (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
        apply_sd_on_this_from_source = true;
      }
    }
    if (apply_sd_on_this_from_source) {
      if (const FieldMeta *deleted_at_field =
              state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
        soft_delete_where_fragment =
            quoteSqlIdentifier(state_.model_meta_->table_name) + "." +
            quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
      }
    }
  }

  bool where_clause_started_by_builder = true;
  build_condition_logic_internal(sql_stream, bound_params_accumulator,
                                 where_clause_started_by_builder,
                                 soft_delete_where_fragment);

  if (where_clause_started_by_builder && soft_delete_where_fragment.empty() &&
      state_.where_conditions_.empty() && state_.or_conditions_.empty() &&
      state_.not_conditions_.empty()) {
    qWarning() << "cpporm QueryBuilder::buildUpdateSQL: Generating UPDATE "
                  "statement without a WHERE clause for table"
               << table_name_qstr
               << ". This will affect ALL rows if not intended.";
  }

  return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
}

} // namespace cpporm// cpporm/builder_parts/query_builder_state.cpp
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/query_builder.h" // For QueryBuilder::quoteSqlIdentifier

namespace cpporm {

// Definition for the free function mapToConditions
std::vector<Condition>
mapToConditions(const std::map<std::string, QueryValue> &condition_map) {
  std::vector<Condition> conditions_vec;
  conditions_vec.reserve(condition_map.size());
  for (const auto &pair : condition_map) {
    // For map conditions, the key is the column name, and the value is its
    // target. The query string becomes "column_name = ?" If the value is a
    // SubqueryExpression, it will be handled by build_condition_logic_internal
    // when QueryBuilder::toQVariant is called for the argument.
    // Here, we just construct the "column = ?" part.
    conditions_vec.emplace_back(QueryBuilder::quoteSqlIdentifier(pair.first) +
                                    " = ?",
                                std::vector<QueryValue>{pair.second});
  }
  return conditions_vec;
}

} // namespace cpporm#include "cpporm/query_builder_core.h" // For QueryBuilder definition
#include <QDebug>
#include <QMetaType> // For QMetaType in AsSubquery and toQVariant
#include <QVariant>  // For QVariant
#include <sstream>   // For std::ostringstream in buildConditionClauseGroup
#include <variant>   // For std::visit on QueryValue

namespace cpporm {

QString QueryBuilder::getFromSourceName() const {
  if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
    const std::string &table_name_str =
        std::get<std::string>(state_.from_clause_source_);
    if (!table_name_str.empty()) {
      return QString::fromStdString(table_name_str);
    }
    // If from_clause_source_ is an empty string, it means use model's table
    // name
    if (state_.model_meta_ && !state_.model_meta_->table_name.empty()) {
      return QString::fromStdString(state_.model_meta_->table_name);
    }
  } else if (std::holds_alternative<SubquerySource>(
                 state_.from_clause_source_)) {
    // If it's a subquery, the "name" is its alias
    return QString::fromStdString(
        std::get<SubquerySource>(state_.from_clause_source_).alias);
  }
  return QString(); // Default empty if no source determined
}

std::expected<SubqueryExpression, Error> QueryBuilder::AsSubquery() const {
  auto [qsql_string, qvariant_bindings] =
      buildSelectSQL(true); // true for subquery context
  if (qsql_string.isEmpty()) {
    return std::unexpected(Error(ErrorCode::StatementPreparationError,
                                 "Failed to build SQL for subquery."));
  }
  std::vector<QueryValueVariantForSubquery> subquery_native_bindings;
  subquery_native_bindings.reserve(qvariant_bindings.size());

  for (const QVariant &qv : qvariant_bindings) {
    if (qv.isNull() || !qv.isValid()) {
      subquery_native_bindings.push_back(nullptr);
    } else {
      QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
      type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
      type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

      if (type_id_val == QMetaType::UnknownType &&
          qv.userType() != QMetaType::UnknownType) {
        type_id_val = static_cast<QMetaType::Type>(qv.userType());
      }

      if (type_id_val == QMetaType::Int) {
        subquery_native_bindings.push_back(qv.toInt());
      } else if (type_id_val == QMetaType::LongLong ||
                 type_id_val == QMetaType::ULongLong) {
        subquery_native_bindings.push_back(qv.toLongLong());
      } else if (type_id_val == QMetaType::Double) {
        subquery_native_bindings.push_back(qv.toDouble());
      } else if (type_id_val == QMetaType::QString) {
        subquery_native_bindings.push_back(qv.toString().toStdString());
      } else if (type_id_val == QMetaType::Bool) {
        subquery_native_bindings.push_back(qv.toBool());
      } else if (type_id_val == QMetaType::QDateTime) {
        subquery_native_bindings.push_back(qv.toDateTime());
      } else if (type_id_val == QMetaType::QDate) {
        subquery_native_bindings.push_back(qv.toDate());
      } else if (type_id_val == QMetaType::QTime) {
        subquery_native_bindings.push_back(qv.toTime());
      } else if (type_id_val == QMetaType::QByteArray) {
        subquery_native_bindings.push_back(qv.toByteArray());
      } else {
        qWarning()
            << "cpporm QueryBuilder::AsSubquery: Unhandled QVariant typeId "
            << static_cast<int>(type_id_val) << " (" << qv.typeName()
            << ") for native conversion into SubqueryExpression bindings.";
        return std::unexpected(Error(
            ErrorCode::MappingError,
            "Unhandled QVariant type in AsSubquery bindings conversion: " +
                std::string(qv.typeName())));
      }
    }
  }
  return SubqueryExpression(qsql_string.toStdString(),
                            subquery_native_bindings);
}

std::string QueryBuilder::quoteSqlIdentifier(const std::string &identifier) {
  if (identifier.empty())
    return "";
  if (identifier == "*" || identifier.find('(') != std::string::npos ||
      identifier.find(')') != std::string::npos ||
      (identifier.front() == '`' && identifier.back() == '`') ||
      (identifier.front() == '"' && identifier.back() == '"')) {
    return identifier;
  }

  char quote_char = '`';
  std::string result;
  size_t start_pos = 0;
  size_t dot_pos;
  std::string temp_identifier = identifier;

  while ((dot_pos = temp_identifier.find('.', start_pos)) !=
         std::string::npos) {
    result += quote_char +
              temp_identifier.substr(start_pos, dot_pos - start_pos) +
              quote_char + ".";
    start_pos = dot_pos + 1;
  }
  result += quote_char + temp_identifier.substr(start_pos) + quote_char;
  return result;
}

QVariant QueryBuilder::toQVariant(const QueryValue &qv,
                                  QVariantList &subquery_bindings_accumulator) {
  return std::visit(
      [&subquery_bindings_accumulator](auto &&arg) -> QVariant {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, std::nullptr_t>) {
          return QVariant(QMetaType(QMetaType::UnknownType));
        } else if constexpr (std::is_same_v<T, int>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, long long>) {
          return QVariant(static_cast<qlonglong>(arg));
        } else if constexpr (std::is_same_v<T, double>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, std::string>) {
          return QVariant(QString::fromStdString(arg));
        } else if constexpr (std::is_same_v<T, bool>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, QDateTime>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, QDate>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, QTime>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, QByteArray>) {
          return QVariant(arg);
        } else if constexpr (std::is_same_v<T, SubqueryExpression>) {
          for (const auto &sub_binding_variant : arg.bindings) {
            std::visit(
                [&subquery_bindings_accumulator](auto &&sub_val) {
                  using SubVT = std::decay_t<decltype(sub_val)>;
                  if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                    subquery_bindings_accumulator.append(
                        QVariant(QMetaType(QMetaType::UnknownType)));
                  } else if constexpr (std::is_same_v<SubVT, int> ||
                                       std::is_same_v<SubVT, long long> ||
                                       std::is_same_v<SubVT, double> ||
                                       std::is_same_v<SubVT, std::string> ||
                                       std::is_same_v<SubVT, bool> ||
                                       std::is_same_v<SubVT, QDateTime> ||
                                       std::is_same_v<SubVT, QDate> ||
                                       std::is_same_v<SubVT, QTime> ||
                                       std::is_same_v<SubVT, QByteArray>) {
                    if constexpr (std::is_same_v<SubVT, std::string>) {
                      subquery_bindings_accumulator.append(
                          QString::fromStdString(sub_val));
                    } else {
                      subquery_bindings_accumulator.append(
                          QVariant::fromValue(sub_val));
                    }
                  } else {
                    qWarning()
                        << "QueryBuilder::toQVariant (Subquery binding): "
                           "Unhandled native type in subquery binding: "
                        << typeid(SubVT).name();
                  }
                },
                sub_binding_variant);
          }
          return QVariant(QString::fromStdString("(" + arg.sql_string + ")"));
        }
        qWarning()
            << "QueryBuilder::toQVariant: Unhandled QueryValue variant type: "
            << typeid(T).name();
        return QVariant();
      },
      qv);
}

QueryValue QueryBuilder::qvariantToQueryValue(const QVariant &qv) {
  if (qv.isNull() || !qv.isValid())
    return nullptr;

  QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
  type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
  type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

  if (type_id_val == QMetaType::UnknownType &&
      qv.userType() != QMetaType::UnknownType) {
    type_id_val = static_cast<QMetaType::Type>(qv.userType());
  }

  if (type_id_val == QMetaType::Int)
    return qv.toInt();
  if (type_id_val == QMetaType::LongLong)
    return qv.toLongLong();
  if (type_id_val == QMetaType::ULongLong)
    return qv.toLongLong(); // Note: Conversion to signed long long
  if (type_id_val == QMetaType::UInt)
    return static_cast<int>(qv.toUInt());
  if (type_id_val == QMetaType::Double)
    return qv.toDouble();
  if (type_id_val == QMetaType::Float)
    return static_cast<double>(qv.toFloat());
  if (type_id_val == QMetaType::QString)
    return qv.toString().toStdString();
  if (type_id_val == QMetaType::Bool)
    return qv.toBool();
  if (type_id_val == QMetaType::QDateTime)
    return qv.toDateTime();
  if (type_id_val == QMetaType::QDate)
    return qv.toDate();
  if (type_id_val == QMetaType::QTime)
    return qv.toTime();
  if (type_id_val == QMetaType::QByteArray)
    return qv.toByteArray();

  qWarning() << "QueryBuilder::qvariantToQueryValue: Unhandled QVariant type "
                "for QueryValue conversion: "
             << qv.typeName() << "(TypeId: " << static_cast<int>(type_id_val)
             << ")";
  return nullptr;
}

std::pair<std::string, std::vector<QueryValue>>
QueryBuilder::buildConditionClauseGroup() const {
  std::ostringstream group_sql_stream;
  QVariantList group_qbindings;

  std::ostringstream user_defined_conditions_ss;
  bool any_user_condition_written = false;

  if (!state_.where_conditions_.empty()) {
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_defined_conditions_ss, group_qbindings, state_.where_conditions_,
        "AND", false);
    any_user_condition_written = true;
  }
  if (!state_.or_conditions_.empty()) {
    if (any_user_condition_written)
      user_defined_conditions_ss << " OR ";
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_defined_conditions_ss, group_qbindings, state_.or_conditions_,
        "OR", false);
    any_user_condition_written = true;
  }
  if (!state_.not_conditions_.empty()) {
    if (any_user_condition_written)
      user_defined_conditions_ss << " AND ";
    QueryBuilder::build_one_condition_block_internal_static_helper(
        user_defined_conditions_ss, group_qbindings, state_.not_conditions_,
        "AND", true);
    any_user_condition_written = true;
  }
  std::string user_conditions_part_sql = user_defined_conditions_ss.str();

  std::string soft_delete_fragment_for_this_group;
  if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
    bool apply_sd_on_this_from_source = false;
    QString current_from_qstr = this->getFromSourceName();
    if (!current_from_qstr.isEmpty() &&
        state_.model_meta_->table_name == current_from_qstr.toStdString()) {
      apply_sd_on_this_from_source = true;
    }

    if (apply_sd_on_this_from_source) {
      if (const FieldMeta *deleted_at_field =
              state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
        soft_delete_fragment_for_this_group =
            QueryBuilder::quoteSqlIdentifier(
                this->getFromSourceName().toStdString()) +
            "." + QueryBuilder::quoteSqlIdentifier(deleted_at_field->db_name) +
            " IS NULL";
      }
    }
  }

  if (!soft_delete_fragment_for_this_group.empty()) {
    group_sql_stream << "(" << soft_delete_fragment_for_this_group << ")";
    if (!user_conditions_part_sql.empty()) {
      group_sql_stream << " AND ";
    }
  }
  if (!user_conditions_part_sql.empty()) {
    group_sql_stream << user_conditions_part_sql;
  }

  std::string final_built_sql_group = group_sql_stream.str();
  if (final_built_sql_group.empty()) {
    return {"", {}};
  }

  std::vector<QueryValue> native_args;
  native_args.reserve(group_qbindings.size());
  for (const QVariant &qv : group_qbindings) {
    native_args.push_back(QueryBuilder::qvariantToQueryValue(qv));
  }

  return {"(" + final_built_sql_group + ")", native_args};
}

QString QueryBuilder::toSqlDebug() const {
  auto [sql_qstr, params_list] = this->buildSelectSQL();
  QString debug_sql = sql_qstr;
  int current_param_idx = 0;
  int placeholder_pos = 0;

  while (current_param_idx < params_list.size()) {
    placeholder_pos = debug_sql.indexOf('?', placeholder_pos);
    if (placeholder_pos == -1)
      break;

    QVariant v = params_list.at(current_param_idx);
    QString param_str_val;

    QMetaType::Type v_type_id;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    v_type_id = static_cast<QMetaType::Type>(v.typeId());
#else
    v_type_id = static_cast<QMetaType::Type>(v.type());
#endif

    if (v.isNull() || !v.isValid() || v_type_id == QMetaType::UnknownType) {
      param_str_val = "NULL";
    } else if (v_type_id == QMetaType::QString) {
      param_str_val = "'" + v.toString().replace("'", "''") + "'";
    } else if (v_type_id == QMetaType::QByteArray) {
      param_str_val =
          "'<BinaryData:" + QString::number(v.toByteArray().size()) + "bytes>'";
    } else if (v_type_id == QMetaType::QDateTime) {
      param_str_val = "'" + v.toDateTime().toString(Qt::ISODateWithMs) + "'";
    } else if (v_type_id == QMetaType::QDate) {
      param_str_val = "'" + v.toDate().toString(Qt::ISODate) + "'";
    } else if (v_type_id == QMetaType::QTime) {
      param_str_val = "'" + v.toTime().toString(Qt::ISODateWithMs) + "'";
    } else if (v_type_id == QMetaType::Bool) {
      param_str_val = v.toBool() ? "TRUE" : "FALSE";
    } else {
      param_str_val = v.toString();
    }

    debug_sql.replace(placeholder_pos, 1, param_str_val);
    placeholder_pos += param_str_val.length();
    current_param_idx++;
  }
  return debug_sql;
}

} // namespace cpporm#include "cpporm/model_base.h" // For declarations in model_base.h

namespace cpporm {
namespace internal {

// Definitions for the global model factory registry
std::map<std::type_index, ModelFactory> &getGlobalModelFactoryRegistry() {
  static std::map<std::type_index, ModelFactory> registry;
  return registry;
}

std::mutex &getGlobalModelFactoryRegistryMutex() {
  static std::mutex registry_mutex;
  return registry_mutex;
}

// Definitions for Global Meta Finalization
std::vector<VoidFunc> &getGlobalModelFinalizerFunctions() {
  static std::vector<VoidFunc> finalizers;
  return finalizers;
}
std::mutex &getGlobalModelFinalizersRegistryMutex() {
  static std::mutex mtx;
  return mtx;
}

} // namespace internal

// Definition for the user-callable global finalization function
void finalize_all_model_meta() {
  // It's crucial that this function is called *after* all static initializers
  // (which call registerModelClassForFinalization) have run, and all model
  // class definitions are complete.

  // Create a copy of the finalizer functions to avoid issues if a finalizer
  // somehow tries to re-register (should not happen with current design).
  std::vector<internal::VoidFunc> finalizers_copy;
  {
    std::lock_guard<std::mutex> lock(
        internal::getGlobalModelFinalizersRegistryMutex());
    finalizers_copy = internal::getGlobalModelFinalizerFunctions();
  }

  // Sort finalizers? Not strictly necessary if _finalizeModelMeta is idempotent
  // and handles its dependencies gracefully (which it tries to, but typeid
  // makes it tricky). For now, call in registration order. A more robust system
  // might involve multiple passes or dependency tracking. qInfo() << "cpporm:
  // Globally finalizing metadata for" << finalizers_copy.size() << "models...";
  for (const auto &finalizer_func : finalizers_copy) {
    if (finalizer_func) {
      finalizer_func();
    }
  }
  // qInfo() << "cpporm: Global metadata finalization complete.";

  // Optional: Clear the global list if finalization is truly a one-time startup
  // event. This prevents re-finalization and saves a little memory. However, if
  // models could be registered dynamically later (not typical for this ORM
  // style), clearing would be problematic.
  // {
  //     std::lock_guard<std::mutex>
  //     lock(internal::getGlobalModelFinalizersRegistryMutex());
  //     internal::getGlobalModelFinalizerFunctions().clear();
  // }
}

} // namespace cpporm#include "cpporm/qt_db_manager.h"
#include <QDebug>    // For Qt-style debug output (optional)
#include <QSqlError> // For QSqlError related information
#include <QSqlQuery> // Needed for executing SET NAMES
#include <QUuid>     // For generating unique names if needed

// std::mutex cpporm::QtDbManager::db_mutex_; // Definition if mutex is used

namespace cpporm {

std::expected<QString, Error>
QtDbManager::openDatabase(const QtDBConfig &config) {
  // std::lock_guard<std::mutex> lock(db_mutex_); // Lock if multi-threaded
  // access to addDatabase

  QString conn_name = QString::fromStdString(config.connection_name);
  if (conn_name.isEmpty()) {
    conn_name =
        QString::fromStdString(QtDBConfig::generateUniqueConnectionName());
  }

  if (QSqlDatabase::contains(conn_name)) {
    QSqlDatabase existing_db = QSqlDatabase::database(conn_name, false);
    if (existing_db.isValid() && existing_db.isOpen()) {
      return conn_name;
    }
    QSqlDatabase::removeDatabase(conn_name);
  }

  QSqlDatabase db = QSqlDatabase::addDatabase(
      QString::fromStdString(config.driver_name), conn_name);

  if (!db.isValid()) {
    return std::unexpected(
        Error(ErrorCode::DriverNotFound,
              "Qt SQL Driver not valid or not found: " + config.driver_name +
                  ". Ensure the driver plugin (e.g., qsqlmysql.dll/so) is "
                  "available. Connection name: " +
                  conn_name.toStdString()));
  }

  db.setHostName(QString::fromStdString(config.host_name));
  if (config.port > 0) {
    db.setPort(config.port);
  }
  db.setDatabaseName(QString::fromStdString(config.database_name));
  db.setUserName(QString::fromStdString(config.user_name));
  db.setPassword(QString::fromStdString(config.password));
  if (!config.connect_options.empty()) {
    db.setConnectOptions(QString::fromStdString(config.connect_options));
  }

  if (!db.open()) {
    QSqlError q_error = db.lastError();
    return std::unexpected(
        Error(ErrorCode::ConnectionFailed,
              "Failed to open Qt database connection: " +
                  q_error.text().toStdString() +
                  " (Driver Error: " + q_error.driverText().toStdString() +
                  ", DB Error: " + q_error.databaseText().toStdString() + ")",
              q_error.nativeErrorCode().toInt(), ""));
  }

  // 在连接成功后，为 MySQL/MariaDB 设置字符集
  QString driverNameUpper =
      QString::fromStdString(config.driver_name).toUpper();
  if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
    QSqlQuery set_names_query(db); // 使用当前连接 'db'
    if (!set_names_query.exec("SET NAMES 'utf8mb4'")) {
      qWarning() << "QtDbManager::openDatabase: Failed to execute SET NAMES "
                    "'utf8mb4' for connection"
                 << conn_name
                 << ". Error:" << set_names_query.lastError().text();
      // 根据需要决定这是否是致命错误。目前仅警告。
      // 如果是致命错误，可以关闭连接并返回错误：
      // db.close();
      // QSqlDatabase::removeDatabase(conn_name);
      // return std::unexpected(Error(ErrorCode::QueryExecutionError, "Failed to
      // set connection charset for " + conn_name.toStdString() + ": " +
      // set_names_query.lastError().text().toStdString()));
    } else {
      // qInfo() << "QtDbManager::openDatabase: Successfully executed SET NAMES
      // 'utf8mb4' for " << conn_name;
    }
  }
  return conn_name;
}

QSqlDatabase QtDbManager::getDatabase(const QString &connection_name) {
  return QSqlDatabase::database(connection_name);
}

void QtDbManager::closeDatabase(const QString &connection_name) {
  if (QSqlDatabase::contains(connection_name)) {
    QSqlDatabase db = QSqlDatabase::database(connection_name, false);
    if (db.isOpen()) {
      db.close();
    }
    QSqlDatabase::removeDatabase(connection_name);
  }
}

bool QtDbManager::isConnectionValid(const QString &connection_name) {
  if (!QSqlDatabase::contains(connection_name)) {
    return false;
  }
  QSqlDatabase db = QSqlDatabase::database(connection_name, false);
  return db.isValid() && db.isOpen();
}

} // namespace cpporm// cpporm/session_batch_execution_and_hooks.cpp
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h" // FriendAccess 定义在此

#include <QDebug>
#include <QSqlError>
#include <QSqlQuery>
#include <QVariant>

namespace cpporm {
namespace internal_batch_helpers {

ExecutionResult
executeBatchSql(Session &session, const QString &sql_to_execute,
                const QVariantList &bindings,
                const std::vector<ModelBase *>
                    &models_in_db_op, // 这些是原始的、准备好进行DB操作的模型
                const OnConflictClause *active_conflict_clause) {
  ExecutionResult result;

  auto exec_pair = FriendAccess::callExecuteQueryInternal(
      session.getDbHandle(), sql_to_execute, bindings);
  result.query_object = std::move(exec_pair.first);
  result.db_error = exec_pair.second;

  if (result.db_error) {
    return result;
  }

  result.rows_affected = result.query_object.numRowsAffected();

  // 根据数据库操作结果和冲突选项，设置 _is_persisted 状态
  // 并将这些模型加入 models_potentially_persisted 列表
  if (result.rows_affected > 0 ||
      (active_conflict_clause &&
       active_conflict_clause->action != OnConflictClause::Action::DoNothing &&
       result.rows_affected >= 0)) {
    // 如果有行受影响，或者有冲突处理（非DO_NOTHING）且行影响数>=0
    for (ModelBase *m : models_in_db_op) {
      if (m) {
        m->_is_persisted =
            true; // <<<<<<<<<<<<<<<<<<<<<<< 关键修复：设置持久化状态
        result.models_potentially_persisted.push_back(m);
      }
    }
  } else if (result.rows_affected == 0 && active_conflict_clause &&
             active_conflict_clause->action ==
                 OnConflictClause::Action::DoNothing) {
    // 对于 DO NOTHING 且0行受影响，模型可能已存在但未被修改。
    // _is_persisted 状态不应改变（如果之前是 false，则保持 false）。
    // 但它们仍然是“已处理”的，所以加入列表供回调。
    for (ModelBase *m : models_in_db_op) {
      if (m) {
        // m->_is_persisted = true; // 错误：这里不应该设置为
        // true，因为没有新插入或更新 如果模型之前不存在，它仍然不是 persisted。
        // 如果它已存在，其 _is_persisted 状态应该由加载它的操作设置。
        // 对于 CreateBatch 的 DO NOTHING 场景，如果记录已存在，
        // _is_persisted 应该保持其原始值（通常是
        // false，因为我们正在尝试创建）。
        result.models_potentially_persisted.push_back(m);
      }
    }
  }
  // 如果 rows_affected < 0 (通常表示错误或非DML语句)
  // models_potentially_persisted 将为空 (除非上面的条件已捕获了错误)。

  return result;
}

void callAfterCreateHooks(
    Session &session,
    const std::vector<ModelBase *> &models_for_hooks, // 改为接收这个列表
    Error &in_out_first_error_encountered) {
  for (ModelBase *model_ptr : models_for_hooks) {
    // 调用钩子前再次确认 _is_persisted，因为ID回填可能会失败，
    // 但DB操作本身可能成功使记录持久化。
    // 或者，钩子应该只为那些不仅DB操作成功，而且ID也成功回填（如果是自增PK）的模型调用。
    // 目前的 successfully_backfilled_models 列表是更准确的。
    // 因此，这里参数应该就是那些真正成功创建并回填ID的模型。
    if (!model_ptr || !model_ptr->_is_persisted) // 确保只为成功持久化的模型调用
      continue;

    Error hook_err = model_ptr->afterCreate(session);
    if (hook_err) {
      if (in_out_first_error_encountered.isOk()) {
        in_out_first_error_encountered = hook_err;
      }
      qWarning() << "callAfterCreateHooks: afterCreate hook failed for a "
                    "model. Error: "
                 << hook_err.toString().c_str();
    }
  }
}

} // namespace internal_batch_helpers
} // namespace cpporm// cpporm/session_batch_id_backfillers.cpp
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"

#include <QDebug>
#include <QSqlDriver>
#include <QSqlQuery>
#include <QVariant>
#include <algorithm> // For std::find

namespace cpporm {
namespace internal_batch_helpers {

std::vector<ModelBase *> backfillIdsFromReturning(
    QSqlQuery &executed_query,
    const ModelMeta &meta, // meta 未在此函数中直接使用，但保留
    const std::vector<ModelBase *>
        &models_to_backfill_from, // 这些模型应已由 executeBatchSql 标记
                                  // _is_persisted = true
    const std::string &pk_cpp_name_str, const std::type_index &pk_cpp_type) {
  std::vector<ModelBase *> successfully_backfilled_models;
  if (models_to_backfill_from.empty()) {
    return successfully_backfilled_models;
  }

  // 迭代 models_to_backfill_from，这些是 executeBatchSql 认为受影响的模型
  for (ModelBase *model_to_backfill : models_to_backfill_from) {
    if (!model_to_backfill)
      continue; // 安全检查
    // 此处不再检查 model_to_backfill->_is_persisted，因为 executeBatchSql
    // 已处理。 我们期望 RETURNING 子句为每个受影响的行返回一个 ID。

    if (!executed_query.next()) {
      qWarning() << "backfillIdsFromReturning: RETURNING clause provided fewer "
                    "ID rows than the number of potentially persisted models "
                    "in the batch for table "
                 << QString::fromStdString(meta.table_name);
      break;
    }
    QVariant id_val_ret = executed_query.value(0);
    std::any pk_any_val;
    bool conv_ok = false;
    Session::qvariantToAny(id_val_ret, pk_cpp_type, pk_any_val, conv_ok);

    if (conv_ok) {
      Error set_err =
          model_to_backfill->setFieldValue(pk_cpp_name_str, pk_any_val);
      if (set_err) {
        qWarning()
            << "backfillIdsFromReturning: Error setting PK value for table "
            << QString::fromStdString(meta.table_name) << ", field "
            << QString::fromStdString(pk_cpp_name_str) << " after RETURNING:"
            << QString::fromStdString(set_err.toString());
        // 即使设置失败，模型在数据库层面是持久化的，但应用层面ID可能不同步
        // 此时不应该将其从“已持久化”中移除，但它不是“成功回填”的
      } else {
        successfully_backfilled_models.push_back(model_to_backfill);
      }
    } else {
      qWarning() << "backfillIdsFromReturning: PK backfill conversion failed "
                    "for RETURNING. DB val:"
                 << id_val_ret.toString() << "to C++ type" << pk_cpp_type.name()
                 << " for table " << QString::fromStdString(meta.table_name);
    }
  }
  return successfully_backfilled_models;
}

std::vector<ModelBase *> backfillIdsFromLastInsertId(
    QSqlQuery &executed_query, const Session &session, const ModelMeta &meta,
    const std::vector<ModelBase *>
        &models_to_backfill_from, // 这些模型应已由 executeBatchSql 标记
                                  // _is_persisted = true
    long long total_rows_affected_by_query, const std::string &pk_cpp_name_str,
    const std::type_index &pk_cpp_type,
    const OnConflictClause *active_conflict_clause) {
  std::vector<ModelBase *> successfully_backfilled_models;
  if (models_to_backfill_from.empty() || total_rows_affected_by_query <= 0) {
    return successfully_backfilled_models;
  }

  QVariant first_id_qval = executed_query.lastInsertId();
  if (!first_id_qval.isValid() ||
      (first_id_qval.toLongLong() == 0 &&
       first_id_qval.toInt() ==
           0)) { // 检查是否为0，因为某些驱动可能返回0表示无ID
    // lastInsertId 不可用或为0，无法回填
    // 只有当确定0不是一个有效的自增ID时，才跳过。
    // 对于某些序列，0可能是有效的。但通常不是。
    bool is_zero_actually = false;
    bool ok_ll = false;
    long long ll_val = first_id_qval.toLongLong(&ok_ll);
    if (ok_ll && ll_val == 0)
      is_zero_actually = true;
    bool ok_int = false;
    int int_val = first_id_qval.toInt(&ok_int);
    if (ok_int && int_val == 0)
      is_zero_actually = true;

    if (!first_id_qval.isValid() ||
        (first_id_qval.isNull() && !is_zero_actually) ||
        (is_zero_actually && pk_cpp_type != typeid(int) &&
         pk_cpp_type != typeid(long long))) {
      qWarning() << "backfillIdsFromLastInsertId: lastInsertId is invalid, "
                    "null, or zero (and PK is not int/longlong) for table "
                 << QString::fromStdString(meta.table_name)
                 << ". Value: " << first_id_qval.toString();
      return successfully_backfilled_models;
    }
  }

  QString db_driver_name_upper = session.getDbHandle().driverName().toUpper();

  // 仅为 models_to_backfill_from 中的模型尝试回填
  if (models_to_backfill_from.size() == 1 &&
      total_rows_affected_by_query >= 1) { // 确保至少有一行受影响
    ModelBase *single_model = models_to_backfill_from[0];
    if (single_model) { // 不需要再次检查 _is_persisted，因为它应已被
                        // executeBatchSql 设置
      std::any pk_any_val;
      bool conv_ok = false;
      Session::qvariantToAny(first_id_qval, pk_cpp_type, pk_any_val, conv_ok);
      if (conv_ok) {
        Error set_err =
            single_model->setFieldValue(pk_cpp_name_str, pk_any_val);
        if (set_err) {
          qWarning() << "backfillIdsFromLastInsertId: Error setting PK value "
                        "(single) for table "
                     << QString::fromStdString(meta.table_name) << ":"
                     << QString::fromStdString(set_err.toString());
        } else {
          successfully_backfilled_models.push_back(single_model);
        }
      } else {
        qWarning() << "backfillIdsFromLastInsertId: PK backfill (single, "
                      "lastInsertId) conversion failed for table "
                   << QString::fromStdString(meta.table_name)
                   << ". DB val: " << first_id_qval.toString()
                   << " to C++ type " << pk_cpp_type.name();
      }
    }
  } else if (
      (db_driver_name_upper.contains("MYSQL") ||
       db_driver_name_upper.contains("MARIADB")) && // MySQL/MariaDB
      total_rows_affected_by_query > 0 &&
      total_rows_affected_by_query <=
          static_cast<long long>(
              models_to_backfill_from
                  .size()) &&     // 受影响行数不应超过尝试插入的行数
      (!active_conflict_clause || // 纯插入
       (active_conflict_clause && // 或冲突导致了插入/更新，且MySQL通常对连续插入返回第一个ID
        (active_conflict_clause->action ==
             OnConflictClause::Action::UpdateAllExcluded ||
         active_conflict_clause->action ==
             OnConflictClause::Action::UpdateSpecific)))) {
    long long first_id_ll = first_id_qval.toLongLong();
    // 仅当受影响的行数与我们期望回填的模型数完全匹配时，才假设连续ID是可靠的
    // 并且这通常只在没有复杂ON DUPLICATE KEY UPDATE（可能跳过一些行）时适用
    if (total_rows_affected_by_query ==
        static_cast<long long>(models_to_backfill_from.size())) {
      for (size_t k = 0; k < models_to_backfill_from.size(); ++k) {
        ModelBase *current_model = models_to_backfill_from[k];
        if (!current_model)
          continue;

        long long current_model_id_ll = first_id_ll + static_cast<long long>(k);
        std::any pk_any_val_seq;
        bool conv_ok_seq = false;
        QVariant qv_current_id(current_model_id_ll);
        Session::qvariantToAny(qv_current_id, pk_cpp_type, pk_any_val_seq,
                               conv_ok_seq);
        if (conv_ok_seq) {
          Error set_err =
              current_model->setFieldValue(pk_cpp_name_str, pk_any_val_seq);
          if (set_err) {
            qWarning() << "backfillIdsFromLastInsertId: Error setting PK value "
                          "(sequential) for table "
                       << QString::fromStdString(meta.table_name) << ":"
                       << QString::fromStdString(set_err.toString());
          } else {
            successfully_backfilled_models.push_back(current_model);
          }
        } else {
          qWarning() << "backfillIdsFromLastInsertId: PK backfill (sequential, "
                        "lastInsertId) "
                        "conversion failed for derived ID:"
                     << current_model_id_ll << " for table "
                     << QString::fromStdString(meta.table_name);
        }
      }
    } else if (!models_to_backfill_from.empty() &&
               total_rows_affected_by_query > 0) {
      // 如果受影响的行数不完全匹配，但至少有一个，则只尝试回填第一个模型（如果它是models_to_backfill_from的一部分）
      // 这种情况可能发生在ON DUPLICATE KEY UPDATE部分更新部分插入时
      ModelBase *first_persisted_model = nullptr;
      for (ModelBase *m :
           models_to_backfill_from) { // 找到 models_to_backfill_from
                                      // 中第一个被标记为持久化的
        if (m && m->_is_persisted) {
          first_persisted_model = m;
          break;
        }
      }
      if (first_persisted_model) {
        std::any pk_any_val;
        bool conv_ok = false;
        Session::qvariantToAny(first_id_qval, pk_cpp_type, pk_any_val, conv_ok);
        if (conv_ok) {
          Error set_err =
              first_persisted_model->setFieldValue(pk_cpp_name_str, pk_any_val);
          if (set_err) { /* qWarning */
          } else {
            successfully_backfilled_models.push_back(first_persisted_model);
          }
        } else { /* qWarning */
        }
      }
      qWarning() << "backfillIdsFromLastInsertId: lastInsertId may not be "
                    "reliable for all rows in this batch "
                 << "operation for table "
                 << QString::fromStdString(meta.table_name)
                 << ". Rows affected (" << total_rows_affected_by_query
                 << ") != models in batch (" << models_to_backfill_from.size()
                 << "). Only first ID (if applicable) might be accurate.";
    }

  } else if (db_driver_name_upper == "QSQLITE" &&
             total_rows_affected_by_query == 1 &&
             models_to_backfill_from.size() >= 1) {
    // SQLite 的 lastInsertId() 返回最后插入行的
    // ROWID。如果批量插入多行，它只返回最后一行的。
    // 所以，只有当批量大小为1（或者我们只关心最后一个）时才可靠。
    // 或者，如果 total_rows_affected_by_query 也是1，这意味着确实只插入了一行。
    ModelBase *model_to_set = models_to_backfill_from.back(); // 假设是最后一个
    if (models_to_backfill_from.size() == 1)
      model_to_set = models_to_backfill_from[0];

    if (model_to_set) {
      std::any pk_any_val;
      bool conv_ok = false;
      Session::qvariantToAny(first_id_qval, pk_cpp_type, pk_any_val, conv_ok);
      if (conv_ok) {
        Error set_err =
            model_to_set->setFieldValue(pk_cpp_name_str, pk_any_val);
        if (set_err) { /* qWarning */
        } else {
          successfully_backfilled_models.push_back(model_to_set);
        }
      } else { /* qWarning */
      }
    }
  } else {
    qWarning() << "backfillIdsFromLastInsertId: lastInsertId is not reliably "
                  "applicable for this batch operation "
               << "on driver " << db_driver_name_upper << " for table "
               << QString::fromStdString(meta.table_name)
               << ". Models in batch: " << models_to_backfill_from.size()
               << ", Rows affected: " << total_rows_affected_by_query;
  }
  return successfully_backfilled_models;
}

} // namespace internal_batch_helpers
} // namespace cpporm// cpporm/session_batch_sql_preparation.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h" // 包含声明和 FriendAccess 定义

#include <QDebug>
#include <QStringList>
#include <QVariant>

namespace cpporm {
namespace internal_batch_helpers {

std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(
    Session &session, const std::vector<ModelBase *> &models_in_provider_chunk,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache,
    BatchSqlParts &out_sql_parts) {
  std::vector<ModelBase *> models_prepared_for_sql_build;
  models_prepared_for_sql_build.reserve(models_in_provider_chunk.size());
  Error first_prepare_error = make_ok();

  out_sql_parts.all_values_flattened.clear();
  out_sql_parts.row_placeholders.clear();

  QString db_driver_name_upper = session.getDbHandle().driverName().toUpper();

  for (ModelBase *model_ptr : models_in_provider_chunk) {
    if (!model_ptr)
      continue;

    Error hook_err = model_ptr->beforeCreate(session);
    if (hook_err) {
      if (first_prepare_error.isOk())
        first_prepare_error = hook_err;
      continue;
    }
    FriendAccess::callAutoSetTimestamps(session, *model_ptr, meta, true);

    // 使用 FriendAccess 调用 Session 的私有 extractModelData
    internal::SessionModelDataForWrite model_data_struct =
        FriendAccess::callExtractModelData(session, *model_ptr, meta, false,
                                           true);

    QStringList current_model_placeholders_segment;
    bool model_can_be_inserted_this_pass = false;
    bool is_pure_auto_inc_pk =
        batch_ordered_db_field_names_cache.empty() && meta.getPrimaryField() &&
        has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);

    if (!batch_ordered_db_field_names_cache.empty()) {
      model_can_be_inserted_this_pass = true;
      for (const std::string &field_db_name :
           batch_ordered_db_field_names_cache) {
        auto it = model_data_struct.fields_to_write.find(
            QString::fromStdString(field_db_name));
        out_sql_parts.all_values_flattened.append(
            it != model_data_struct.fields_to_write.end() ? it->second
                                                          : QVariant());
        current_model_placeholders_segment.append("?");
      }
      out_sql_parts.row_placeholders.append(
          QString("(%1)").arg(current_model_placeholders_segment.join(",")));
    } else if (is_pure_auto_inc_pk) {
      model_can_be_inserted_this_pass = true;
      if (db_driver_name_upper == "QPSQL") {
        if (models_in_provider_chunk.size() == 1 &&
            model_data_struct.fields_to_write.empty()) {
          // 单个 PG DEFAULT VALUES 不需要显式占位符行
        } else if (models_in_provider_chunk.size() > 1 &&
                   model_data_struct.fields_to_write.empty()) {
          qWarning() << "prepareModelsAndSqlPlaceholders: Unexpected path for "
                        "PG pure auto-inc multi-row batch in SQL prep stage.";
          model_can_be_inserted_this_pass = false;
        }
      } else {
        out_sql_parts.row_placeholders.append("()");
      }
    }

    if (model_can_be_inserted_this_pass) {
      models_prepared_for_sql_build.push_back(model_ptr);
    } else {
      if (first_prepare_error.isOk()) {
        first_prepare_error =
            Error(ErrorCode::MappingError,
                  "Model (table: " + meta.table_name +
                      ", C++ type: " + typeid(*model_ptr).name() +
                      ") could not be prepared for batch insertion (no "
                      "fields/PK to form SQL).");
      }
    }
  }
  return {models_prepared_for_sql_build, first_prepare_error};
}

Error buildFullBatchSqlStatement(
    const Session &session, const QueryBuilder &qb_prototype,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache,
    const OnConflictClause *active_conflict_clause,
    BatchSqlParts &in_out_sql_parts) {
  in_out_sql_parts.can_proceed = false;
  QString db_driver_name_upper = session.getDbHandle().driverName().toUpper();

  QString sql_verb = "INSERT";
  if (active_conflict_clause &&
      active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
    if (db_driver_name_upper.contains("MYSQL"))
      sql_verb = "INSERT IGNORE";
  }

  bool is_pure_auto_inc_pk_case =
      batch_ordered_db_field_names_cache.empty() && meta.getPrimaryField() &&
      has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);

  if (is_pure_auto_inc_pk_case) {
    if (db_driver_name_upper == "QPSQL") {
      if (in_out_sql_parts.row_placeholders
              .isEmpty()) { // 应该为空，因为 prepare... 中 PG 单个会跳过
        in_out_sql_parts.sql_insert_base =
            QString("INSERT INTO %1 DEFAULT VALUES")
                .arg(QString::fromStdString(
                    QueryBuilder::quoteSqlIdentifier(meta.table_name)));
        in_out_sql_parts.all_values_flattened.clear();
      } else {
        qWarning() << "buildFullBatchSqlStatement: PG pure auto-inc case "
                      "received non-empty placeholders for single insert.";
        return Error(ErrorCode::StatementPreparationError,
                     "PG pure auto-inc batch SQL build inconsistency for "
                     "single insert.");
      }
    } else {
      if (in_out_sql_parts.row_placeholders.isEmpty()) {
        qWarning() << "buildFullBatchSqlStatement: Non-PG pure auto-inc case "
                      "received empty placeholders.";
        return Error(ErrorCode::StatementPreparationError,
                     "Non-PG pure auto-inc batch SQL build inconsistency.");
      }
      in_out_sql_parts.sql_insert_base =
          QString("%1 INTO %2 () VALUES %3")
              .arg(sql_verb)
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(meta.table_name)))
              .arg(in_out_sql_parts.row_placeholders.join(","));
      in_out_sql_parts.all_values_flattened.clear();
    }
  } else if (!batch_ordered_db_field_names_cache.empty() &&
             !in_out_sql_parts.row_placeholders.isEmpty()) {
    QStringList q_fields_for_sql;
    for (const auto &s : batch_ordered_db_field_names_cache)
      q_fields_for_sql.append(
          QString::fromStdString(QueryBuilder::quoteSqlIdentifier(s)));

    in_out_sql_parts.sql_insert_base =
        QString("%1 INTO %2 (%3) VALUES %4")
            .arg(sql_verb)
            .arg(QString::fromStdString(
                QueryBuilder::quoteSqlIdentifier(meta.table_name)))
            .arg(q_fields_for_sql.join(","))
            .arg(in_out_sql_parts.row_placeholders.join(","));
  } else {
    return Error(
        ErrorCode::StatementPreparationError,
        "Cannot build batch INSERT SQL: missing field names or placeholders.");
  }

  in_out_sql_parts.sql_on_conflict_suffix.clear();
  in_out_sql_parts.conflict_suffix_bindings.clear();
  if (active_conflict_clause && !(sql_verb == "INSERT IGNORE" &&
                                  active_conflict_clause->action ==
                                      OnConflictClause::Action::DoNothing)) {
    QueryBuilder temp_qb_for_suffix_build(
        nullptr, qb_prototype.getConnectionName(), &meta);
    temp_qb_for_suffix_build.getState_().on_conflict_clause_ =
        std::make_unique<OnConflictClause>(*active_conflict_clause);
    auto suffix_pair_result = temp_qb_for_suffix_build.buildInsertSQLSuffix(
        batch_ordered_db_field_names_cache);
    in_out_sql_parts.sql_on_conflict_suffix = suffix_pair_result.first;
    in_out_sql_parts.conflict_suffix_bindings = suffix_pair_result.second;
  }

  in_out_sql_parts.final_sql_statement =
      in_out_sql_parts.sql_insert_base + " " +
      in_out_sql_parts.sql_on_conflict_suffix;
  in_out_sql_parts.final_bindings = in_out_sql_parts.all_values_flattened;
  in_out_sql_parts.final_bindings.append(
      in_out_sql_parts.conflict_suffix_bindings);

  bool has_pk_for_returning =
      meta.getPrimaryField() &&
      has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement) &&
      !meta.getPrimaryField()->db_name.empty();
  bool use_returning =
      (db_driver_name_upper == "QPSQL" && has_pk_for_returning &&
       (!active_conflict_clause ||
        active_conflict_clause->action != OnConflictClause::Action::DoNothing));

  if (use_returning) {
    in_out_sql_parts.final_sql_statement +=
        " RETURNING " + QString::fromStdString(QueryBuilder::quoteSqlIdentifier(
                            meta.getPrimaryField()->db_name));
  }

  in_out_sql_parts.can_proceed = true;
  return make_ok();
}

} // namespace internal_batch_helpers
} // namespace cpporm// cpporm/session_builder_factories.cpp
#include "cpporm/model_base.h"    // For ModelBase, ModelMeta
#include "cpporm/query_builder.h" // 因为这些方法返回 QueryBuilder
#include "cpporm/session.h"       // 主头文件

namespace cpporm {

// --- Model/Table selection implementation ---
QueryBuilder Session::Model(const ModelBase *model_instance_hint) {
  if (!model_instance_hint) {
    return QueryBuilder(this, this->connection_name_, nullptr);
  }
  return QueryBuilder(this, this->connection_name_,
                      &(model_instance_hint->_getOwnModelMeta()));
}

QueryBuilder Session::Model(const ModelMeta &meta) {
  return QueryBuilder(this, this->connection_name_, &meta);
}

QueryBuilder Session::Table(const std::string &table_name) {
  QueryBuilder qb(this, this->connection_name_, nullptr);
  qb.Table(table_name);
  return qb;
}

QueryBuilder Session::MakeQueryBuilder() {
  return QueryBuilder(this, this->connection_name_, nullptr);
}

// --- OnConflict clause setters implementation ---
Session &Session::OnConflictUpdateAllExcluded() {
  if (!temp_on_conflict_clause_) {
    temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  temp_on_conflict_clause_->action =
      OnConflictClause::Action::UpdateAllExcluded;
  temp_on_conflict_clause_->update_assignments.clear();
  return *this;
}

Session &Session::OnConflictDoNothing() {
  if (!temp_on_conflict_clause_) {
    temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  temp_on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
  temp_on_conflict_clause_->update_assignments.clear();
  return *this;
}

Session &Session::OnConflictUpdateSpecific(
    std::function<void(SessionOnConflictUpdateSetter &)> updater_fn) {
  if (!temp_on_conflict_clause_) {
    temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
  }
  SessionOnConflictUpdateSetter setter(*temp_on_conflict_clause_);
  updater_fn(setter);
  return *this;
}

} // namespace cpporm// cpporm/session_create_batch_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h" // 包含新的私有助手声明

#include <QDateTime>
#include <QDebug>
#include <QMetaType>
#include <QSqlDriver>
#include <QSqlError>
#include <QSqlQuery>
#include <QVariant>
#include <algorithm>
#include <utility>
#include <vector>

namespace cpporm {

// 实现 CreateBatchProviderInternal
Error Session::CreateBatchProviderInternal(
    QueryBuilder qb_prototype,
    std::function<std::optional<std::vector<ModelBase *>>()>
        data_batch_provider_base,
    std::function<
        void(const std::vector<ModelBase *> &processed_batch_models_with_ids,
             Error batch_error)>
        per_db_batch_completion_callback,
    const OnConflictClause *conflict_options_override) {

  const ModelMeta *meta_ptr = qb_prototype.getModelMeta();
  if (!meta_ptr) {
    return Error(ErrorCode::InvalidConfiguration,
                 "CreateBatchProviderInternal: QB prototype has no ModelMeta.");
  }
  const ModelMeta &meta = *meta_ptr;

  const OnConflictClause *active_conflict_clause = conflict_options_override;
  if (!active_conflict_clause && qb_prototype.getOnConflictClause()) {
    active_conflict_clause = qb_prototype.getOnConflictClause();
  }
  if (!active_conflict_clause && temp_on_conflict_clause_) {
    active_conflict_clause = temp_on_conflict_clause_.get();
  }
  bool clear_session_temp_on_conflict_at_end =
      (active_conflict_clause == temp_on_conflict_clause_.get() &&
       !conflict_options_override && !qb_prototype.getOnConflictClause());

  if (!data_batch_provider_base || !per_db_batch_completion_callback) {
    if (clear_session_temp_on_conflict_at_end)
      this->clearTempOnConflictClause();
    return Error(ErrorCode::InvalidConfiguration,
                 "CreateBatchProviderInternal: Null data provider or "
                 "completion callback.");
  }

  const FieldMeta *auto_inc_pk_field = meta.getPrimaryField();
  bool has_auto_inc_pk =
      (auto_inc_pk_field &&
       has_flag(auto_inc_pk_field->flags, FieldFlag::AutoIncrement));
  std::string pk_db_name_str = has_auto_inc_pk
                                   ? auto_inc_pk_field->db_name
                                   : ""; // DB name for RETURNING or metadata
  std::string pk_cpp_name_str =
      has_auto_inc_pk ? auto_inc_pk_field->cpp_name : "";
  std::type_index pk_cpp_type =
      has_auto_inc_pk ? auto_inc_pk_field->cpp_type : typeid(void);
  bool driver_supports_last_insert_id =
      db_handle_.driver()->hasFeature(QSqlDriver::LastInsertId);
  QString db_driver_name_upper = db_handle_.driverName().toUpper(); // Get once
  bool use_returning_for_batch =
      (db_driver_name_upper == "QPSQL" && has_auto_inc_pk &&
       !pk_db_name_str.empty() &&
       (!active_conflict_clause ||
        (active_conflict_clause && active_conflict_clause->action !=
                                       OnConflictClause::Action::DoNothing)));

  std::vector<std::string> batch_ordered_db_field_names_cache;
  std::optional<std::vector<ModelBase *>> current_provider_chunk_opt;
  Error first_error_encountered_in_loop = make_ok();

  while (
      (current_provider_chunk_opt = data_batch_provider_base()).has_value()) {
    std::vector<ModelBase *> &models_in_current_provider_chunk =
        current_provider_chunk_opt.value();

    if (models_in_current_provider_chunk.empty()) {
      per_db_batch_completion_callback({}, make_ok());
      continue;
    }

    // 1. 确定字段顺序 (如果尚未确定)
    if (batch_ordered_db_field_names_cache.empty()) {
      ModelBase *first_valid_model = nullptr;
      for (ModelBase *m : models_in_current_provider_chunk) {
        if (m) {
          first_valid_model = m;
          break;
        }
      }
      if (first_valid_model) {
        // 使用 Session 的私有 extractModelData (通过外部助手或友元访问)
        internal::SessionModelDataForWrite first_data =
            this->extractModelData(*first_valid_model, meta, false, true);
        if (first_data.fields_to_write.empty() &&
            !first_data.has_auto_increment_pk) {
          Error err =
              Error(ErrorCode::MappingError,
                    "First model in batch has no writable fields and no "
                    "auto-inc PK. Batch cannot determine field order.");
          per_db_batch_completion_callback(models_in_current_provider_chunk,
                                           err);
          if (first_error_encountered_in_loop.isOk())
            first_error_encountered_in_loop = err;
          continue;
        }
        for (const auto &pair : first_data.fields_to_write) {
          batch_ordered_db_field_names_cache.push_back(
              pair.first.toStdString());
        }
      } else {
        per_db_batch_completion_callback(models_in_current_provider_chunk,
                                         make_ok()); // Chunk of nullptrs
        continue;
      }
    }

    // 特殊处理 PG 纯自增批量插入 (分解为单个)
    if (batch_ordered_db_field_names_cache.empty() && has_auto_inc_pk &&
        db_driver_name_upper == "QPSQL" &&
        models_in_current_provider_chunk.size() > 1) {
      std::vector<ModelBase *> successfully_processed_this_chunk_pg_special;
      bool error_in_this_pg_chunk = false;
      for (ModelBase *model_to_insert_individually :
           models_in_current_provider_chunk) {
        if (!model_to_insert_individually)
          continue;
        QueryBuilder single_model_qb(this, connection_name_, &meta);
        auto single_res =
            this->CreateImpl(single_model_qb, *model_to_insert_individually,
                             active_conflict_clause);

        if (single_res.has_value() &&
            model_to_insert_individually->_is_persisted) {
          successfully_processed_this_chunk_pg_special.push_back(
              model_to_insert_individually);
        } else {
          Error err_single =
              single_res.has_value() ? make_ok() : single_res.error();
          if (!single_res.has_value() &&
              model_to_insert_individually
                  ->_is_persisted) { // persisted but error (unlikely)
            err_single =
                Error(ErrorCode::InternalError,
                      "Model persisted but CreateImpl returned error.");
          } else if (single_res.has_value() &&
                     !model_to_insert_individually
                          ->_is_persisted) { // no error but not persisted
            err_single = Error(ErrorCode::InternalError,
                               "CreateImpl success but model not persisted.");
          }
          per_db_batch_completion_callback({model_to_insert_individually},
                                           err_single);
          if (first_error_encountered_in_loop.isOk() && err_single)
            first_error_encountered_in_loop = err_single;
          error_in_this_pg_chunk = true;
        }
      }
      if (!successfully_processed_this_chunk_pg_special.empty() &&
          !error_in_this_pg_chunk) {
        per_db_batch_completion_callback(
            successfully_processed_this_chunk_pg_special, make_ok());
      } // Individual errors already reported by callback
      continue;
    }

    internal_batch_helpers::BatchSqlParts sql_parts_for_this_db_batch;
    auto [models_prepared_for_db_op, prepare_error] =
        internal_batch_helpers::prepareModelsAndSqlPlaceholders(
            *this, models_in_current_provider_chunk, meta,
            batch_ordered_db_field_names_cache, sql_parts_for_this_db_batch);

    if (prepare_error) {
      if (first_error_encountered_in_loop.isOk())
        first_error_encountered_in_loop = prepare_error;
      if (models_prepared_for_db_op
              .empty()) { // 如果准备后完全为空，则整个 chunk 都有问题
        per_db_batch_completion_callback(models_in_current_provider_chunk,
                                         prepare_error);
      } else { // 部分准备成功，部分失败（失败的已在
               // prepareModelsAndSqlPlaceholders 中单独回调）
        // 对于成功准备的部分，我们是否继续？或者因为批次中部分失败而整体失败？
        // 目前 prepareModelsAndSqlPlaceholders 不会单独回调，它返回第一个错误。
        // 所以如果 prepare_error 非空，意味着整个 chunk 的准备阶段有问题。
        per_db_batch_completion_callback(models_in_current_provider_chunk,
                                         prepare_error);
      }
      continue;
    }
    if (models_prepared_for_db_op.empty()) {
      per_db_batch_completion_callback(models_in_current_provider_chunk,
                                       make_ok()); // 无可操作模型
      continue;
    }

    Error build_sql_err = internal_batch_helpers::buildFullBatchSqlStatement(
        *this, qb_prototype, meta, batch_ordered_db_field_names_cache,
        active_conflict_clause, sql_parts_for_this_db_batch);

    if (build_sql_err || !sql_parts_for_this_db_batch.can_proceed) {
      Error final_build_err = build_sql_err
                                  ? build_sql_err
                                  : Error(ErrorCode::StatementPreparationError,
                                          "Failed to build final SQL for batch "
                                          "(can_proceed is false).");
      per_db_batch_completion_callback(models_prepared_for_db_op,
                                       final_build_err);
      if (first_error_encountered_in_loop.isOk())
        first_error_encountered_in_loop = final_build_err;
      continue;
    }

    internal_batch_helpers::ExecutionResult exec_result =
        internal_batch_helpers::executeBatchSql(
            *this, sql_parts_for_this_db_batch.final_sql_statement,
            sql_parts_for_this_db_batch.final_bindings,
            models_prepared_for_db_op, // 这些是实际参与DB操作的模型
            active_conflict_clause);

    if (exec_result.db_error) {
      per_db_batch_completion_callback(models_prepared_for_db_op,
                                       exec_result.db_error);
      if (first_error_encountered_in_loop.isOk())
        first_error_encountered_in_loop = exec_result.db_error;
      continue;
    }

    std::vector<ModelBase *> successfully_backfilled_models;
    if (has_auto_inc_pk && !exec_result.models_potentially_persisted.empty()) {
      if (use_returning_for_batch) {
        successfully_backfilled_models =
            internal_batch_helpers::backfillIdsFromReturning(
                exec_result.query_object, meta,
                exec_result.models_potentially_persisted, pk_cpp_name_str,
                pk_cpp_type);
      } else if (driver_supports_last_insert_id) {
        successfully_backfilled_models =
            internal_batch_helpers::backfillIdsFromLastInsertId(
                exec_result.query_object, *this, meta,
                exec_result.models_potentially_persisted,
                exec_result.rows_affected, pk_cpp_name_str, pk_cpp_type,
                active_conflict_clause);
      } else { // 无 RETURNING 且无 LastInsertId，但操作成功
        // 此时 successfully_backfilled_models 将为空，但
        // models_potentially_persisted 中的模型 可能已被标记为
        // _is_persisted。回调时传递 models_potentially_persisted。
        for (ModelBase *m : exec_result.models_potentially_persisted) {
          if (m && m->_is_persisted)
            successfully_backfilled_models.push_back(m);
        }
      }
    } else if (!exec_result.models_potentially_persisted.empty() &&
               exec_result.rows_affected >= 0) { // 无自增PK，但操作成功
      for (ModelBase *m : exec_result.models_potentially_persisted) {
        if (m) { // 之前在 executeBatchSql 中已根据行影响数和冲突选项初步标记
          if (m->_is_persisted)
            successfully_backfilled_models.push_back(m);
        }
      }
    }

    internal_batch_helpers::callAfterCreateHooks(
        *this, successfully_backfilled_models, first_error_encountered_in_loop);

    // 决定回调中传递哪个列表：
    // 如果ID回填成功了一些模型，则传递 successfully_backfilled_models。
    // 如果ID回填没有适用或失败，但DB操作本身成功，则传递
    // exec_result.models_potentially_persisted （这些模型已被标记为
    // _is_persisted，只是没有获得ID）。
    // 回调的目的是通知哪些模型被“成功处理”（插入/更新，并尽可能回填ID）。
    if (!successfully_backfilled_models.empty()) {
      per_db_batch_completion_callback(successfully_backfilled_models,
                                       make_ok());
    } else if (exec_result.rows_affected >= 0 &&
               exec_result.db_error.isOk()) { // DB操作成功，但可能无ID回填
      // 检查 models_prepared_for_db_op 中哪些被标记为 _is_persisted
      std::vector<ModelBase *> final_persisted_for_callback;
      for (ModelBase *m : models_prepared_for_db_op) {
        if (m && m->_is_persisted)
          final_persisted_for_callback.push_back(m);
      }
      per_db_batch_completion_callback(final_persisted_for_callback, make_ok());
    } else { // 如果没有成功回填的模型，并且DB操作可能有问题（虽然上面已检查
             // exec_result.db_error）
      per_db_batch_completion_callback(
          {}, exec_result.db_error.isOk()
                  ? Error(ErrorCode::UnknownError,
                          "Batch operation reported success but no models "
                          "processed or IDs backfilled.")
                  : exec_result.db_error);
    }

  } // 结束 provider while 循环

  if (clear_session_temp_on_conflict_at_end) {
    this->clearTempOnConflictClause();
  }

  return first_error_encountered_in_loop;
}

// 实现 CreateBatchWithMeta
std::expected<size_t, Error> Session::CreateBatchWithMeta(
    const ModelMeta &meta, const std::vector<ModelBase *> &models_to_create,
    size_t internal_db_batch_size_hint,
    const OnConflictClause *conflict_options_override) {

  if (models_to_create.empty())
    return 0;

  QueryBuilder qb_proto = this->Model(meta);

  size_t provider_current_idx = 0;
  auto internal_vector_provider = [&models_to_create, provider_current_idx,
                                   internal_db_batch_size_hint]() mutable
      -> std::optional<std::vector<ModelBase *>> {
    if (provider_current_idx >= models_to_create.size()) {
      return std::nullopt;
    }
    std::vector<ModelBase *> chunk;
    size_t end_idx =
        std::min(models_to_create.size(),
                 provider_current_idx + internal_db_batch_size_hint);
    for (size_t i = provider_current_idx; i < end_idx; ++i) {
      if (models_to_create[i]) {
        chunk.push_back(models_to_create[i]);
      }
    }
    provider_current_idx = end_idx;

    if (chunk.empty() && provider_current_idx < models_to_create.size()) {
      return std::vector<ModelBase *>();
    }
    if (chunk.empty())
      return std::nullopt;
    return chunk;
  };

  size_t total_successfully_persisted_accumulator = 0;
  Error first_error_encountered_overall = make_ok();

  auto per_db_batch_completion_callback_for_vector =
      [&total_successfully_persisted_accumulator,
       &first_error_encountered_overall](
          const std::vector<ModelBase *> &processed_batch_models_with_ids,
          Error op_error) {
        if (op_error) {
          if (first_error_encountered_overall.isOk()) {
            first_error_encountered_overall = op_error;
          }
        } else {
          for (ModelBase *bm : processed_batch_models_with_ids) {
            if (bm && bm->_is_persisted) {
              total_successfully_persisted_accumulator++;
            }
          }
        }
      };

  Error provider_loop_err = this->CreateBatchProviderInternal(
      qb_proto, internal_vector_provider,
      per_db_batch_completion_callback_for_vector, conflict_options_override);

  if (provider_loop_err) {
    return std::unexpected(provider_loop_err);
  }
  if (first_error_encountered_overall) {
    return std::unexpected(first_error_encountered_overall);
  }

  return total_successfully_persisted_accumulator;
}

} // namespace cpporm// cpporm/session_create_single_op.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
// #include "cpporm/qt_db_manager.h" // 如果需要直接访问

#include <QDateTime>
#include <QDebug>
#include <QMetaType>
#include <QSqlDriver>
#include <QSqlError>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QVariant>

namespace cpporm {

// Session 的 IQueryExecutor::CreateImpl 实现 (单个模型创建)
std::expected<QVariant, Error>
Session::CreateImpl(const QueryBuilder &qb, ModelBase &model_instance,
                    const OnConflictClause *conflict_options_override) {

  const OnConflictClause *active_conflict_clause = conflict_options_override;
  if (!active_conflict_clause && qb.getOnConflictClause()) {
    active_conflict_clause = qb.getOnConflictClause();
  }
  if (!active_conflict_clause && temp_on_conflict_clause_) {
    active_conflict_clause = temp_on_conflict_clause_.get();
  }

  bool clear_temp_on_conflict_at_end =
      (active_conflict_clause == temp_on_conflict_clause_.get() &&
       !conflict_options_override && !qb.getOnConflictClause());

  const ModelMeta *meta_ptr = qb.getModelMeta();
  if (!meta_ptr) { // 尝试从模型实例获取
    meta_ptr = &(model_instance._getOwnModelMeta());
  }
  if (!meta_ptr || meta_ptr->table_name.empty()) {
    if (clear_temp_on_conflict_at_end)
      this->clearTempOnConflictClause();
    return std::unexpected(
        Error(ErrorCode::InvalidConfiguration,
              "CreateImpl: ModelMeta is not valid or table name is empty."));
  }
  const ModelMeta &meta = *meta_ptr;

  Error hook_err = model_instance.beforeCreate(*this);
  if (hook_err) {
    if (clear_temp_on_conflict_at_end)
      this->clearTempOnConflictClause();
    return std::unexpected(hook_err);
  }

  this->autoSetTimestamps(model_instance, meta, true);
  cpporm::internal::SessionModelDataForWrite data_to_write =
      this->extractModelData(model_instance, meta, false /* for_update */,
                             true /* include_timestamps_even_if_null */);

  if (data_to_write.fields_to_write.empty() &&
      !data_to_write.has_auto_increment_pk) {
    bool is_simple_auto_inc_model =
        data_to_write.has_auto_increment_pk && meta.fields.size() == 1 &&
        meta.getPrimaryField() &&
        has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);
    if (!is_simple_auto_inc_model) {
      if (clear_temp_on_conflict_at_end)
        this->clearTempOnConflictClause();
      return std::unexpected(Error(ErrorCode::MappingError,
                                   "No fields to insert for Create operation "
                                   "and not a simple auto-increment model."));
    }
  }

  QStringList field_names_qsl;
  QVariantList values_to_bind_insert;
  QStringList placeholders_qsl;
  std::vector<std::string> ordered_db_field_names_vec;

  QString driverNameUpper = db_handle_.driverName().toUpper();

  for (const auto &[db_name_qstr, q_val] : data_to_write.fields_to_write) {
    ordered_db_field_names_vec.push_back(db_name_qstr.toStdString());
    field_names_qsl.append(QString::fromStdString(
        QueryBuilder::quoteSqlIdentifier(db_name_qstr.toStdString())));
    values_to_bind_insert.append(q_val); // Value always gets appended

    bool placeholder_handled = false;
    if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
      const FieldMeta *fm = meta.findFieldByDbName(db_name_qstr.toStdString());
      if (fm &&
          (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" ||
           fm->db_type_hint == "LINESTRING" || fm->db_type_hint == "POLYGON" ||
           fm->db_type_hint == "MULTIPOINT" ||
           fm->db_type_hint == "MULTILINESTRING" ||
           fm->db_type_hint == "MULTIPOLYGON" ||
           fm->db_type_hint == "GEOMETRYCOLLECTION")) {
        placeholders_qsl.append("ST_GeomFromText(?)");
        placeholder_handled = true;
      }
    }
    if (!placeholder_handled) {
      placeholders_qsl.append("?");
    }
  }

  QString sql_verb = "INSERT";
  if (active_conflict_clause &&
      active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
    if (db_handle_.driverName().toUpper().contains("MYSQL")) {
      sql_verb = "INSERT IGNORE";
    }
    // 对于 PostgreSQL, ON CONFLICT DO NOTHING 会在 suffix 中处理
  }

  QString sql_query_base;
  if (!field_names_qsl.isEmpty()) {
    sql_query_base = QString("%1 INTO %2 (%3) VALUES (%4)")
                         .arg(sql_verb)
                         .arg(QString::fromStdString(
                             QueryBuilder::quoteSqlIdentifier(meta.table_name)))
                         .arg(field_names_qsl.join(", "))
                         .arg(placeholders_qsl.join(", "));
  } else if (data_to_write.has_auto_increment_pk) { // 只有自增主键的情况
    if (db_handle_.driverName().toUpper() == "QPSQL") {
      // PostgreSQL: INSERT INTO "table" DEFAULT VALUES
      // 如果是 INSERT IGNORE，PG 的对应是 ON CONFLICT DO NOTHING，由 suffix
      // 处理
      sql_query_base =
          QString("INSERT INTO %1 DEFAULT VALUES") // sql_verb 总是 INSERT
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(meta.table_name)));
    } else { // MySQL: INSERT IGNORE INTO `table` () VALUES () 或 INSERT INTO
             // `table` () VALUES ()
      sql_query_base =
          QString("%1 INTO %2 () VALUES ()")
              .arg(sql_verb)
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(meta.table_name)));
    }
  } else {
    if (clear_temp_on_conflict_at_end)
      this->clearTempOnConflictClause();
    return std::unexpected(
        Error(ErrorCode::MappingError,
              "Cannot construct INSERT: no fields and no auto-inc PK."));
  }

  QString sql_on_conflict_suffix_str;
  QVariantList suffix_bindings;
  if (active_conflict_clause) { // 只要有 active_conflict_clause 就尝试构建后缀
    // 创建一个临时的 QB 来构建后缀，它不需要 executor
    QueryBuilder temp_qb_for_suffix(nullptr, this->connection_name_, &meta);
    // 复制 OnConflictClause 的状态给临时 QB
    temp_qb_for_suffix.getState_().on_conflict_clause_ =
        std::make_unique<OnConflictClause>(*active_conflict_clause);

    auto suffix_pair =
        temp_qb_for_suffix.buildInsertSQLSuffix(ordered_db_field_names_vec);
    sql_on_conflict_suffix_str = suffix_pair.first;
    suffix_bindings = suffix_pair.second;

    // 特殊处理 MySQL 的 INSERT IGNORE：如果 buildInsertSQLSuffix 返回了非空后缀
    // （例如，它内部没有处理 IGNORE 的特殊情况），而我们已经设置了 sql_verb =
    // "INSERT IGNORE"， 这时需要避免重复的冲突处理。 但当前的
    // buildInsertSQLSuffix 对于 Action::DoNothing (MySQL) 返回空，所以没问题。
  }

  QString final_sql_query_str = sql_query_base + sql_on_conflict_suffix_str;
  QVariantList all_bindings = values_to_bind_insert;
  all_bindings.append(suffix_bindings);

  bool driver_can_return_id =
      db_handle_.driver()->hasFeature(QSqlDriver::LastInsertId);
  bool use_returning_clause =
      (db_handle_.driverName().toUpper() == "QPSQL" &&
       data_to_write.has_auto_increment_pk &&
       !data_to_write.auto_increment_pk_name_db.isEmpty() &&
       // RETURNING 适用于普通 INSERT 或 ON CONFLICT ... DO UPDATE
       (sql_verb ==
            "INSERT" || // sql_verb 对 PG 总是 INSERT，冲突由 suffix 处理
        (active_conflict_clause && active_conflict_clause->action !=
                                       OnConflictClause::Action::DoNothing)));

  if (use_returning_clause) {
    final_sql_query_str +=
        " RETURNING " +
        QString::fromStdString(QueryBuilder::quoteSqlIdentifier(
            data_to_write.auto_increment_pk_name_db.toStdString()));
  }

  auto [query, exec_err] = execute_query_internal(
      this->db_handle_, final_sql_query_str, all_bindings);

  if (clear_temp_on_conflict_at_end)
    this->clearTempOnConflictClause();

  if (exec_err)
    return std::unexpected(exec_err);

  long long rows_affected = query.numRowsAffected();
  model_instance._is_persisted =
      (rows_affected > 0 ||
       (active_conflict_clause &&
        active_conflict_clause->action != OnConflictClause::Action::DoNothing &&
        rows_affected >=
            0)); // MySQL ON DUP UPDATE 可能返回 0（无变化）或 2（有变化）

  QVariant returned_id;
  bool was_insert_action =
      (sql_verb == "INSERT" || sql_verb == "INSERT IGNORE");
  bool was_upsert_action =
      (active_conflict_clause &&
       active_conflict_clause->action != OnConflictClause::Action::DoNothing);

  if (use_returning_clause && (was_insert_action || was_upsert_action) &&
      rows_affected > 0) {
    if (query.next())
      returned_id = query.value(0);
  } else if (data_to_write.has_auto_increment_pk && driver_can_return_id &&
             was_insert_action && rows_affected == 1) {
    returned_id = query.lastInsertId();
  } else if (data_to_write.has_auto_increment_pk && driver_can_return_id &&
             was_upsert_action && rows_affected > 0 && sql_verb == "INSERT") {
    // 对于 MySQL 的 ON DUPLICATE KEY UPDATE, 如果实际执行了 UPDATE,
    // lastInsertId 通常是0或旧ID 如果是新插入（即冲突导致了新行），lastInsertId
    // 是新ID，rows_affected 是1 如果是更新，rows_affected 是2 (MySQL 5.x+) 或 1
    // (如果行未改变)
    if (rows_affected == 1 &&
        db_handle_.driverName().toUpper().contains("MYSQL")) { // 假设是新插入
      returned_id = query.lastInsertId();
    }
  }

  if (returned_id.isValid() && !returned_id.isNull() &&
      data_to_write.has_auto_increment_pk) {
    std::any pk_val_any;
    bool conversion_ok = false;
    const auto &pk_type = data_to_write.pk_cpp_type_for_autoincrement;
    const std::string &pk_cpp_name =
        data_to_write.pk_cpp_name_for_autoincrement;
    if (pk_type == typeid(int))
      pk_val_any = returned_id.toInt(&conversion_ok);
    else if (pk_type == typeid(long long))
      pk_val_any = returned_id.toLongLong(&conversion_ok);
    else if (pk_type == typeid(unsigned int))
      pk_val_any = returned_id.toUInt(&conversion_ok);
    else if (pk_type == typeid(unsigned long long))
      pk_val_any = returned_id.toULongLong(&conversion_ok);
    else if (pk_type == typeid(std::string)) {
      pk_val_any = returned_id.toString().toStdString();
      conversion_ok = true;
    } else {
      qWarning() << "CreateImpl: Unhandled PK C++ type for backfill:"
                 << pk_type.name();
    }
    if (conversion_ok) {
      Error set_pk_err = model_instance.setFieldValue(pk_cpp_name, pk_val_any);
      if (set_pk_err)
        qWarning() << "CreateImpl: Error setting auto-incremented PK: "
                   << set_pk_err.toString().c_str();
    } else {
      qWarning() << "CreateImpl: Conversion failed for PK backfill. DB val:"
                 << returned_id.toString() << " to C++ type " << pk_type.name();
    }
  }

  if (model_instance._is_persisted) {
    hook_err = model_instance.afterCreate(*this);
    if (hook_err)
      return std::unexpected(hook_err);
  }

  if (returned_id.isValid() && !returned_id.isNull())
    return returned_id;
  return QVariant(rows_affected);
}

// Session 的便捷 Create 方法
std::expected<QVariant, Error>
Session::Create(ModelBase &model,
                const OnConflictClause *conflict_options_override) {
  // 使用 model 的元数据创建一个基础的 QueryBuilder，它将包含正确的 executor
  QueryBuilder qb = this->Model(&model);
  return this->CreateImpl(qb, model, conflict_options_override);
}

} // namespace cpporm// cpporm/session_delete_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h" // Now includes core, execution, and state
#include "cpporm/session.h"

#include <QDateTime>
#include <QDebug>
#include <QSqlQuery>
#include <QVariant>
#include <algorithm> // for std::min

namespace cpporm {

// Session 的 IQueryExecutor::DeleteImpl 实现
std::expected<long long, Error>
Session::DeleteImpl(const QueryBuilder &qb_const) {
  QueryBuilder qb = qb_const; // Work with a copy

  const ModelMeta *meta = qb.getModelMeta();

  // Soft Delete Logic
  if (meta && qb.isSoftDeleteScopeActive()) { // isSoftDeleteScopeActive is from
                                              // QueryBuilderScopesMixin
    if (const FieldMeta *deletedAtField =
            meta->findFieldWithFlag(FieldFlag::DeletedAt)) {

      bool can_soft_delete_this_target = false;
      if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
        const std::string &from_name =
            std::get<std::string>(qb.getFromClauseSource());
        // Check if the FROM source is the model's primary table
        if ((!from_name.empty() && from_name == meta->table_name) ||
            (from_name.empty() &&
             !meta->table_name
                  .empty() /* implies default to model's table */)) {
          can_soft_delete_this_target = true;
        }
      }

      if (can_soft_delete_this_target) {
        if (deletedAtField->cpp_type == typeid(QDateTime)) {
          std::map<std::string, QueryValue> updates_for_soft_delete;
          updates_for_soft_delete[deletedAtField->db_name] =
              QDateTime::currentDateTimeUtc();

          if (const FieldMeta *updatedAtField =
                  meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
            if (updatedAtField->cpp_type == typeid(QDateTime)) {
              updates_for_soft_delete[updatedAtField->db_name] =
                  QDateTime::currentDateTimeUtc();
            } else {
              qWarning("Session::DeleteImpl (Soft Delete): Model %s has "
                       "UpdatedAt field (%s) but it's not QDateTime. It won't "
                       "be auto-updated during soft delete.",
                       meta->table_name.c_str(),
                       updatedAtField->db_name.c_str());
            }
          }

          QueryBuilder update_qb_for_soft_delete = qb;
          update_qb_for_soft_delete.Unscoped();

          // Call UpdatesImpl which correctly builds UPDATE SQL and handles
          // hooks UpdatesImpl (which is Session::UpdatesImpl) will handle its
          // own timestamp logic based on the qb and meta. If we set updated_at
          // here, it's fine.
          return this->UpdatesImpl(update_qb_for_soft_delete,
                                   updates_for_soft_delete);
        } else {
          qWarning(
              "Session::DeleteImpl: Model %s has DeletedAt field (%s) but it's "
              "not QDateTime. Soft delete skipped. Hard delete will proceed.",
              meta->table_name.c_str(), deletedAtField->db_name.c_str());
        }
      }
    }
  }

  // If not soft-deleted, proceed with hard delete
  auto [sql, params] = qb.buildDeleteSQL();
  if (sql.isEmpty()) {
    return std::unexpected(
        Error(ErrorCode::StatementPreparationError,
              "Failed to build SQL for hard Delete operation."));
  }

  // Hooks are generally managed by higher-level methods if model instances are
  // involved. DeleteImpl is generic.

  auto [query_obj, exec_err] =
      execute_query_internal(this->db_handle_, sql, params);
  if (exec_err)
    return std::unexpected(exec_err);

  return query_obj.numRowsAffected();
}

// Session 的便捷 Delete 方法 (通过 QB)
std::expected<long long, Error> Session::Delete(QueryBuilder qb) {
  if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
    qWarning("Session::Delete(QueryBuilder): QueryBuilder was associated with "
             "a different executor. "
             "The operation will use THIS session's context by calling its "
             "DeleteImpl. "
             "Ensure this is intended.");
  }
  // Always use this session's Impl method for consistency when
  // Session::Delete(QB) is called.
  return this->DeleteImpl(qb);
}

// Session 的便捷 Delete 方法 (通过 ModelBase 实例)
std::expected<long long, Error>
Session::Delete(const ModelBase &model_condition) {
  const ModelMeta &meta = model_condition._getOwnModelMeta();
  // Use session's Model<T>() or Model(meta) to get a QB associated with this
  // session
  QueryBuilder qb = this->Model(meta);

  if (meta.primary_keys_db_names.empty()) {
    return std::unexpected(
        Error(ErrorCode::MappingError,
              "Delete by model_condition: No PK defined for model " +
                  meta.table_name));
  }

  // Hooks: GORM typically calls hooks on the model instance if Delete(&model)
  // is used. For Delete(ModelBase&), we might need to cast away const to call
  // non-const hooks. This is a design choice. For now, assuming hooks handled
  // at a higher level or if a non-const ModelBase& was passed. If we want to
  // call hooks here: cpporm::Error hook_err =
  // const_cast<ModelBase&>(model_condition).beforeDelete(*this); if(hook_err)
  // return std::unexpected(hook_err);

  std::map<std::string, QueryValue> pk_conditions;
  for (const auto &pk_name : meta.primary_keys_db_names) {
    const FieldMeta *fm = meta.findFieldByDbName(pk_name);
    if (!fm)
      return std::unexpected(Error(
          ErrorCode::InternalError,
          "PK field meta not found for DB name '" + pk_name +
              "' in Delete by model_condition for table " + meta.table_name));
    std::any val = model_condition.getFieldValue(fm->cpp_name);
    if (!val.has_value())
      return std::unexpected(
          Error(ErrorCode::MappingError,
                "PK value for '" + fm->cpp_name +
                    "' not set in model_condition for Delete on table " +
                    meta.table_name));

    QueryValue qv_pk = Session::anyToQueryValueForSessionConvenience(val);
    if (std::holds_alternative<std::nullptr_t>(qv_pk) &&
        val.has_value()) { // Conversion failed
      return std::unexpected(Error(
          ErrorCode::MappingError,
          "Delete by model_condition: Unsupported PK type (" +
              std::string(val.type().name()) + ") for field " + fm->cpp_name));
    }
    pk_conditions[pk_name] = qv_pk;
  }

  if (pk_conditions.empty() ||
      pk_conditions.size() !=
          meta.primary_keys_db_names
              .size()) // Ensure all PKs were found and valid
    return std::unexpected(Error(
        ErrorCode::MappingError,
        "Could not extract all PKs for Delete by model_condition on table " +
            meta.table_name));

  qb.Where(pk_conditions);

  auto delete_result = this->DeleteImpl(qb);

  // if (delete_result.has_value() && delete_result.value() > 0) {
  //   cpporm::Error hook_err_after =
  //   const_cast<ModelBase&>(model_condition).afterDelete(*this);
  //   if(hook_err_after) return std::unexpected(hook_err_after);
  // }
  return delete_result;
}

// Session 的便捷 Delete 方法 (通过 ModelMeta 和条件)
std::expected<long long, Error>
Session::Delete(const ModelMeta &meta,
                const std::map<std::string, QueryValue> &conditions) {
  QueryBuilder qb = this->Model(meta);
  if (!conditions.empty()) {
    qb.Where(conditions);
  } else {
    // Warning about deleting all rows is handled by
    // QueryBuilder::buildDeleteSQL if no WHERE clause is ultimately produced.
  }
  return this->DeleteImpl(qb);
}

std::expected<long long, Error> Session::DeleteBatch(
    const ModelMeta &meta,
    const std::vector<std::map<std::string, QueryValue>> &primary_keys_list,
    size_t batch_delete_size_hint) {

  if (primary_keys_list.empty()) {
    return 0LL;
  }
  if (meta.table_name.empty()) {
    return std::unexpected(
        Error(ErrorCode::InvalidConfiguration,
              "DeleteBatch: ModelMeta does not have a valid table name."));
  }
  if (meta.primary_keys_db_names.empty()) {
    return std::unexpected(
        Error(ErrorCode::MappingError, "DeleteBatch: Model " + meta.table_name +
                                           " has no primary keys defined."));
  }

  long long total_rows_affected_accumulator = 0;
  Error first_error_encountered = make_ok();
  bool an_error_occurred_in_any_batch = false;

  size_t actual_batch_size = batch_delete_size_hint;
  if (actual_batch_size == 0 && !primary_keys_list.empty())
    actual_batch_size = 1;
  if (actual_batch_size > 200)
    actual_batch_size = 100; // Cap batch size

  for (size_t i = 0; i < primary_keys_list.size(); i += actual_batch_size) {
    // Create a QB specifically for this session and meta for each batch
    QueryBuilder qb_for_this_batch(this, this->connection_name_, &meta);

    size_t current_batch_end_idx =
        std::min(i + actual_batch_size, primary_keys_list.size());

    if (current_batch_end_idx <= i)
      continue;

    if (meta.primary_keys_db_names.size() == 1) { // Single PK
      const std::string &pk_col_db_name = meta.primary_keys_db_names[0];
      std::vector<QueryValue> pk_values_for_in_clause;
      pk_values_for_in_clause.reserve(current_batch_end_idx - i);

      for (size_t k = i; k < current_batch_end_idx; ++k) {
        const auto &pk_map_for_item = primary_keys_list[k];
        auto it = pk_map_for_item.find(pk_col_db_name);
        if (it != pk_map_for_item.end()) {
          pk_values_for_in_clause.push_back(it->second);
        } else {
          qWarning("DeleteBatch: PK '%s' not found in map for item at index "
                   "%zu. Skipping this item.",
                   pk_col_db_name.c_str(), k);
        }
      }
      if (!pk_values_for_in_clause.empty()) {
        std::string placeholders_for_in;
        for (size_t p = 0; p < pk_values_for_in_clause.size(); ++p) {
          placeholders_for_in += (p == 0 ? "?" : ",?");
        }
        qb_for_this_batch.Where(
            QueryBuilder::quoteSqlIdentifier(pk_col_db_name) + " IN (" +
                placeholders_for_in + ")",
            pk_values_for_in_clause);
      } else {
        continue;
      }
    } else { // Composite PKs
      std::vector<std::string> or_conditions_str_parts;
      std::vector<QueryValue> all_composite_pk_bindings;
      or_conditions_str_parts.reserve(current_batch_end_idx - i);

      for (size_t k = i; k < current_batch_end_idx; ++k) {
        std::string current_item_pk_condition_group_str = "(";
        bool first_col_in_group = true;
        bool current_item_pk_group_valid = true;
        std::vector<QueryValue> bindings_for_current_item_group;
        bindings_for_current_item_group.reserve(
            meta.primary_keys_db_names.size());

        for (const std::string &pk_col_db_name_part :
             meta.primary_keys_db_names) {
          const auto &pk_map_for_item = primary_keys_list[k];
          auto it = pk_map_for_item.find(pk_col_db_name_part);
          if (it == pk_map_for_item.end()) {
            qWarning("DeleteBatch: Composite PK part '%s' not found for item "
                     "at index %zu. Skipping this item.",
                     pk_col_db_name_part.c_str(), k);
            current_item_pk_group_valid = false;
            break;
          }
          if (!first_col_in_group) {
            current_item_pk_condition_group_str += " AND ";
          }
          current_item_pk_condition_group_str +=
              QueryBuilder::quoteSqlIdentifier(pk_col_db_name_part) + " = ?";
          bindings_for_current_item_group.push_back(it->second);
          first_col_in_group = false;
        }
        current_item_pk_condition_group_str += ")";

        if (current_item_pk_group_valid &&
            !bindings_for_current_item_group.empty()) {
          or_conditions_str_parts.push_back(
              current_item_pk_condition_group_str);
          all_composite_pk_bindings.insert(
              all_composite_pk_bindings.end(),
              std::make_move_iterator(bindings_for_current_item_group.begin()),
              std::make_move_iterator(bindings_for_current_item_group.end()));
        }
      }
      if (!or_conditions_str_parts.empty()) {
        std::string final_or_where_clause_str;
        for (size_t o_idx = 0; o_idx < or_conditions_str_parts.size();
             ++o_idx) {
          final_or_where_clause_str += or_conditions_str_parts[o_idx];
          if (o_idx < or_conditions_str_parts.size() - 1) {
            final_or_where_clause_str += " OR ";
          }
        }
        qb_for_this_batch.Where(final_or_where_clause_str,
                                all_composite_pk_bindings);
      } else {
        continue;
      }
    }

    auto batch_delete_result = this->DeleteImpl(qb_for_this_batch);

    if (batch_delete_result.has_value()) {
      total_rows_affected_accumulator += batch_delete_result.value();
    } else {
      if (!an_error_occurred_in_any_batch) {
        first_error_encountered = batch_delete_result.error();
        an_error_occurred_in_any_batch = true;
      }
      qWarning("DeleteBatch: Error in sub-batch for table %s. Error: %s",
               meta.table_name.c_str(),
               batch_delete_result.error().toString().c_str());
    }
  }

  if (an_error_occurred_in_any_batch)
    return std::unexpected(first_error_encountered);
  return total_rows_affected_accumulator;
}

} // namespace cpporm// cpporm/session_lifecycle.cpp
#include "cpporm/model_base.h" // FriendAccess 可能需要 ModelBase/ModelMeta
#include "cpporm/qt_db_manager.h"
#include "cpporm/session.h" // 主头文件
#include "cpporm/session_priv_batch_helpers.h" // For FriendAccess definition & internal::SessionModelDataForWrite

#include <QDebug>
#include <QSqlDriver>
#include <QSqlError>
#include <QSqlQuery> // For FriendAccess::callExecuteQueryInternal

namespace cpporm {

// --- Session 构造函数、析构函数、移动操作 ---
Session::Session(QString connection_name)
    : connection_name_(std::move(connection_name)),
      db_handle_(QtDbManager::getDatabase(connection_name_)),
      is_explicit_transaction_handle_(false),
      temp_on_conflict_clause_(nullptr) {
  if (!db_handle_.isValid()) {
    qWarning()
        << "cpporm Session: Constructed with invalid QSqlDatabase for "
           "connection name:"
        << connection_name_ << ". Last DB error: "
        << QSqlDatabase::database(connection_name_, false).lastError().text();
  }
}

Session::Session(QSqlDatabase db_handle)
    : connection_name_(db_handle.connectionName()), db_handle_(db_handle),
      is_explicit_transaction_handle_(true), temp_on_conflict_clause_(nullptr) {
  if (!db_handle_.isValid()) {
    qWarning() << "cpporm Session: Constructed with an invalid QSqlDatabase "
                  "handle for connection:"
               << connection_name_;
  }
}

Session::~Session() {
  if (is_explicit_transaction_handle_ && db_handle_.isValid() &&
      db_handle_.isOpen() && db_handle_.driver() &&
      db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
    qWarning() << "cpporm Session: Destructor called for an active "
                  "transaction on connection"
               << connection_name_ << ". Rolling back automatically.";
    db_handle_.rollback();
  }
}

Session::Session(Session &&other) noexcept
    : connection_name_(std::move(other.connection_name_)),
      db_handle_(std::move(other.db_handle_)),
      is_explicit_transaction_handle_(other.is_explicit_transaction_handle_),
      temp_on_conflict_clause_(std::move(other.temp_on_conflict_clause_)) {
  other.is_explicit_transaction_handle_ = false;
}

Session &Session::operator=(Session &&other) noexcept {
  if (this != &other) {
    if (is_explicit_transaction_handle_ && db_handle_.isValid() &&
        db_handle_.isOpen() && db_handle_.driver() &&
        db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
      db_handle_.rollback();
    }
    connection_name_ = std::move(other.connection_name_);
    db_handle_ = std::move(other.db_handle_);
    is_explicit_transaction_handle_ = other.is_explicit_transaction_handle_;
    temp_on_conflict_clause_ = std::move(other.temp_on_conflict_clause_);
    other.is_explicit_transaction_handle_ = false;
  }
  return *this;
}

// --- Accessors implementation ---
QString Session::getConnectionName() const { return connection_name_; }

QSqlDatabase Session::getDbHandle() const {
  if (!connection_name_.isEmpty()) {
    // Ensure it returns the handle for this session, not just a default
    return QSqlDatabase::database(connection_name_, false);
  }
  // If connection_name_ is empty (should not happen with current constructors),
  // or if the named connection was removed externally, this could be an issue.
  // For safety, one might re-validate db_handle_ here or always use
  // QSqlDatabase::database. However, db_handle_ is stored for transactional
  // session objects.
  return db_handle_; // Return the stored handle
}
const OnConflictClause *Session::getTempOnConflictClause() const {
  return temp_on_conflict_clause_.get();
}
void Session::clearTempOnConflictClause() { temp_on_conflict_clause_.reset(); }

// --- internal_batch_helpers::FriendAccess implementations ---
// 这些方法使得 internal_batch_helpers 命名空间中的函数能够以受控的方式访问
// Session 的私有成员。

cpporm::internal::SessionModelDataForWrite
internal_batch_helpers::FriendAccess::callExtractModelData(
    Session &s, const ModelBase &model_instance, const ModelMeta &meta,
    bool for_update, bool include_timestamps_even_if_null) {
  // 直接调用 Session 的私有成员函数
  return s.extractModelData(model_instance, meta, for_update,
                            include_timestamps_even_if_null);
}

std::pair<QSqlQuery, Error>
internal_batch_helpers::FriendAccess::callExecuteQueryInternal(
    QSqlDatabase db, // Session 实例不是必需的，因为原始函数是静态的
    const QString &sql, const QVariantList &params) {
  // 直接调用 Session 的私有静态成员函数
  return Session::execute_query_internal(db, sql, params);
}

void internal_batch_helpers::FriendAccess::callAutoSetTimestamps(
    Session &s, ModelBase &model_instance, const ModelMeta &meta,
    bool is_create_op) {
  s.autoSetTimestamps(model_instance, meta, is_create_op);
}

} // namespace cpporm// cpporm/session_mapping_utils.cpp
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QDebug>
#include <QMetaType>
#include <QSqlRecord>
#include <QTime>
#include <QVariant>

namespace cpporm {

Error Session::mapRowToModel(QSqlQuery &query, ModelBase &model,
                             const ModelMeta &meta) {
  QSqlRecord record = query.record();
  for (int i = 0; i < record.count(); ++i) {
    QString db_col_name_qstr = record.fieldName(i);
    const FieldMeta *field_meta =
        meta.findFieldByDbName(db_col_name_qstr.toStdString());

    if (!field_meta) {
      continue;
    }
    if (has_flag(field_meta->flags, FieldFlag::Association))
      continue;

    QVariant q_value = query.value(i);
    std::any cpp_value;

    if (q_value.isNull() || q_value.typeId() == QMetaType::UnknownType ||
        !q_value.isValid()) {
      // If DB value is NULL, set std::any to represent this (empty or specific
      // null type)
      Error set_err = model.setFieldValue(field_meta->cpp_name, std::any{});
      if (set_err) {
        qWarning() << "cpporm Session::mapRowToModel: Error setting "
                      "null/invalid field"
                   << QString::fromStdString(field_meta->cpp_name) << ":"
                   << set_err.toString().c_str();
      }
      continue;
    }

    bool conversion_ok = false;
    if (field_meta->cpp_type == typeid(QDateTime)) {
      if (q_value.canConvert<QDateTime>()) {
        cpp_value = q_value.toDateTime();
        conversion_ok = true;
      }
    } else if (field_meta->cpp_type == typeid(QDate)) {
      if (q_value.canConvert<QDate>()) {
        cpp_value = q_value.toDate();
        conversion_ok = true;
      }
    } else if (field_meta->cpp_type == typeid(QTime)) {
      if (q_value.canConvert<QTime>()) {
        cpp_value = q_value.toTime();
        conversion_ok = true;
      }
    } else if (field_meta->cpp_type == typeid(std::string)) {
      if (q_value.typeId() == QMetaType::QByteArray) {
        // If the database returns bytes (e.g. for TEXT/BLOB treated as string)
        // assume UTF-8. If it's truly binary, std::string might not be the best
        // C++ type.
        QByteArray ba = q_value.toByteArray();
        cpp_value = std::string(ba.constData(), static_cast<size_t>(ba.size()));
        conversion_ok = true;
      } else if (q_value.canConvert<QString>()) {
        QByteArray ba = q_value.toString().toUtf8();
        cpp_value = std::string(ba.constData(), static_cast<size_t>(ba.size()));
        conversion_ok = true;
      } else {
        qWarning()
            << "cpporm Session::mapRowToModel: QVariant for std::string field "
            << QString::fromStdString(field_meta->cpp_name)
            << " cannot be converted to QString or QByteArray. DB value type: "
            << q_value.typeName();
      }
    } else if (field_meta->cpp_type == typeid(int)) {
      cpp_value = q_value.toInt(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(long long)) {
      cpp_value = q_value.toLongLong(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(unsigned int)) {
      cpp_value = q_value.toUInt(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(unsigned long long)) {
      cpp_value = q_value.toULongLong(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(double)) {
      cpp_value = q_value.toDouble(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(float)) {
      cpp_value = q_value.toFloat(&conversion_ok);
    } else if (field_meta->cpp_type == typeid(bool)) {
      cpp_value = q_value.toBool();
      conversion_ok = true;
    } else if (field_meta->cpp_type == typeid(QByteArray)) {
      cpp_value = q_value.toByteArray();
      conversion_ok = true;
    } else {
      qWarning()
          << "cpporm Session::mapRowToModel: Unsupported C++ type for field"
          << QString::fromStdString(field_meta->cpp_name)
          << "Type:" << field_meta->cpp_type.name();
      continue;
    }

    if (!conversion_ok) {
      qWarning() << "cpporm Session::mapRowToModel: QVariant to C++ type "
                    "conversion failed for field"
                 << QString::fromStdString(field_meta->cpp_name)
                 << ". DB value:" << q_value.toString()
                 << "(QVariant type:" << q_value.typeName()
                 << ", Target C++ type:" << field_meta->cpp_type.name() << ")";
      Error set_err = model.setFieldValue(field_meta->cpp_name, std::any{});
      if (set_err) {
        // Potentially return error or log and continue
      }
      continue;
    }

    Error set_err = model.setFieldValue(field_meta->cpp_name, cpp_value);
    if (set_err) {
      qWarning() << "cpporm Session::mapRowToModel: Error setting field"
                 << QString::fromStdString(field_meta->cpp_name)
                 << "after conversion:" << set_err.toString().c_str();
    }
  }
  model._is_persisted = true;
  return make_ok();
}

cpporm::internal::SessionModelDataForWrite
Session::extractModelData(const ModelBase &model_instance,
                          const ModelMeta &meta, bool for_update,
                          bool include_timestamps_even_if_null) {
  cpporm::internal::SessionModelDataForWrite data;

  for (const auto &field_meta : meta.fields) {
    if (has_flag(field_meta.flags, FieldFlag::Association))
      continue;

    bool is_pk = has_flag(field_meta.flags, FieldFlag::PrimaryKey);
    bool is_auto_inc = has_flag(field_meta.flags, FieldFlag::AutoIncrement);

    std::any val_any = model_instance.getFieldValue(field_meta.cpp_name);

    QVariant q_val;
    if (!val_any.has_value()) {
      q_val = QVariant(QMetaType(
          QMetaType::UnknownType)); // Explicitly SQL NULL representation
    } else if (val_any.type() == typeid(int)) {
      q_val.setValue(std::any_cast<int>(val_any));
    } else if (val_any.type() == typeid(long long)) {
      q_val.setValue(std::any_cast<long long>(val_any));
    } else if (val_any.type() == typeid(unsigned int)) {
      q_val.setValue(std::any_cast<unsigned int>(val_any));
    } else if (val_any.type() == typeid(unsigned long long)) {
      q_val.setValue(std::any_cast<unsigned long long>(val_any));
    } else if (val_any.type() == typeid(double)) {
      q_val.setValue(std::any_cast<double>(val_any));
    } else if (val_any.type() == typeid(float)) {
      q_val.setValue(std::any_cast<float>(val_any));
    } else if (val_any.type() == typeid(std::string)) {
      q_val.setValue(
          QString::fromUtf8(std::any_cast<std::string>(val_any).c_str()));
    } else if (val_any.type() == typeid(bool)) {
      q_val.setValue(std::any_cast<bool>(val_any));
    } else if (val_any.type() == typeid(QByteArray)) {
      q_val.setValue(std::any_cast<QByteArray>(val_any));
    } else if (val_any.type() == typeid(QDate)) {
      q_val.setValue(std::any_cast<QDate>(val_any));
    } else if (val_any.type() == typeid(QTime)) {
      q_val.setValue(std::any_cast<QTime>(val_any));
    } else if (val_any.type() == typeid(QDateTime)) {
      q_val.setValue(std::any_cast<QDateTime>(val_any));
    } else {
      qWarning() << "cpporm Session::extractModelData: Unsupported C++ type "
                    "in model field "
                 << QString::fromStdString(field_meta.cpp_name);
      continue;
    }

    if (is_pk) {
      if (q_val.isValid() && !q_val.isNull()) {
        data.primary_key_fields[QString::fromStdString(field_meta.db_name)] =
            q_val;
      }
      if (is_auto_inc) {
        data.has_auto_increment_pk = true;
        data.auto_increment_pk_name_db =
            QString::fromStdString(field_meta.db_name);
        data.pk_cpp_name_for_autoincrement = field_meta.cpp_name;
        data.pk_cpp_type_for_autoincrement = field_meta.cpp_type;
      }
    }

    if (for_update) {
      if (is_pk || has_flag(field_meta.flags, FieldFlag::CreatedAt)) {
        continue;
      }
      if (has_flag(field_meta.flags, FieldFlag::UpdatedAt) &&
          !include_timestamps_even_if_null && !val_any.has_value()) {
        continue;
      }
    } else { // Create operation
      if (is_auto_inc && is_pk) {
        continue;
      }
      if ((has_flag(field_meta.flags, FieldFlag::CreatedAt) ||
           has_flag(field_meta.flags, FieldFlag::UpdatedAt)) &&
          !include_timestamps_even_if_null && !val_any.has_value()) {
        continue;
      }
    }
    data.fields_to_write[QString::fromStdString(field_meta.db_name)] = q_val;
  }
  return data;
}

void Session::autoSetTimestamps(ModelBase &model_instance,
                                const ModelMeta &meta, bool is_create_op) {
  QDateTime current_ts = QDateTime::currentDateTimeUtc();

  if (is_create_op) {
    if (const FieldMeta *created_at_field =
            meta.findFieldWithFlag(FieldFlag::CreatedAt)) {
      if (created_at_field->cpp_type == typeid(QDateTime)) {
        std::any current_val =
            model_instance.getFieldValue(created_at_field->cpp_name);
        if (!current_val.has_value() ||
            (current_val.type() == typeid(QDateTime) &&
             !std::any_cast<QDateTime>(current_val).isValid())) {
          model_instance.setFieldValue(created_at_field->cpp_name, current_ts);
        }
      }
    }
  }

  if (const FieldMeta *updated_at_field =
          meta.findFieldWithFlag(FieldFlag::UpdatedAt)) {
    if (updated_at_field->cpp_type == typeid(QDateTime)) {
      model_instance.setFieldValue(updated_at_field->cpp_name, current_ts);
    }
  }
}

} // namespace cpporm#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"

#include <QDebug>
#include <QSqlError>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QVariant>
#include <algorithm>

namespace cpporm {
namespace internal {

std::string normalizeDbType(const std::string &db_type_raw,
                            const QString &driverNameUpper) {
  std::string lower_type = db_type_raw;
  std::transform(lower_type.begin(), lower_type.end(), lower_type.begin(),
                 [](unsigned char c) { return std::tolower(c); });

  if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
    if (lower_type.rfind("int", 0) == 0 &&
        lower_type.find("unsigned") == std::string::npos &&
        lower_type != "tinyint(1)")
      return "int";
    if (lower_type.rfind("int unsigned", 0) == 0)
      return "int unsigned";
    if (lower_type.rfind("bigint", 0) == 0 &&
        lower_type.find("unsigned") == std::string::npos)
      return "bigint";
    if (lower_type.rfind("bigint unsigned", 0) == 0)
      return "bigint unsigned";
    if (lower_type == "tinyint(1)")
      return "boolean";
    if (lower_type.rfind("varchar", 0) == 0)
      return "varchar";
    if (lower_type.rfind("char", 0) == 0 &&
        lower_type.find("varchar") == std::string::npos)
      return "char";
    if (lower_type == "text" || lower_type == "tinytext" ||
        lower_type == "mediumtext" || lower_type == "longtext")
      return "text";
    if (lower_type == "datetime")
      return "datetime";
    if (lower_type == "timestamp")
      return "timestamp";
    if (lower_type == "date")
      return "date";
    if (lower_type == "time")
      return "time";
    if (lower_type == "float")
      return "float";
    if (lower_type == "double" || lower_type == "real")
      return "double";
    if (lower_type.rfind("decimal", 0) == 0 ||
        lower_type.rfind("numeric", 0) == 0)
      return "decimal";
    if (lower_type == "blob" || lower_type == "tinyblob" ||
        lower_type == "mediumblob" || lower_type == "longblob" ||
        lower_type == "varbinary" || lower_type == "binary")
      return "blob";
  } else if (driverNameUpper == "QPSQL") {
    if (lower_type == "integer" || lower_type == "int4")
      return "int";
    if (lower_type == "bigint" || lower_type == "int8")
      return "bigint";
    if (lower_type == "smallint" || lower_type == "int2")
      return "smallint";
    if (lower_type == "boolean" || lower_type == "bool")
      return "boolean";
    if (lower_type.rfind("character varying", 0) == 0)
      return "varchar";
    if ((lower_type.rfind("character(", 0) == 0 ||
         lower_type.rfind("char(", 0) == 0) &&
        lower_type.find("varying") == std::string::npos)
      return "char";
    if (lower_type == "text")
      return "text";
    if (lower_type == "timestamp without time zone" ||
        lower_type == "timestamp")
      return "timestamp";
    if (lower_type == "timestamp with time zone")
      return "timestamptz";
    if (lower_type == "date")
      return "date";
    if (lower_type == "time without time zone" || lower_type == "time")
      return "time";
    if (lower_type == "time with time zone")
      return "timetz";
    if (lower_type == "real" || lower_type == "float4")
      return "float";
    if (lower_type == "double precision" || lower_type == "float8")
      return "double";
    if (lower_type == "numeric" || lower_type == "decimal")
      return "decimal";
    if (lower_type == "bytea")
      return "blob";
  } else if (driverNameUpper == "QSQLITE") {
    if (lower_type.find("int") != std::string::npos)
      return "int"; // Covers INTEGER
    if (lower_type == "text" || lower_type.find("char") != std::string::npos ||
        lower_type.find("clob") != std::string::npos)
      return "text"; // Covers VARCHAR, TEXT etc.
    if (lower_type == "blob" || lower_type.empty())
      return "blob"; // Covers BLOB
    if (lower_type == "real" || lower_type.find("floa") != std::string::npos ||
        lower_type.find("doub") != std::string::npos)
      return "double"; // Covers REAL, FLOAT, DOUBLE
    if (lower_type == "numeric" ||
        lower_type.find("deci") != std::string::npos ||
        lower_type.find("bool") != std::string::npos ||
        lower_type.find("date") != std::string::npos ||
        lower_type.find("datetime") != std::string::npos)
      return "numeric"; // Covers NUMERIC, DECIMAL, BOOLEAN, DATE, DATETIME
  }
  return lower_type; // Return normalized if not specifically mapped, or
                     // original lowercased
}

std::map<std::string, DbColumnInfo>
getTableColumnsInfo(Session &session, const QString &tableName,
                    const QString &driverNameUpper) {
  std::map<std::string, DbColumnInfo> columns;
  QSqlQuery query(session.getDbHandle());
  QString sql;

  if (driverNameUpper == "QSQLITE") {
    sql = QString("PRAGMA table_xinfo(%1);").arg(tableName);
    if (!query.exec(sql)) {
      sql = QString("PRAGMA table_info(%1);").arg(tableName);
      if (!query.exec(sql)) {
        qWarning() << "getTableColumnsInfo (SQLite): Failed to query PRAGMA "
                      "table_info/table_xinfo for table"
                   << tableName << ":" << query.lastError().text();
        return columns;
      }
    }
  } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
    sql = QString("SHOW FULL COLUMNS FROM %1;")
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(tableName.toStdString())));
    if (!query.exec(sql)) {
      qWarning() << "getTableColumnsInfo (MySQL): Failed to query SHOW FULL "
                    "COLUMNS for table"
                 << tableName << ":" << query.lastError().text()
                 << "SQL:" << sql;
      return columns;
    }
  } else if (driverNameUpper == "QPSQL") {
    sql = QString("SELECT column_name, data_type, udt_name, is_nullable, "
                  "column_default, "
                  "character_maximum_length, numeric_precision, numeric_scale, "
                  "collation_name "
                  "FROM information_schema.columns WHERE table_schema = "
                  "current_schema() AND table_name = '%1';")
              .arg(tableName);
    if (!query.exec(sql)) {
      qWarning() << "getTableColumnsInfo (PostgreSQL): Failed to query "
                    "information_schema.columns for table"
                 << tableName << ":" << query.lastError().text()
                 << "SQL:" << sql;
      return columns;
    }
  } else {
    qWarning()
        << "getTableColumnsInfo: Unsupported driver for detailed column info:"
        << driverNameUpper;
    return columns;
  }

  while (query.next()) {
    DbColumnInfo colInfo;
    if (driverNameUpper == "QSQLITE") {
      colInfo.name = query.value("name").toString().toStdString();
      colInfo.type = query.value("type").toString().toStdString();
      colInfo.is_nullable = !query.value("notnull").toBool();
      QVariant dflt_val = query.value("dflt_value");
      colInfo.default_value =
          dflt_val.isNull() ? "" : dflt_val.toString().toStdString();
      colInfo.column_key = query.value("pk").toInt() > 0 ? "PRI" : "";
    } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
      colInfo.name = query.value("Field").toString().toStdString();
      colInfo.type = query.value("Type").toString().toStdString();
      colInfo.is_nullable = (query.value("Null").toString().toUpper() == "YES");
      QVariant defVal = query.value("Default");
      colInfo.default_value =
          defVal.isNull() ? "" : defVal.toString().toStdString();
      colInfo.collation_name =
          query.value("Collation").toString().toStdString();
      colInfo.column_key = query.value("Key").toString().toStdString();
      colInfo.extra = query.value("Extra").toString().toStdString();
    } else if (driverNameUpper == "QPSQL") {
      colInfo.name = query.value("column_name").toString().toStdString();
      std::string pg_udt_name =
          query.value("udt_name").toString().toStdString();
      std::string pg_data_type =
          query.value("data_type").toString().toStdString();

      if (pg_data_type.rfind("ARRAY", 0) == 0) {
        colInfo.type = pg_udt_name;
        if (colInfo.type.rfind('_', 0) == 0)
          colInfo.type.erase(0, 1);
        colInfo.type += "[]";
      } else if (pg_udt_name.empty() || pg_udt_name == "anyelement" ||
                 pg_udt_name == "anyarray") {
        colInfo.type = pg_data_type;
      } else {
        colInfo.type = pg_udt_name;
      }
      colInfo.is_nullable =
          (query.value("is_nullable").toString().toUpper() == "YES");
      colInfo.default_value =
          query.value("column_default").toString().toStdString();
      colInfo.collation_name =
          query.value("collation_name").toString().toStdString();
    }
    if (!colInfo.name.empty()) {
      colInfo.normalized_type = normalizeDbType(colInfo.type, driverNameUpper);
      columns[colInfo.name] = colInfo;
    }
  }
  return columns;
}

Error migrateModifyColumns(Session &session, const ModelMeta &meta,
                           const QString &driverNameUpper) {
  qInfo() << "migrateModifyColumns: Checking columns for table '"
          << QString::fromStdString(meta.table_name) << "'...";
  std::map<std::string, DbColumnInfo> existing_db_columns = getTableColumnsInfo(
      session, QString::fromStdString(meta.table_name), driverNameUpper);

  for (const auto &model_field : meta.fields) {
    if (has_flag(model_field.flags, FieldFlag::Association) ||
        model_field.db_name.empty()) {
      continue;
    }

    std::string model_sql_type_str =
        Session::getSqlTypeForCppType(model_field, driverNameUpper);
    std::string model_normalized_sql_type =
        normalizeDbType(model_sql_type_str, driverNameUpper);

    auto it_db_col = existing_db_columns.find(model_field.db_name);
    if (it_db_col == existing_db_columns.end()) { // Column doesn't exist in DB
      qInfo() << "migrateModifyColumns: Column '"
              << QString::fromStdString(model_field.db_name)
              << "' not found in table '"
              << QString::fromStdString(meta.table_name)
              << "'. Attempting to ADD.";

      std::string add_col_sql_str =
          "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) +
          " ADD COLUMN " +
          QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " +
          model_sql_type_str;

      if (has_flag(model_field.flags, FieldFlag::NotNull))
        add_col_sql_str += " NOT NULL";
      if (has_flag(model_field.flags, FieldFlag::Unique) &&
          !has_flag(model_field.flags, FieldFlag::PrimaryKey)) {
        add_col_sql_str += " UNIQUE";
      }
      add_col_sql_str += ";";

      qInfo() << "migrateModifyColumns (ADD DDL): "
              << QString::fromStdString(add_col_sql_str);
      auto [_, add_err] = execute_ddl_query(
          session.getDbHandle(), QString::fromStdString(add_col_sql_str));
      if (add_err) {
        qWarning() << "migrateModifyColumns: Failed to ADD column '"
                   << QString::fromStdString(model_field.db_name)
                   << "': " << QString::fromStdString(add_err.toString());
      }

    } else { // Column exists, check for modifications
      DbColumnInfo &db_col = it_db_col->second;
      bool needs_alter = false;

      // Check for type differences
      if (model_normalized_sql_type != db_col.normalized_type) {
        needs_alter = true; // Basic normalized types differ

        // SQLite specific handling for TEXT/VARCHAR compatibility
        if (driverNameUpper == "QSQLITE" &&
            ((model_normalized_sql_type == "text" &&
              db_col.normalized_type == "varchar") ||
             (model_normalized_sql_type == "varchar" &&
              db_col.normalized_type == "text"))) {
          needs_alter = false; // Treat as compatible for SQLite
        }
        // Skip alter for narrowing integer conversions
        else if ((model_normalized_sql_type == "int" &&
                  db_col.normalized_type == "bigint") ||
                 (model_normalized_sql_type == "smallint" &&
                  (db_col.normalized_type == "int" ||
                   db_col.normalized_type == "bigint"))
                 // Consider adding unsigned variations if needed
        ) {
          qInfo() << "migrateModifyColumns: Model requests narrowing integer "
                     "conversion for column '"
                  << QString::fromStdString(model_field.db_name)
                  << "' from DB type '" << QString::fromStdString(db_col.type)
                  << "' to model type '"
                  << QString::fromStdString(model_sql_type_str)
                  << "'. Skipping automatic type alteration.";
          needs_alter = false;
        }
      } else { // Normalized types are the same, check for other differences
               // like VARCHAR length if desired
        // For VARCHAR, if model_sql_type_str (e.g. "VARCHAR(1000)") differs
        // from db_col.type (e.g. "varchar(255)"), it implies a length change.
        // We generally want to allow widening. This comparison is very basic
        // and assumes model_sql_type_str is the canonical definition.
        if (model_normalized_sql_type == "varchar" &&
            model_sql_type_str != db_col.type) {
          // A more robust check would parse lengths. For now, if the raw types
          // differ but normalized are same (varchar), assume alter for
          // widening. Example: model "VARCHAR(1000)", db "varchar(255)" ->
          // needs_alter = true. Example: model "VARCHAR(50)", db "varchar(255)"
          // -> this is narrowing, more complex. GORM often allows widening but
          // might be cautious with narrowing VARCHAR. Let's assume for now if
          // raw types differ for varchar, attempt an alter. This could be
          // refined by parsing lengths from model_sql_type_str and db_col.type.
          // needs_alter = true; // Cautiously enable this if length parsing
          // isn't in place For now, let's say if normalized is same, type is
          // compatible. A change from TEXT to VARCHAR(1000) will be caught by
          // normalized_type diff.
        }
      }

      if (needs_alter) {
        qInfo() << "migrateModifyColumns: Type mismatch or desired change for "
                   "column '"
                << QString::fromStdString(model_field.db_name)
                << "'. DB type: '" << QString::fromStdString(db_col.type)
                << "' (norm: " << QString::fromStdString(db_col.normalized_type)
                << "), Model type: '"
                << QString::fromStdString(model_sql_type_str) << "' (norm: "
                << QString::fromStdString(model_normalized_sql_type)
                << "). Attempting to MODIFY.";

        std::string alter_col_sql_str =
            "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name);
        if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
          alter_col_sql_str +=
              " MODIFY COLUMN " +
              QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " +
              model_sql_type_str;
          if (has_flag(model_field.flags, FieldFlag::NotNull))
            alter_col_sql_str += " NOT NULL";
          else
            alter_col_sql_str += " NULL";
        } else if (driverNameUpper == "QPSQL") {
          alter_col_sql_str +=
              " ALTER COLUMN " +
              QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " TYPE " +
              model_sql_type_str;
          // For PG, nullability and default changes are separate ALTER
          // statements. This simplified version only handles type change. A
          // full solution would chain them.
        } else if (driverNameUpper == "QSQLITE") {
          qWarning()
              << "migrateModifyColumns: SQLite has very limited ALTER TABLE "
                 "support for modifying column types. Type change for '"
              << QString::fromStdString(model_field.db_name) << "' skipped.";
          continue; // Skip to next field
        } else {
          qWarning() << "migrateModifyColumns: Don't know how to alter column "
                        "type for driver "
                     << driverNameUpper << ". Column '"
                     << QString::fromStdString(model_field.db_name)
                     << "' type alteration skipped.";
          continue; // Skip to next field
        }
        alter_col_sql_str += ";";

        qInfo() << "migrateModifyColumns (MODIFY DDL): "
                << QString::fromStdString(alter_col_sql_str);
        auto [_, alter_err] = execute_ddl_query(
            session.getDbHandle(), QString::fromStdString(alter_col_sql_str));
        if (alter_err) {
          qWarning() << "migrateModifyColumns: Failed to MODIFY column '"
                     << QString::fromStdString(model_field.db_name)
                     << "': " << QString::fromStdString(alter_err.toString());
        }
      }
      // TODO: Add logic to check and alter NULLability, DEFAULT values if they
      // differ, which might require separate ALTER COLUMN statements for some
      // DBs (like PostgreSQL).
    }
  }
  return make_ok();
}

} // namespace internal
} // namespace cpporm// cpporm/session_migrate_index_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"

#include <QDebug>
#include <QRegularExpression> // For sanitizing names if used in auto-generated index names
#include <QSqlError>
#include <QSqlQuery>
#include <QSqlRecord>
#include <algorithm>
#include <set> // For tracking processed names

namespace cpporm {
namespace internal {

// Helper to compare index definitions (columns and uniqueness)
// Order of columns in definition matters.
bool areIndexDefinitionsEquivalent(const DbIndexInfo &db_idx,
                                   const IndexDefinition &model_idx_def,
                                   const QString &driverNameUpper) {
  (void)driverNameUpper; // driverNameUpper might be used for type_method
                         // normalization later

  if (db_idx.is_unique != model_idx_def.is_unique)
    return false;
  if (db_idx.column_names.size() != model_idx_def.db_column_names.size())
    return false;

  // Assuming column names from DB and model are already in canonical form
  // (e.g., lowercase or as defined) If not, normalization (e.g., to_lower)
  // should happen before comparison. Direct comparison of ordered columns:
  for (size_t i = 0; i < db_idx.column_names.size(); ++i) {
    // Basic case-insensitive comparison for safety, though DBs might be
    // case-sensitive
    std::string db_col_lower = db_idx.column_names[i];
    std::string model_col_lower = model_idx_def.db_column_names[i];
    std::transform(db_col_lower.begin(), db_col_lower.end(),
                   db_col_lower.begin(), ::tolower);
    std::transform(model_col_lower.begin(), model_col_lower.end(),
                   model_col_lower.begin(), ::tolower);
    if (db_col_lower != model_col_lower)
      return false;
  }

  // Compare index type/method (BTREE, HASH, GIN, etc.) if available and
  // specified
  if (!model_idx_def.type_str.empty() && !db_idx.type_method.empty()) {
    std::string model_type_lower = model_idx_def.type_str;
    std::string db_type_lower = db_idx.type_method;
    std::transform(model_type_lower.begin(), model_type_lower.end(),
                   model_type_lower.begin(), ::tolower);
    std::transform(db_type_lower.begin(), db_type_lower.end(),
                   db_type_lower.begin(), ::tolower);
    // Simple string comparison. More robust would be to normalize (e.g. "btree"
    // vs "BTREE")
    if (model_type_lower != db_type_lower) {
      // Exception: MySQL often reports "BTREE" by default, model might not
      // specify it. If model type_str is empty, but DB has a common default
      // like BTREE, consider it a match.
      if (!model_idx_def.type_str
               .empty()) { // Only if model explicitly specifies a type
        return false;
      }
    }
  }
  // Compare partial index conditions (mainly PG) - this is complex
  // if (!model_idx_def.condition_str.empty() || (db_idx has condition property
  // and it's not empty)) {
  //    if (normalize_condition(model_idx_def.condition_str) !=
  //    normalize_condition(db_idx.condition_property)) return false;
  // }

  return true;
}

std::map<std::string, DbIndexInfo>
getTableIndexesInfo(Session &session, const QString &tableName,
                    const QString &driverNameUpper) {
  std::map<std::string, DbIndexInfo> indexes;
  QSqlQuery query(session.getDbHandle());
  QString sql;

  if (driverNameUpper == "QSQLITE") {
    if (!query.exec(QString("PRAGMA index_list(%1);").arg(tableName))) {
      qWarning() << "getTableIndexesInfo (SQLite): Failed to get index list for"
                 << tableName << ":" << query.lastError().text();
      return indexes;
    }
    std::vector<DbIndexInfo> temp_index_list_sqlite;
    while (query.next()) {
      DbIndexInfo idx_base_info;
      idx_base_info.index_name = query.value("name").toString().toStdString();
      idx_base_info.is_unique = query.value("unique").toInt() == 1;
      // "origin" column can tell if 'pk', 'u' (unique constraint), 'c' (create
      // index) We want to manage 'c' type indexes primarily. PKs and UNIQUE
      // constraints are handled by table def.
      QString origin = query.value("origin").toString();
      if (idx_base_info.index_name.starts_with("sqlite_autoindex_") ||
          origin == "pk" || origin == "u") {
        idx_base_info.is_primary_key =
            (origin == "pk"); // Mark it if it's an autoindex for PK
        // Store it to avoid recreating, but don't manage as separate index if
        // it's just backing a constraint indexes[idx_base_info.index_name] =
        // idx_base_info;
        continue; // Skip auto-indexes and those backing PK/UNIQUE constraints
                  // for explicit management
      }
      temp_index_list_sqlite.push_back(idx_base_info);
    }

    for (DbIndexInfo &idx_info_ref : temp_index_list_sqlite) {
      if (!query.exec(QString("PRAGMA index_xinfo(%1);")
                          .arg(QString::fromStdString(
                              idx_info_ref.index_name)))) { // index_xinfo for
                                                            // column names
        if (!query.exec(
                QString("PRAGMA index_info(%1);")
                    .arg(QString::fromStdString(idx_info_ref.index_name)))) {
          qWarning()
              << "getTableIndexesInfo (SQLite): Failed to get info for index"
              << QString::fromStdString(idx_info_ref.index_name) << ":"
              << query.lastError().text();
          continue;
        }
      }
      std::vector<std::pair<int, std::string>>
          col_order_pairs; // cid for xinfo, seqno for info
      bool use_cid = query.record().contains("cid");

      while (query.next()) {
        col_order_pairs.push_back({
            query.value(use_cid ? "cid" : "seqno").toInt(),
            query.value("name").toString().toStdString() // This is the column
                                                         // name
        });
      }
      std::sort(col_order_pairs.begin(),
                col_order_pairs.end()); // Sort by sequence number
      for (const auto &p : col_order_pairs)
        idx_info_ref.column_names.push_back(p.second);

      if (!idx_info_ref.column_names.empty())
        indexes[idx_info_ref.index_name] = idx_info_ref;
    }

  } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
    sql = QString("SHOW INDEX FROM %1;")
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(tableName.toStdString())));
    if (!query.exec(sql)) {
      qWarning() << "getTableIndexesInfo (MySQL): Failed for table" << tableName
                 << ":" << query.lastError().text();
      return indexes;
    }

    std::map<std::string, DbIndexInfo> temp_building_indexes;
    while (query.next()) {
      std::string idx_name_str =
          query.value("Key_name").toString().toStdString();
      DbIndexInfo &current_idx =
          temp_building_indexes[idx_name_str]; // Creates if not exists

      if (current_idx.index_name.empty()) { // First time seeing this index name
        current_idx.index_name = idx_name_str;
        current_idx.is_unique = (query.value("Non_unique").toInt() == 0);
        current_idx.is_primary_key = (idx_name_str == "PRIMARY");
        current_idx.type_method =
            query.value("Index_type").toString().toStdString();
      }
      // Add column in its sequence
      // SHOW INDEX already returns columns ordered by Seq_in_index for a given
      // Key_name
      current_idx.column_names.push_back(
          query.value("Column_name").toString().toStdString());
    }
    for (const auto &pair_val : temp_building_indexes) {
      if (pair_val.second.is_primary_key)
        continue; // Skip managing PRIMARY KEY as an index here
      if (!pair_val.second.column_names.empty())
        indexes[pair_val.first] = pair_val.second;
    }

  } else if (driverNameUpper == "QPSQL") {
    sql =
        QString("SELECT idx.relname AS index_name, att.attname AS column_name, "
                "i.indisunique AS is_unique, "
                "       i.indisprimary AS is_primary, am.amname AS index_type, "
                "       (SELECT pg_get_indexdef(i.indexrelid, k + 1, true) "
                "FROM generate_subscripts(i.indkey, 1) k WHERE i.indkey[k] = "
                "att.attnum) as col_def_in_idx, "
                "       array_position(i.indkey, att.attnum) as column_seq "
                "FROM   pg_index i "
                "JOIN   pg_class tbl ON tbl.oid = i.indrelid "
                "JOIN   pg_class idx ON idx.oid = i.indexrelid "
                "JOIN   pg_attribute att ON att.attrelid = tbl.oid AND "
                "att.attnum = ANY(i.indkey) "
                "LEFT JOIN pg_am am ON am.oid = idx.relam " // Use LEFT JOIN for
                                                            // pg_am
                "WHERE  tbl.relname = '%1' AND tbl.relnamespace = (SELECT oid "
                "FROM pg_namespace WHERE nspname = current_schema()) "
                "ORDER BY index_name, column_seq;" // Order for correct column
                                                   // assembly
                )
            .arg(tableName);

    if (!query.exec(sql)) {
      qWarning() << "getTableIndexesInfo (PostgreSQL): Failed for table"
                 << tableName << ":" << query.lastError().text()
                 << "SQL:" << sql;
      return indexes;
    }

    std::map<std::string, DbIndexInfo> temp_building_indexes_pg;
    while (query.next()) {
      std::string idx_name_str =
          query.value("index_name").toString().toStdString();
      DbIndexInfo &current_idx = temp_building_indexes_pg[idx_name_str];

      if (current_idx.index_name.empty()) {
        current_idx.index_name = idx_name_str;
        current_idx.is_unique = query.value("is_unique").toBool();
        current_idx.is_primary_key = query.value("is_primary").toBool();
        current_idx.type_method =
            query.value("index_type").toString().toStdString();
      }
      // pg_get_indexdef can give more info about expression indexes or
      // collation/opclass For simple column names, att.attname is fine.
      current_idx.column_names.push_back(
          query.value("column_name").toString().toStdString());
    }
    for (const auto &pair_val : temp_building_indexes_pg) {
      if (pair_val.second.is_primary_key)
        continue;
      if (!pair_val.second.column_names.empty())
        indexes[pair_val.first] = pair_val.second;
    }
  } else {
    qWarning() << "getTableIndexesInfo: Unsupported driver for index info:"
               << driverNameUpper;
  }
  return indexes;
}

Error migrateManageIndexes(Session &session, const ModelMeta &meta,
                           const QString &driverNameUpper) {
  qInfo() << "migrateManageIndexes: Managing indexes for table '"
          << QString::fromStdString(meta.table_name) << "'...";
  std::map<std::string, DbIndexInfo> existing_db_indexes = getTableIndexesInfo(
      session, QString::fromStdString(meta.table_name), driverNameUpper);

  std::set<std::string>
      model_index_names_processed; // To track which model indexes we've handled

  // Pass 1: Ensure indexes defined in ModelMeta exist and match, or
  // create/recreate them.
  for (const auto &model_idx_def : meta.indexes) {
    if (model_idx_def.db_column_names.empty()) {
      qWarning() << "migrateManageIndexes: Model index definition for table '"
                 << QString::fromStdString(meta.table_name)
                 << "' (intended name: '"
                 << QString::fromStdString(model_idx_def.index_name)
                 << "') has no columns. Skipping.";
      continue;
    }

    QString model_idx_name_qstr =
        QString::fromStdString(model_idx_def.index_name);
    if (model_idx_name_qstr.isEmpty()) {
      model_idx_name_qstr = (model_idx_def.is_unique ? "uix_" : "idx_") +
                            QString::fromStdString(meta.table_name);
      for (const auto &col_name_std : model_idx_def.db_column_names) {
        QString temp_col_name = QString::fromStdString(col_name_std);
        temp_col_name.replace(QRegularExpression("[^a-zA-Z0-9_]"), "_");
        model_idx_name_qstr += "_" + temp_col_name;
      }
      if (model_idx_name_qstr.length() >
          60) { // Basic length check for compatibility
        QString hash_suffix =
            QString::number(qHash(model_idx_name_qstr +
                                  QString::number(model_idx_def.is_unique)),
                            16)
                .left(8);
        model_idx_name_qstr =
            model_idx_name_qstr.left(60 - 1 - hash_suffix.length()) + "_" +
            hash_suffix;
      }
    }
    std::string model_idx_name_std = model_idx_name_qstr.toStdString();
    model_index_names_processed.insert(model_idx_name_std);

    auto it_db_idx = existing_db_indexes.find(model_idx_name_std);
    bool needs_create = true;
    bool needs_drop_first = false;

    if (it_db_idx != existing_db_indexes.end()) {
      if (it_db_idx->second.is_primary_key) {
        qInfo()
            << "migrateManageIndexes: Model index '" << model_idx_name_qstr
            << "' matches a DB PRIMARY KEY. Explicit index management skipped.";
        needs_create = false;
      } else if (areIndexDefinitionsEquivalent(it_db_idx->second, model_idx_def,
                                               driverNameUpper)) {
        qInfo() << "migrateManageIndexes: Index '" << model_idx_name_qstr
                << "' matches existing DB index. No changes.";
        needs_create = false;
      } else {
        qInfo() << "migrateManageIndexes: Index '" << model_idx_name_qstr
                << "' exists but definition differs. Will DROP and RECREATE.";
        needs_drop_first = true;
        needs_create = true;
      }
    }

    if (needs_drop_first) {
      QString drop_sql =
          QString("DROP INDEX %1")
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(model_idx_name_std)));
      if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
        drop_sql +=
            " ON " + QString::fromStdString(
                         QueryBuilder::quoteSqlIdentifier(meta.table_name));
      }
      drop_sql += ";";
      qInfo() << "migrateManageIndexes (DROP DDL): " << drop_sql;
      auto [_, drop_err] =
          execute_ddl_query(session.getDbHandle(), drop_sql); // Pass copy
      if (drop_err) {
        qWarning() << "migrateManageIndexes: Failed to DROP index '"
                   << model_idx_name_qstr
                   << "': " << QString::fromStdString(drop_err.toString());
      }
    }

    if (needs_create) {
      QStringList q_cols;
      for (const auto &c : model_idx_def.db_column_names)
        q_cols << QString::fromStdString(QueryBuilder::quoteSqlIdentifier(c));

      QString create_sql =
          QString("CREATE %1INDEX %2%3 ON %4 (%5)")
              .arg(model_idx_def.is_unique ? "UNIQUE " : "")
              .arg((driverNameUpper == "QSQLITE" || driverNameUpper == "QPSQL")
                       ? "IF NOT EXISTS "
                       : "")
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(model_idx_name_std)))
              .arg(QString::fromStdString(
                  QueryBuilder::quoteSqlIdentifier(meta.table_name)))
              .arg(q_cols.join(", "));
      if (!model_idx_def.type_str.empty() &&
          (driverNameUpper == "QPSQL" || driverNameUpper == "QMYSQL" ||
           driverNameUpper == "QMARIADB")) {
        create_sql +=
            " USING " + QString::fromStdString(model_idx_def.type_str);
      }
      if (!model_idx_def.condition_str.empty() && driverNameUpper == "QPSQL") {
        create_sql += " WHERE (" +
                      QString::fromStdString(model_idx_def.condition_str) + ")";
      }
      create_sql += ";";

      qInfo() << "migrateManageIndexes (CREATE DDL): " << create_sql;
      auto [_, create_err] =
          execute_ddl_query(session.getDbHandle(), create_sql); // Pass copy
      if (create_err) {
        bool ignorable = false;
        std::string err_msg_lower = create_err.message;
        std::transform(err_msg_lower.begin(), err_msg_lower.end(),
                       err_msg_lower.begin(), ::tolower);

        if (((driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") &&
             create_err.native_db_error_code == 1061 /*ER_DUP_KEYNAME*/) ||
            (driverNameUpper == "QSQLITE" &&
             err_msg_lower.find("already exists") != std::string::npos) ||
            (driverNameUpper == "QPSQL" && (create_err.sql_state == "42P07" ||
                                            create_err.sql_state == "42710"))) {
          ignorable = true;
        }

        if (ignorable && !needs_drop_first) { // Only truly ignorable if we
                                              // didn't try to drop it first
          qInfo() << "migrateManageIndexes: Index " << model_idx_name_qstr
                  << " likely already exists (error caught on create): "
                  << QString::fromStdString(create_err.toString());
        } else if (!ignorable) { // If it's not an "already exists" error, or if
                                 // we tried to drop and still failed create
          qWarning() << "migrateManageIndexes: Failed to CREATE index '"
                     << model_idx_name_qstr
                     << "': " << QString::fromStdString(create_err.toString());
        }
      }
    }
  }
  return make_ok();
}

} // namespace internal
} // namespace cpporm// cpporm/session_migrate_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/qt_db_manager.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"

#include <QDebug>
#include <QSqlDriver>
#include <QSqlError>
#include <QSqlQuery>
#include <QSqlRecord>
#include <algorithm>
#include <set>

namespace cpporm {

Error Session::AutoMigrate(const ModelMeta &meta) {
  if (!db_handle_.isOpen()) {
    if (!db_handle_.open()) {
      QSqlError err = db_handle_.lastError();
      return Error(ErrorCode::ConnectionNotOpen,
                   "Cannot AutoMigrate: Database connection is not open and "
                   "failed to open: " +
                       err.text().toStdString());
    }
  }
  if (meta.table_name.empty()) {
    return Error(ErrorCode::InvalidConfiguration,
                 "Cannot AutoMigrate: ModelMeta has no table name.");
  }
  qInfo() << "AutoMigrate: Starting migration for table '"
          << QString::fromStdString(meta.table_name) << "'...";

  QString driverNameUpper = db_handle_.driverName().toUpper();

  // Pass '*this' (Session reference) to internal migration functions
  Error table_err = internal::migrateCreateTable(*this, meta, driverNameUpper);
  if (table_err) {
    qWarning() << "AutoMigrate: Failed during table creation for '"
               << QString::fromStdString(meta.table_name)
               << "': " << QString::fromStdString(table_err.toString());
    return table_err;
  }
  qInfo() << "AutoMigrate: Table creation/check phase completed for '"
          << QString::fromStdString(meta.table_name) << "'.";

  Error column_err =
      internal::migrateModifyColumns(*this, meta, driverNameUpper);
  if (column_err) {
    qWarning() << "AutoMigrate: Failed during column modification for '"
               << QString::fromStdString(meta.table_name)
               << "': " << QString::fromStdString(column_err.toString());
    return column_err;
  }
  qInfo() << "AutoMigrate: Column modification phase completed for '"
          << QString::fromStdString(meta.table_name) << "'.";

  Error index_err =
      internal::migrateManageIndexes(*this, meta, driverNameUpper);
  if (index_err) {
    qWarning() << "AutoMigrate: Failed during index management for '"
               << QString::fromStdString(meta.table_name)
               << "': " << QString::fromStdString(index_err.toString());
    return index_err;
  }
  qInfo() << "AutoMigrate: Index management phase completed for '"
          << QString::fromStdString(meta.table_name) << "'.";

  qInfo() << "AutoMigrate: Migration successfully completed for table '"
          << QString::fromStdString(meta.table_name) << "'.";
  return make_ok();
}

Error Session::AutoMigrate(const std::vector<const ModelMeta *> &metas_vec) {
  for (const auto *m_ptr : metas_vec) {
    if (m_ptr) {
      if (auto e_obj = AutoMigrate(*m_ptr)) {
        return e_obj;
      }
    } else {
      qWarning() << "AutoMigrate (vector): Encountered a null ModelMeta "
                    "pointer. Skipping.";
    }
  }
  qInfo() << "AutoMigrate: Batch migration completed for" << metas_vec.size()
          << "models.";
  return make_ok();
}

// REMOVED THE DUPLICATE DEFINITION of Session::getSqlTypeForCppType from here.
// It is now solely defined in session_static_utils.cpp

} // namespace cpporm// cpporm/session_migrate_table_ops.cpp
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"

#include <QDebug>
#include <QSqlDriver>
#include <QSqlError>
#include <QSqlQuery>
#include <mutex>

namespace cpporm {
namespace internal {

Error migrateCreateTable(Session &session, const ModelMeta &meta,
                         const QString &driverNameUpper) {
  if (meta.table_name.empty()) {
    return Error(ErrorCode::InvalidConfiguration,
                 "migrateCreateTable: ModelMeta has no table name.");
  }

  std::vector<std::string> column_definitions_sql;
  std::vector<std::string> pk_col_db_names_for_constraint;
  std::vector<std::string> table_constraints_sql;

  for (const auto &field : meta.fields) {
    if (has_flag(field.flags, FieldFlag::Association) ||
        field.db_name.empty()) {
      continue;
    }

    std::string col_def_str = QueryBuilder::quoteSqlIdentifier(field.db_name);
    // Use Session's public static method
    col_def_str += " " + Session::getSqlTypeForCppType(field, driverNameUpper);

    if (has_flag(field.flags, FieldFlag::PrimaryKey)) {
      pk_col_db_names_for_constraint.push_back(field.db_name);
      if ((driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") &&
          has_flag(field.flags, FieldFlag::AutoIncrement)) {
        col_def_str += " AUTO_INCREMENT";
      } else if (driverNameUpper == "QSQLITE" &&
                 has_flag(field.flags, FieldFlag::AutoIncrement) &&
                 pk_col_db_names_for_constraint.size() == 1 &&
                 (field.cpp_type == typeid(int) ||
                  field.cpp_type == typeid(long long) ||
                  field.cpp_type == typeid(unsigned int) ||
                  field.cpp_type == typeid(unsigned long long))) {
        // SQLite: INTEGER PRIMARY KEY AUTOINCREMENT
        // For SQLite, adding "PRIMARY KEY AUTOINCREMENT" to the column
        // definition is one way If we do this, the table-level "PRIMARY KEY
        // (...)" for a single int PK might be redundant or conflict. GORM Go
        // for SQLite with auto-inc integer PK generates: "id" integer primary
        // key autoincrement, It does not add a separate table-level PRIMARY KEY
        // constraint in this specific case. For simplicity and consistency with
        // other DBs that use table-level PK for composite keys, we'll keep the
        // table-level PK constraint and let the column definition just have
        // AUTO_INCREMENT if applicable (MySQL). SQLite's "INTEGER PRIMARY KEY"
        // on a column (typically named id or with ROWID alias) makes it
        // auto-incrementing by default. The AUTOINCREMENT keyword enforces
        // stricter monotonically increasing ID behavior and prevents reuse of
        // IDs. If strict AUTOINCREMENT is desired for SQLite, this would be: if
        // (driverNameUpper == "QSQLITE" && has_flag(field.flags,
        // FieldFlag::AutoIncrement)) col_def_str += " AUTOINCREMENT"; However,
        // this is usually paired with removing it from the table-level PK
        // constraint if it's a single column. Let's keep current logic: MySQL
        // gets col-level AUTO_INCREMENT, others rely on table PK + type.
      }
    }
    if (has_flag(field.flags, FieldFlag::NotNull)) {
      col_def_str += " NOT NULL";
    }
    if (has_flag(field.flags, FieldFlag::Unique) &&
        !has_flag(field.flags, FieldFlag::PrimaryKey)) {
      col_def_str += " UNIQUE";
    }
    column_definitions_sql.push_back(col_def_str);
  }

  if (!pk_col_db_names_for_constraint.empty()) {
    std::string pk_constraint_str = "PRIMARY KEY (";
    for (size_t i = 0; i < pk_col_db_names_for_constraint.size(); ++i) {
      pk_constraint_str +=
          QueryBuilder::quoteSqlIdentifier(pk_col_db_names_for_constraint[i]);
      if (i < pk_col_db_names_for_constraint.size() - 1)
        pk_constraint_str += ", ";
    }
    pk_constraint_str += ")";
    table_constraints_sql.push_back(pk_constraint_str);
  }

  for (const auto &assoc : meta.associations) {
    if (assoc.type == AssociationType::BelongsTo &&
        !assoc.foreign_key_db_name.empty()) {
      std::string fk_col_on_curr_table = assoc.foreign_key_db_name;
      std::string target_table_name_str;
      std::string target_pk_col_name_str;

      cpporm::internal::ModelFactory factory_fn;
      {
        std::lock_guard<std::mutex> lock(
            cpporm::internal::getGlobalModelFactoryRegistryMutex());
        auto it_factory =
            cpporm::internal::getGlobalModelFactoryRegistry().find(
                assoc.target_model_type);
        if (it_factory !=
            cpporm::internal::getGlobalModelFactoryRegistry().end()) {
          factory_fn = it_factory->second;
        }
      }
      if (factory_fn) {
        auto temp_target_model = factory_fn();
        if (temp_target_model) {
          const ModelMeta &target_meta = temp_target_model->_getOwnModelMeta();
          target_table_name_str = target_meta.table_name;
          if (!assoc.target_model_pk_db_name.empty()) {
            target_pk_col_name_str = assoc.target_model_pk_db_name;
          } else if (!target_meta.primary_keys_db_names.empty()) {
            target_pk_col_name_str = target_meta.primary_keys_db_names[0];
          }
        }
      }

      if (!target_table_name_str.empty() && !target_pk_col_name_str.empty()) {
        std::string fk_sql =
            "FOREIGN KEY (" +
            QueryBuilder::quoteSqlIdentifier(fk_col_on_curr_table) + ")" +
            " REFERENCES " +
            QueryBuilder::quoteSqlIdentifier(target_table_name_str) + " (" +
            QueryBuilder::quoteSqlIdentifier(target_pk_col_name_str) + ")";
        table_constraints_sql.push_back(fk_sql);
      } else {
        qWarning() << "migrateCreateTable (FK): Could not determine target "
                      "table/PK for BelongsTo association '"
                   << QString::fromStdString(assoc.cpp_field_name)
                   << "' on table '" << QString::fromStdString(meta.table_name)
                   << "'. FK constraint not created.";
      }
    }
  }

  std::string all_definitions_sql_str;
  for (size_t i = 0; i < column_definitions_sql.size(); ++i) {
    all_definitions_sql_str += column_definitions_sql[i];
    if (i < column_definitions_sql.size() - 1 ||
        !table_constraints_sql.empty()) {
      all_definitions_sql_str += ", ";
    }
  }
  for (size_t i = 0; i < table_constraints_sql.size(); ++i) {
    all_definitions_sql_str += table_constraints_sql[i];
    if (i < table_constraints_sql.size() - 1) {
      all_definitions_sql_str += ", ";
    }
  }

  if (!all_definitions_sql_str.empty()) {
    bool ends_with_comma_space = true;
    while (ends_with_comma_space && !all_definitions_sql_str.empty()) {
      if (all_definitions_sql_str.back() == ',' ||
          all_definitions_sql_str.back() == ' ') {
        all_definitions_sql_str.pop_back();
      } else {
        ends_with_comma_space = false;
      }
    }
  }
  if (all_definitions_sql_str.empty()) {
    return Error(ErrorCode::InvalidConfiguration,
                 "migrateCreateTable: No column definitions or constraints "
                 "generated for table '" +
                     meta.table_name + "'.");
  }

  QString create_table_ddl =
      QString("CREATE TABLE IF NOT EXISTS %1 (%2);")
          .arg(QString::fromStdString(
              QueryBuilder::quoteSqlIdentifier(meta.table_name)))
          .arg(QString::fromStdString(all_definitions_sql_str));

  qInfo() << "migrateCreateTable (DDL for "
          << QString::fromStdString(meta.table_name)
          << "): " << create_table_ddl;
  // Pass session.getDbHandle() which returns a QSqlDatabase copy
  auto [_, err_obj] =
      execute_ddl_query(session.getDbHandle(), create_table_ddl);
  return err_obj;
}

std::pair<QSqlQuery, Error>
execute_ddl_query(QSqlDatabase db,
                  const QString &ddl_sql) { // Takes QSqlDatabase by value
  if (!db.isOpen()) {
    if (!db.open()) {
      QSqlError err = db.lastError();
      qWarning() << "execute_ddl_query: Failed to open database for DDL:"
                 << err.text() << "SQL:" << ddl_sql;
      return {QSqlQuery(db), Error(ErrorCode::ConnectionNotOpen,
                                   "Failed to open database for DDL: " +
                                       err.text().toStdString())};
    }
  }
  QSqlQuery query(db);
  if (!query.exec(ddl_sql)) {
    QSqlError err = query.lastError();
    qWarning() << "execute_ddl_query: DDL execution failed:" << err.text()
               << "SQL:" << ddl_sql;
    return {query, Error(ErrorCode::QueryExecutionError,
                         "DDL execution failed: " + err.text().toStdString() +
                             " SQL: " + ddl_sql.toStdString(),
                         err.nativeErrorCode().toInt())};
  }
  return {query, make_ok()};
}

} // namespace internal
} // namespace cpporm// cpporm/session_migrate_utils.cpp (新文件 - 目前为空或只包含辅助声明)
#include "cpporm/session_migrate_priv.h" // For DbColumnInfo, DbIndexInfo potentially if utils are complex

// This file can contain utility functions shared across migration operations.
// For example:
// - More sophisticated DB type normalization.
// - Helpers to parse specific DB information (e.g., default values, constraints
// from strings).
// - If getSqlTypeForCppType is made a free function, it could live here.

namespace cpporm {
namespace internal {

// Example: If getSqlTypeForCppType were moved here:
/*
std::string getSqlTypeForModelField_utility_moved(const FieldMeta &field_meta,
const QString &driverNameUpper) {
    // ... implementation ...
    if (!field_meta.db_type_hint.empty()) return field_meta.db_type_hint;
    // ... rest of type mapping logic ...
    return "TEXT"; // Fallback
}
*/

// Currently, most logic is within the _column_ops.cpp and _index_ops.cpp.
// If common patterns emerge during their full implementation, they can be
// refactored here.

} // namespace internal
} // namespace cpporm// cpporm/session_preload_utils.cpp
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"

#include <QDebug>
#include <algorithm>
#include <any>
#include <map>
#include <memory>
#include <mutex>
#include <set>
#include <string>
#include <vector>

namespace cpporm {

static std::string
any_to_string_for_map_key_in_preload_util(const std::any &val) {
  if (!val.has_value())
    return "__cpporm_NULL_KEY__";

  const auto &type = val.type();
  if (type == typeid(int))
    return "i_" + std::to_string(std::any_cast<int>(val));
  if (type == typeid(long long))
    return "ll_" + std::to_string(std::any_cast<long long>(val));
  if (type == typeid(unsigned int))
    return "ui_" + std::to_string(std::any_cast<unsigned int>(val));
  if (type == typeid(unsigned long long))
    return "ull_" + std::to_string(std::any_cast<unsigned long long>(val));
  if (type == typeid(std::string))
    return "s_" + std::any_cast<std::string>(val);
  if (type == typeid(const char *))
    return "s_" + std::string(std::any_cast<const char *>(val));
  if (type == typeid(QDateTime))
    return "dt_" + std::any_cast<QDateTime>(val)
                       .toUTC()
                       .toString(Qt::ISODateWithMs)
                       .toStdString();
  if (type == typeid(QDate))
    return "d_" + std::any_cast<QDate>(val).toString(Qt::ISODate).toStdString();
  if (type == typeid(bool))
    return "b_" + std::string(std::any_cast<bool>(val) ? "true" : "false");
  if (type == typeid(double))
    return "dbl_" + std::to_string(std::any_cast<double>(val));
  if (type == typeid(float))
    return "flt_" + std::to_string(std::any_cast<float>(val));

  qWarning()
      << "any_to_string_for_map_key_in_preload_util: Unsupported std::any type "
      << " ('" << val.type().name()
      << "') for map key generation during preload. ";
  return "__cpporm_UNSUPPORTED_KEY_TYPE_" + std::string(val.type().name()) +
         "__";
}

Error Session::processPreloadsInternal(
    const QueryBuilder &qb, std::vector<ModelBase *> &parent_models_raw_ptr) {
  const std::vector<PreloadRequest> &preload_requests = qb.getPreloadRequests();
  const ModelMeta *main_model_meta_ptr = qb.getModelMeta();

  if (!main_model_meta_ptr) {
    return Error(ErrorCode::InvalidConfiguration,
                 "processPreloadsInternal: QueryBuilder has no ModelMeta for "
                 "main model.");
  }
  const ModelMeta &main_model_meta = *main_model_meta_ptr;

  if (preload_requests.empty() || parent_models_raw_ptr.empty()) {
    return make_ok();
  }

  for (const auto &request : preload_requests) {
    std::string association_to_load = request.association_cpp_field_name;
    if (association_to_load.find('.') != std::string::npos) {
      qWarning() << "Session::processPreloadsInternal: Nested preload paths "
                    "(e.g., 'Orders.Items') are not yet fully supported. "
                 << "Preloading only the first part of: '"
                 << QString::fromStdString(association_to_load) << "'";
      association_to_load =
          association_to_load.substr(0, association_to_load.find('.'));
    }

    const AssociationMeta *assoc_meta =
        main_model_meta.findAssociationByCppName(association_to_load);
    if (!assoc_meta) {
      qWarning() << "Session::processPreloadsInternal: Association '"
                 << QString::fromStdString(association_to_load)
                 << "' not found in model '"
                 << QString::fromStdString(main_model_meta.table_name)
                 << "' for preloading.";
      continue;
    }

    Error err = executePreloadForAssociation(*assoc_meta, main_model_meta,
                                             parent_models_raw_ptr);
    if (err) {
      qWarning() << "Session::processPreloadsInternal: Error preloading "
                    "association '"
                 << QString::fromStdString(association_to_load)
                 << "': " << QString::fromStdString(err.toString());
      return err;
    }
  }
  return make_ok();
}

Error Session::processPreloads(
    const QueryBuilder &qb,
    std::vector<std::unique_ptr<ModelBase>> &loaded_models_unique_ptr) {
  if (loaded_models_unique_ptr.empty()) {
    return make_ok();
  }
  std::vector<ModelBase *> raw_ptr_vec;
  raw_ptr_vec.reserve(loaded_models_unique_ptr.size());
  for (const auto &u_ptr : loaded_models_unique_ptr) {
    if (u_ptr) {
      raw_ptr_vec.push_back(u_ptr.get());
    }
  }
  if (raw_ptr_vec.empty() && !loaded_models_unique_ptr.empty()) {
    return make_ok();
  }
  return processPreloadsInternal(qb, raw_ptr_vec);
}

Error Session::executePreloadForAssociation(
    const AssociationMeta &assoc_meta, const ModelMeta &parent_model_meta,
    std::vector<ModelBase *> &parent_models_raw_ptr) {

  if (parent_models_raw_ptr.empty()) {
    return make_ok();
  }

  cpporm::internal::ModelFactory target_model_factory_fn;
  {
    std::lock_guard<std::mutex> lock(
        internal::getGlobalModelFactoryRegistryMutex());
    auto it_factory = internal::getGlobalModelFactoryRegistry().find(
        assoc_meta.target_model_type);
    if (it_factory == internal::getGlobalModelFactoryRegistry().end()) {
      return Error(
          ErrorCode::InternalError,
          "Preload Error: Target model factory not found for type_index: " +
              std::string(assoc_meta.target_model_type.name()) +
              " for association '" + assoc_meta.cpp_field_name + "'.");
    }
    target_model_factory_fn = it_factory->second;
  }

  std::unique_ptr<ModelBase> temp_target_instance_uptr =
      target_model_factory_fn();
  if (!temp_target_instance_uptr) {
    return Error(ErrorCode::InternalError,
                 "Preload Error: Target model factory failed to create "
                 "instance for type: " +
                     std::string(assoc_meta.target_model_type.name()) +
                     " for association '" + assoc_meta.cpp_field_name + "'.");
  }
  const ModelMeta &target_model_meta =
      temp_target_instance_uptr->_getOwnModelMeta();
  if (target_model_meta.table_name.empty()) {
    return Error(ErrorCode::InvalidConfiguration,
                 "Preload Error: Target model '" +
                     std::string(assoc_meta.target_model_type.name()) +
                     "' has an empty table name in its metadata.");
  }

  std::string parent_model_key_cpp_name;
  std::string target_model_key_db_name;

  if (assoc_meta.type == AssociationType::HasMany ||
      assoc_meta.type == AssociationType::HasOne) {
    const FieldMeta *pk_field_on_parent = nullptr;
    if (!assoc_meta.primary_key_db_name_on_current_model.empty()) {
      pk_field_on_parent = parent_model_meta.findFieldByDbName(
          assoc_meta.primary_key_db_name_on_current_model);
    } else if (!parent_model_meta.primary_keys_db_names.empty()) {
      pk_field_on_parent = parent_model_meta.findFieldByDbName(
          parent_model_meta.primary_keys_db_names[0]);
    } else {
      return Error(ErrorCode::MappingError,
                   "Preload Error (HasMany/HasOne): Parent model '" +
                       parent_model_meta.table_name +
                       "' has no primary keys defined for association '" +
                       assoc_meta.cpp_field_name + "'.");
    }
    if (!pk_field_on_parent) {
      return Error(
          ErrorCode::MappingError,
          "Preload Error (HasMany/HasOne): Parent reference key DB name '" +
              (assoc_meta.primary_key_db_name_on_current_model.empty()
                   ? (parent_model_meta.primary_keys_db_names.empty()
                          ? "[UNKNOWN_PK]"
                          : parent_model_meta.primary_keys_db_names[0])
                   : assoc_meta.primary_key_db_name_on_current_model) +
              "' not found on parent model '" + parent_model_meta.table_name +
              "' for association '" + assoc_meta.cpp_field_name + "'.");
    }
    parent_model_key_cpp_name = pk_field_on_parent->cpp_name;
    target_model_key_db_name = assoc_meta.foreign_key_db_name;
    if (target_model_key_db_name.empty()) {
      return Error(ErrorCode::MappingError,
                   "Preload Error (HasMany/HasOne): Foreign key on target "
                   "model not specified for association '" +
                       assoc_meta.cpp_field_name + "'.");
    }
  } else if (assoc_meta.type == AssociationType::BelongsTo) {
    const FieldMeta *fk_field_on_parent =
        parent_model_meta.findFieldByDbName(assoc_meta.foreign_key_db_name);
    if (!fk_field_on_parent) {
      return Error(ErrorCode::MappingError,
                   "Preload Error (BelongsTo): Foreign key DB name '" +
                       assoc_meta.foreign_key_db_name +
                       "' not found on parent model '" +
                       parent_model_meta.table_name + "' for association '" +
                       assoc_meta.cpp_field_name + "'.");
    }
    parent_model_key_cpp_name = fk_field_on_parent->cpp_name;
    if (!assoc_meta.target_model_pk_db_name.empty()) {
      target_model_key_db_name = assoc_meta.target_model_pk_db_name;
    } else if (!target_model_meta.primary_keys_db_names.empty()) {
      target_model_key_db_name = target_model_meta.primary_keys_db_names[0];
    } else {
      return Error(ErrorCode::MappingError,
                   "Preload Error (BelongsTo): Target model '" +
                       target_model_meta.table_name +
                       "' has no primary keys defined for association '" +
                       assoc_meta.cpp_field_name + "'.");
    }
    if (target_model_key_db_name.empty()) {
      return Error(ErrorCode::MappingError,
                   "Preload Error (BelongsTo): Referenced key on target model "
                   "not specified or determinable for association '" +
                       assoc_meta.cpp_field_name + "'.");
    }
  } else if (assoc_meta.type == AssociationType::ManyToMany) {
    return Error(ErrorCode::UnsupportedFeature,
                 "Preload Error: ManyToMany preloading for association '" +
                     assoc_meta.cpp_field_name + "' is not yet implemented.");
  } else {
    return Error(ErrorCode::InternalError,
                 "Preload Error: Unknown association type for '" +
                     assoc_meta.cpp_field_name + "'.");
  }

  if (parent_model_key_cpp_name.empty() || target_model_key_db_name.empty()) {
    return Error(ErrorCode::MappingError,
                 "Preload Error: Could not determine one or both join key "
                 "names for association '" +
                     assoc_meta.cpp_field_name + "'. ParentKeyCppName: '" +
                     parent_model_key_cpp_name + "', TargetKeyDbName: '" +
                     target_model_key_db_name + "'.");
  }

  std::vector<QueryValue> parent_key_values_for_in_clause;
  parent_key_values_for_in_clause.reserve(parent_models_raw_ptr.size());
  for (const auto parent_model_ptr : parent_models_raw_ptr) {
    if (parent_model_ptr) {
      std::any key_any =
          parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
      if (key_any.has_value()) {
        QueryValue qv = Session::anyToQueryValueForSessionConvenience(key_any);
        if (std::holds_alternative<std::nullptr_t>(qv) && key_any.has_value()) {
          qWarning() << "Preload Warning: Unsupported parent key type ('"
                     << key_any.type().name()
                     << "') for IN clause when preloading '"
                     << QString::fromStdString(assoc_meta.cpp_field_name)
                     << "'. Skipping key value.";
          continue;
        }
        if (!std::holds_alternative<std::nullptr_t>(qv)) {
          parent_key_values_for_in_clause.push_back(qv);
        }
      }
    }
  }

  if (parent_key_values_for_in_clause.empty()) {
    return make_ok();
  }

  QueryBuilder qb_preload(this, this->connection_name_, &target_model_meta);

  std::string quoted_target_key_db_name =
      QueryBuilder::quoteSqlIdentifier(target_model_key_db_name);
  if (parent_key_values_for_in_clause.empty()) {
    return make_ok();
  }
  std::string in_placeholders_sql_segment;
  for (size_t i = 0; i < parent_key_values_for_in_clause.size(); ++i) {
    in_placeholders_sql_segment += (i == 0 ? "?" : ", ?");
  }
  qb_preload.Where(quoted_target_key_db_name + " IN (" +
                       in_placeholders_sql_segment + ")",
                   parent_key_values_for_in_clause);

  std::vector<std::unique_ptr<ModelBase>>
      associated_results_unique_ptr_vec; // Correct type for FindImpl
  Error find_err = this->FindImpl(qb_preload, associated_results_unique_ptr_vec,
                                  target_model_factory_fn);

  if (find_err) {
    return Error(find_err.code,
                 "Preload Error: Failed to fetch associated models for '" +
                     assoc_meta.cpp_field_name + "' from table '" +
                     target_model_meta.table_name + "': " + find_err.message);
  }

  if (associated_results_unique_ptr_vec.empty()) {
    for (auto parent_model_ptr : parent_models_raw_ptr) {
      if (!parent_model_ptr)
        continue;
      if (assoc_meta.type == AssociationType::HasMany &&
          assoc_meta.data_setter_vector) {
        std::vector<std::shared_ptr<ModelBase>> empty_vec;
        assoc_meta.data_setter_vector(parent_model_ptr, empty_vec);
      } else if ((assoc_meta.type == AssociationType::HasOne ||
                  assoc_meta.type == AssociationType::BelongsTo) &&
                 assoc_meta.data_setter_single) {
        assoc_meta.data_setter_single(parent_model_ptr, nullptr);
      }
    }
    return make_ok();
  }

  const FieldMeta *target_model_key_field_meta =
      target_model_meta.findFieldByDbName(target_model_key_db_name);
  if (!target_model_key_field_meta) {
    return Error(ErrorCode::MappingError,
                 "Preload Error: Target model's join key C++ field meta not "
                 "found for DB name: '" +
                     target_model_key_db_name + "' on table '" +
                     target_model_meta.table_name + "'. Cannot map results.");
  }

  std::map<std::string, std::vector<std::shared_ptr<ModelBase>>>
      map_associated_by_their_link_key_value;
  for (auto &assoc_model_uptr : associated_results_unique_ptr_vec) {
    if (assoc_model_uptr) {
      std::any link_key_val_any = assoc_model_uptr->getFieldValue(
          target_model_key_field_meta->cpp_name);
      std::string link_key_val_str_key =
          any_to_string_for_map_key_in_preload_util(link_key_val_any);

      if (link_key_val_str_key.rfind("__cpporm_UNSUPPORTED_KEY_TYPE_", 0) ==
              0 ||
          link_key_val_str_key == "__cpporm_NULL_KEY__") {
        // Corrected variable name: assoc_model_uptr is the current item.
        const ModelMeta &t_assoc_meta =
            assoc_model_uptr->_getOwnModelMeta(); // Was current_assoc_meta
        const FieldMeta *current_assoc_pk_field =
            t_assoc_meta.getPrimaryField(); // Use t_assoc_meta
        std::string current_assoc_pk_val_str = "N/A_PK_FIELD";
        if (current_assoc_pk_field) {
          current_assoc_pk_val_str = any_to_string_for_map_key_in_preload_util(
              assoc_model_uptr->getFieldValue(
                  current_assoc_pk_field->cpp_name));
        }

        qWarning() << "Preload Warning: Could not get or convert foreign key "
                      "value to string for mapping associated model for "
                   << QString::fromStdString(assoc_meta.cpp_field_name)
                   << ". Target model PK (if available): "
                   << QString::fromStdString(current_assoc_pk_val_str);
        continue;
      }
      map_associated_by_their_link_key_value[link_key_val_str_key].push_back(
          std::move(assoc_model_uptr));
    }
  }
  associated_results_unique_ptr_vec.clear();

  for (auto parent_model_ptr : parent_models_raw_ptr) {
    if (!parent_model_ptr)
      continue;
    std::any parent_key_val_any =
        parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
    std::string parent_key_val_str_key =
        any_to_string_for_map_key_in_preload_util(parent_key_val_any);

    auto it_found_associated =
        map_associated_by_their_link_key_value.find(parent_key_val_str_key);

    if (it_found_associated != map_associated_by_their_link_key_value.end()) {
      std::vector<std::shared_ptr<ModelBase>>
          &associated_for_this_parent_sptrs = it_found_associated->second;
      if (assoc_meta.type == AssociationType::HasMany) {
        if (assoc_meta.data_setter_vector) {
          assoc_meta.data_setter_vector(parent_model_ptr,
                                        associated_for_this_parent_sptrs);
        } else {
          qWarning()
              << "Preload: Missing vector setter for HasMany association "
              << QString::fromStdString(assoc_meta.cpp_field_name)
              << " on parent "
              << QString::fromStdString(parent_model_meta.table_name);
        }
      } else if (assoc_meta.type == AssociationType::HasOne ||
                 assoc_meta.type == AssociationType::BelongsTo) {
        if (assoc_meta.data_setter_single) {
          if (!associated_for_this_parent_sptrs.empty()) {
            assoc_meta.data_setter_single(
                parent_model_ptr, associated_for_this_parent_sptrs.front());
          } else {
            assoc_meta.data_setter_single(parent_model_ptr, nullptr);
          }
        } else {
          qWarning() << "Preload: Missing single setter for HasOne/BelongsTo "
                        "association "
                     << QString::fromStdString(assoc_meta.cpp_field_name)
                     << " on parent "
                     << QString::fromStdString(parent_model_meta.table_name);
        }
      }
    } else {
      if (assoc_meta.type == AssociationType::HasMany &&
          assoc_meta.data_setter_vector) {
        std::vector<std::shared_ptr<ModelBase>> empty_sptr_vec;
        assoc_meta.data_setter_vector(parent_model_ptr, empty_sptr_vec);
      } else if ((assoc_meta.type == AssociationType::HasOne ||
                  assoc_meta.type == AssociationType::BelongsTo) &&
                 assoc_meta.data_setter_single) {
        assoc_meta.data_setter_single(parent_model_ptr, nullptr);
      }
    }
  }
  return make_ok();
}

} // namespace cpporm// cpporm/session_raw_ops.cpp
#include "cpporm/error.h"
#include "cpporm/session.h"

#include <QDebug>    // For qWarning
#include <QSqlError> // For QSqlError details
#include <QSqlQuery>
#include <QString>
#include <QVariantList>

namespace cpporm {

std::expected<long long, Error> Session::ExecRaw(const QString &sql,
                                                 const QVariantList &args) {
  if (sql.isEmpty()) {
    return std::unexpected(Error(ErrorCode::StatementPreparationError,
                                 "Raw SQL query string is empty."));
  }
  // `execute_query_internal` is a static private helper method of Session,
  // defined in session.cpp
  auto [query_obj, exec_err] =
      execute_query_internal(this->db_handle_, sql, args);

  if (exec_err) {
    qWarning() << "Session::ExecRaw: Execution failed for SQL:" << sql
               << "Args:" << args
               << "Error:" << QString::fromStdString(exec_err.toString());
    return std::unexpected(exec_err);
  }

  // QSqlQuery::numRowsAffected() behavior:
  // - For DML (INSERT, UPDATE, DELETE): Returns the number of rows affected.
  // - For SELECT: Behavior is driver-dependent. Some return -1, some the number
  // of rows fetched so far.
  // - For DDL (CREATE, ALTER, DROP): Behavior is driver-dependent. Often -1 or
  // 0. GORM's Exec() is typically for DML/DDL and returns RowsAffected. If the
  // user intends to fetch rows from a SELECT, they should use a different raw
  // query method (e.g., one that returns QSqlQuery or maps to models/structs).
  long long rows_affected = query_obj.numRowsAffected();

  // It's possible that for some DDL statements, numRowsAffected might be -1
  // even if successful. We might want to consider query.isActive() as a sign of
  // success for DDL if numRowsAffected is inconclusive. However, for a generic
  // ExecRaw, returning numRowsAffected is the most common ORM behavior.
  if (rows_affected == -1) {
    // This could be a SELECT statement, or a DDL statement on some drivers.
    // Or it could be an actual error state not caught by query.exec() returning
    // false (rare). If it's a non-DML statement that succeeded, -1 might be
    // "normal". We can't easily distinguish without knowing the type of SQL
    // statement. For now, we return it as is. The user of ExecRaw needs to be
    // aware of this. qInfo() << "Session::ExecRaw: numRowsAffected is -1. SQL:
    // " << sql << ". This may be normal for SELECT or DDL statements.";
  }

  return rows_affected;
}

} // namespace cpporm// cpporm/session_read_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
// #include "cpporm/qt_db_manager.h" // 通常不需要

#include <QDebug>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QVariant>
#include <algorithm>

namespace cpporm {

Error Session::FirstImpl(const QueryBuilder &qb, ModelBase &result_model) {
  const ModelMeta *meta = qb.getModelMeta();
  if (!meta) {
    // If QB doesn't have meta (e.g., built via MakeQueryBuilder and Table()),
    // use the meta from the result_model instance.
    meta = &(result_model._getOwnModelMeta());
    if (meta->table_name.empty()) {
      return Error(ErrorCode::InvalidConfiguration,
                   "FirstImpl: Could not determine ModelMeta for query.");
    }
  }

  QueryBuilder local_qb = qb; // Make a mutable copy for Limit(1)
  local_qb.Limit(1);
  auto [sql, params] = local_qb.buildSelectSQL();

  if (sql.isEmpty()) {
    return Error(ErrorCode::StatementPreparationError,
                 "Failed to build SQL for First operation.");
  }

  auto [query, exec_err] =
      execute_query_internal(this->db_handle_, sql, params);
  if (exec_err) {
    return exec_err;
  }

  if (query.next()) {
    Error map_err = mapRowToModel(query, result_model, *meta);
    if (map_err) {
      qWarning() << "cpporm Session::FirstImpl: Error mapping row:"
                 << map_err.toString().c_str();
      return map_err;
    }
    result_model._is_persisted = true;
    Error hook_err = result_model.afterFind(*this);
    if (hook_err)
      return hook_err;

    // Preloading logic: If there are preload requests, handle them.
    // This logic is now correctly placed within the IQueryExecutor (Session)
    // implementation.
    if (!qb.getPreloadRequests().empty()) {
      // Convert ModelBase& to a vector of raw pointers for
      // processPreloadsInternal
      std::vector<ModelBase *> models_for_preload = {&result_model};
      Error preload_err = this->processPreloadsInternal(qb, models_for_preload);
      if (preload_err) {
        qWarning()
            << "Session::FirstImpl: Preloading failed after fetching model: "
            << preload_err.toString().c_str();
        // Decide if preload failure should make the whole operation fail
        // return preload_err;
      }
    }
    return make_ok();
  } else {
    return Error(ErrorCode::RecordNotFound,
                 "No record found for First operation.");
  }
}

Error Session::FindImpl(
    const QueryBuilder &qb,
    std::vector<std::unique_ptr<ModelBase>> &results_vector,
    std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
  if (!element_type_factory) {
    return Error(ErrorCode::InternalError,
                 "Element type factory function is null for Find operation.");
  }

  const ModelMeta *meta_for_query = qb.getModelMeta();
  if (!meta_for_query) {
    auto temp_instance = element_type_factory();
    if (temp_instance &&
        !temp_instance->_getOwnModelMeta().table_name.empty()) {
      meta_for_query = &(temp_instance->_getOwnModelMeta());
    } else {
      return Error(ErrorCode::InvalidConfiguration,
                   "FindImpl: Could not determine ModelMeta for query from "
                   "QueryBuilder or factory.");
    }
  }

  auto [sql, params] = qb.buildSelectSQL();
  if (sql.isEmpty()) {
    return Error(ErrorCode::StatementPreparationError,
                 "Failed to build SQL for Find operation.");
  }

  auto [query, exec_err] =
      execute_query_internal(this->db_handle_, sql, params);
  if (exec_err) {
    return exec_err;
  }

  results_vector.clear();
  while (query.next()) {
    std::unique_ptr<ModelBase> new_element = element_type_factory();
    if (!new_element) {
      return Error(ErrorCode::InternalError,
                   "Element factory returned nullptr inside Find loop.");
    }
    Error map_err = mapRowToModel(query, *new_element, *meta_for_query);
    if (map_err) {
      qWarning() << "cpporm Session::FindImpl: Error mapping row: "
                 << map_err.toString().c_str() << ". SQL was: " << sql;
      return map_err;
    }
    new_element->_is_persisted = true;
    Error hook_err = new_element->afterFind(*this);
    if (hook_err) {
      qWarning()
          << "cpporm Session::FindImpl: afterFind hook failed for an element: "
          << hook_err.toString().c_str();
    }
    results_vector.push_back(std::move(new_element));
  }

  // Preloading logic for FindImpl
  if (!results_vector.empty() && !qb.getPreloadRequests().empty()) {
    // processPreloads now correctly takes a vector of unique_ptr
    Error preload_err = this->processPreloads(qb, results_vector);
    if (preload_err) {
      return preload_err;
    }
  }
  return make_ok();
}

std::expected<int64_t, Error> Session::CountImpl(const QueryBuilder &qb_const) {
  QueryBuilder qb = qb_const; // 创建可修改副本
  if (!qb.getGroupClause().empty()) {
    qWarning("cpporm Session::CountImpl: Count() called with existing GROUP "
             "BY clause. Clearing GROUP BY for total count.");
    qb.Group("");
  }
  qb.Select("COUNT(*)");
  qb.Order("");
  qb.Limit(-1);
  qb.Offset(-1);
  if (!qb.getState_().preload_requests_.empty()) {
    // It's good practice to clear preloads for a COUNT query as they are
    // irrelevant.
    QueryBuilderState &mutable_state =
        const_cast<QueryBuilder &>(qb).getState_();
    mutable_state.preload_requests_.clear();
  }

  auto [sql, params] = qb.buildSelectSQL();
  if (sql.isEmpty()) {
    return std::unexpected(Error(ErrorCode::StatementPreparationError,
                                 "Failed to build SQL for Count operation."));
  }
  auto [query, err] = execute_query_internal(this->db_handle_, sql, params);
  if (err) {
    return std::unexpected(err);
  }
  if (query.next()) {
    bool ok_conversion;
    int64_t count_val = query.value(0).toLongLong(&ok_conversion);
    if (ok_conversion) {
      return count_val;
    } else {
      return std::unexpected(
          Error(ErrorCode::MappingError,
                "Failed to convert COUNT(*) result to integer. Value: " +
                    query.value(0).toString().toStdString()));
    }
  } else {
    qWarning() << "cpporm Session::CountImpl: COUNT(*) query returned no rows "
                  "(unexpected). SQL:"
               << sql;
    return std::unexpected(Error(ErrorCode::QueryExecutionError,
                                 "COUNT(*) query returned no rows."));
  }
}

} // namespace cpporm// cpporm/session_save_op.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"

#include <QDateTime>
#include <QDebug>
#include <QMetaType>
#include <QSqlQuery>
#include <QVariant>

namespace cpporm {

// Helper to convert QVariant to QueryValue, specific for SaveOp needs.
QueryValue qvariantToQueryValueForSaveOpHelper(const QVariant &qv) {
  if (qv.isNull() || !qv.isValid()) {
    return nullptr;
  }

  QMetaType::Type effectiveTypeId;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
  effectiveTypeId = static_cast<QMetaType::Type>(qv.typeId());
#else
  effectiveTypeId = static_cast<QMetaType::Type>(qv.type());
#endif
  if (effectiveTypeId == QMetaType::UnknownType &&
      qv.userType() != QMetaType::UnknownType) {
    effectiveTypeId = static_cast<QMetaType::Type>(qv.userType());
  }

  switch (effectiveTypeId) {
  case QMetaType::Int:
    return qv.toInt();
  case QMetaType::LongLong:
    return qv.toLongLong();
  case QMetaType::ULongLong:
    return static_cast<long long>(
        qv.toULongLong()); // Potential truncation if too large, QueryValue uses
                           // signed
  case QMetaType::UInt:
    return static_cast<int>(qv.toUInt()); // Potential truncation
  case QMetaType::Double:
    return qv.toDouble();
  case QMetaType::QString:
    return qv.toString().toStdString();
  case QMetaType::Bool:
    return qv.toBool();
  case QMetaType::QDateTime:
    return qv.toDateTime();
  case QMetaType::QDate:
    return qv.toDate();
  case QMetaType::QTime:
    return qv.toTime();
  case QMetaType::QByteArray:
    return qv.toByteArray();
  case QMetaType::Float:
    return static_cast<double>(
        qv.toFloat()); // Promote float to double for QueryValue
  default:
    qWarning() << "qvariantToQueryValueForSaveOpHelper: Unhandled QVariant "
                  "metaType for QueryValue conversion:"
               << qv.typeName()
               << "(TypeId: " << static_cast<int>(effectiveTypeId)
               << ", UserType: " << qv.userType() << ")";
    return nullptr;
  }
}

std::map<std::string, QueryValue>
convertQStringVariantMapToStringQueryValueMapForSaveOpHelper(
    const std::map<QString, QVariant> &qtMap) {
  std::map<std::string, QueryValue> result;
  for (const auto &pair : qtMap) {
    QueryValue q_val = qvariantToQueryValueForSaveOpHelper(pair.second);

    bool conversion_failed_for_valid_qvariant =
        std::holds_alternative<std::nullptr_t>(q_val) &&
        pair.second.isValid() && !pair.second.isNull();

    if (!conversion_failed_for_valid_qvariant) {
      result[pair.first.toStdString()] = q_val;
    } else {
      qWarning() << "convertQStringVariantMapToStringQueryValueMapForSaveOpHelp"
                    "er: Failed to convert QVariant for key"
                 << pair.first << "to QueryValue. Original QVariant type: "
                 << pair.second.typeName() << ". Skipping this field in map.";
    }
  }
  return result;
}

std::expected<long long, Error> Session::SaveImpl(
    const QueryBuilder
        &qb_param, // QB used for model meta and potentially OnConflict from QB
    ModelBase &model_instance) {
  const ModelMeta *meta_from_qb = qb_param.getModelMeta();
  const ModelMeta &meta =
      meta_from_qb ? *meta_from_qb : model_instance._getOwnModelMeta();

  if (meta.table_name.empty()) {
    return std::unexpected(
        Error(ErrorCode::InvalidConfiguration,
              "SaveImpl: ModelMeta does not have a valid table_name."));
  }

  Error hook_err = model_instance.beforeSave(*this);
  if (hook_err)
    return std::unexpected(hook_err);

  bool has_defined_pk = !meta.primary_keys_db_names.empty();
  bool model_has_all_pks_set_and_non_default = false;
  if (has_defined_pk) {
    model_has_all_pks_set_and_non_default = true;
    for (const auto &pk_db_name : meta.primary_keys_db_names) {
      const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
      if (pk_field) {
        std::any pk_val_any = model_instance.getFieldValue(pk_field->cpp_name);
        if (!pk_val_any.has_value()) {
          model_has_all_pks_set_and_non_default = false;
          break;
        }
        // Check for "zero" or "empty" values that GORM might consider as "not
        // set" for update decisions
        if (pk_val_any.type() == typeid(int) &&
            std::any_cast<int>(pk_val_any) == 0) {
          model_has_all_pks_set_and_non_default = false;
          break;
        } else if (pk_val_any.type() == typeid(long long) &&
                   std::any_cast<long long>(pk_val_any) == 0) {
          model_has_all_pks_set_and_non_default = false;
          break;
        } else if (pk_val_any.type() == typeid(unsigned int) &&
                   std::any_cast<unsigned int>(pk_val_any) == 0) {
          model_has_all_pks_set_and_non_default = false;
          break;
        } else if (pk_val_any.type() == typeid(unsigned long long) &&
                   std::any_cast<unsigned long long>(pk_val_any) == 0) {
          model_has_all_pks_set_and_non_default = false;
          break;
        } else if (pk_val_any.type() == typeid(std::string) &&
                   std::any_cast<std::string>(pk_val_any).empty()) {
          model_has_all_pks_set_and_non_default = false;
          break;
        }
      } else {
        model_has_all_pks_set_and_non_default = false; // PK meta missing
        qWarning() << "SaveImpl: PK field meta not found for"
                   << QString::fromStdString(pk_db_name);
        break;
      }
    }
  }

  // GORM's Save logic:
  // If primary key has non-zero value, it updates; otherwise, it creates.
  // _is_persisted can also hint, but PK value is often the primary driver.
  bool attempt_update =
      (model_instance._is_persisted || model_has_all_pks_set_and_non_default) &&
      has_defined_pk;

  if (attempt_update) {                                   // Attempt an UPDATE
    this->autoSetTimestamps(model_instance, meta, false); // Set updated_at
    cpporm::internal::SessionModelDataForWrite data_to_write =
        this->extractModelData(model_instance, meta, true, true);

    if (data_to_write.primary_key_fields.empty() && has_defined_pk) {
      return std::unexpected(
          Error(ErrorCode::MappingError,
                "SaveImpl (Update path): Failed to extract valid primary key "
                "values for WHERE clause."));
    }

    bool has_fields_to_set = !data_to_write.fields_to_write.empty();
    if (!has_fields_to_set) {
      qInfo("SaveImpl (Update path): No fields (including timestamps) to "
            "update for table %s. Skipping DB operation.",
            meta.table_name.c_str());
      // Still call hooks as the intent was to save/update
      hook_err = model_instance.beforeUpdate(
          *this); // Call beforeUpdate even if no DB op
      if (hook_err)
        return std::unexpected(hook_err);
      hook_err = model_instance.afterUpdate(*this);
      if (hook_err)
        return std::unexpected(hook_err);
      hook_err = model_instance.afterSave(*this);
      if (hook_err)
        return std::unexpected(hook_err);
      return 0LL; // 0 rows affected
    }

    hook_err = model_instance.beforeUpdate(*this);
    if (hook_err)
      return std::unexpected(hook_err);

    QueryBuilder update_qb(this, this->connection_name_, &meta);
    for (const auto &pk_name_std : meta.primary_keys_db_names) {
      QString pk_name_qstr = QString::fromStdString(pk_name_std);
      auto it = data_to_write.primary_key_fields.find(pk_name_qstr);
      if (it != data_to_write.primary_key_fields.end() &&
          it->second.isValid() && !it->second.isNull()) {
        update_qb.Where(pk_name_std + " = ?",
                        {qvariantToQueryValueForSaveOpHelper(it->second)});
      } else {
        return std::unexpected(Error(
            ErrorCode::MappingError,
            "SaveImpl (Update path): PK '" + pk_name_std +
                "' missing or invalid in extracted PKs for WHERE clause."));
      }
    }

    std::map<std::string, QueryValue> updates_for_impl =
        convertQStringVariantMapToStringQueryValueMapForSaveOpHelper(
            data_to_write.fields_to_write);

    // Remove PKs from the SET clause if they somehow got in (extractModelData
    // should handle this for `for_update=true`)
    for (const auto &pk_db_name : meta.primary_keys_db_names) {
      updates_for_impl.erase(pk_db_name);
    }
    if (updates_for_impl.empty()) { // If only PKs were in fields_to_write and
                                    // now it's empty
      qInfo("SaveImpl (Update path): After removing PKs, no fields left to "
            "update for table %s. Skipping DB operation.",
            meta.table_name.c_str());
      hook_err = model_instance.afterUpdate(*this);
      if (hook_err)
        return std::unexpected(hook_err);
      hook_err = model_instance.afterSave(*this);
      if (hook_err)
        return std::unexpected(hook_err);
      return 0LL;
    }

    auto update_result = this->UpdatesImpl(update_qb, updates_for_impl);

    if (!update_result.has_value())
      return std::unexpected(update_result.error());

    if (update_result.value() >= 0)
      model_instance._is_persisted = true;

    hook_err = model_instance.afterUpdate(*this);
    if (hook_err)
      return std::unexpected(hook_err);
    hook_err = model_instance.afterSave(*this);
    if (hook_err)
      return std::unexpected(hook_err);

    return update_result.value();

  } else { // Attempt a CREATE
    hook_err = model_instance.beforeCreate(*this);
    if (hook_err)
      return std::unexpected(hook_err);

    this->autoSetTimestamps(model_instance, meta, true);

    const OnConflictClause *final_conflict_options = nullptr;
    std::unique_ptr<OnConflictClause>
        save_upsert_clause_ptr; // Use unique_ptr for ownership

    if (qb_param
            .getOnConflictClause()) { // 1. From QueryBuilder passed to SaveImpl
      final_conflict_options = qb_param.getOnConflictClause();
    } else if (this->getTempOnConflictClause()) { // 2. From Session's temporary
                                                  // state
      final_conflict_options = this->getTempOnConflictClause();
    } else if (has_defined_pk && model_has_all_pks_set_and_non_default) {
      // 3. Default for Save: if PKs are set, behave like UPSERT (update all
      // non-PK) This implies an "ON DUPLICATE KEY UPDATE" or "ON CONFLICT DO
      // UPDATE" behavior.
      save_upsert_clause_ptr = std::make_unique<OnConflictClause>(
          OnConflictClause::Action::UpdateAllExcluded);
      // For PostgreSQL, UpdateAllExcluded needs conflict targets.
      // If model_meta has PKs, they are good default targets.
      if (!meta.primary_keys_db_names.empty() &&
          save_upsert_clause_ptr->conflict_target_columns_db_names.empty()) {
        save_upsert_clause_ptr->conflict_target_columns_db_names =
            meta.primary_keys_db_names;
      }
      final_conflict_options = save_upsert_clause_ptr.get();
    }
    // If no PKs defined or PKs are zero/default, it's a pure INSERT,
    // final_conflict_options remains nullptr.

    auto create_result =
        this->CreateImpl(qb_param, model_instance, final_conflict_options);

    // Clear session's temporary OnConflict if it was used and not overridden by
    // QB's
    if (this->getTempOnConflictClause() && !qb_param.getOnConflictClause() &&
        final_conflict_options == this->getTempOnConflictClause()) {
      this->clearTempOnConflictClause();
    }

    if (!create_result.has_value())
      return std::unexpected(create_result.error());
    // model_instance._is_persisted and afterCreate hook are handled by
    // CreateImpl.

    hook_err = model_instance.afterSave(*this);
    if (hook_err)
      return std::unexpected(hook_err);

    QVariant returned_value_from_create = create_result.value();
    long long rows_affected_or_id = -1;
    if (returned_value_from_create.isValid() &&
        !returned_value_from_create.isNull()) {
      bool ok;
      rows_affected_or_id = returned_value_from_create.toLongLong(&ok);
      if (!ok)
        rows_affected_or_id = -1; // Conversion failed
    }

    // Interpret result for Save's return (usually 1 if successful, 0 if "do
    // nothing" on conflict)
    if (final_conflict_options &&
        final_conflict_options->action == OnConflictClause::Action::DoNothing) {
      return (rows_affected_or_id == 0 && model_instance._is_persisted)
                 ? 0LL
                 : (model_instance._is_persisted
                        ? 1LL
                        : 0LL); // If DO NOTHING and it existed, _is_persisted
                                // should be true, ret 0. If new, ret 1.
    }
    return model_instance._is_persisted ? 1LL
                                        : 0LL; // 1 if persisted (new or updated
                                               // via conflict), 0 otherwise
  }
}

std::expected<long long, Error> Session::Save(ModelBase &model_instance) {
  QueryBuilder qb = this->Model(&model_instance);
  return this->SaveImpl(qb, model_instance);
}

} // namespace cpporm// cpporm/session_static_utils.cpp
#include "cpporm/error.h"      // For Error, make_ok
#include "cpporm/model_base.h" // For FieldMeta in getSqlTypeForCppType
#include "cpporm/session.h"    // 主头文件

#include <QDebug>
#include <QMetaType>
#include <QSqlError> // For execute_query_internal
#include <QSqlQuery> // For execute_query_internal
#include <QVariant>
#include <any> // For anyToQueryValueForSessionConvenience, qvariantToAny

namespace cpporm {

// --- Static Helpers implementation ---
std::string Session::getSqlTypeForCppType(const FieldMeta &field_meta,
                                          const QString &driverName_upper) {
  if (!field_meta.db_type_hint.empty()) {
    return field_meta.db_type_hint;
  }
  const std::type_index &cpp_type = field_meta.cpp_type;

  if (cpp_type == typeid(int))
    return "INT";
  if (cpp_type == typeid(unsigned int)) {
    if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE")
      return "INTEGER";
    return "INT UNSIGNED";
  }
  if (cpp_type == typeid(long long))
    return "BIGINT";
  if (cpp_type == typeid(unsigned long long)) {
    if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE")
      return "BIGINT";
    return "BIGINT UNSIGNED";
  }
  if (cpp_type == typeid(float))
    return "FLOAT";
  if (cpp_type == typeid(double))
    return "DOUBLE PRECISION";
  if (cpp_type == typeid(bool)) {
    if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE")
      return "BOOLEAN";
    if (driverName_upper == "QMYSQL" || driverName_upper == "QMARIADB")
      return "TINYINT(1)";
    return "BOOLEAN";
  }
  if (cpp_type == typeid(std::string))
    return "TEXT";
  if (cpp_type == typeid(QDateTime)) {
    if (driverName_upper == "QPSQL")
      return "TIMESTAMP WITH TIME ZONE";
    if (driverName_upper == "QSQLITE")
      return "DATETIME";
    return "DATETIME";
  }
  if (cpp_type == typeid(QDate))
    return "DATE";
  if (cpp_type == typeid(QTime))
    return "TIME";
  if (cpp_type == typeid(QByteArray)) {
    if (driverName_upper == "QPSQL")
      return "BYTEA";
    if (driverName_upper == "QSQLITE")
      return "BLOB";
    return "BLOB";
  }

  qWarning() << "Session::getSqlTypeForCppType: Unknown C++ type "
             << QString::fromLocal8Bit(field_meta.cpp_type.name())
             << " for field '" << QString::fromStdString(field_meta.cpp_name)
             << "'. Defaulting to TEXT. Driver: " << driverName_upper;
  return "TEXT";
}

void Session::qvariantToAny(const QVariant &qv,
                            const std::type_index &target_cpp_type,
                            std::any &out_any, bool &out_conversion_ok) {
  out_conversion_ok = false;
  out_any.reset();

  if (qv.isNull() || !qv.isValid() || qv.userType() == QMetaType::UnknownType) {
    out_conversion_ok = true;
    return;
  }
  if (target_cpp_type == typeid(int)) {
    out_any = qv.toInt(&out_conversion_ok);
  } else if (target_cpp_type == typeid(long long)) {
    out_any = qv.toLongLong(&out_conversion_ok);
  } else if (target_cpp_type == typeid(unsigned int)) {
    out_any = qv.toUInt(&out_conversion_ok);
  } else if (target_cpp_type == typeid(unsigned long long)) {
    out_any = qv.toULongLong(&out_conversion_ok);
  } else if (target_cpp_type == typeid(double)) {
    out_any = qv.toDouble(&out_conversion_ok);
  } else if (target_cpp_type == typeid(float)) {
    out_any = qv.toFloat(&out_conversion_ok);
  } else if (target_cpp_type == typeid(bool)) {
    out_any = qv.toBool();
    out_conversion_ok = true;
  } else if (target_cpp_type == typeid(std::string)) {
    if (qv.canConvert<QString>()) {
      out_any = qv.toString().toStdString();
      out_conversion_ok = true;
    } else if (qv.typeId() == QMetaType::QByteArray) {
      QByteArray ba = qv.toByteArray();
      out_any = std::string(ba.constData(), static_cast<size_t>(ba.size()));
      out_conversion_ok = true;
    } else {
      qWarning() << "Session::qvariantToAny: Cannot convert QVariant type"
                 << qv.typeName() << "to std::string for target type"
                 << QString::fromLocal8Bit(target_cpp_type.name());
    }
  } else if (target_cpp_type == typeid(QDateTime)) {
    if (qv.canConvert<QDateTime>()) {
      out_any = qv.toDateTime();
      out_conversion_ok = qv.toDateTime().isValid();
    }
  } else if (target_cpp_type == typeid(QDate)) {
    if (qv.canConvert<QDate>()) {
      out_any = qv.toDate();
      out_conversion_ok = qv.toDate().isValid();
    }
  } else if (target_cpp_type == typeid(QTime)) {
    if (qv.canConvert<QTime>()) {
      out_any = qv.toTime();
      out_conversion_ok = qv.toTime().isValid();
    }
  } else if (target_cpp_type == typeid(QByteArray)) {
    if (qv.canConvert<QByteArray>()) {
      out_any = qv.toByteArray();
      out_conversion_ok = true;
    }
  } else {
    qWarning() << "Session::qvariantToAny: Unsupported C++ target type for "
                  "QVariant conversion: "
               << QString::fromLocal8Bit(target_cpp_type.name())
               << "from QVariant type" << qv.typeName();
  }
  if (!out_conversion_ok && qv.isValid() && !qv.isNull()) {
    qWarning()
        << "Session::qvariantToAny: Conversion failed for QVariant value ["
        << qv.toString() << "] of type" << qv.typeName() << "to C++ type"
        << QString::fromLocal8Bit(target_cpp_type.name());
  }
}

QueryValue Session::anyToQueryValueForSessionConvenience(const std::any &val) {
  if (!val.has_value())
    return nullptr;
  const auto &type = val.type();
  if (type == typeid(int))
    return std::any_cast<int>(val);
  if (type == typeid(long long))
    return std::any_cast<long long>(val);
  if (type == typeid(double))
    return std::any_cast<double>(val);
  if (type == typeid(std::string))
    return std::any_cast<std::string>(val);
  if (type == typeid(bool))
    return std::any_cast<bool>(val);
  if (type == typeid(QDateTime))
    return std::any_cast<QDateTime>(val);
  if (type == typeid(QDate))
    return std::any_cast<QDate>(val);
  if (type == typeid(QTime))
    return std::any_cast<QTime>(val);
  if (type == typeid(QByteArray))
    return std::any_cast<QByteArray>(val);
  if (type == typeid(const char *))
    return std::string(std::any_cast<const char *>(val));
  if (type == typeid(std::nullptr_t))
    return nullptr;
  if (type == typeid(float))
    return static_cast<double>(std::any_cast<float>(val));
  if (type == typeid(short))
    return static_cast<int>(std::any_cast<short>(val));
  if (type == typeid(char)) {
    return static_cast<int>(std::any_cast<char>(val));
  }
  if (type == typeid(unsigned char))
    return static_cast<int>(std::any_cast<unsigned char>(val));
  if (type == typeid(unsigned short))
    return static_cast<int>(std::any_cast<unsigned short>(val));
  if (type == typeid(unsigned int))
    return static_cast<long long>(std::any_cast<unsigned int>(val));
  if (type == typeid(unsigned long long))
    return static_cast<long long>(std::any_cast<unsigned long long>(val));
  qWarning() << "Session::anyToQueryValueForSessionConvenience: Unhandled "
                "std::any type:"
             << QString::fromLocal8Bit(val.type().name());
  return nullptr;
}

// --- Private Static execute_query_internal (implementation) ---
// 这现在是 Session 类的私有静态成员，它的唯一定义在此处。
std::pair<QSqlQuery, Error>
Session::execute_query_internal(QSqlDatabase db_conn_val_copy,
                                const QString &sql,
                                const QVariantList &bound_params) {
  if (!db_conn_val_copy.isOpen()) {
    if (!db_conn_val_copy.open()) {
      QSqlError err = db_conn_val_copy.lastError();
      return {QSqlQuery(db_conn_val_copy),
              Error(ErrorCode::ConnectionNotOpen,
                    "execute_query_internal: Failed to open database for query "
                    "execution on connection '" +
                        db_conn_val_copy.connectionName().toStdString() +
                        "': " + err.text().toStdString(),
                    err.nativeErrorCode().toInt())};
    }
  }
  QSqlQuery query(db_conn_val_copy);
  query.prepare(sql);
  QSqlError prepareError = query.lastError();
  if (prepareError.type() != QSqlError::NoError &&
      prepareError.type() != QSqlError::UnknownError) {
    if (!query.isValid() || (prepareError.type() > QSqlError::NoError &&
                             prepareError.type() < QSqlError::StatementError)) {
      return {query, Error(ErrorCode::StatementPreparationError,
                           "Failed to prepare SQL query: " +
                               prepareError.text().toStdString() +
                               " SQL: " + sql.toStdString(),
                           prepareError.nativeErrorCode().toInt())};
    }
  }
  for (const QVariant &param : bound_params) {
    query.addBindValue(param);
  }
  if (!query.exec()) {
    QSqlError err = query.lastError();
    QStringList params_str_list;
    for (const auto &v : bound_params)
      params_str_list << v.toString();
    return {query,
            Error(ErrorCode::QueryExecutionError,
                  "SQL query execution failed: " + err.text().toStdString() +
                      " (Driver: " + err.driverText().toStdString() +
                      ", DB: " + err.databaseText().toStdString() + ")" +
                      "\nSQL: " + sql.toStdString() +
                      "\nParams: " + params_str_list.join(", ").toStdString(),
                  err.nativeErrorCode().toInt(),
                  err.isValid() && !err.nativeErrorCode().isEmpty()
                      ? err.nativeErrorCode().toStdString()
                      : "")};
  }
  return {query, make_ok()};
}

} // namespace cpporm// cpporm/session_transaction.cpp
#include "cpporm/qt_db_manager.h"
#include "cpporm/session.h"

#include <QDebug>
#include <QSqlDatabase>
#include <QSqlDriver>
#include <QSqlError>

namespace cpporm {

std::expected<std::unique_ptr<Session>, Error> Session::Begin() {
  if (is_explicit_transaction_handle_) {
    // GORM Go allows nested transactions using SAVEPOINT. QtSqlDatabase doesn't
    // directly expose SAVEPOINT. For simplicity, we disallow nested Begin() on
    // the same Session object conceptually. A new Session object representing a
    // savepoint would be a more advanced feature.
    qWarning() << "cpporm Session::Begin: Attempting to Begin() on an already "
                  "transactional Session. "
                  "This usually implies a logical error or need for savepoints "
                  "(not directly supported).";
    return std::unexpected(
        Error(ErrorCode::TransactionError,
              "Session is already explicitly transactional. Nested Begin() is "
              "not supported in this manner."));
  }

  // Ensure the current db_handle_ is valid and open.
  if (!db_handle_.isValid()) {
    return std::unexpected(Error(
        ErrorCode::ConnectionInvalid,
        "Cannot begin transaction: Session's QSqlDatabase handle is invalid."));
  }
  if (!db_handle_.isOpen()) {
    qInfo() << "Session::Begin: Database handle was not open. Attempting to "
               "open...";
    if (!db_handle_.open()) {
      QSqlError open_err = db_handle_.lastError();
      return std::unexpected(Error(ErrorCode::ConnectionNotOpen,
                                   "Failed to open database for transaction: " +
                                       open_err.text().toStdString(),
                                   open_err.nativeErrorCode().toInt()));
    }
  }

  if (!db_handle_.driver()) {
    return std::unexpected(
        Error(ErrorCode::InternalError,
              "Cannot begin transaction: QSqlDatabase driver is null."));
  }

  if (!db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
    return std::unexpected(Error(ErrorCode::UnsupportedFeature,
                                 "Database driver for connection '" +
                                     connection_name_.toStdString() +
                                     "' does not support transactions."));
  }

  // Attempt to start the transaction on the current connection.
  if (db_handle_.transaction()) {
    // Create a new Session instance that "owns" this transaction.
    // It uses the same underlying connection (via a copy of db_handle_), but is
    // marked as transactional. The Session(QSqlDatabase) constructor sets
    // is_explicit_transaction_handle_ = true.
    return std::make_unique<Session>(db_handle_);
  } else {
    QSqlError q_error = db_handle_.lastError();
    return std::unexpected(
        Error(ErrorCode::TransactionError,
              "Failed to begin transaction on connection '" +
                  connection_name_.toStdString() +
                  "': " + q_error.text().toStdString() +
                  " (Driver Error: " + q_error.driverText().toStdString() +
                  ", DB Error: " + q_error.databaseText().toStdString() + ")",
              q_error.nativeErrorCode().toInt()));
  }
}

Error Session::Commit() {
  if (!is_explicit_transaction_handle_) {
    return Error(
        ErrorCode::TransactionError,
        "Commit called on a non-transactional Session. Call Begin() first.");
  }
  if (!db_handle_.isValid()) {               // Check if handle became invalid
    is_explicit_transaction_handle_ = false; // Reset state as it's broken
    return Error(ErrorCode::ConnectionInvalid,
                 "Cannot commit: QSqlDatabase handle is invalid.");
  }
  if (!db_handle_.isOpen()) {                // Check if connection dropped
    is_explicit_transaction_handle_ = false; // Reset state
    return Error(ErrorCode::ConnectionNotOpen,
                 "Cannot commit: Database connection is not open.");
  }
  if (!db_handle_.driver() ||
      !db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
    is_explicit_transaction_handle_ = false;
    return Error(ErrorCode::UnsupportedFeature,
                 "Cannot commit: Driver does not support transactions or "
                 "driver is null.");
  }

  if (db_handle_.commit()) {
    is_explicit_transaction_handle_ = false; // Transaction successfully ended
    return make_ok();
  } else {
    QSqlError q_error = db_handle_.lastError();
    // After a failed commit, the transaction is typically still active (per SQL
    // standard). User should ideally Rollback. We don't automatically set
    // is_explicit_transaction_handle_ = false here.
    return Error(
        ErrorCode::TransactionError,
        "Failed to commit transaction: " + q_error.text().toStdString() +
            " (Driver: " + q_error.driverText().toStdString() +
            ", DB: " + q_error.databaseText().toStdString() + ")",
        q_error.nativeErrorCode().toInt());
  }
}

Error Session::Rollback() {
  if (!is_explicit_transaction_handle_) {
    return Error(
        ErrorCode::TransactionError,
        "Rollback called on a non-transactional Session. Call Begin() first.");
  }
  if (!db_handle_.isValid()) {
    is_explicit_transaction_handle_ = false;
    return Error(ErrorCode::ConnectionInvalid,
                 "Cannot rollback: QSqlDatabase handle is invalid.");
  }
  if (!db_handle_.isOpen()) {
    is_explicit_transaction_handle_ = false;
    return Error(ErrorCode::ConnectionNotOpen,
                 "Cannot rollback: Database connection is not open.");
  }
  if (!db_handle_.driver() ||
      !db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
    is_explicit_transaction_handle_ = false;
    return Error(ErrorCode::UnsupportedFeature,
                 "Cannot rollback: Driver does not support transactions or "
                 "driver is null.");
  }

  if (db_handle_.rollback()) {
    is_explicit_transaction_handle_ = false; // Transaction successfully ended
    return make_ok();
  } else {
    QSqlError q_error = db_handle_.lastError();
    // Even if rollback fails, the transactional state is effectively over or
    // undefined.
    is_explicit_transaction_handle_ = false;
    return Error(
        ErrorCode::TransactionError,
        "Failed to rollback transaction: " + q_error.text().toStdString() +
            " (Driver: " + q_error.driverText().toStdString() +
            ", DB: " + q_error.databaseText().toStdString() + ")",
        q_error.nativeErrorCode().toInt());
  }
}

bool Session::IsTransaction() const {
  // is_explicit_transaction_handle_ is the primary indicator managed by this
  // Session class. Additionally, ensure the handle itself is still in a state
  // that could support a transaction.
  if (is_explicit_transaction_handle_) {
    if (db_handle_.isValid() && db_handle_.isOpen() && db_handle_.driver() &&
        db_handle_.driver()->hasFeature(QSqlDriver::Transactions)) {
      // Qt doesn't have a direct QSqlDatabase::isTransactionActive() method.
      // So, our flag is the best source of truth from the ORM's perspective
      // once Begin() has been successfully called on this Session object's
      // representative.
      return true;
    } else {
      // If our flag is true, but DB state is bad, it's an inconsistent state.
      // Logically, the Session *thinks* it's in a transaction.
      qWarning(
          "Session::IsTransaction: Session is marked as transactional, but DB "
          "handle is invalid, closed, or driver lost. Inconsistent state.");
      return true; // Or false, depending on how strictly to interpret. True
                   // means "was supposed to be".
    }
  }
  return false;
}

} // namespace cpporm// cpporm/session_update_ops.cpp
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"

#include <QDateTime>
#include <QDebug>
#include <QSqlQuery>
#include <QVariant>

namespace cpporm {

// Session 的 IQueryExecutor::UpdatesImpl 实现
std::expected<long long, Error>
Session::UpdatesImpl(const QueryBuilder &qb_const, // Renamed to avoid conflict
                     const std::map<std::string, QueryValue> &updates_map_in) {

  QueryBuilder qb =
      qb_const; // Work with a copy to modify (e.g., add timestamps)

  if (updates_map_in.empty()) {
    qInfo("cpporm Session::UpdatesImpl: No update values provided.");
    return 0LL;
  }

  std::map<std::string, QueryValue> final_updates = updates_map_in;
  const ModelMeta *meta = qb.getModelMeta();

  // Automatically add 'updated_at' if the model has it
  if (meta) {
    // Check if the FROM source is actually the model's table before blindly
    // adding timestamps
    bool update_model_table_directly = false;
    if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
      const std::string &from_name =
          std::get<std::string>(qb.getFromClauseSource());
      if (!from_name.empty() && from_name == meta->table_name) {
        update_model_table_directly = true;
      } else if (from_name.empty() &&
                 !meta->table_name.empty()) { // Defaulted to model table
        update_model_table_directly = true;
      }
    }

    if (update_model_table_directly) {
      if (const FieldMeta *updatedAtField =
              meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
        if (updatedAtField->cpp_type == typeid(QDateTime)) {
          // Add or overwrite updated_at in the final_updates map
          final_updates[updatedAtField->db_name] =
              QDateTime::currentDateTimeUtc();
        }
      }
    }
  }

  auto [sql, params] = qb.buildUpdateSQL(final_updates); // qb is already a copy
  if (sql.isEmpty()) {
    return std::unexpected(
        Error(ErrorCode::StatementPreparationError,
              "Failed to build SQL for Updates operation. Target might be "
              "invalid (e.g., a subquery) or table name missing."));
  }

  auto [query_obj, exec_err] =
      execute_query_internal(this->db_handle_, sql, params);
  if (exec_err) {
    return std::unexpected(exec_err);
  }

  return query_obj.numRowsAffected();
}

// Session 便捷方法 Updates(QueryBuilder, map)
std::expected<long long, Error>
Session::Updates(QueryBuilder qb, // Pass QB by value to allow modification if
                                  // needed by QB's own Updates
                 const std::map<std::string, QueryValue> &updates) {
  if (qb.getExecutor() == nullptr) {
    // This typically means QueryBuilder was not created via a Session.
    // We need to ensure it uses *this* session's executor.
    // However, QueryBuilder::Updates itself calls its stored executor.
    // This design is a bit tricky. For now, assume the user intends for
    // the QB to be executed by *this* session if they call Session::Updates.
    // A safer design might involve QueryBuilder not storing an executor,
    // and Session always providing it.
    // For this specific call path, since it's Session::Updates, we will use
    // *this* session's Impl.
    QueryBuilder qb_with_this_session_executor = qb; // Make a copy
    // qb_with_this_session_executor.executor_ = this; // This is private, can't
    // do.
    //  The `qb.Updates()` call will use its own executor.
    //  The correct way for Session::Updates(QB, map) is to call *this*
    //  session's Impl. We use the passed qb's state but execute with *this*
    //  session.

    // If the QB was created by a *different* session, this is problematic.
    // If it was created by *this* session, qb.getExecutor() == this, so
    // qb.Updates() is fine. If it was default-constructed (executor=nullptr),
    // then qb.Updates() will fail.

    // Simplest approach: if qb's executor is not this, warn and proceed using
    // qb's executor (via its own .Updates()) OR, reconstruct a QB for this
    // session using the state of the passed QB. (Complex) OR, the
    // Session::Updates(QB,map) should not exist, and users should always call
    // qb.Updates() directly.

    // Let's assume if Session::Updates(QB, map) is called, the QB should be
    // executed by *this* session. The most straightforward is to call the Impl
    // method of *this* session, passing the qb. QueryBuilder::Updates is just a
    // public wrapper around executor_->UpdatesImpl(*this, updates) So, calling
    // this->UpdatesImpl(qb, updates) makes sense.
    if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
      qWarning(
          "Session::Updates(QueryBuilder, ...): QueryBuilder was associated "
          "with a different executor. The operation will use THIS session's "
          "context, "
          "but the QueryBuilder's state. Ensure this is intended.");
    }
    return this->UpdatesImpl(qb, updates);
  }
  // If qb.getExecutor() == this, then qb.Updates() is fine.
  return qb.Updates(updates);
}

// Session 便捷方法 Updates(const ModelMeta&, updates_map, conditions_map)
std::expected<long long, Error> Session::Updates(
    const ModelMeta &meta,
    const std::map<std::string, QueryValue> &updates_map, // Renamed
    const std::map<std::string, QueryValue> &conditions) {
  if (updates_map.empty()) {
    qInfo("cpporm Session::Updates (by meta): No update values provided.");
    return 0LL;
  }
  QueryBuilder qb = this->Model(meta);
  if (!conditions.empty()) {
    qb.Where(conditions);
  } else {
    // This warning is good, but buildUpdateSQL also has a similar one if no
    // WHERE clause is produced. qWarning("cpporm Session::Updates (by meta):
    // Attempting to update table "
    //          "'%s' without WHERE conditions. This will update ALL rows.",
    //          meta.table_name.c_str());
  }
  // Call the Impl method, not qb.Updates() to ensure correct executor and
  // timestamp logic
  return this->UpdatesImpl(qb, updates_map);
}

// Session 便捷方法 Updates(const ModelBase& model_condition, updates_map)
std::expected<long long, Error> Session::Updates(
    const ModelBase &model_condition,
    const std::map<std::string, QueryValue> &updates_map) { // Renamed
  if (updates_map.empty()) {
    qInfo("cpporm Session::Updates (by model): No update values provided.");
    return 0LL;
  }
  const ModelMeta &meta = model_condition._getOwnModelMeta();
  QueryBuilder qb = this->Model(meta);

  if (meta.primary_keys_db_names.empty()) {
    return std::unexpected(
        Error(ErrorCode::MappingError,
              "Updates by model instance: No primary key defined for model " +
                  meta.table_name));
  }

  std::map<std::string, QueryValue> pk_conditions;
  for (const auto &pk_db_name : meta.primary_keys_db_names) {
    const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
    if (!pk_field) {
      return std::unexpected(
          Error(ErrorCode::InternalError,
                "Updates by model instance: PK field meta not found for " +
                    pk_db_name));
    }
    std::any pk_val_any = model_condition.getFieldValue(pk_field->cpp_name);
    if (!pk_val_any.has_value()) {
      return std::unexpected(Error(ErrorCode::MappingError,
                                   "Updates by model instance: PK value for " +
                                       pk_db_name +
                                       " is not set in the model."));
    }
    // Use the Session's helper for std::any to QueryValue conversion
    QueryValue qv_pk =
        Session::anyToQueryValueForSessionConvenience(pk_val_any);
    if (std::holds_alternative<std::nullptr_t>(qv_pk) &&
        pk_val_any.has_value()) { // If conversion failed for a non-empty any
      return std::unexpected(
          Error(ErrorCode::MappingError,
                "Updates by model_condition: Unsupported PK type (" +
                    std::string(pk_val_any.type().name()) + ") for field " +
                    pk_db_name));
    }
    pk_conditions[pk_db_name] = qv_pk;
  }

  if (pk_conditions
          .empty()) { // Should be caught by !pk_val_any.has_value() above
    return std::unexpected(Error(
        ErrorCode::MappingError,
        "Updates by model instance: Failed to extract valid PK conditions."));
  }
  qb.Where(pk_conditions);
  // Call the Impl method
  return this->UpdatesImpl(qb, updates_map);
}

} // namespace cpporm// cpporm_sqldriver/sql_database.h
#pragma once
#include <map>
#include <string>

#include "sql_driver.h"  // 可选，用于特性
#include "sql_error.h"

namespace cpporm_sqldriver {

    // 前向声明，实际的驱动特性接口
    // class ISqlDriver;

    class SqlDatabase {
      public:
        // SqlDatabase(); // 默认构造通常无效，需要通过 SqlDriverManager 获取
        ~SqlDatabase();

        // 连接管理 (模仿 QSqlDatabase 实例方法)
        bool open();
        bool open(const std::string& user, const std::string& password);
        void close();
        bool isOpen() const;
        bool isValid() const;  // 检查驱动是否有效加载

        // 事务控制
        bool transaction();  // 开始事务
        bool commit();
        bool rollback();

        // 驱动和连接信息
        std::string driverName() const;    // e.g., "MYSQL", "SQLITE"
        std::string databaseName() const;  // 连接的数据库名
        std::string userName() const;
        std::string password() const;
        std::string hostName() const;
        int port() const;
        std::string connectOptions() const;

        void setDatabaseName(const std::string& name);
        void setUserName(const std::string& name);
        void setPassword(const std::string& password);
        void setHostName(const std::string& host);
        void setPort(int port);
        void setConnectOptions(const std::string& options);

        SqlError lastError() const;

        // ISqlDriver* driver() const; // 可选，返回驱动特性接口

        // 内部使用，由 SqlDriverManager 设置
        SqlDatabase(const std::string& driverType, const std::string& connectionName);

      private:
        friend class SqlDriverManager;  // 允许管理器访问构造和内部
        friend class SqlQuery;          // 允许查询访问连接句柄

        // 实现将依赖 Transport 和 Protocol
        // 需要成员变量来存储:
        // - 驱动类型 (e.g., "MYSQL")
        // - 连接名
        // - 连接参数
        // - 底层连接句柄 (来自 Transport 层)
        // - 事务状态
        // - 错误状态
        // - 指向具体驱动实现的指针 (ISqlDriver* 或更具体的)
        class Private;  // PImpl
        Private* d;

        // 防止拷贝
        SqlDatabase(const SqlDatabase&) = delete;
        SqlDatabase& operator=(const SqlDatabase&) = delete;
        // 允许移动
        SqlDatabase(SqlDatabase&&) noexcept;
        SqlDatabase& operator=(SqlDatabase&&) noexcept;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_driver.h
#pragma once
#include <string>

namespace cpporm_sqldriver {

    // 这个枚举模仿 QSqlDriver::Feature，但可以根据您的需求调整
    enum class Feature {
        Transactions,                // 是否支持事务
        QuerySize,                   // query.size() 是否有效
        BLOB,                        // 是否支持 BLOB
        Unicode,                     // 是否支持 Unicode
        PreparedQueries,             // 是否支持预处理语句
        NamedPlaceholders,           // 是否支持命名占位符 (e.g., :name)
        PositionalPlaceholders,      // 是否支持位置占位符 (e.g., ?)
        LastInsertId,                // lastInsertId() 是否有效
        BatchOperations,             // 是否支持批量操作 (通过 addBindValue + execBatch)
        SimpleScrollOnError,         //
        EventNotifications,          // (可能不需要)
        FinishQuery,                 // (可能不需要)
        MultipleResultSets,          // 一次执行返回多个结果集
        Named जयपुरियाholders LietKe  // (这是一个示例，表明可以有自定义特性)
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_driver_manager.h
#pragma once
#include <memory>  // for unique_ptr
#include <string>
#include <vector>

#include "sql_database.h"  // 需要 SqlDatabase

namespace cpporm_sqldriver {

    class SqlDriverManager {
      public:
        // 连接管理 (模仿 QSqlDatabase 静态方法)
        static SqlDatabase addDatabase(const std::string& driverType, const std::string& connectionName = defaultConnectionName());

        static SqlDatabase database(const std::string& connectionName = defaultConnectionName(),
                                    bool open = true);  // open 参数 Qt 中没有，但可以考虑

        static void removeDatabase(const std::string& connectionName);
        static bool contains(const std::string& connectionName = defaultConnectionName());
        static std::vector<std::string> drivers();  // 列出可用的驱动类型 ("MYSQL", "SQLITE"...)

        static std::string defaultConnectionName();  // "qt_sql_default_connection"

        // 注册驱动的接口 (由具体驱动实现在初始化时调用)
        // typedef std::function<std::unique_ptr<ISqlDriverImplInterface>()> DriverFactory;
        // static void registerDriver(const std::string& driverName, DriverFactory factory);

      private:
        SqlDriverManager() = delete;  // 静态类

        // 内部管理连接池或连接列表
        // static std::map<std::string, SqlDatabase> connections_;
        // static std::map<std::string, DriverFactory> registered_drivers_;
        // static std::mutex mutex_;
        class Private;
        static Private* d();  // 获取静态 PImpl 实例
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_error.h
#pragma once
#include <string>

namespace cpporm_sqldriver {

    enum class ErrorType { NoError = 0, ConnectionError, StatementError, TransactionError, UnknownError };

    class SqlError {
      public:
        SqlError();  // NoError
        SqlError(ErrorType type, const std::string& databaseText, const std::string& driverText = "", const std::string& nativeErrorCode = "");

        ErrorType type() const;
        std::string databaseText() const;     // 对应 QSqlError::databaseText()
        std::string driverText() const;       // 对应 QSqlError::driverText()
        std::string text() const;             // 综合性错误信息
        std::string nativeErrorCode() const;  // 对应 QSqlError::nativeErrorCode()
        bool isValid() const;                 // type() != NoError

      private:
        ErrorType type_;
        std::string database_text_;
        std::string driver_text_;
        std::string native_error_code_;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_field.h
#pragma once
#include <string>

#include "sql_value.h"  // 需要 SqlValue 来表示默认值和当前值

namespace cpporm_sqldriver {

    class SqlField {
      public:
        SqlField(const std::string& name = "", SqlValueType type = SqlValueType::Null);  // type 可以是更通用的 SqlValueType

        std::string name() const;
        SqlValue value() const;         // 当前字段的值 (在 SqlRecord 中更有用)
        SqlValue defaultValue() const;  // 字段的默认值 (元数据)
        SqlValueType type() const;      // 字段的 (通用) 数据类型
        // int typeID() const; // 如果需要更底层的类型 ID

        bool isNull() const;
        bool isAutoValue() const;  // 是否自增 (元数据)
        bool isReadOnly() const;   // 是否只读 (元数据)
        bool isRequired() const;   // 是否NOT NULL (元数据)

        int length() const;     // 字段长度 (元数据)
        int precision() const;  // 字段精度 (元数据)

        // 内部设置方法 (由驱动填充)
        void setName(const std::string& name);
        voidsetValue(const SqlValue& value);  // 用于填充 SqlRecord 中的字段值
        void setDefaultValue(const SqlValue& defaultValue);
        void setType(SqlValueType type);
        // ... 其他 setters

      private:
        std::string name_;
        SqlValue current_value_;  // 这个字段在 SqlRecord 中更有意义，单独的 SqlField 通常代表元数据
        SqlValue default_value_meta_;
        SqlValueType type_meta_;
        // ... 其他元数据成员
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_query.h
#pragma once
#include <map>  // 用于命名参数绑定
#include <string>
#include <vector>

#include "sql_error.h"
#include "sql_record.h"
#include "sql_value.h"

namespace cpporm_sqldriver {

    class SqlDatabase;  // 前向声明

    enum class ParamType {
        In,
        Out,   // 用于存储过程 (可选)
        InOut  // 用于存储过程 (可选)
    };

    class SqlQuery {
      public:
        explicit SqlQuery(SqlDatabase* db = nullptr);  // 传入关联的 SqlDatabase
        explicit SqlQuery(const std::string& query, SqlDatabase* db = nullptr);
        ~SqlQuery();

        // 准备和执行 (模仿 QSqlQuery)
        bool prepare(const std::string& query);
        bool exec();                          // 执行已准备的语句
        bool exec(const std::string& query);  // 准备并执行

        // 参数绑定
        void bindValue(int pos, const SqlValue& val, ParamType type = ParamType::In);
        void bindValue(const std::string& placeholderName, const SqlValue& val, ParamType type = ParamType::In);
        void addBindValue(const SqlValue& val, ParamType type = ParamType::In);  // 用于位置绑定

        SqlValue boundValue(int pos) const;
        SqlValue boundValue(const std::string& placeholderName) const;
        std::map<std::string, SqlValue> boundValues() const;  // 获取所有绑定的命名参数
        std::vector<SqlValue> positionalBoundValues() const;  // 获取所有绑定的位置参数

        // 结果集导航和数据获取
        bool next();  // 移动到下一条记录
        bool first();
        bool last();
        bool previous();
        bool seek(int index, bool relative = false);  // 定位到特定行

        SqlRecord record() const;         // 获取当前行的记录对象
        SqlValue value(int index) const;  // 直接获取当前行指定列的值
        SqlValue value(const std::string& name) const;

        int at() const;    // 当前行号 (0-based)
        int size() const;  // 结果集中的行数 (如果驱动支持且有效)

        // 状态和错误
        bool isActive() const;
        bool isValid() const;  // 通常指 next() 是否有效
        SqlError lastError() const;
        std::string lastQuery() const;

        long long numRowsAffected() const;  // DML 操作影响的行数
        SqlValue lastInsertId() const;      // 获取最后插入的自增ID (如果支持)

        void finish();  // 可选，提前释放资源，类似 QSqlQuery::finish()

        SqlDatabase* database() const;  // 获取关联的 SqlDatabase

        // 批量执行 (如果支持)
        // bool execBatch(BatchExecutionMode mode = ValuesAsRows); // 名字待定

      private:
        // 实现将依赖 Transport 和 Protocol
        // 需要成员变量来存储:
        // - 指向关联的 SqlDatabase 的指针 (或引用)
        // - SQL 语句字符串
        // - 绑定的参数 (位置参数列表，命名参数映射)
        // - 当前结果集 (可能是 Transport 返回的某种句柄或缓存的数据)
        // - 当前记录 SqlRecord
        // - 当前行号
        // - 错误状态
        // - ...

        class Private;  // PImpl
        Private* d;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_record.h
#pragma once
#include <string>
#include <vector>

#include "sql_field.h"  // 可选
#include "sql_value.h"

namespace cpporm_sqldriver {

    class SqlRecord {
      public:
        SqlRecord();

        int count() const;
        std::string fieldName(int index) const;  // 获取列名

        SqlValue value(int index) const;                // 按索引获取值
        SqlValue value(const std::string& name) const;  // 按名称获取值

        bool isNull(int index) const;
        bool isNull(const std::string& name) const;

        int indexOf(const std::string& name) const;  // 获取名称对应的索引

        // SqlField field(int index) const; // 可选: 按索引获取字段元数据和值
        // SqlField field(const std::string& name) const; // 可选: 按名称获取

        void clear();

        // 内部使用:
        // 由 SqlQuery 在获取一行数据时填充
        void addValue(const std::string& name, const SqlValue& value /*, SqlValueType type_hint (可选) */);
        // 或者更底层的
        // void setValues(const std::vector<SqlValue>& values);
        // void setFieldNames(const std::vector<std::string>& names); // 确保与 values 对应

      private:
        std::vector<std::string> field_names_;  // 顺序存储列名
        std::vector<SqlValue> values_;          // 顺序存储列值
        // 或者: std::vector<SqlField> fields_; // 如果 SqlField 同时存储元数据和当前值
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_value.h
#pragma once
#include <chrono>  // 用于时间类型
#include <optional>
#include <string>
#include <variant>
#include <vector>

// 如果仍然想用 Qt 的时间类型，可以包含它们，但不依赖 QtSql
#include <QByteArray>
#include <QDate>
#include <QDateTime>  // 假设允许依赖 Qt Core
#include <QTime>

namespace cpporm_sqldriver {

    enum class SqlValueType {
        Null,
        Bool,
        Int,
        LongLong,
        Double,
        String,
        ByteArray,
        Date,      // 可以是 std::chrono::year_month_day 或 QDate
        Time,      // 可以是 std::chrono::hh_mm_ss 或 QTime
        DateTime,  // 可以是 std::chrono::system_clock::time_point 或 QDateTime
        // ... 其他可能的原生类型
    };

    class SqlValue {
      public:
        using NativeTimePoint = std::chrono::system_clock::time_point;  // 示例
        using NativeDate = std::chrono::year_month_day;                 // 示例

        // 构造函数
        SqlValue();  // Null
        SqlValue(bool val);
        SqlValue(int val);
        SqlValue(long long val);
        SqlValue(double val);
        SqlValue(const char* val);
        SqlValue(const std::string& val);
        SqlValue(const QByteArray& val);  // 如果允许 Qt Core
        SqlValue(const QDate& val);       // 如果允许 Qt Core
        SqlValue(const QTime& val);       // 如果允许 Qt Core
        SqlValue(const QDateTime& val);   // 如果允许 Qt Core
        // SqlValue(const NativeDate& val);
        // SqlValue(const NativeTimePoint& val);

        // 类型检查和转换 (模仿 QVariant)
        bool isNull() const;
        bool isValid() const;       // 通常 SqlValue 总是 valid，除非特殊状态
        SqlValueType type() const;  // 或者 int typeId() const;

        bool toBool(bool* ok = nullptr) const;
        int toInt(bool* ok = nullptr) const;
        long long toLongLong(bool* ok = nullptr) const;
        double toDouble(bool* ok = nullptr) const;
        std::string toString(bool* ok = nullptr) const;  // 或者 QString
        QByteArray toByteArray(bool* ok = nullptr) const;
        QDate toDate(bool* ok = nullptr) const;
        QTime toTime(bool* ok = nullptr) const;
        QDateTime toDateTime(bool* ok = nullptr) const;
        // NativeDate toNativeDate(bool* ok = nullptr) const;
        // NativeTimePoint toNativeTimePoint(bool* ok =nullptr) const;

        // 静态工厂方法 (可选)
        static SqlValue fromString(const std::string& s);
        // ...

      private:
        // 使用 std::variant 作为底层存储示例
        std::variant<std::monostate,  // 代表 Null
                     bool,
                     int,
                     long long,
                     double,
                     std::string,
                     QByteArray,  // 如果允许
                     QDate,       // 如果允许
                     QTime,       // 如果允许
                     QDateTime    // 如果允许
                     // NativeDate,
                     // NativeTimePoint
                     >
            value_;

        // 或者使用 std::any，但类型转换会更麻烦
        // std::any value_;
        // SqlValueType current_type_;
    };

}  // namespace cpporm_sqldriver