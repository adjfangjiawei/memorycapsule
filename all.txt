This file contains the full license text of the included third party
libraries. For an overview of the licenses see the NOTICE.txt file.


------------------------------------------------------------------------------
Apache Software License, Version 2.0
  Neo4j Bolt Connection (Bolt Provider reference impl)
  Neo4j Bolt Connection (Pooled Source impl)
  Neo4j Bolt Connection (Provider SPI)
  Neo4j Bolt Connection (Routed Source impl)
  Netty/Buffer
  Netty/Codec/Base
  Netty/Common
  Netty/Handler
  Netty/Resolver
  Netty/TomcatNative [OpenSSL - Classes]
  Netty/Transport
  Netty/Transport/Native/Unix/Common
  Non-Blocking Reactive Foundation for the JVM
------------------------------------------------------------------------------

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



------------------------------------------------------------------------------
MIT No Attribution License
  reactive-streams
------------------------------------------------------------------------------

MIT No Attribution

Copyright <year> <copyright holders>

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.




Copyright (c) "Neo4j"
Neo4j Sweden AB [https://neo4j.com]

This file is part of Neo4j.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Full license texts are found in LICENSES.txt.


Third-party licenses
--------------------

Apache Software License, Version 2.0
  Neo4j Bolt Connection (Bolt Provider reference impl)
  Neo4j Bolt Connection (Pooled Source impl)
  Neo4j Bolt Connection (Provider SPI)
  Neo4j Bolt Connection (Routed Source impl)
  Netty/Buffer
  Netty/Codec/Base
  Netty/Common
  Netty/Handler
  Netty/Resolver
  Netty/TomcatNative [OpenSSL - Classes]
  Netty/Transport
  Netty/Transport/Native/Unix/Common
  Non-Blocking Reactive Foundation for the JVM

MIT No Attribution License
  reactive-streams

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.neo4j.driver</groupId>
    <artifactId>neo4j-java-driver-parent</artifactId>
    <version>6.0-SNAPSHOT</version>
  </parent>

  <groupId>org.neo4j.doc.driver</groupId>
  <artifactId>neo4j-java-driver-examples</artifactId>

  <packaging>jar</packaging>
  <name>Neo4j Java Driver Examples</name>
  <description>Examples of using the Neo4j graph database through Java</description>
  <url>https://github.com/neo4j/neo4j-java-driver</url>

  <properties>
    <rootDir>${project.basedir}/..</rootDir>
    <!-- Turned off because it moves/deletes example tags and needs investigation. -->
    <spotless.check.skip>true</spotless.check.skip>
    <spotless.apply.skip>true</spotless.apply.skip>
  </properties>

  <dependencies>
    <!-- Compile dependencies -->
    <dependency>
      <groupId>org.neo4j.driver</groupId>
      <artifactId>neo4j-java-driver</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-core</artifactId>
    </dependency>

    <!-- Test dependencies -->
    <dependency>
      <groupId>org.neo4j.driver</groupId>
      <artifactId>neo4j-java-driver</artifactId>
      <version>${project.version}</version>
      <type>test-jar</type>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.rauschig</groupId>
      <artifactId>jarchivelib</artifactId>
    </dependency>
    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>neo4j</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.bouncycastle</groupId>
      <artifactId>bcpkix-jdk18on</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-javadoc-plugin</artifactId>
        <executions>
          <execution>
            <id>attach-javadocs</id>
            <phase>none</phase>
          </execution>
          <execution>
            <id>aggregate</id>
            <phase>none</phase>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

  <scm>
    <connection>scm:git:git://github.com/neo4j/neo4j-java-driver.git</connection>
    <developerConnection>scm:git:git@github.com:neo4j/neo4j-java-driver.git</developerConnection>
    <url>https://github.com/neo4j/neo4j-java-driver</url>
  </scm>

</project>
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::custom-auth-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import java.util.Map;
// end::custom-auth-import[]

public class CustomAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::custom-auth[]
    public CustomAuthExample(
            String uri,
            String principal,
            String credentials,
            String realm,
            String scheme,
            Map<String, Object> parameters) {
        driver = GraphDatabase.driver(uri, AuthTokens.custom(principal, credentials, realm, scheme, parameters));
    }
    // end::custom-auth[]

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletionStage;

public class AsyncAutocommitTransactionExample extends BaseApplication {
    public AsyncAutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    @SuppressWarnings("CallToPrintStackTrace")
    // tag::async-autocommit-transaction[]
    public CompletionStage<List<String>> readProductTitles() {
        var query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
        var parameters = Map.<String, Object>of("id", 0);

        var session = driver.session(AsyncSession.class);

        return session.runAsync(query, parameters)
                .thenCompose(cursor -> cursor.listAsync(record -> record.get(0).asString()))
                .exceptionally(error -> {
                    // query execution failed, print error and fallback to empty list of titles
                    error.printStackTrace();
                    return Collections.emptyList();
                })
                .thenCompose(titles -> session.closeAsync().thenApply(ignore -> titles));
    }
    // end::async-autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.async.AsyncSession;

import java.util.List;
import java.util.concurrent.CompletionStage;

public class AsyncResultConsumeExample extends BaseApplication {
    public AsyncResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-result-consume[]
    public CompletionStage<List<String>> getPeople() {
        var query = new Query("MATCH (a:Person) RETURN a.name ORDER BY a.name");
        var session = driver.session(AsyncSession.class);
        return session.executeReadAsync(tx -> tx.runAsync(query)
                .thenCompose(cursor -> cursor.listAsync(record -> record.get(0).asString())));
    }
    // end::async-result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.async.AsyncTransactionContext;
import org.neo4j.driver.async.ResultCursor;
import org.neo4j.driver.summary.ResultSummary;
import org.neo4j.driver.summary.SummaryCounters;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static org.neo4j.driver.Values.parameters;

public class AsyncRunMultipleTransactionExample extends BaseApplication {
    public AsyncRunMultipleTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-multiple-tx[]
    public CompletionStage<Integer> addEmployees(final String companyName) {
        var session = driver.session(AsyncSession.class);
        return session.executeReadAsync(AsyncRunMultipleTransactionExample::matchPersonNodes)
                .thenCompose(personNames -> session.executeWriteAsync(tx -> createNodes(tx, companyName, personNames)));
    }

    private static CompletionStage<List<String>> matchPersonNodes(AsyncTransactionContext tx) {
        return tx.runAsync("MATCH (a:Person) RETURN a.name AS name")
                .thenCompose(cursor -> cursor.listAsync(record -> record.get("name").asString()));
    }

    private static CompletionStage<Integer> createNodes(AsyncTransactionContext tx, String companyName, List<String> personNames) {
        return personNames.stream()
                .map(personName -> createNode(tx, companyName, personName))
                .reduce(CompletableFuture.completedFuture(0), (stage1, stage2) -> stage1.thenCombine(stage2, Integer::sum));
    }

    private static CompletionStage<Integer> createNode(AsyncTransactionContext tx, String companyName, String personName) {
        return tx.runAsync("MATCH (emp:Person {name: $person_name}) MERGE (com:Company {name: $company_name}) MERGE (emp)-[:WORKS_FOR]->(com)",
                        parameters("person_name", personName, "company_name", companyName))
                .thenCompose(ResultCursor::consumeAsync)
                .thenApply(ResultSummary::counters)
                .thenApply(SummaryCounters::nodesCreated);
    }
    // end::async-multiple-tx[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.summary.ResultSummary;

import java.util.Collections;
import java.util.Map;
import java.util.concurrent.CompletionStage;

public class AsyncTransactionFunctionExample extends BaseApplication {
    public AsyncTransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-transaction-function[]
    public CompletionStage<ResultSummary> printAllProducts() {
        var query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
        Map<String, Object> parameters = Collections.singletonMap("id", 0);

        var session = driver.session(AsyncSession.class);

        return session.executeReadAsync(tx -> tx.runAsync(query, parameters)
                .thenCompose(cursor -> cursor.forEachAsync(record ->
                        // asynchronously print every record
                        System.out.println(record.get(0).asString()))));
    }
    // end::async-transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class AutocommitTransactionExample extends BaseApplication {
    public AutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::autocommit-transaction[]
    public void addPerson(String name) {
        try (var session = driver.session()) {
            session.run("CREATE (a:Person {name: $name})", parameters("name", name));
        }
    }
    // end::autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public abstract class BaseApplication implements AutoCloseable {
    protected final Driver driver;

    public BaseApplication(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::basic-auth-import[]

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::basic-auth-import[]

public class BasicAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::basic-auth[]
    public BasicAuthExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }
    // end::basic-auth[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import java.util.concurrent.TimeUnit;

public class ConfigConnectionPoolExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-connection-pool[]
    public ConfigConnectionPoolExample(String uri, String user, String password) {
        var config = Config.builder()
                .withMaxConnectionLifetime(30, TimeUnit.MINUTES)
                .withMaxConnectionPoolSize(50)
                .withConnectionAcquisitionTimeout(2, TimeUnit.MINUTES)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-connection-pool[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-connection-timeout-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import static java.util.concurrent.TimeUnit.SECONDS;
// end::config-connection-timeout-import[]

public class ConfigConnectionTimeoutExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-connection-timeout[]
    public ConfigConnectionTimeoutExample(String uri, String user, String password) {
        var config = Config.builder()
                .withConnectionTimeout(15, SECONDS)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-connection-timeout[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthToken;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.net.ServerAddress;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class ConfigCustomResolverExample {
    @SuppressWarnings("unused")
    // tag::config-custom-resolver[]
    public void addExampleNode() {
        var addresses = Set.of(
                ServerAddress.of("a.example.com", 7676),
                ServerAddress.of("b.example.com", 8787),
                ServerAddress.of("c.example.com", 9898)
        );
        addNode("neo4j://x.example.com", AuthTokens.basic("neo4j", "some password"), addresses, UUID.randomUUID().toString());
    }

    public void addNode(String virtualUri, AuthToken authToken, Set<ServerAddress> addresses, String id) {
        var config = Config.builder()
                .withResolver(address -> addresses)
                .build();
        try (var driver = GraphDatabase.driver(virtualUri, authToken, config)) {
            driver.executableQuery("CREATE ({id: $id})")
                    .withParameters(Map.of("id", id))
                    .execute();
        }
    }
    // end::config-custom-resolver[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-max-retry-time-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import static java.util.concurrent.TimeUnit.SECONDS;
// end::config-max-retry-time-import[]

public class ConfigMaxRetryTimeExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-max-retry-time[]
    public ConfigMaxRetryTimeExample(String uri, String user, String password) {
        var config = Config.builder()
                .withMaxTransactionRetryTime(15, SECONDS)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-max-retry-time[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-trust-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::config-trust-import[]

public class ConfigTrustExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-trust[]
    public ConfigTrustExample(String uri, String user, String password) {
        var config = Config.builder()
                .withTrustStrategy(Config.TrustStrategy.trustSystemCertificates())
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-trust[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-unencrypted-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::config-unencrypted-import[]

public class ConfigUnencryptedExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-unencrypted[]
    public ConfigUnencryptedExample(String uri, String user, String password) {
        var config = Config.builder().withoutEncryption().build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-unencrypted[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::database-selection-import[]

import org.neo4j.driver.AccessMode;
import org.neo4j.driver.SessionConfig;
// end::database-selection-import[]

public class DatabaseSelectionExample extends BaseApplication {
    public DatabaseSelectionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    public void useAnotherDatabaseExample() {
        // tag::database-selection[]
        try (var session = driver.session(SessionConfig.forDatabase("examples"))) {
            session.run("CREATE (a:Greeting {message: 'Hello, Example-Database'}) RETURN a").consume();
        }

        var sessionConfig = SessionConfig.builder()
                .withDatabase("examples")
                .withDefaultAccessMode(AccessMode.READ)
                .build();
        try (var session = driver.session(sessionConfig)) {
            var msg = session.run("MATCH (a:Greeting) RETURN a.message as msg")
                    .single()
                    .get("msg")
                    .asString();
            System.out.println(msg);
        }
        // end::database-selection[]
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::driver-lifecycle-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::driver-lifecycle-import[]

// tag::driver-lifecycle[]
public class DriverLifecycleExample implements AutoCloseable {
    private final Driver driver;

    public DriverLifecycleExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
// end::driver-lifecycle[]
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::hello-world-import[]

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.Query;

import static org.neo4j.driver.Values.parameters;
// end::hello-world-import[]

// tag::hello-world[]
public class HelloWorldExample implements AutoCloseable {
    private final Driver driver;

    public HelloWorldExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public void printGreeting(final String message) {
        try (var session = driver.session()) {
            var greeting = session.executeWrite(tx -> {
                var query = new Query("CREATE (a:Greeting) SET a.message = $message RETURN a.message + ', from node ' + id(a)", parameters("message", message));
                var result = tx.run(query);
                return result.single().get(0).asString();
            });
            System.out.println(greeting);
        }
    }

    public static void main(String... args) {
        try (var greeter = new HelloWorldExample("bolt://localhost:7687", "neo4j", "password")) {
            greeter.printGreeting("hello, world");
        }
    }
}
// end::hello-world[]

// tag::hello-world-output[]
// hello, world, from node 1234
// end::hello-world-output[]
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::kerberos-auth-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::kerberos-auth-import[]

@SuppressWarnings("unused")
public class KerberosAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::kerberos-auth[]
    public KerberosAuthExample(String uri, String ticket) {
        driver = GraphDatabase.driver(uri, AuthTokens.kerberos(ticket));
    }
    // end::kerberos-auth[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::pass-bookmarks-import[]

import org.neo4j.driver.AccessMode;
import org.neo4j.driver.Bookmark;
import org.neo4j.driver.TransactionContext;

import java.util.ArrayList;
import java.util.List;

import static org.neo4j.driver.SessionConfig.builder;
import static org.neo4j.driver.Values.parameters;
// end::pass-bookmarks-import[]

public class PassBookmarkExample extends BaseApplication {

    public PassBookmarkExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::pass-bookmarks[]
    // Create a company node
    private void addCompany(TransactionContext tx, String name) {
        tx.run("CREATE (:Company {name: $name})", parameters("name", name));
    }

    // Create a person node
    private void addPerson(TransactionContext tx, String name) {
        tx.run("CREATE (:Person {name: $name})", parameters("name", name));
    }

    // Create an employment relationship to a pre-existing company node.
    // This relies on the person first having been created.
    private void employ(TransactionContext tx, String person, String company) {
        tx.run("MATCH (person:Person {name: $person_name}) MATCH (company:Company {name: $company_name}) CREATE (person)-[:WORKS_FOR]->(company)",
                parameters("person_name", person, "company_name", company));
    }

    // Create a friendship between two people.
    @SuppressWarnings("SameParameterValue")
    private void makeFriends(TransactionContext tx, String person1, String person2) {
        tx.run("MATCH (a:Person {name: $person_1}) MATCH (b:Person {name: $person_2}) MERGE (a)-[:KNOWS]->(b)",
                parameters("person_1", person1, "person_2", person2));
    }

    // Match and display all friendships.
    private void printFriends(TransactionContext tx) {
        var result = tx.run("MATCH (a)-[:KNOWS]->(b) RETURN a.name, b.name");
        while (result.hasNext()) {
            var record = result.next();
            System.out.printf("%s knows %s%n", record.get("a.name").asString(), record.get("b.name").toString());
        }
    }

    public void addEmployAndMakeFriends() {
        // To collect the session bookmarks
        List<Bookmark> savedBookmarks;

        // Create the first person and employment relationship.
        try (var session1 =
                driver.session(builder().withDefaultAccessMode(AccessMode.WRITE).build())) {
            session1.executeWriteWithoutResult(tx -> addCompany(tx, "Wayne Enterprises"));
            session1.executeWriteWithoutResult(tx -> addPerson(tx, "Alice"));
            session1.executeWriteWithoutResult(tx -> employ(tx, "Alice", "Wayne Enterprises"));

            savedBookmarks = new ArrayList<>(session1.lastBookmarks());
        }

        // Create the second person and employment relationship.
        try (var session2 =
                driver.session(builder().withDefaultAccessMode(AccessMode.WRITE).build())) {
            session2.executeWriteWithoutResult(tx -> addCompany(tx, "LexCorp"));
            session2.executeWriteWithoutResult(tx -> addPerson(tx, "Bob"));
            session2.executeWriteWithoutResult(tx -> employ(tx, "Bob", "LexCorp"));

            savedBookmarks.addAll(session2.lastBookmarks());
        }

        // Create a friendship between the two people created above.
        try (var session3 = driver.session(builder()
                .withDefaultAccessMode(AccessMode.WRITE)
                .withBookmarks(savedBookmarks)
                .build())) {
            session3.executeWriteWithoutResult(tx -> makeFriends(tx, "Alice", "Bob"));

            session3.executeWriteWithoutResult(this::printFriends);
        }
    }
    // end::pass-bookmarks[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::read-write-transaction-import[]

import org.neo4j.driver.TransactionContext;

import static org.neo4j.driver.Values.parameters;
// end::read-write-transaction-import[]

public class ReadWriteTransactionExample extends BaseApplication {
    public ReadWriteTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::read-write-transaction[]
    public long addPerson(final String name) {
        try (var session = driver.session()) {
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume());
            return session.executeRead(tx -> matchPersonNode(tx, name));
        }
    }

    private static long matchPersonNode(TransactionContext tx, String name) {
        var result = tx.run("MATCH (a:Person {name: $name}) RETURN id(a)", parameters("name", name));
        return result.single().get(0).asLong();
    }
    // end::read-write-transaction[]

}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import java.util.ArrayList;
import java.util.List;

public class ResultConsumeExample extends BaseApplication {
    public ResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::result-consume[]
    public List<String> getPeople() {
        try (var session = driver.session()) {
            return session.executeRead(tx -> {
                List<String> names = new ArrayList<>();
                var result = tx.run("MATCH (a:Person) RETURN a.name ORDER BY a.name");
                while (result.hasNext()) {
                    names.add(result.next().get(0).asString());
                }
                return names;
            });
        }
    }
    // end::result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class ResultRetainExample extends BaseApplication {
    public ResultRetainExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::result-retain[]
    @SuppressWarnings("UnusedReturnValue")
    public int addEmployees(final String companyName) {
        try (var session = driver.session()) {
            var persons = session.executeRead(tx -> tx.run("MATCH (a:Person) RETURN a.name AS name").list());
            return persons.stream().mapToInt(person -> session.executeWrite(tx -> {
                var result = tx.run(
                        "MATCH (emp:Person {name: $person_name}) " + "MERGE (com:Company {name: $company_name}) "
                                + "MERGE (emp)-[:WORKS_FOR]->(com)",
                        parameters("person_name", person.get("name").asString(), "company_name", companyName));
                result.consume();
                return 1;
            })).sum();
        }
    }
    // end::result-retain[]

}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveSession;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;

public class RxAutocommitTransactionExample extends BaseApplication {
    public RxAutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-autocommit-transaction[]
    public Flux<String> readProductTitles() {
        var query = new Query("MATCH (p:Product) WHERE p.id = $id RETURN p.title", Collections.singletonMap("id", 0));
        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.run(query))
                        .flatMap(result -> flowPublisherToFlux(result.records()))
                        .map(record -> record.get(0).asString()),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveSession;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;
import static reactor.adapter.JdkFlowAdapter.publisherToFlowPublisher;

public class RxResultConsumeExample extends BaseApplication {
    public RxResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-result-consume[]
    public Flux<String> getPeople() {
        var query = new Query("MATCH (a:Person) RETURN a.name ORDER BY a.name");
        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.executeRead(tx -> {
                    var flux = flowPublisherToFlux(tx.run(query))
                            .flatMap(result -> flowPublisherToFlux(result.records()))
                            .map(record -> record.get(0).asString());
                    return publisherToFlowPublisher(flux);
                })),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveResult;
import org.neo4j.driver.reactive.ReactiveSession;
import org.neo4j.driver.summary.ResultSummary;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.concurrent.atomic.AtomicReference;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;
import static reactor.adapter.JdkFlowAdapter.publisherToFlowPublisher;

public class RxTransactionFunctionExample extends BaseApplication {
    public RxTransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-transaction-function[]
    public Flux<ResultSummary> printAllProducts() {
        var query = new Query("MATCH (p:Product) WHERE p.id = $id RETURN p.title", Collections.singletonMap("id", 0));

        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.executeRead(tx -> {
                    var resultRef = new AtomicReference<ReactiveResult>();
                    var flux = flowPublisherToFlux(tx.run(query))
                            .doOnNext(resultRef::set)
                            .flatMap(result -> flowPublisherToFlux(result.records()))
                            .doOnNext(record -> System.out.println(record.get(0).asString()))
                            .then(Mono.defer(() -> Mono.from(flowPublisherToFlux(resultRef.get().consume()))));
                    return publisherToFlowPublisher(flux);
                })),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class TransactionFunctionExample extends BaseApplication {
    public TransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-function[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume());
        }
    }
    // end::transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.TransactionConfig;

import java.util.Map;

import static org.neo4j.driver.Values.parameters;
import static org.neo4j.driver.Values.value;

public class TransactionMetadataConfigExample extends BaseApplication {
    public TransactionMetadataConfigExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-metadata-config[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            var txConfig = TransactionConfig.builder()
                    .withMetadata(Map.of("applicationId", value("123")))
                    .build();
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume(), txConfig);
        }
    }
    // end::transaction-metadata-config[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.TransactionConfig;

import java.time.Duration;

import static org.neo4j.driver.Values.parameters;

public class TransactionTimeoutConfigExample extends BaseApplication {
    public TransactionTimeoutConfigExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-timeout-config[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            var txConfig = TransactionConfig.builder()
                    .withTimeout(Duration.ofSeconds(5))
                    .build();
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)), txConfig);
        }
    }
    // end::transaction-timeout-config[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
import org.neo4j.driver.SessionConfig;
import org.neo4j.driver.Value;
import org.neo4j.driver.Values;
import org.neo4j.driver.internal.util.EnabledOnNeo4jWith;
import org.neo4j.driver.summary.QueryType;
import org.neo4j.driver.testutil.DatabaseExtension;
import org.neo4j.driver.testutil.ParallelizableIT;
import org.neo4j.driver.testutil.StdIOCapture;
import org.neo4j.driver.testutil.TestUtil;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static java.util.Arrays.asList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.neo4j.driver.Values.parameters;
import static org.neo4j.driver.internal.util.Neo4jEdition.ENTERPRISE;
import static org.neo4j.driver.internal.util.Neo4jFeature.BOLT_V4;
import static org.neo4j.driver.testutil.TestUtil.await;
import static org.neo4j.driver.testutil.TestUtil.createDatabase;
import static org.neo4j.driver.testutil.TestUtil.dropDatabase;

@ParallelizableIT
class ExamplesIT {
    static final String USER = "neo4j";

    @RegisterExtension
    static final DatabaseExtension neo4j = new DatabaseExtension();

    private String uri;

    @SuppressWarnings("resource")
    private int readInt(String database, final String query, final Value parameters) {
        SessionConfig sessionConfig;
        if (database == null) {
            sessionConfig = SessionConfig.defaultConfig();
        } else {
            sessionConfig = SessionConfig.forDatabase(database);
        }
        try (var session = neo4j.driver().session(sessionConfig)) {
            return session.executeRead(
                    tx -> tx.run(query, parameters).single().get(0).asInt());
        }
    }

    private int readInt(final String query, final Value parameters) {
        return readInt(null, query, parameters);
    }

    private int readInt(final String query) {
        return readInt(query, parameters());
    }

    @SuppressWarnings("resource")
    private void write(final String query, final Value parameters) {
        try (var session = neo4j.driver().session()) {
            session.executeWriteWithoutResult(tx -> tx.run(query, parameters).consume());
        }
    }

    private void write(String query) {
        write(query, parameters());
    }

    private int personCount(String name) {
        return readInt("MATCH (a:Person {name: $name}) RETURN count(a)", parameters("name", name));
    }

    private int companyCount(String name) {
        return readInt("MATCH (a:Company {name: $name}) RETURN count(a)", parameters("name", name));
    }

    @BeforeEach
    void setUp() {
        uri = neo4j.uri().toString();
        TestUtil.cleanDb(neo4j.driver());
    }

    @Test
    void testShouldRunAutocommitTransactionExample() {
        // Given
        try (var example =
                new AutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    @SuppressWarnings("resource")
    void testShouldRunAsyncAutocommitTransactionExample() {
        try (var example =
                new AsyncAutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run("UNWIND ['Tesseract', 'Orb', 'Eye of Agamotto'] AS item "
                        + "CREATE (:Product {id: 0, title: item})");
            }

            // read all 'Product' nodes
            var titles = await(example.readProductTitles());
            assertEquals(new HashSet<>(asList("Tesseract", "Orb", "Eye of Agamotto")), new HashSet<>(titles));
        }
    }

    @Test
    void testShouldAsyncRunResultConsumeExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new AsyncResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = await(example.getPeople());

            // Then
            assertEquals(asList("Alice", "Bob"), names);
        }
    }

    @Test
    void testShouldAsyncRunMultipleTransactionExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example =
                new AsyncRunMultipleTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            var nodesCreated = await(example.addEmployees("Acme"));

            // Then
            var employeeCount =
                    readInt("MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Acme' RETURN count(emp)");
            assertEquals(2, employeeCount);
            assertEquals(1, nodesCreated);
        }
    }

    @Test
    void testShouldRunConfigConnectionPoolExample() {
        // Given
        try (var example = new ConfigConnectionPoolExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunBasicAuthExample() {
        // Given
        try (var example = new BasicAuthExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunCustomAuthExample() {
        // Given
        try (var example = new CustomAuthExample(uri, USER, neo4j.adminPassword(), null, "basic", Map.of())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunConfigConnectionTimeoutExample() {
        // Given
        try (var example =
                new ConfigConnectionTimeoutExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigMaxRetryTimeExample() {
        // Given
        try (var example = new ConfigMaxRetryTimeExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigTrustExample() {
        // Given
        try (var example = new ConfigTrustExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigUnencryptedExample() {
        // Given
        try (var example = new ConfigUnencryptedExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunDriverLifecycleExample() {
        // Given
        try (var example = new DriverLifecycleExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunHelloWorld() {
        // Given
        try (var greeter = new HelloWorldExample(uri, USER, neo4j.adminPassword())) {
            // When
            var stdIO = StdIOCapture.capture();

            try (stdIO) {
                greeter.printGreeting("hello, world");
            }

            // Then
            assertEquals(1, stdIO.stdout().size());
            assertTrue(stdIO.stdout().get(0).contains("hello, world"));
        }
    }

    @Test
    void testShouldRunReadWriteTransactionExample() {
        // Given
        try (var example = new ReadWriteTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            var nodeID = example.addPerson("Alice");

            // Then
            assertTrue(nodeID >= 0L);
        }
    }

    @Test
    void testShouldRunResultConsumeExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new ResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = example.getPeople();

            // Then
            assertEquals(List.of("Alice", "Bob"), names);
        }
    }

    @Test
    void testShouldRunResultRetainExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new ResultRetainExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addEmployees("Acme");

            // Then
            var employeeCount =
                    readInt("MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Acme' RETURN count(emp)");
            assertEquals(2, employeeCount);
        }
    }

    @Test
    void testShouldRunTransactionFunctionExample() {
        // Given
        try (var example = new TransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    void testShouldConfigureTransactionTimeoutExample() {
        // Given
        try (var example =
                new TransactionTimeoutConfigExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    void testShouldConfigureTransactionMetadataExample() {
        // Given
        try (var example =
                new TransactionMetadataConfigExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    @SuppressWarnings("resource")
    void testShouldRunAsyncTransactionFunctionExample() {
        try (var example =
                new AsyncTransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run(
                        "UNWIND ['Infinity Gauntlet', 'Mjölnir'] AS item " + "CREATE (:Product {id: 0, title: item})");
            }

            var stdIOCapture = StdIOCapture.capture();

            // print all 'Product' nodes to fake stdout
            try (stdIOCapture) {
                var summary = await(example.printAllProducts());
                assertEquals(QueryType.READ_ONLY, summary.queryType());
            }

            Set<String> capturedOutput = new HashSet<>(stdIOCapture.stdout());
            assertEquals(new HashSet<>(asList("Infinity Gauntlet", "Mjölnir")), capturedOutput);
        }
    }

    @Test
    void testPassBookmarksExample() {
        try (var example = new PassBookmarkExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addEmployAndMakeFriends();

            // Then
            assertEquals(1, companyCount("Wayne Enterprises"));
            assertEquals(1, companyCount("LexCorp"));
            assertEquals(1, personCount("Alice"));
            assertEquals(1, personCount("Bob"));

            var employeeCountOfWayne = readInt(
                    "MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Wayne Enterprises' RETURN count(emp)");
            assertEquals(1, employeeCountOfWayne);

            var employeeCountOfLexCorp = readInt(
                    "MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'LexCorp' RETURN count(emp)");
            assertEquals(1, employeeCountOfLexCorp);

            var friendCount =
                    readInt("MATCH (a:Person {name: 'Alice'})-[:KNOWS]->(b:Person {name: 'Bob'}) RETURN count(a)");
            assertEquals(1, friendCount);
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    @SuppressWarnings("resource")
    void testShouldRunRxAutocommitTransactionExample() {
        try (var example =
                new RxAutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run("UNWIND ['Tesseract', 'Orb', 'Eye of Agamotto'] AS item "
                        + "CREATE (:Product {id: 0, title: item})");
            }

            // read all 'Product' nodes
            var titles = await(example.readProductTitles());
            assertEquals(new HashSet<>(asList("Tesseract", "Orb", "Eye of Agamotto")), new HashSet<>(titles));
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    @SuppressWarnings("resource")
    void testShouldRunRxTransactionFunctionExampleReactor() {
        try (var example =
                new RxTransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run(
                        "UNWIND ['Infinity Gauntlet', 'Mjölnir'] AS item " + "CREATE (:Product {id: 0, title: item})");
            }

            var stdIOCapture = StdIOCapture.capture();

            // print all 'Product' nodes to fake stdout
            try (stdIOCapture) {
                final var summaryList = await(example.printAllProducts());
                assertEquals(1, summaryList.size());
                var summary = summaryList.get(0);
                assertEquals(QueryType.READ_ONLY, summary.queryType());
            }

            Set<String> capturedOutput = new HashSet<>(stdIOCapture.stdout());
            assertEquals(new HashSet<>(asList("Infinity Gauntlet", "Mjölnir")), capturedOutput);
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    void testShouldRunRxResultConsumeExampleReactor() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new RxResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = await(example.getPeople());

            // Then
            assertEquals(List.of("Alice", "Bob"), names);
        }
    }

    @Test
    @EnabledOnNeo4jWith(value = BOLT_V4, edition = ENTERPRISE)
    void testUseAnotherDatabaseExample() {
        var driver = neo4j.driver();
        dropDatabase(driver, "examples");
        createDatabase(driver, "examples");

        try (var example = new DatabaseSelectionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.useAnotherDatabaseExample();

            // Then
            var greetingCount = readInt("examples", "MATCH (a:Greeting) RETURN count(a)", Values.parameters());
            assertEquals(1, greetingCount);
        }
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.DisabledIfSystemProperty;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.internal.util.EnabledOnNeo4jWith;
import org.neo4j.driver.internal.util.Neo4jFeature;
import org.neo4j.driver.net.ServerAddress;
import org.testcontainers.containers.Neo4jContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.net.URI;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;

@Testcontainers(disabledWithoutDocker = true)
@DisabledIfSystemProperty(named = "skipDockerTests", matches = "^true$")
class RoutingExamplesIT {
    private static final String NEO4J_VERSION =
            Optional.ofNullable(System.getenv("NEO4J_VERSION")).orElse("4.4");

    @Container
    @SuppressWarnings("resource")
    private static final Neo4jContainer<?> NEO4J_CONTAINER = new Neo4jContainer<>(
                    String.format("neo4j:%s-enterprise", NEO4J_VERSION))
            .withEnv("NEO4J_ACCEPT_LICENSE_AGREEMENT", "yes")
            // in this testing deployment the server runs inside a container and its Bolt port is exposed to the test(s)
            // on a random port that might not match the port in the routing table
            // this setting leads to the server echoing back the routing context address supplied by the driver
            // the test(s) may define the routing context address via the URI
            .withNeo4jConfig("dbms.routing.default_router", "SERVER")
            .withAdminPassword(null);

    @Test
    @EnabledOnNeo4jWith(Neo4jFeature.SERVER_SIDE_ROUTING_ENABLED_BY_DEFAULT)
    void testShouldRunConfigCustomResolverExample() {
        // Given
        var boltUri = URI.create(NEO4J_CONTAINER.getBoltUrl());
        var id = UUID.randomUUID().toString();
        var example = new ConfigCustomResolverExample();
        var neo4j = String.format("neo4j://%s:%d", boltUri.getHost(), boltUri.getPort());

        // When
        example.addNode(neo4j, AuthTokens.none(), Set.of(ServerAddress.of(boltUri.getHost(), boltUri.getPort())), id);

        // Then
        try(var driver = GraphDatabase.driver(boltUri, AuthTokens.none())) {
            var num = driver.executableQuery("MATCH (n{id: $id}) RETURN count(n)")
                    .withParameters(Map.of("id", id))
                    .execute();
            assertEquals(1, num.records().get(0).get(0).asInt());
        }
    }
}
<configuration>
  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>target/test.log</file>
    <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="FILE"/>
  </root>
</configuration>
# CMakeLists.txt for BoltProtocol module

# Since this module is purely for protocol logic and data structures,
# it might not have complex dependencies beyond standard C++.
# If PackStream or other parts need external libs (e.g., for specific data types),
# they would be added here.

file(GLOB_RECURSE BOLT_PROTOCOL_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(BoltProtocol ${BOLT_PROTOCOL_SOURCES})

target_include_directories(BoltProtocol
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(BoltProtocol PUBLIC Boost::asio OpenSSL::SSL OpenSSL::Crypto)

# build example, no condition
add_subdirectory(Example)

# BoltProtocol itself likely doesn't link to socket libraries.
# It provides structures and serialization/deserialization logic.
# The Neo4jBoltDriver will link the socket library and use BoltProtocol.

# Example of how other modules would link against BoltProtocol:
# target_link_libraries(Neo4jBoltDriver PRIVATE BoltProtocol)# BoltProtocol 库简介

欢迎使用 BoltProtocol 库！这是一个C++实现的底层库，用于处理 Neo4j Bolt 协议的编码、解码和核心交互逻辑。它旨在为构建功能完善的 Neo4j C++ 驱动程序或直接与 Bolt 协议交互的工具提供坚实的基础。

## 目标

*   **协议合规性**: 严格遵循 Neo4j Bolt 协议规范的各个版本。
*   **灵活性**: 提供底层的序列化和反序列化原语，同时也支持强类型的特定数据结构。
*   **可移植性**: 依赖标准 C++。
*   **错误处理**: 提供清晰的错误码和状态反馈。

## 主要功能概述

本库提供以下核心功能：

*   **PackStream 序列化与反序列化**:
    *   支持 Bolt 协议使用的 PackStream V1 数据格式的所有类型（Null, Boolean, Integer, Float, String, List, Map, Structure）。
    *   通过 `boltprotocol::Value` 类型在 C++ 中统一表示 PackStream 数据。
*   **Bolt 握手 (Handshake)**:
    *   实现客户端与服务器之间的 Bolt 协议版本协商。
    *   提供 `boltprotocol::versions::Version` 结构体表示版本。
    *   函数 `boltprotocol::perform_handshake` 执行完整握手流程。
*   **消息分块 (Chunking)**:
    *   通过 `boltprotocol::ChunkedWriter` 将完整的 Bolt 消息分块写入输出流。
    *   通过 `boltprotocol::ChunkedReader` 从输入流读取分块数据并重组为完整消息。
*   **Bolt 消息定义与处理**:
    *   **消息标签**: `boltprotocol::MessageTag` 枚举定义了所有标准 Bolt 消息类型。
    *   **消息参数结构体**: 为每种 Bolt 消息（如 HELLO, RUN, SUCCESS 等）定义了相应的 C++ `struct` (例如 `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`) 来表示其参数。这些结构体通常包含 `std::string`, `int64_t`, `std::optional`, `std::vector`, `std::map<std::string, boltprotocol::Value>` 等成员。
    *   **客户端消息序列化**: 提供函数将 C++ 参数结构体序列化为 Bolt 消息字节流 (例如 `boltprotocol::serialize_hello_message`)。
    *   **服务器响应反序列化**: 提供函数将服务器响应字节流反序列化为 C++ 参数结构体 (例如 `boltprotocol::deserialize_success_message`)。
    *   **服务器端请求反序列化**: 提供函数供服务器解析客户端请求字节流 (例如 `boltprotocol::deserialize_hello_message_request`)。
*   **特定 PackStream 结构类型支持**:
    *   为常见的图元（Node, Relationship, Path）和数据类型（Date, Time, DateTime, Point 等）定义了强类型的 C++ `struct` (例如 `boltprotocol::BoltNode`, `boltprotocol::BoltDate`)。
    *   提供转换函数在这些强类型结构与通用的 `boltprotocol::PackStreamStructure` 之间进行转换 (例如 `boltprotocol::from_packstream`, `boltprotocol::to_packstream`)。

## 如何开始

要开始使用 BoltProtocol 库，您通常需要：

1.  **包含主头文件**:
    *   `#include "boltprotocol/message_defs.h"`: 这是最主要的聚合头文件，它包含了：
        *   核心数据类型 (`Value`, `BoltMap`, `BoltList`, `PackStreamStructure`)
        *   错误枚举 (`BoltError`)
        *   版本结构 (`versions::Version`) 和相关常量
        *   消息标签 (`MessageTag`)
        *   所有消息参数结构体 (`HelloMessageParams` 等)
        *   特定结构类型 (`BoltNode`, `BoltDate` 等，通过包含 `bolt_structure_types.h`)
    *   `#include "boltprotocol/message_serialization.h"`: 获取所有消息序列化和反序列化函数的声明。
    *   `#include "boltprotocol/handshake.h"`: 获取握手相关函数的声明。
    *   `#include "boltprotocol/chunking.h"`: 获取分块读写器的声明。
    *   `#include "boltprotocol/bolt_structure_serialization.h"`: 获取特定 PackStream 结构类型（如 `BoltNode`）与通用 `PackStreamStructure` 之间转换函数的声明。
2.  **理解核心概念**: 熟悉 PackStream、Bolt 消息、握手和分块机制（详见本文档后续章节）。
3.  **查阅后续文档**: 详细了解如何使用特定功能，如消息序列化、反序列化、特定结构转换和错误处理。

## 模块结构概览 (供库开发者参考)

为了方便维护和理解，本库的内部实现分布在不同的目录和文件中：

*   **`Include/boltprotocol/`**: 包含所有公共头文件。
    *   `detail/`: 包含库内部使用的辅助头文件，不应被库用户直接包含。
    *   `message_defs.h`: 聚合了核心类型定义。
    *   其他 `.h` 文件对应各个功能模块。
*   **`Source/`**: 包含所有 `.cpp` 实现文件。
    *   文件按功能模块组织 (例如 `packstream_reader_*.cpp`, `message_serialization_client_*.cpp`, `bolt_structure_*.cpp`)。

让我们深入了解核心概念，开始构建您的 Bolt 应用！# BoltProtocol 核心概念

理解 Bolt 协议的几个核心概念对于有效使用本库至关重要。

## 1. PackStream

PackStream 是 Bolt 协议用于在网络上传输数据的一种二进制序列化格式。它支持多种数据类型，本库对这些类型提供了相应的 C++ 表示。

### C++ 中的 PackStream 类型表示

所有 PackStream 类型最终都可以通过 `boltprotocol::Value` 来表示。这是一个 `std::variant`，能够持有以下C++类型，对应不同的 PackStream 类型：

*   **`std::nullptr_t`**:
    *   对应 PackStream `Null`。
*   **`bool`**:
    *   对应 PackStream `Boolean` (`true` 或 `false`)。
*   **`int64_t`**:
    *   对应所有 PackStream `Integer` 类型 (TinyInt, Int8, Int16, Int32, Int64)。库会自动处理不同大小整数的编码和解码。
*   **`double`**:
    *   对应 PackStream `Float` (64位浮点数)。
*   **`std::string`**:
    *   对应 PackStream `String` (UTF-8 编码)。
*   **`std::shared_ptr<boltprotocol::BoltList>`**:
    *   对应 PackStream `List`。
    *   `boltprotocol::BoltList` 结构体包含一个成员：
        *   `std::vector<boltprotocol::Value> elements;`
*   **`std::shared_ptr<boltprotocol::BoltMap>`**:
    *   对应 PackStream `Map`。
    *   `boltprotocol::BoltMap` 结构体包含一个成员：
        *   `std::map<std::string, boltprotocol::Value> pairs;`
*   **`std::shared_ptr<boltprotocol::PackStreamStructure>`**:
    *   对应 PackStream `Structure`。这是 Bolt 协议中用于表示消息和复杂数据类型（如图节点、日期时间等）的基础。
    *   `boltprotocol::PackStreamStructure` 结构体包含成员：
        *   `uint8_t tag;`：一个字节的标签，用于标识该结构的具体类型（例如，消息类型或特定数据如 Node、Date 的类型）。
        *   `std::vector<boltprotocol::Value> fields;`：一个包含该结构所有字段值的列表。

**注意**: 您通常不需要手动创建或解析底层的 `Value`、`BoltList`、`BoltMap` 或 `PackStreamStructure` 对象来构造或解析 Bolt 消息。库提供了更高级别的消息参数结构体 (`XxxMessageParams`) 和针对特定 PackStream 结构（如 `BoltNode`）的强类型 C++ `struct`，以及相应的序列化/反序列化函数来处理这些转换。

## 2. Bolt 消息

Bolt 协议通过客户端和服务器之间的请求-响应消息交换进行通信。

*   **请求消息 (Request Message)**: 由客户端发送给服务器。
*   **响应消息 (Response Message)**: 由服务器发送给客户端。一个完整的响应通常由以下组成：
    *   零个或多个 **详情消息 (Detail Message)**: 例如 `RECORD` 消息，用于流式传输结果数据。
    *   恰好一个 **总结消息 (Summary Message)**: 例如 `SUCCESS` 或 `FAILURE`，标志着请求处理的结束和最终状态。

每条 Bolt 消息（无论是请求还是响应）都被编码为一个 **PackStream Structure**。

### 消息标签 (`boltprotocol::MessageTag`)

`boltprotocol::MessageTag` 是一个 `enum class`，定义了所有标准 Bolt 消息的唯一类型标签 (一个字节的整数)。这个标签值被用作相应消息的 `PackStreamStructure` 的 `tag` 字段。

*   **一些重要的消息标签示例**:
    *   `MessageTag::HELLO` (0x01): 客户端发送，用于初始化连接。
    *   `MessageTag::LOGON` (0x6A): 客户端发送，用于认证 (Bolt 5.1+)。
    *   `MessageTag::RUN` (0x10): 客户端发送，用于执行 Cypher 查询。
    *   `MessageTag::PULL` (0x3F): 客户端发送，用于拉取 `RUN` 查询的结果。
    *   `MessageTag::BEGIN` (0x11): 客户端发送，用于开始一个显式事务。
    *   `MessageTag::COMMIT` (0x12): 客户端发送，用于提交一个显式事务。
    *   `MessageTag::SUCCESS` (0x70): 服务器发送，表示请求成功。
    *   `MessageTag::FAILURE` (0x7F): 服务器发送，表示请求失败。
    *   `MessageTag::RECORD` (0x71): 服务器发送，包含一条结果记录。
    *   `MessageTag::IGNORED` (0x7E): 服务器发送，表示请求被忽略。
    *   ... (更多标签请参见规范或后续文档)

### 消息参数结构体 (`boltprotocol::*MessageParams`)

为了方便在 C++ 中构造和处理消息的参数，本库为大多数 Bolt 消息定义了对应的参数结构体。这些结构体以 `MessageParams` 结尾，例如 `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`, `boltprotocol::SuccessMessageParams`。

*   这些结构体通常包含与消息字段对应的成员，使用标准的 C++ 类型如 `std::string`, `int64_t`, `std::vector`, `std::map`, 以及 `std::optional` (用于可选字段) 和 `boltprotocol::Value` (用于可变类型字段)。
*   **例如, `boltprotocol::RunMessageParams` 可能包含**:
    *   `std::string cypher_query;`
    *   `std::map<std::string, boltprotocol::Value> parameters;`
    *   `std::optional<std::vector<std::string>> bookmarks;`
    *   `std::optional<std::string> db;`
    *   ... 等等。
*   您可以通过填充这些结构体的成员来准备要发送的消息，或者在反序列化服务器响应（或客户端请求）后从这些结构体中读取参数。

## 3. 特定 PackStream 结构 (图元和数据类型)

除了 Bolt 消息本身，PackStream 还用于在消息字段中序列化 Neo4j 的特定数据类型，例如图节点、关系、路径、日期、时间、空间点等。

本库为这些常见的 PackStream Structure 定义了强类型的 C++ `struct`，例如：

*   `boltprotocol::BoltNode` (对应 PackStream Structure tag `0x4E 'N'`)
*   `boltprotocol::BoltRelationship` (tag `0x52 'R'`)
*   `boltprotocol::BoltPath` (tag `0x50 'P'`)
*   `boltprotocol::BoltDate` (tag `0x44 'D'`)
*   `boltprotocol::BoltTime` (tag `0x54 'T'`)
*   `boltprotocol::BoltDateTime` (tag `0x49 'I'` 或遗留的 `0x46 'F'`)
*   ... 等等。

这些强类型结构及其与通用 `PackStreamStructure` (`Value` 中持有的 `std::shared_ptr<PackStreamStructure>`) 之间的转换函数将在 `06-structure-types-and-conversions.md` 中详细介绍。这些转换函数通常会考虑不同 Bolt 版本对这些结构字段定义的影响。

## 总结

*   Bolt 协议的数据交换基于 **PackStream** 二进制序列化格式。
*   在 C++ 中，通用的 PackStream 数据由 `boltprotocol::Value` (一个 `std::variant`) 表示，它可以包含基本类型、`BoltList`、`BoltMap` 或 `PackStreamStructure`。
*   **Bolt 消息** 本质上是带有特定 `MessageTag` 的 `PackStreamStructure`。
*   使用库定义的 **`XxxMessageParams`** 结构体来方便地构造和访问消息的参数。
*   常见的图元和数据类型也有对应的 **强类型 C++ `struct`** (如 `BoltNode`)，并提供了与通用 `PackStreamStructure` 之间的转换机制。

理解这些核心概念是高效使用本库进行 Bolt 协议编程的基础。好的，这是第三个文档文件 `03-handshake-and-chunking.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/03-handshake-and-chunking.md`**

```markdown
# Bolt 握手与消息分块

在任何 Bolt 消息交换开始之前，客户端和服务器必须执行一次握手来协商协议版本。在握手成功后，所有消息的传输都将采用分块编码。本章详细介绍如何使用 BoltProtocol 库处理这两个过程。

## 1. Bolt 握手 (Handshake)

握手是 Bolt 连接的第一个步骤，用于客户端和服务器就后续通信将使用的 Bolt 协议版本达成一致。此过程不依赖于特定的 Bolt 消息版本。

### 版本表示 (`boltprotocol::versions::Version`)

Bolt 协议版本由 `boltprotocol::versions::Version` 结构体表示，其定义（概念性）如下：

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 主版本号
        uint8_t minor; // 次版本号

        // 构造函数，例如 Version(5, 4) 代表 Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        // 比较操作符 (<, ==, !=)
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;

        // 将版本转换为握手时发送的4字节数组 (大端序, 00 00 Maj Min)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 从服务器响应的4字节数组解析版本
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    // 预定义的版本常量，例如:
    // extern const Version V5_4; // (5,4)
    // extern const Version V5_3; // (5,3)
    // ... 等
} // namespace versions
} // namespace boltprotocol
```
您可以直接使用这些预定义的常量，如 `boltprotocol::versions::V5_4`。

### 握手相关函数

所有握手相关的函数和类型都在 `#include "boltprotocol/handshake.h"` 中声明。

*   **`std::vector<boltprotocol::versions::Version> boltprotocol::versions::get_default_proposed_versions();`**
    *   **描述**: 返回一个库预设的、客户端可以向服务器提议的 Bolt 版本列表。列表按偏好顺序（通常是最新的、最受支持的在前）排列。
    *   **返回值**: 一个包含 `Version` 对象的 `std::vector`。

*   **`boltprotocol::BoltError boltprotocol::perform_handshake(std::ostream& client_output_stream, std::istream& client_input_stream, const std::vector<boltprotocol::versions::Version>& proposed_versions, boltprotocol::versions::Version& out_negotiated_version);`**
    *   **描述**: 执行完整的 Bolt 握手流程。此函数会：
        1.  根据 `proposed_versions` 构建握手请求。
        2.  通过 `client_output_stream` 将20字节的握手请求（包括魔法序列 `6060B017` 和最多4个提议版本）发送给服务器。
        3.  通过 `client_input_stream` 从服务器读取4字节的握手响应。
        4.  解析服务器响应，并将协商成功的版本存储在 `out_negotiated_version` 中。
    *   **参数**:
        *   `client_output_stream`: 一个 `std::ostream&`，代表客户端向服务器发送数据的流（例如，网络套接字的输出流部分）。
        *   `client_input_stream`: 一个 `std::istream&`，代表客户端从服务器接收数据的流（例如，网络套接字的输入流部分）。
        *   `proposed_versions`: 一个 `const std::vector<boltprotocol::versions::Version>&`，包含客户端希望提议的协议版本。通常使用 `get_default_proposed_versions()` 的结果。
        *   `out_negotiated_version`: 一个 `boltprotocol::versions::Version&` 的引用，用于接收握手成功后服务器选择的版本。
    *   **返回值**:
        *   `boltprotocol::BoltError::SUCCESS`: 握手成功，`out_negotiated_version` 已填充。
        *   `boltprotocol::BoltError::INVALID_ARGUMENT`: 如果 `proposed_versions` 为空。
        *   `boltprotocol::BoltError::NETWORK_ERROR`: 在流读写过程中发生错误。
        *   `boltprotocol::BoltError::HANDSHAKE_NO_COMMON_VERSION`: 服务器返回全零 (`00 00 00 00`)，表示不支持客户端提议的任何版本。
        *   `boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION`: 服务器返回的响应格式无法解析为一个有效的 Bolt 版本。
        *   其他可能的错误码。

### 握手流程示例

```cpp
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h" // For BoltError and versions::Version constants
#include <iostream>
#include <sstream>   // 用于模拟网络流
#include <vector>
#include <array>     // 用于模拟服务器响应

int main() {
    std::stringstream client_to_server_pipe; 
    std::stringstream server_to_client_pipe; 
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError err;

    // 1. 客户端获取提议版本列表
    std::vector<boltprotocol::versions::Version> client_proposals = 
        boltprotocol::versions::get_default_proposed_versions();

    if (client_proposals.empty()) {
        std::cerr << "Client: No versions to propose." << std::endl;
        return 1;
    }
    std::cout << "Client: Proposing versions: ";
    for (const auto& v : client_proposals) {
        std::cout << (int)v.major << "." << (int)v.minor << " ";
    }
    std::cout << std::endl;

    // --- 模拟服务器端行为 ---
    // 假设服务器支持客户端提议的第一个版本 (例如 Bolt 5.4)
    boltprotocol::versions::Version server_supported_choice = client_proposals[0]; 
    std::array<uint8_t, boltprotocol::HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_data = 
        server_supported_choice.to_handshake_bytes();
    
    // 服务器将响应写入 "server_to_client_pipe"
    server_to_client_pipe.write(
        reinterpret_cast<const char*>(server_response_data.data()), 
        server_response_data.size()
    );
    // 模拟完毕后，确保服务器端的流准备好被客户端读取
    server_to_client_pipe.seekg(0); 
    // --- 服务器端行为模拟结束 ---

    // 2. 客户端执行握手
    std::cout << "Client: Performing handshake..." << std::endl;
    err = boltprotocol::perform_handshake(
        client_to_server_pipe,   // 客户端写数据到这里
        server_to_client_pipe,   // 客户端从这里读数据
        client_proposals,
        negotiated_version
    );

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "Client: Handshake successful!" << std::endl;
        std::cout << "Client: Negotiated Bolt Protocol Version: "
                  << static_cast<int>(negotiated_version.major) << "."
                  << static_cast<int>(negotiated_version.minor) << std::endl;
        // 后续通信应使用 negotiated_version
    } else {
        std::cerr << "Client: Handshake failed. Error code: " << static_cast<int>(err) << std::endl;
        // 根据错误码进行相应处理
        return 1;
    }

    // 此时，client_to_server_pipe 中包含了客户端发送的20字节握手数据
    // server_to_client_pipe 中的4字节响应数据已被 perform_handshake 读取完毕

    return 0;
}
```

## 2. 消息分块 (Chunking)

在成功的握手之后，所有 Bolt 消息（包括 HELLO 消息）都必须使用分块编码进行传输。分块机制允许将一条逻辑消息分割成一个或多个物理块进行传输。

### 分块规则

*   **块结构**: 每个块以一个 **2字节的块头** 开始。这个头部是一个无符号的、大端序的16位整数，表示紧随其后的数据块负载的大小（以字节为单位）。因此，单个块的最大负载大小是 65,535 字节 (0xFFFF)。
*   **消息结束标记**: 每条完整的 Bolt 消息在其所有数据块之后，必须以一个**零大小的块**作为结束。这个标记由两个字节 `00 00`（即块头声明大小为0）表示。它用于向接收方指示消息的边界。
*   **NOOP Chunk (Bolt 4.1+)**: 一个零大小的块 (`00 00`) 也可以在消息之间作为 NOOP (No Operation) 块发送，通常用于连接保活 (keep-alive)。

### 分块读写器接口

本库在 `#include "boltprotocol/chunking.h"` 中提供了处理分块的类。

*   **`boltprotocol::ChunkedWriter`**: 用于将一条完整的、已经过 PackStream 序列化的 Bolt 消息分块并写入输出流。
    *   **构造函数**: `ChunkedWriter(std::ostream& output_stream);`
        *   `output_stream`: 将分块数据写入的目标流。
    *   **核心方法**: `boltprotocol::BoltError write_message(const std::vector<uint8_t>& full_message_payload);`
        *   `full_message_payload`: 一个包含单条、完整、已 PackStream 序列化的 Bolt 消息的字节向量。
        *   此方法会自动将 `full_message_payload` 分割成一个或多个数据块（每个块不超过最大尺寸），为每个块添加2字节的块头，并在所有数据块之后写入 `00 00` 结束标记。
        *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::NETWORK_ERROR`）。

*   **`boltprotocol::ChunkedReader`**: 用于从输入流中读取分块数据，并将它们重新组装成一条完整的 Bolt 消息。
    *   **构造函数**: `ChunkedReader(std::istream& input_stream);`
        *   `input_stream`: 从中读取分块数据的来源流。
    *   **核心方法**: `boltprotocol::BoltError read_message(std::vector<uint8_t>& out_reconstructed_payload);`
        *   此方法会持续读取块（块头 + 块数据），直到遇到零大小的块 (`00 00`)。
        *   所有读取到的块负载数据会被聚合并存储在 `out_reconstructed_payload` 中。
        *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::NETWORK_ERROR`, `BoltError::CHUNK_DECODING_ERROR`, `BoltError::MESSAGE_TOO_LARGE`）。
        *   如果连续读取到 `00 00`（例如，一个消息结束标记后紧跟着一个 NOOP chunk），当为 NOOP chunk 调用 `read_message` 时，`out_reconstructed_payload` 将为空。

### 分块使用流程

1.  **准备消息负载**: 使用本库的消息序列化函数 (例如 `serialize_hello_message`) 将消息参数对象转换为 `std::vector<uint8_t>` 形式的 PackStream 字节流。
2.  **发送分块消息**:
    a.  创建 `ChunkedWriter` 实例，绑定到网络输出流。
    b.  调用 `writer.write_message()`，传入准备好的消息负载。
    c.  检查错误。
3.  **接收分块消息**:
    a.  创建 `ChunkedReader` 实例，绑定到网络输入流。
    b.  创建一个空的 `std::vector<uint8_t>` 来存储重组后的消息。
    c.  调用 `reader.read_message()`。
    d.  检查错误。
    e.  如果成功且接收到的向量不为空，这些字节就是完整的 PackStream 编码的 Bolt 消息，可以传递给相应的消息反序列化函数 (例如 `deserialize_success_message`) 进行处理。

**示例代码已在 `01-introduction.md` 中通过模拟流展示，请参考该示例了解具体调用方式。**

正确地使用握手和分块是 Bolt 协议通信的基础。本库的 `perform_handshake`, `ChunkedWriter`, 和 `ChunkedReader` 封装了这些过程的复杂性。
```好的，这是第四个文档文件 `04-message-serialization.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/04-message-serialization.md`**

```markdown
# Bolt 客户端消息序列化

本章详细介绍如何使用 BoltProtocol 库将 C++ 中的消息参数结构体序列化为可以通过网络发送给服务器的 Bolt 消息字节流。所有 Bolt 消息都使用 PackStream V1 格式进行序列化，并通过分块机制传输（分块处理见 `03-handshake-and-chunking.md`）。

所有客户端请求消息的序列化函数都在头文件 `#include "boltprotocol/message_serialization.h"` 中声明。

## 通用序列化流程

对于客户端发送的每一个请求消息，序列化过程通常如下：

1.  **包含必要的头文件**:
    ```cpp
    #include "boltprotocol/message_defs.h"     // 提供 XxxMessageParams 结构体, Value, versions::Version, MessageTag 等
    #include "boltprotocol/message_serialization.h" // 提供 serialize_xxx_message 函数声明
    #include "boltprotocol/packstream_writer.h"   // 提供 PackStreamWriter 类
    #include <vector>                           // 用于存储序列化后的字节
    ```
2.  **创建并填充参数结构体**:
    根据您要发送的消息类型，创建并填充相应的 `boltprotocol::XxxMessageParams` 结构体。例如，对于 `RUN` 消息，使用 `boltprotocol::RunMessageParams`。请参考每个消息的具体文档或 `bolt_message_params.h` 中的定义来了解其成员。
3.  **准备 `PackStreamWriter`**:
    实例化一个 `boltprotocol::PackStreamWriter` 对象。它需要一个输出目标来写入序列化后的字节。通常，这是一个 `std::vector<uint8_t>`。
    ```cpp
    std::vector<uint8_t> serialized_message_bytes;
    boltprotocol::PackStreamWriter writer(serialized_message_bytes);
    ```
4.  **调用序列化函数**:
    调用与消息类型对应的 `boltprotocol::serialize_xxx_message()` 函数。将准备好的参数结构体实例和 `PackStreamWriter` 实例传递给它。
    *   **版本依赖性**: 某些消息（如 `HELLO`, `RUN`, `BEGIN`, `ROUTE`）的结构或其 `extra` 字典中的字段会根据 Bolt 协议版本而变化。因此，这些消息的序列化函数需要一个额外的 `const boltprotocol::versions::Version& target_bolt_version` 参数，以指明应按照哪个 Bolt 版本的规范来构造消息。通常，这个版本是客户端与服务器握手后协商得到的版本，或者是客户端在发送 `HELLO` 时意图使用的版本。
5.  **错误检查**:
    所有序列化函数都返回一个 `boltprotocol::BoltError`。务必检查此返回值。如果不是 `boltprotocol::BoltError::SUCCESS`，则表示序列化过程中发生了错误。`PackStreamWriter` 对象内部也会记录错误状态，可以通过其 `has_error()` 和 `get_error()` 方法查询。
6.  **获取序列化数据**:
    如果序列化成功，并且 `PackStreamWriter` 的目标是 `std::vector<uint8_t>`，那么这个向量现在就包含了完整的、PackStream 编码的 Bolt 消息的字节负载。
    ```cpp
    // ... (接上例)
    // serialized_message_bytes 现在包含了可以发送给 ChunkedWriter 的数据。
    ```

## 支持的客户端请求消息及其序列化

以下是本库支持序列化的主要客户端请求消息的列表、它们的参数结构体关键成员以及对应的序列化函数签名。

---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)
*用于初始化连接，进行认证（Bolt < 5.1）和能力协商。*

*   **参数结构体**: `boltprotocol::HelloMessageParams`
    *   `user_agent` (std::string): **必需**. 客户端应用程序的用户代理字符串。
    *   `auth_scheme` (std::optional<std::string>): 认证方案，如 "basic", "none", "kerberos"。主要用于 Bolt < 5.1。
    *   `auth_principal` (std::optional<std::string>): 用户名，用于 "basic" 等方案。
    *   `auth_credentials` (std::optional<std::string>): 凭证（如密码），用于 "basic" 等方案。
    *   `auth_scheme_specific_tokens` (std::optional<std::map<std::string, Value>>): 其他特定认证方案的参数。
    *   `routing_context` (std::optional<std::map<std::string, Value>>): Bolt 4.1+。用于传递路由信息，例如 `{"address": "initial.host:port"}`。
    *   `patch_bolt` (std::optional<std::vector<std::string>>): Bolt 4.3-4.4。用于请求协议补丁，例如 `{"utc"}`。
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+。设置最小通知级别。
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+。禁用特定类别的通知。
    *   `bolt_agent` (std::optional<BoltAgentInfo>): Bolt 5.3+ **必需**. 包含驱动/库自身的信息。
        *   `BoltAgentInfo::product` (std::string): **必需**. 例如 "MyCppDriver/1.0"。
        *   `BoltAgentInfo::platform` (std::optional<std::string>): 例如 "Linux x86_64"。
        *   `BoltAgentInfo::language` (std::optional<std::string>): 例如 "C++20"。
        *   `BoltAgentInfo::language_details` (std::optional<std::string>): 例如 "GCC 11.3"。
    *   `other_extra_tokens` (std::map<std::string, Value>): 用于任何其他非标准或未来版本的 `extra` 字典参数。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_hello_message(
        const boltprotocol::HelloMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& client_target_version
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)
*用于 Bolt 5.1+ 的身份验证。*

*   **参数结构体**: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>): **必需**. 包含 `"scheme"` (必需, String) 以及该 scheme 所需的其他认证信息，例如：
        *   对于 `"basic"` scheme: `"principal"` (String), `"credentials"` (String).
        *   对于 `"bearer"` scheme: `"credentials"` (String, 包含 token).
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_logon_message(
        const boltprotocol::LogonMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)
*用于 Bolt 5.1+ 注销当前用户。*

*   **参数结构体**: `boltprotocol::LogoffMessageParams` (此结构体为空，因为 LOGOFF 消息没有参数字段。)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_logoff_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
    *注意*: 此函数不需要 `LogoffMessageParams` 类型的参数，因为它序列化的是一个没有字段的 PackStream Structure。

---

### 4. `RUN` (MessageTag::RUN - `0x10`)
*用于执行一个 Cypher 查询，可以用于自动提交事务或在显式事务内。*

*   **参数结构体**: `boltprotocol::RunMessageParams`
    *   `cypher_query` (std::string): **必需**. 要执行的 Cypher 查询语句。
    *   `parameters` (std::map<std::string, Value>): Cypher 查询的参数。
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+. 用于因果一致性的书签列表。
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+. 事务超时时间（毫秒）。
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+. 事务相关的元数据。
    *   `mode` (std::optional<std::string>): Bolt 3+. 事务访问模式 ("r" 表示只读，"w" 表示读写，默认为 "w")。仅用于自动提交事务。
    *   `db` (std::optional<std::string>): Bolt 4.0+. 指定要操作的数据库名称。
    *   `imp_user` (std::optional<std::string>): Bolt 4.4+. 模拟用户（仅用于自动提交的 RUN）。
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>): 其他自定义的 `extra` 字典字段。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_run_message(
        const boltprotocol::RunMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```
*   **注意**: `target_bolt_version` 用于确定 `extra` 字典中应包含哪些版本特定的字段。显式事务中的 `RUN` 消息的 `extra` 字段为空。

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)
*用于开始一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::BeginMessageParams`
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+.
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+.
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+.
    *   `mode` (std::optional<std::string>): Bolt 3+ (默认为 "w" 如果不指定)。
    *   `db` (std::optional<std::string>): Bolt 4.0+.
    *   `imp_user` (std::optional<std::string>): Bolt 4.0+.
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>): 其他自定义 `extra` 字段。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_begin_message(
        const boltprotocol::BeginMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)
*用于从服务器拉取由 `RUN` 启动的查询结果流。在 Bolt 4.0 之前被称为 `PULL_ALL` 且无参数。*

*   **参数结构体**: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+)**. 要获取的记录数。`-1` 表示获取所有剩余记录。
    *   `qid` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+ 显式事务中的 PULL)**. 查询ID，用于标识要从哪个结果流拉取数据。对于自动提交事务或 Bolt 4.0 之前的 `PULL_ALL`，此字段可能不那么关键或默认为 `-1`。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_pull_message(
        const boltprotocol::PullMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 此函数序列化为 Bolt 4.0+ 的 PULL 格式（包含一个 `extra` map）。对于 Bolt < 4.0 的 `PULL_ALL`（没有字段），客户端需要发送一个空的 PSS (tag PULL, 0 fields)，这需要一个不同的序列化逻辑或此函数的版本判断。目前此函数假定 Bolt 4.0+ 格式。

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)
*用于丢弃服务器上由 `RUN` 启动的查询结果流中剩余的记录。在 Bolt 4.0 之前被称为 `DISCARD_ALL` 且无参数。*

*   **参数结构体**: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+)**. 要丢弃的记录数。`-1` 表示丢弃所有剩余记录。
    *   `qid` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+ 显式事务中的 DISCARD)**. 查询ID。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_discard_message(
        const boltprotocol::DiscardMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 同 PULL。

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)
*用于提交一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::CommitMessageParams` (空结构体)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_commit_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: COMMIT 消息的 PackStream Structure 包含一个字段，该字段是一个空的 PackStream Map `{}`。

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)
*用于回滚一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::RollbackMessageParams` (空结构体)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_rollback_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 与 COMMIT 类似，包含一个空 map 字段。

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)
*用于将连接重置回初始状态（通常是 `READY` 或 `AUTHENTICATION` 状态，取决于版本）。*

*   **参数结构体**: 无
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_reset_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: RESET 消息的 PackStream Structure 没有字段。

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)
*客户端通知服务器它将优雅地关闭连接 (Bolt 3+)。服务器通常不响应此消息。*

*   **参数结构体**: 无
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_goodbye_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: GOODBYE 消息的 PackStream Structure 没有字段。

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)
*用于从服务器获取路由信息 (Bolt 4.3+)。*

*   **参数结构体**: `boltprotocol::RouteMessageParams`
    *   `routing_table_context` (std::map<std::string, Value>): 包含路由上下文信息，如客户端的初始连接地址。对于 ROUTE V2，此 map 可能包含 `"db"` 和 `"imp_user"`。
    *   `bookmarks` (std::vector<std::string>): 用于会话一致性的书签。
    *   `db_name_for_v43` (std::optional<std::string>): **仅用于 Bolt 4.3**。作为 PackStream Structure 的第三个顶级字段。
    *   `extra_for_v44_plus` (std::optional<std::map<std::string, Value>>): **用于 Bolt 4.4+**。作为 PackStream Structure 的第三个顶级字段，此 map 可包含 `"db"` 和/或 `"imp_user"`。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_route_message(
        const boltprotocol::RouteMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& negotiated_bolt_version
    );
    ```
*   **注意**: `negotiated_bolt_version` 用于决定第三个顶级字段的结构（是 `db_name_for_v43` 还是 `extra_for_v44_plus`）。

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)
*用于向服务器发送驱动 API 使用情况的遥测数据 (Bolt 5.4+)。*

*   **参数结构体**: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>): **必需**. 必须包含一个键为 `"api"`，值为 `Integer` 的条目，表示使用的 API 类型。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_telemetry_message(
        const boltprotocol::TelemetryMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

## 示例：序列化 HELLO 消息

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h" // For HelloMessageParams, Value, versions::Version etc.
#include "boltprotocol/packstream_writer.h"
#include <vector>
#include <iostream>

int main() {
    boltprotocol::HelloMessageParams hello_p;
    // 假设客户端目标版本是 Bolt 5.3
    boltprotocol::versions::Version target_version(5, 3);

    hello_p.user_agent = "MyAwesomeCppApp/1.0";
    
    // Bolt 5.3+ 需要 bolt_agent
    boltprotocol::HelloMessageParams::BoltAgentInfo agent;
    agent.product = "MyDriver/0.1";
    agent.platform = "Linux x64";
    agent.language = "C++20";
    hello_p.bolt_agent = agent;

    // Bolt 5.3 HELLO 中不包含认证信息 (应使用 LOGON)
    // hello_p.auth_scheme = "basic"; 
    // hello_p.auth_principal = "user";
    // hello_p.auth_credentials = "pass";

    std::map<std::string, boltprotocol::Value> routing_ctx;
    routing_ctx["address"] = boltprotocol::Value(std::string("client.initial.host:7687"));
    hello_p.routing_context = routing_ctx; // For Bolt 4.1+

    std::vector<uint8_t> serialized_bytes;
    boltprotocol::PackStreamWriter writer(serialized_bytes);

    boltprotocol::BoltError err = boltprotocol::serialize_hello_message(hello_p, writer, target_version);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "HELLO message serialized. Size: " << serialized_bytes.size() << std::endl;
        // serialized_bytes 可以传递给 ChunkedWriter
    } else {
        std::cerr << "HELLO serialization failed: " << static_cast<int>(err) << std::endl;
    }

    return 0;
}

```

通过使用这些函数和参数结构体，您可以方便地为各种 Bolt 客户端请求构建符合协议规范的 PackStream 字节流。务必根据您正在交互的服务器所支持的 Bolt 版本以及消息本身的规范来正确填充参数。
```好的，这是第五个文档文件 `05-message-deserialization.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/05-message-deserialization.md`**

```markdown
# Bolt 消息反序列化

本章详细介绍如何使用 BoltProtocol 库将从网络接收到的 Bolt 消息字节流（已通过 `ChunkedReader` 重组为完整的 PackStream 消息）反序列化为 C++ 中的参数结构体。这包括客户端解析服务器的响应消息，以及服务器端解析客户端的请求消息。

所有消息的反序列化函数都在头文件 `#include "boltprotocol/message_serialization.h"` 中声明。

## 通用反序列化流程

无论是客户端接收服务器响应，还是服务器接收客户端请求，反序列化一条 Bolt 消息通常遵循以下步骤：

1.  **包含必要的头文件**:
    ```cpp
    #include "boltprotocol/message_defs.h"     // 提供 XxxMessageParams 结构体, Value, versions::Version, MessageTag 等
    #include "boltprotocol/message_serialization.h" // 提供 deserialize_xxx_message 函数声明
    #include "boltprotocol/packstream_reader.h"   // 提供 PackStreamReader 类
    #include <vector>                           // 通常用于存储从 ChunkedReader 获取的字节
    ```
2.  **获取完整的消息字节**:
    使用 `boltprotocol::ChunkedReader` 从输入流中读取一个完整的、已去分块的 Bolt 消息，这将得到一个 `std::vector<uint8_t>` 类型的 `received_message_bytes`。
3.  **准备 `PackStreamReader`**:
    实例化一个 `boltprotocol::PackStreamReader` 对象，将其绑定到包含完整消息字节的向量。
    ```cpp
    // std::vector<uint8_t> received_message_bytes = ... (from ChunkedReader)
    boltprotocol::PackStreamReader reader(received_message_bytes);
    ```
4.  **确定消息类型并调用反序列化函数**:
    *   **如果已知道期望的消息类型**: 直接调用相应的 `boltprotocol::deserialize_xxx_message()` (用于客户端解析响应) 或 `boltprotocol::deserialize_xxx_message_request()` (用于服务器解析请求) 函数。这些函数内部会验证消息标签是否匹配。
    *   **如果需要动态判断消息类型**:
        a.  先读取通用的 `boltprotocol::Value`，并检查它是否为一个 `std::shared_ptr<boltprotocol::PackStreamStructure>`。
        b.  如果是，获取其 `tag` 字段，转换为 `boltprotocol::MessageTag`。
        c.  根据 `tag` 分发到对应的反序列化函数。
        d.  **重要**: 如果采用这种方式，在调用特定消息的反序列化函数之前，需要**重新**用原始的 `received_message_bytes` 构建一个新的 `PackStreamReader`，因为第一次读取 `Value` 会消耗流。或者，`deserialize_message_structure_prelude` 可以被用来更安全地提取顶层结构而不完全消耗，但这主要用于反序列化函数内部。对于外部判断，通常是读一次，然后根据类型决定下一步。更稳健的方式是有一个通用的消息分派机制。
    *   **版本依赖性**: 某些消息的反序列化函数（如 `HELLO`, `RUN`, `BEGIN`, `ROUTE` 的请求反序列化，以及特定结构如 `BoltDateTime` 的转换）需要传递当前连接协商的 Bolt 版本 (`const boltprotocol::versions::Version& negotiated_version`)，因为消息的字段或其解释可能依赖于此版本。

5.  **错误检查**:
    所有反序列化函数都返回一个 `boltprotocol::BoltError`。务必检查此返回值。如果不是 `boltprotocol::BoltError::SUCCESS`，则表示反序列化过程中发生了错误（例如，格式错误、数据不完整、标签不匹配、字段数量不对等）。`PackStreamReader` 对象内部也会记录错误状态。
6.  **访问反序列化后的参数**:
    如果反序列化成功，传递给函数的输出参数结构体（例如 `SuccessMessageParams& out_params`）现在就包含了从消息字节中解析出来的数据。

## A. 客户端解析服务器响应消息

这些函数由客户端用于解析从服务器接收到的响应。

---

### 1. `SUCCESS` (MessageTag::SUCCESS - `0x70`)
*表示请求已成功处理。*

*   **参数结构体 (输出)**: `boltprotocol::SuccessMessageParams`
    *   `metadata` (std::map<std::string, Value>): 包含服务器返回的各种元数据。具体内容取决于产生此 `SUCCESS` 的原始请求和 Bolt 版本。常见的键包括：
        *   `"fields"` (List<String>): 对于 `RUN` 的响应，列出结果集的字段名。
        *   `"qid"` (Integer): 对于显式事务中的 `RUN`，返回查询ID。
        *   `"t_first"` (Integer): 第一个记录可用的时间 (毫秒)。
        *   `"server"` (String): 服务器代理字符串 (例如 "Neo4j/5.10.0")。通常在 `HELLO` 的响应中。
        *   `"connection_id"` (String): 服务器端的连接标识符。通常在 `HELLO` 的响应中。
        *   `"bookmark"` (String): 对于自动提交事务或 `COMMIT` 的响应，返回事务书签。
        *   `"has_more"` (Boolean): 对于 `PULL`/`DISCARD` 的响应 (Bolt 4.0+)，指示是否还有更多记录。
        *   `"patch_bolt"` (List<String>): 对于 `HELLO` 的响应 (Bolt 4.3-4.4)，确认服务器接受的协议补丁。
        *   `"hints"` (Map): 对于 `HELLO` 的响应 (Bolt 4.3+)，服务器配置提示。
        *   ... 以及其他如 `type`, `db`, `plan`, `profile`, `stats` 等。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_success_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::SuccessMessageParams& out_params
    );
    ```

---

### 2. `FAILURE` (MessageTag::FAILURE - `0x7F`)
*表示请求处理失败。*

*   **参数结构体 (输出)**: `boltprotocol::FailureMessageParams`
    *   `metadata` (std::map<std::string, Value>): 包含错误信息。常见的键包括：
        *   `"code"` (String): Neo4j 错误码 (Bolt < 5.7)。
        *   `"message"` (String): 人类可读的错误描述。
        *   `"neo4j_code"` (String): Neo4j 错误码 (Bolt 5.7+)。
        *   `"gql_status"` (String): GQL 状态码 (Bolt 5.7+)。
        *   `"description"` (String): GQL 状态描述 (Bolt 5.7+)。
        *   `"diagnostic_record"` (Map): 诊断信息 (Bolt 5.7+)。
        *   `"cause"` (Map): 错误的内部原因 (Bolt 5.7+)。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_failure_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::FailureMessageParams& out_params
    );
    ```

---

### 3. `RECORD` (MessageTag::RECORD - `0x71`)
*包含查询结果集中的一条记录。*

*   **参数结构体 (输出)**: `boltprotocol::RecordMessageParams`
    *   `fields` (std::vector<Value>): 一个包含该记录所有字段值的列表。值的顺序与 `RUN` 响应的 `SUCCESS` 消息中 `"fields"` 元数据定义的顺序一致。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_record_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RecordMessageParams& out_params
    );
    ```

---

### 4. `IGNORED` (MessageTag::IGNORED - `0x7E`)
*表示服务器忽略了对应的请求（例如，当连接处于 `FAILED` 或 `INTERRUPTED` 状态时）。*

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_ignored_message(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: IGNORED 消息的 PackStream Structure 可以有0个字段，或者1个包含元数据 map 的字段。此函数主要验证消息结构。

---

## B. 服务器解析客户端请求消息

这些函数由服务器端用于解析从客户端接收到的请求。

---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)

*   **参数结构体 (输出)**: `boltprotocol::HelloMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_hello_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::HelloMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version // 服务器期望或已协商的版本
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)

*   **参数结构体 (输出)**: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_logon_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::LogonMessageParams& out_params
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_logoff_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```

---

### 4. `RUN` (MessageTag::RUN - `0x10`)

*   **参数结构体 (输出)**: `boltprotocol::RunMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_run_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RunMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)

*   **参数结构体 (输出)**: `boltprotocol::BeginMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_begin_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::BeginMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)

*   **参数结构体 (输出)**: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_pull_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::PullMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 此函数会根据 `server_negotiated_version` 判断是 Bolt < 4.0 的 `PULL_ALL` (0个字段) 还是 Bolt 4.0+ 的 `PULL` (1个 `extra` map 字段)。

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)

*   **参数结构体 (输出)**: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_discard_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::DiscardMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 同 PULL。

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_commit_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为1个字段（空 map）。

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_rollback_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 同 COMMIT。

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_reset_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为0个字段。

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_goodbye_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为0个字段。

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)

*   **参数结构体 (输出)**: `boltprotocol::RouteMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_route_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RouteMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 根据 `server_negotiated_version` 解析第三个字段是 `db_name` (Bolt 4.3) 还是 `extra` map (Bolt 4.4+)。

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)

*   **参数结构体 (输出)**: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>): 应包含 `"api"` (Integer) 键。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_telemetry_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::TelemetryMessageParams& out_params
    );
    ```

## 反序列化示例 (客户端解析 RECORD 消息)

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include <vector>
#include <iostream>

// 假设 received_record_bytes 是从 ChunkedReader 获取的 RECORD 消息的字节
// std::vector<uint8_t> received_record_bytes = ...; 

void process_record_message(const std::vector<uint8_t>& received_record_bytes) {
    boltprotocol::PackStreamReader reader(received_record_bytes);
    boltprotocol::RecordMessageParams record_data;
    boltprotocol::BoltError err = boltprotocol::deserialize_record_message(reader, record_data);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "RECORD message deserialized. Number of fields: " << record_data.fields.size() << std::endl;
        for (size_t i = 0; i < record_data.fields.size(); ++i) {
            const auto& fieldValue = record_data.fields[i];
            // 根据 fieldValue 的实际类型 (通过 std::holds_alternative 和 std::get) 进行处理
            if (std::holds_alternative<std::string>(fieldValue)) {
                std::cout << "  Field " << i << " (String): " << std::get<std::string>(fieldValue) << std::endl;
            } else if (std::holds_alternative<int64_t>(fieldValue)) {
                std::cout << "  Field " << i << " (Integer): " << std::get<int64_t>(fieldValue) << std::endl;
            } // ... 其他类型 ...
        }
    } else {
        std::cerr << "Failed to deserialize RECORD message, error: " << static_cast<int>(err) << std::endl;
    }
}
```
正确使用这些反序列化函数，并结合版本信息（如果需要），可以帮助您的应用程序或服务器正确地解析和理解 Bolt 协议消息。
```好的，这是第六个文档文件 `06-structure-types-and-conversions.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/06-structure-types-and-conversions.md`**

```markdown
# 特定 PackStream 结构类型与转换

Bolt 协议不仅使用 PackStream 传输顶层的请求和响应消息，还在这些消息的字段中（例如，`RECORD` 消息的数据，或 `RUN` 消息的参数）使用 PackStream Structure 来表示图数据库中的核心实体（如节点、关系、路径）以及特定的数据类型（如日期、时间、空间点等）。

为了方便在 C++ 中以类型安全和面向对象的方式操作这些常见的结构化数据，BoltProtocol 库提供了：

1.  **强类型的 C++ 结构体**: 为每种标准的 PackStream Structure 定义了对应的 C++ `struct`。
2.  **转换函数**: 用于在通用的 `boltprotocol::PackStreamStructure` (通常通过 `std::shared_ptr` 持有，并包含在 `boltprotocol::Value` 中) 与这些强类型 C++ 结构体之间进行双向转换。

所有强类型结构体定义在 `#include "boltprotocol/bolt_structure_types.h"` (它被聚合头文件 `boltprotocol/message_defs.h` 包含)。
所有转换函数声明在 `#include "boltprotocol/bolt_structure_serialization.h"`。

## 1. 支持的强类型 C++ 结构体

以下是本库目前支持的强类型 C++ 结构体及其对应的 PackStream 标签和关键成员。请注意，某些结构的字段会随 Bolt 版本变化（例如 `element_id` 在 Bolt 5.0+ 中为图元添加）。转换函数会考虑这些版本差异。

### 图元 (Graph Primitives)

*   **`boltprotocol::BoltNode`** (PackStream Tag: `0x4E 'N'`)
    *   `int64_t id;`
    *   `std::vector<std::string> labels;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltRelationship`** (PackStream Tag: `0x52 'R'`)
    *   `int64_t id;`
    *   `int64_t start_node_id;`
    *   `int64_t end_node_id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> start_node_element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> end_node_element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltUnboundRelationship`** (PackStream Tag: `0x72 'r'`)
    *   *用于 `BoltPath` 内部，表示不含端点的关系。*
    *   `int64_t id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltPath`** (PackStream Tag: `0x50 'P'`)
    *   `std::vector<BoltNode> nodes;`
    *   `std::vector<BoltUnboundRelationship> rels;`
    *   `std::vector<int64_t> indices;` (描述路径如何由节点和关系构成)

### 时间类型 (Temporal Types)

*   **`boltprotocol::BoltDate`** (PackStream Tag: `0x44 'D'`)
    *   `int64_t days_since_epoch;` (自 Unix 纪元以来的天数)

*   **`boltprotocol::BoltTime`** (PackStream Tag: `0x54 'T'`)
    *   `int64_t nanoseconds_since_midnight;` (相对于给定偏移量的午夜以来的纳秒数)
    *   `int32_t tz_offset_seconds;` (距 UTC 的秒数偏移量)

*   **`boltprotocol::BoltLocalTime`** (PackStream Tag: `0x74 't'`)
    *   `int64_t nanoseconds_since_midnight;` (本地午夜以来的纳秒数，无时区信息)

*   **`boltprotocol::BoltDateTime`** (PackStream Tag: `0x49 'I'` (现代) / `0x46 'F'` (遗留))
    *   `int64_t seconds_epoch_utc;` (自 Unix 纪元以来的 UTC 秒数)
    *   `int32_t nanoseconds_of_second;` (秒内的纳秒部分, 0-999,999,999)
    *   `int32_t tz_offset_seconds;` (原始时间的 UTC 秒数偏移量)

*   **`boltprotocol::BoltDateTimeZoneId`** (PackStream Tag: `0x69 'i'` (现代) / `0x66 'f'` (遗留))
    *   `int64_t seconds_epoch_utc;` (自 Unix 纪元以来的 UTC 秒数。**注意**: 对于从遗留 'f' 格式反序列化，此字段可能包含已调整的秒数，而非纯 UTC，需上层结合 TZDB 处理。)
    *   `int32_t nanoseconds_of_second;`
    *   `std::string tz_id;` (时区标识符，如 "Europe/Paris")

*   **`boltprotocol::BoltLocalDateTime`** (PackStream Tag: `0x64 'd'`)
    *   `int64_t seconds_epoch_local;` (自 Unix 纪元以来的秒数，解释为本地日期时间)
    *   `int32_t nanoseconds_of_second;`

*   **`boltprotocol::BoltDuration`** (PackStream Tag: `0x45 'E'`)
    *   `int64_t months;`
    *   `int64_t days;`
    *   `int64_t seconds;`
    *   `int32_t nanoseconds;` (秒的纳秒调整部分)

### 空间类型 (Spatial Types)

*   **`boltprotocol::BoltPoint2D`** (PackStream Tag: `0x58 'X'`)
    *   `uint32_t srid;` (空间参考系统标识符)
    *   `double x;`
    *   `double y;`

*   **`boltprotocol::BoltPoint3D`** (PackStream Tag: `0x59 'Y'`)
    *   `uint32_t srid;`
    *   `double x;`
    *   `double y;`
    *   `double z;`

## 2. 转换函数

这些函数用于在通用的 `boltprotocol::PackStreamStructure` 和上述强类型 C++ 结构体之间进行转换。

### A. 从 `PackStreamStructure` 转换为强类型 (`from_packstream`)

这些函数通常在接收到包含特定结构的数据后（例如，在 `RECORD` 消息的字段中）调用。

*   **通用函数签名模式**:
    ```cpp
    boltprotocol::BoltError from_packstream(
        const boltprotocol::PackStreamStructure& pss, 
        TypedStruct& out_struct, 
        /* 可选参数: const boltprotocol::versions::Version& bolt_version (用于版本依赖的结构) */
    );
    ```
    *   `pss`: 输入的、从 PackStream 反序列化得到的通用结构。
    *   `out_struct`: 输出参数，用于填充转换后的强类型结构数据。
    *   `bolt_version`: 对于字段随 Bolt 版本变化的结构（如 `BoltNode`, `BoltRelationship`, `BoltDateTime`），需要提供此参数。
    *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::INVALID_MESSAGE_FORMAT` 如果标签或字段不匹配）。

*   **示例函数**:
    *   `from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDate& out_date);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);`
    *   ... (其他类型的对应函数)

### B. 将强类型转换为 `PackStreamStructure` (`to_packstream`)

这些函数用于客户端需要构造特定类型的结构（例如，作为 Cypher 查询的参数）并将其发送给服务器的场景。

*   **通用函数签名模式**:
    ```cpp
    boltprotocol::BoltError to_packstream(
        const TypedStruct& typed_struct, 
        /* 可选参数: const boltprotocol::versions::Version& bolt_version, */
        /* 可选参数: bool utc_patch_active_for_4_4, (仅用于 BoltDateTime/ZoneId 和 Bolt 4.4) */
        std::shared_ptr<PackStreamStructure>& out_pss_sptr 
    );
    ```
    *   `typed_struct`: 输入的强类型 C++ 结构体实例。
    *   `bolt_version`, `utc_patch_active_for_4_4`: 用于确保序列化为目标 Bolt 版本兼容的格式，特别是对于 DateTime 和 DateTimeZoneId。
    *   `out_pss_sptr`: 输出参数，将被填充为一个新创建的、包含序列化数据的 `std::shared_ptr<PackStreamStructure>`。这个 `shared_ptr` 可以包装在 `Value` 中用于更高层的消息构造。
    *   **返回值**: `BoltError::SUCCESS` 或错误码。

*   **示例函数**:
    *   `to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   ... (其他类型的对应函数)

### C. 从 `Value` 到强类型的便捷模板 (`value_to_typed_struct`)

为了简化从一个通用的 `boltprotocol::Value`（它可能持有一个 `std::shared_ptr<PackStreamStructure>`）到强类型结构的转换，提供了一个模板函数：

*   **函数签名**:
    ```cpp
    // 主要版本，用于需要版本和/或补丁信息的类型
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct, 
        const boltprotocol::versions::Version& bolt_version, 
        bool utc_patch_active_for_4_4 = false // 默认为false
    );

    // 重载版本，用于不需要版本或补丁信息的简单类型 (如 BoltDate)
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct
    );
    ```
*   **行为**:
    1.  检查 `value` 是否确实持有一个 `std::shared_ptr<PackStreamStructure>`。
    2.  如果是，并且指针非空，则调用相应的 `from_packstream` 重载。
    3.  返回 `from_packstream` 的结果。
*   **使用示例**:
    ```cpp
    // 假设 record_field 是从 RecordMessageParams::fields 中获取的一个 Value
    // boltprotocol::Value record_field = ...;
    // boltprotocol::versions::Version current_bolt_version = ...;
    // bool is_utc_patch_active_for_4_4 = ...; // (例如从会话状态获取)

    boltprotocol::BoltNode node;
    boltprotocol::BoltError err_node = boltprotocol::value_to_typed_struct(record_field, node, current_bolt_version);
    if (err_node == boltprotocol::BoltError::SUCCESS) {
        // 使用 node
    }

    boltprotocol::BoltDate date_obj;
    boltprotocol::BoltError err_date = boltprotocol::value_to_typed_struct(record_field, date_obj); // Date转换不需要版本
    if (err_date == boltprotocol::BoltError::SUCCESS) {
        // 使用 date_obj
    }

    boltprotocol::BoltDateTime datetime_obj;
    // DateTime 转换需要版本，并且如果 bolt_version 是 4.4，还需要 utc_patch_active_for_4_4
    boltprotocol::BoltError err_dt = boltprotocol::value_to_typed_struct(record_field, datetime_obj, current_bolt_version, is_utc_patch_active_for_4_4);
    if (err_dt == boltprotocol::BoltError::SUCCESS) {
        // 使用 datetime_obj (注意，from_packstream for DateTime/ZoneId 本身是基于标签的，utc_patch主要影响to_packstream)
        // 但提供版本信息给from_packstream总是个好习惯，以防未来有更细微的版本依赖。
    }
    ```

## 版本和补丁的注意事项

*   **图元版本**: `BoltNode`, `BoltRelationship`, `BoltUnboundRelationship` 的字段（特别是 `element_id` 相关的）在 Bolt 5.0 中有变化。它们的转换函数需要 `bolt_version` 参数。
*   **DateTime 和 DateTimeZoneId**:
    *   Bolt 5.0 引入了新的结构 (tag 'I' 和 'i') 取代了遗留的结构 (tag 'F' 和 'f')。
    *   Bolt 4.4 版本可以通过 `HELLO` 消息协商 `"utc"` 补丁来使用新的（现代的）结构。
    *   `from_packstream` 函数会根据读取到的 PackStream Structure 的**标签**来决定按现代还是遗留格式解析。
    *   `to_packstream` 函数则需要 `bolt_version` 和 `utc_patch_active_for_4_4` (当版本为4.4时) 参数来决定序列化为哪种格式（现代还是遗留）。
    *   **遗留 `DateTimeZoneId` (tag 'f') 的复杂性**: 将其 `seconds` 字段（它是本地调整过的秒数）正确转换为纯 UTC 秒数，或者从纯 UTC 秒数和 `tz_id` 正确构造出遗留格式所需的本地调整秒数，都需要访问时区数据库 (TZDB)。本库不包含 TZDB，因此在处理遗留 `DateTimeZoneId` 时存在固有的不精确性，相关函数实现中已包含注释说明。

通过使用这些强类型结构和转换函数，可以极大地简化应用程序与 Bolt 协议中这些常见数据结构交互的复杂性，并提高代码的类型安全性和可读性。
```

---

**7. `Base/Protocol/BoltProtocol/Document/07-error-handling.md`** (已在上一轮提供，保持不变)
**8. `Base/Protocol/BoltProtocol/Document/08-versioning.md`** (已在上一轮提供，保持不变)

这些文档应该能让用户在不直接查阅头文件的情况下，理解如何使用库的核心功能，包括特定结构类型的处理。好的，这是第七个文档文件 `07-error-handling.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/07-error-handling.md`**

```markdown
# BoltProtocol 库错误处理

BoltProtocol 库采用基于返回值的错误处理机制，以确保与各种项目（包括不使用或有特定异常处理策略的项目）的良好集成性。所有可能失败的操作都会返回一个 `boltprotocol::BoltError` 枚举类型的值。

## 1. `boltprotocol::BoltError` 枚举

`BoltError` 枚举定义了库中可能发生的各种错误情况。它在头文件 `boltprotocol/bolt_errors_versions.h` 中定义（该头文件由聚合头文件 `boltprotocol/message_defs.h` 包含）。

以下是一些关键的错误码及其含义：

*   **`BoltError::SUCCESS` (值为 0)**:
    *   表示操作成功完成，没有发生错误。

*   **通用错误**:
    *   `BoltError::UNKNOWN_ERROR`: 发生了未分类或意外的错误。
    *   `BoltError::INVALID_ARGUMENT`: 提供给函数的参数无效（例如，空指针、超出范围的值）。
    *   `BoltError::OUT_OF_MEMORY`: 在操作过程中无法分配所需的内存。

*   **序列化/反序列化错误**:
    *   `BoltError::SERIALIZATION_ERROR`: 将 C++ 对象序列化为 PackStream 字节流时出错（例如，字符串过长、数据结构不符合规范）。
    *   `BoltError::DESERIALIZATION_ERROR`: 从 PackStream 字节流反序列化为 C++ 对象时出错（例如，数据格式损坏、意外的字节序列、数据不完整）。
    *   `BoltError::INVALID_MESSAGE_FORMAT`: 接收到的消息的 PackStream Structure 不符合预期（例如，消息标签错误、字段数量不正确、字段类型不匹配）。
    *   `BoltError::RECURSION_DEPTH_EXCEEDED`: 在解析或序列化深度嵌套的 PackStream 结构（如 List, Map, Structure）时，超出了库设定的最大递归深度，以防止栈溢出。
    *   `BoltError::MESSAGE_TOO_LARGE`: 尝试处理的消息（或其组成部分，如字符串）的大小超出了实现或协议的限制。

*   **网络与连接错误**:
    *   `BoltError::NETWORK_ERROR`: 底层网络流操作（读/写）失败。这可能表示连接已关闭、网络中断或其他 I/O 问题。

*   **握手 (Handshake) 错误**:
    *   `BoltError::HANDSHAKE_FAILED`: 握手过程总体失败。
    *   `BoltError::HANDSHAKE_NO_COMMON_VERSION`: 服务器不支持客户端提议的任何 Bolt 协议版本。
    *   `BoltError::HANDSHAKE_MAGIC_MISMATCH`: （理论上，如果实现此检查）客户端发送的魔法序列与 Bolt 协议不符。
    *   `BoltError::UNSUPPORTED_PROTOCOL_VERSION`: 服务器返回了一个无法识别或不支持的协议版本格式。

*   **分块 (Chunking) 错误**:
    *   `BoltError::CHUNK_TOO_LARGE`: （理论上）单个数据块声明的大小超过了允许的最大值 (65535 字节)。
    *   `BoltError::CHUNK_ENCODING_ERROR`: 在将消息编码为分块时发生内部错误。
    *   `BoltError::CHUNK_DECODING_ERROR`: 在从分块数据重组消息时发生错误（例如，块大小与实际数据不符）。

## 2. 检查函数返回值

库中绝大多数执行实际操作的函数（如序列化、反序列化、握手、分块读写）都会返回一个 `BoltError` 类型的值。**使用者必须检查这些函数的返回值，以确定操作是否成功。**

**标准用法**:
```cpp
#include "boltprotocol/message_defs.h" // For BoltError
#include <iostream>

// 假设 some_bolt_operation 是库中的一个函数
// boltprotocol::BoltError result = some_bolt_operation(args...);

// if (result != boltprotocol::BoltError::SUCCESS) {
//     std::cerr << "Bolt operation failed with error code: " 
//               << static_cast<int>(result) << std::endl;
//     // 在此根据具体的 result 值采取相应的错误处理措施，
//     // 例如记录日志、重试、关闭连接或向上传递错误。
// } else {
//     // 操作成功，可以继续。
// }
```

## 3. `PackStreamReader` 和 `PackStreamWriter` 的内部错误状态

`PackStreamReader` 和 `PackStreamWriter` 对象（以及 `ChunkedReader` 和 `ChunkedWriter`）内部维护一个错误状态。一旦在其操作过程中发生错误，它们的内部错误状态会被设置。后续对同一对象的读/写操作通常会立即失败，并返回之前记录的错误码（或一个新的相关错误码）。

您可以使用以下成员函数来查询这些对象的错误状态：

*   **`bool has_error() const;`**:
    *   如果对象内部已记录错误，则返回 `true`，否则返回 `false`。
*   **`boltprotocol::BoltError get_error() const;`**:
    *   返回对象内部记录的 `BoltError` 值。如果 `has_error()` 为 `false`，则此函数返回 `BoltError::SUCCESS`。

**使用示例**:
```cpp
#include "boltprotocol/packstream_writer.h"
#include "boltprotocol/message_defs.h" // For Value, BoltError
#include <vector>
#include <string>
#include <iostream>

// std::vector<uint8_t> buffer;
// boltprotocol::PackStreamWriter writer(buffer);
// boltprotocol::Value val1(std::string("test"));
// boltprotocol::Value val2(12345LL);

// writer.write(val1); // 假设第一次写入成功
// writer.write(val2); // 假设第二次写入也成功

// // 可以在一系列操作后检查最终状态
// if (writer.has_error()) {
//     boltprotocol::BoltError final_error = writer.get_error();
//     std::cerr << "PackStreamWriter encountered an error during operations: " 
//               << static_cast<int>(final_error) << std::endl;
// } else {
//     std::cout << "All PackStream writes successful." << std::endl;
// }
```
虽然每个单独的 `write` 或 `read` 操作都会返回错误码，但在执行了一系列操作后检查对象的整体错误状态也是一种有用的模式。

## 4. 关于 C++ 异常

BoltProtocol 库的设计目标是**不主动向上层调用者抛出 C++ 异常**。它通过返回 `BoltError` 枚举值来报告所有已知的操作失败。

然而，库的内部实现依赖于标准 C++ 库，例如 `std::vector`, `std::string`, `std::map` 的内存分配，以及流操作。在极端情况下（例如系统内存耗尽），这些标准库组件可能会抛出异常（最常见的是 `std::bad_alloc`）。

*   **库内部的异常捕获**: 本库会尽力在其内部实现中捕获由标准库操作（特别是内存分配）直接引起的常见异常，如 `std::bad_alloc`，并将其转换为相应的 `BoltError`（例如 `BoltError::OUT_OF_MEMORY`）返回给调用者。
*   **未捕获的异常**: 如果发生了库未能预见或捕获的异常，或者异常源于用户代码（例如，在提供给库的回调函数中，尽管本库目前不采用回调模式），则这些异常可能会传播到库的调用者之外。应用程序应具备处理此类情况的常规异常处理机制。

总而言之，您应该主要依赖检查 `BoltError` 返回值来处理本库的错误，而不是期望捕获来自本库的特定 C++ 异常。

## 5. 错误恢复策略 (上层应用的职责)

本库提供错误信息，但具体的错误恢复策略由使用本库的上层应用程序或驱动程序来决定。

*   **可恢复错误**: 某些错误可能是暂时的（例如，某些类型的 `BoltError::NETWORK_ERROR` 可能通过重试解决）。
*   **致命错误**: 许多错误，特别是与协议格式、序列化/反序列化相关的错误（如 `BoltError::INVALID_MESSAGE_FORMAT`, `BoltError::DESERIALIZATION_ERROR`）或严重的连接问题，通常被认为是致命的，至少对于当前的 Bolt 会话/连接而言。在这种情况下，推荐的策略通常是：
    1.  记录详细的错误信息。
    2.  安全地关闭当前的 Bolt 连接。
    3.  （可选）尝试建立一个新的连接和会话。
    4.  向上层或用户报告错误。

## 总结

*   **检查返回值**: 这是使用 BoltProtocol 库时最重要的错误处理步骤。
*   **理解错误码**: 熟悉 `BoltError` 枚举中不同值的含义。
*   **读写器状态**: 可以使用 `has_error()` 和 `get_error()` 检查读写器对象的累积错误状态。
*   **异常**: 库本身不抛出异常，但依赖的标准库在极端情况下可能抛出。

通过仔细处理 `BoltError` 返回值，您可以构建出能够稳健处理各种通信和数据处理问题的应用程序。
```好的，这是第八个文档文件 `08-versioning.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/08-versioning.md`**

```markdown
# Bolt 版本处理

Bolt 协议是一个多版本协议，客户端和服务器需要在通信开始时通过握手过程协商一个共同支持的协议版本。这个协商得到的版本将决定后续消息交换的格式和行为。BoltProtocol 库提供了处理版本信息和版本相关逻辑的机制。

## 1. 版本表示 (`boltprotocol::versions::Version`)

Bolt 协议版本由 `boltprotocol::versions::Version` 结构体表示，其定义（在 `boltprotocol/bolt_errors_versions.h` 中，通过 `boltprotocol/message_defs.h` 聚合包含）如下：

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 主版本号
        uint8_t minor; // 次版本号

        // 默认构造函数 (通常初始化为 0.0 或无效状态)
        Version(); 

        // 构造特定版本，例如 Version(5, 4) 代表 Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        // 比较操作符
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;
        bool operator!=(const Version& other) const;
        // >=, >, <= 可以通过 < 和 == 组合实现，或显式提供

        // 用于握手：将版本对象转换为4字节大端序数组 (格式通常为 00 00 Major Minor)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 用于握手：从服务器响应的4字节数组解析版本对象
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    // 预定义的常见 Bolt 版本常量
    extern const Version V5_4; // (5,4)
    extern const Version V5_3; // (5,3)
    extern const Version V5_2; // (5,2)
    extern const Version V5_1; // (5,1)
    extern const Version V5_0; // (5,0)
    extern const Version V4_4; // (4,4)
    // ... 以及其他可能定义的版本

    // 获取库推荐的客户端提议版本列表
    extern const std::vector<Version>& get_default_proposed_versions();

} // namespace versions
} // namespace boltprotocol
```

您可以使用这些预定义的常量（如 `boltprotocol::versions::V5_4`）或构造自己的 `Version` 对象。比较操作符允许您轻松地判断版本的先后。

## 2. 握手与版本协商

连接建立后的第一步是**握手**，其目的是协商后续通信所使用的 Bolt 协议版本。详细的握手过程和 API 使用方法在 `03-handshake-and-chunking.md` 中有详细描述。

关键函数是 `boltprotocol::perform_handshake()`，它会：
1.  接收客户端希望提议的版本列表 (`std::vector<boltprotocol::versions::Version>`)。
2.  向服务器发送握手请求。
3.  接收服务器的响应。
4.  将服务器选择的、双方共同支持的版本填充到输出参数 `boltprotocol::versions::Version& out_negotiated_version` 中。

这个 `out_negotiated_version` **至关重要**，因为库中的许多后续操作（特别是消息的序列化和反序列化）都需要这个版本信息来确保与服务器的兼容性。

## 3. 版本对消息结构和行为的影响

Bolt 协议的许多方面都会随版本而演变。了解这些差异并使用协商得到的版本信息是正确实现 Bolt 通信的基础。本库在内部处理了许多这样的版本差异，但需要您在调用相关函数时提供正确的版本上下文。

主要受版本影响的方面包括：

*   **消息结构与字段**:
    *   **`HELLO` 消息**:
        *   Bolt 5.1 之前：认证信息（scheme, principal, credentials）在 HELLO 的 `extra` map 中。
        *   Bolt 5.1 及之后：认证信息移至单独的 `LOGON` 消息。
        *   Bolt 4.1+：`extra` map 中可包含 `routing` 字典。
        *   Bolt 4.3-4.4：`extra` map 中可包含 `patch_bolt` 列表 (如 `"utc"`)。
        *   Bolt 5.2+：`extra` map 中可包含 `notifications_minimum_severity` 和 `notifications_disabled_categories`。
        *   Bolt 5.3+：`extra` map 中**必须**包含 `bolt_agent` 字典。
    *   **`RUN` 和 `BEGIN` 消息**: 其 `extra` map 中可包含的字段（如 `db`, `imp_user`, `tx_timeout`, `mode`, `bookmarks`, `notifications_...`）在不同 Bolt 版本中被引入。
    *   **`PULL` 和 `DISCARD` 消息**:
        *   Bolt 4.0 之前：被称为 `PULL_ALL` 和 `DISCARD_ALL`，其 PackStream Structure 没有字段。
        *   Bolt 4.0 及之后：重命名为 `PULL` 和 `DISCARD`，其 PackStream Structure 包含一个 `extra` map 字段，该 map 包含 `n` 和 `qid` 参数。
    *   **`ROUTE` 消息**:
        *   Bolt 4.3：PackStream Structure 的第三个字段是 `db` (String 或 Null)。
        *   Bolt 4.4 及之后：PackStream Structure 的第三个字段是一个 `extra` Map (可包含 `db`, `imp_user`)。
    *   **`LOGON`, `LOGOFF`, `TELEMETRY`**: 这些消息是在特定 Bolt 版本之后才引入的。

*   **PackStream 特定结构体字段**:
    *   例如，`BoltNode`, `BoltRelationship`, `BoltUnboundRelationship` 结构体中的 `element_id` 相关字段是在 Bolt 5.0 中添加的。
    *   `BoltDateTime` 和 `BoltDateTimeZoneId` 结构：Bolt 5.0 引入了新的、修正了问题的结构 (标签 'I', 'i')，取代了旧的遗留结构 (标签 'F', 'f')。Bolt 4.4 版本可以通过协商 `"utc"` patch 来使用新的结构。

*   **服务器行为**:
    *   例如，服务器对 `ROUTE` 消息的响应（特别是 `rt` 路由表中的 `db` 字段）在 Bolt 4.4 中有变化。
    *   服务器对 `SUCCESS` 和 `FAILURE` 消息 `metadata` 中返回的字段也随版本演变（例如 `FAILURE` 中的 `gql_status` 在 Bolt 5.7+ 引入）。

## 4. 在 BoltProtocol 库中使用版本信息

为了处理上述版本差异，本库的许多 API 都要求传递协商得到的 `boltprotocol::versions::Version` 对象。

*   **客户端消息序列化**:
    *   `serialize_hello_message(params, writer, client_target_version)`: `client_target_version` 指示客户端希望或能够支持的最高版本，用于构造符合该版本预期的 HELLO 消息。
    *   `serialize_run_message(params, writer, negotiated_version)`
    *   `serialize_begin_message(params, writer, negotiated_version)`
    *   `serialize_route_message(params, writer, negotiated_version)`
    *   这些函数会使用 `negotiated_version` 来决定序列化哪些可选字段或采用哪种结构。

*   **服务器端请求消息反序列化**:
    *   `deserialize_hello_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_run_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_begin_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_pull_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_discard_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_route_message_request(reader, out_params, server_negotiated_version)`
    *   这些函数使用 `server_negotiated_version` 来正确解析和填充参数结构体。

*   **特定 PackStream 结构转换**:
    *   `from_packstream(pss, out_node, bolt_version)`
    *   `to_packstream(node, bolt_version, out_pss)`
    *   `to_packstream(datetime, bolt_version, utc_patch_active_for_4_4, out_pss)`
    *   这些函数使用版本信息（以及 `utc_patch_active_for_4_4` 标志）来处理结构字段的版本差异和 DateTime/DateTimeZoneId 的现代/遗留格式选择。

## 5. 上层应用的职责

使用本 BoltProtocol 库的上层应用（如驱动程序或服务器）需要：

1.  **执行握手**: 在连接建立后立即调用 `perform_handshake`。
2.  **存储协商版本**: 保存 `perform_handshake` 返回的 `negotiated_version`。
3.  **传递版本信息**: 在调用本库中依赖版本的序列化、反序列化或结构转换函数时，正确传递存储的 `negotiated_version`。
4.  **处理服务器能力**: 对于 `HELLO` 的 `SUCCESS` 响应，解析其 `metadata` 中的 `patch_bolt` 列表（以确定如 "utc" patch 是否激活）和 `hints`/`configuration_hints`（以了解服务器的特定能力，如对 ROUTE V2 上下文的支持）。这些信息将指导上层应用如何构造后续消息的参数（例如，如何填充 `RouteMessageParams` 的 `routing_table_context`，或在调用 `to_packstream` 时传递 `utc_patch_active_for_4_4` 标志）。

## 总结

Bolt 协议的版本控制是其核心特性之一。本库通过要求在关键 API 中传递协商版本信息，并在内部逻辑中根据此版本进行调整，来支持与不同版本 Bolt 服务器的兼容通信。正确管理和使用版本信息是上层应用程序确保互操作性的关键。
```#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "client_example_session.h"  // For ClientSession struct
#include "client_example_utils.h"    // For print_bolt_error_details_client if main directly reports an error

// Include new transaction step headers
#include "boltprotocol/message_defs.h"  // For BoltError, Value
#include "client_example_tx_begin.h"
#include "client_example_tx_commit.h"
#include "client_example_tx_pull.h"
#include "client_example_tx_run.h"

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Client Example (No-Exception, Refactored TX)" << std::endl;
    std::cout << "-----------------------------------------------------------" << std::endl;

    ClientSession session;  // Manages streams, negotiated_version, last_error

    // --- 0. Perform Handshake ---
    std::cout << "\n--- Performing Handshake ---" << std::endl;
    if (session.perform_handshake_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- 1. Client Sends HELLO Message ---
    std::cout << "\n--- Client Sending HELLO ---" << std::endl;
    if (session.send_hello_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- Transaction Block ---
    std::cout << "\n--- Starting Transaction Block ---" << std::endl;
    if (ClientTransaction::begin_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }

    int64_t query_id = -1;
    std::string test_query = "CREATE (a:Person {name: 'Alice'}) RETURN id(a)";
    std::map<std::string, Value> test_params;

    // std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl; // Moved into function
    if (ClientTransaction::run_query_in_transaction(session, test_query, test_params, query_id) != BoltError::SUCCESS) {
        // Consider ROLLBACK here
        session.send_goodbye_sequence();
        return 1;
    }

    if (query_id != -1) {
        std::vector<RecordMessageParams> records;
        // std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << query_id << " ---" << std::endl; // Moved
        if (ClientTransaction::pull_all_results_in_transaction(session, query_id, records) != BoltError::SUCCESS) {
            session.send_goodbye_sequence();
            return 1;
        }
        std::cout << "Client: PULL sequence successful. Received " << records.size() << " records." << std::endl;
        for (const auto& record_param : records) {
            std::cout << "  Record: ";
            for (const auto& field_value : record_param.fields) {
                if (std::holds_alternative<int64_t>(field_value)) {
                    std::cout << std::get<int64_t>(field_value) << " ";
                } else if (std::holds_alternative<std::string>(field_value)) {
                    std::cout << "\"" << std::get<std::string>(field_value) << "\" ";
                } else {
                    std::cout << "[type_idx:" << field_value.index() << "] ";
                }
            }
            std::cout << std::endl;
        }
    } else {
        std::cout << "Client: No valid qid from RUN, or qid indicates no results to pull. Skipping PULL." << std::endl;
    }

    // std::cout << "\n--- Client Sending COMMIT ---" << std::endl; // Moved
    if (ClientTransaction::commit_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }
    std::cout << "--- Transaction Block Finished ---" << std::endl;

    // --- 5. Client Sends GOODBYE ---
    std::cout << "\n--- Client Sending GOODBYE ---" << std::endl;
    if (session.send_goodbye_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    std::cout << "\nClient example finished successfully." << std::endl;
    return 0;
}// Base/Protocol/BoltProtocol/Example/client_example_session.cpp
#include "client_example_session.h"

#include <array>  // For std::array in manual handshake simulation

#include "boltprotocol/bolt_errors_versions.h"
#include "boltprotocol/message_defs.h"

// Anonymous namespace for implementation details or helpers local to this file
namespace {

    boltprotocol::BoltError prepare_hello_message_bytes(const boltprotocol::versions::Version& target_version, std::vector<uint8_t>& out_bytes) {
        using namespace boltprotocol;
        using versions::V5_1;
        using versions::V5_3;

        out_bytes.clear();
        PackStreamWriter ps_writer(out_bytes);

        HelloMessageParams hello_params;
        bool prep_ok = true;
        try {
            hello_params.user_agent = DEFAULT_USER_AGENT_FORMAT_STRING + " (Bolt " + std::to_string(target_version.major) + "." + std::to_string(target_version.minor) + ")";

            if (target_version < V5_1) {
                hello_params.auth_scheme = "basic";
                hello_params.auth_principal = "neo4j";
                hello_params.auth_credentials = "password";
            }

            if (target_version == V5_3 || !(target_version < V5_3)) {  // Equivalent to target_version >= V5_3
                HelloMessageParams::BoltAgentInfo agent_info;
                agent_info.product = "MyExampleClientLib/0.1";
                agent_info.platform = "Cpp/LinuxGeneric";
                hello_params.bolt_agent = agent_info;
            }

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc HELLO params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc HELLO params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep HELLO params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return BoltError::UNKNOWN_ERROR;

        BoltError err = serialize_hello_message(hello_params, ps_writer, target_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing HELLO", err, nullptr, &ps_writer);
        }
        return err;
    }

}  // anonymous namespace

boltprotocol::BoltError ClientSession::perform_handshake_sequence() {
    using namespace boltprotocol;
    client_to_server_stream.clear();  // Clear flags
    client_to_server_stream.str("");  // Clear content
    server_to_client_stream.clear();  // Clear flags
    server_to_client_stream.str("");  // Clear content

    std::vector<versions::Version> proposed_versions = versions::get_default_proposed_versions();
    if (proposed_versions.empty()) {
        print_bolt_error_details_client("perform_handshake_sequence: proposed_versions empty", BoltError::INVALID_ARGUMENT);
        last_error = BoltError::INVALID_ARGUMENT;
        return last_error;
    }

    // Simulate server choosing the first proposed version
    versions::Version server_chosen_version_sim = proposed_versions[0];
    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_b = server_chosen_version_sim.to_handshake_bytes();
    server_to_client_stream.write(reinterpret_cast<const char*>(server_response_b.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    server_to_client_stream.seekg(0);  // Rewind for client to read

    // For std::stringstream, we need to pass them directly to a perform_handshake
    // that is overloaded or templated to accept std::istream and std::ostream.
    // The current template `perform_handshake(SyncReadWriteStream& stream, ...)`
    // will not work directly with two separate std::stringstream.
    // The previous attempt to call it with two std::stringstream instances was due to a
    // misunderstanding of the template after it was changed from (ostream, istream, ...) form.

    // Since client_example uses std::stringstream, and perform_handshake is now
    // templated for a single SyncReadWriteStream (which std::stringstream does not model
    // in the way Boost.ASIO sockets do, e.g. no write_some/read_some for asio::write/read free functions),
    // we must manually implement the handshake byte exchange for the example.
    // OR, we could create a simple wrapper for std::stringstream that *does* satisfy
    // SyncReadWriteStream, but that's more involved for just an example.

    std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes_content;
    last_error = build_handshake_request(proposed_versions, handshake_request_bytes_content);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Building handshake request for example", last_error);
        return last_error;
    }

    client_to_server_stream.write(reinterpret_cast<const char*>(handshake_request_bytes_content.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
    if (client_to_server_stream.fail()) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Writing handshake to client_to_server_stream", last_error);
        return last_error;
    }
    client_to_server_stream.flush();  // Ensure it's "sent"

    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes_read;
    server_to_client_stream.read(reinterpret_cast<char*>(server_response_bytes_read.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    if (server_to_client_stream.fail() || static_cast<size_t>(server_to_client_stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Reading handshake response from server_to_client_stream", last_error);
        return last_error;
    }

    last_error = parse_handshake_response(server_response_bytes_read, negotiated_version);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Example: Parsing handshake response", last_error);
        return last_error;
    }

    std::cout << "Client: Handshake successful! Negotiated version: " << static_cast<int>(negotiated_version.major) << "." << static_cast<int>(negotiated_version.minor) << std::endl;
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_hello_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    last_error = prepare_hello_message_bytes(negotiated_version, raw_message_bytes_storage);
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = simulate_server_simple_success_response(server_to_client_stream, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("HELLO resp empty", BoltError::DESERIALIZATION_ERROR);
        last_error = BoltError::DESERIALIZATION_ERROR;
        return last_error;
    }
    SuccessMessageParams hello_success_params;
    {
        PackStreamReader hello_response_reader(raw_response_bytes_storage);
        last_error = deserialize_success_message(hello_response_reader, hello_success_params);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser HELLO SUCCESS", last_error, &hello_response_reader);
            return last_error;
        }
    }
    std::cout << "Client: HELLO SUCCESS deserialized." << std::endl;
    auto it_conn_id = hello_success_params.metadata.find("connection_id");
    if (it_conn_id != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_conn_id->second))) {
            std::cout << "Client: Received connection_id: " << *str_val << std::endl;
        }
    }
    auto it_server_agent = hello_success_params.metadata.find("server");
    if (it_server_agent != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_server_agent->second))) {
            std::cout << "Client: Server agent: " << *str_val << std::endl;
        }
    }
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_goodbye_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        last_error = serialize_goodbye_message(ps_writer);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing GOODBYE", last_error, nullptr, &ps_writer);
            return last_error;
        }
    }
    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "GOODBYE", false);
    if (last_error != BoltError::SUCCESS) {
        return last_error;
    }
    std::cout << "Client: GOODBYE sent." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_SESSION_H
#define CLIENT_EXAMPLE_SESSION_H

#include <array>  // For handshake
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For helpers

struct ClientSession {
    std::stringstream client_to_server_stream;
    std::stringstream server_to_client_stream;
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError last_error = boltprotocol::BoltError::SUCCESS;

    ClientSession() = default;

    boltprotocol::BoltError perform_handshake_sequence();
    boltprotocol::BoltError send_hello_sequence();
    boltprotocol::BoltError send_goodbye_sequence();
};

#endif  // CLIENT_EXAMPLE_SESSION_H#include "client_example_tx_begin.h"

#include "boltprotocol/message_serialization.h"  // For serialize_begin_message
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For simulate_server_simple_success_response, send_and_receive_raw_message_client

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending BEGIN ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            BeginMessageParams begin_params;
            // Populate begin_params with specific fields if needed, e.g., based on session.negotiated_version
            // begin_params.tx_timeout = 5000; // Example
            session.last_error = serialize_begin_message(begin_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing BEGIN", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("BEGIN resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams begin_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, begin_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser BEGIN SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: BEGIN SUCCESS deserialized." << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_BEGIN_H
#define CLIENT_EXAMPLE_TX_BEGIN_H

#include "boltprotocol/message_defs.h"  // For BoltError
#include "client_example_session.h"     // For ClientSession

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_BEGIN_H#include "client_example_tx_commit.h"

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending COMMIT ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            session.last_error = serialize_commit_message(ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing COMMIT", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("COMMIT resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams commit_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, commit_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser COMMIT SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: COMMIT SUCCESS deserialized." << std::endl;
        // Check for bookmark from commit_success_params.metadata if needed
        auto it_bookmark = commit_success_params.metadata.find("bookmark");
        if (it_bookmark != commit_success_params.metadata.end()) {
            if (const auto* str_val = std::get_if<std::string>(&(it_bookmark->second))) {
                std::cout << "Client: Received bookmark from COMMIT: " << *str_val << std::endl;
            }
        }
        return BoltError::SUCCESS;
    }

    // Implement rollback_transaction here if needed in the future
    /*
    boltprotocol::BoltError rollback_transaction(ClientSession& session) {
        // ... similar to commit_transaction but sends ROLLBACK and expects SUCCESS
        return BoltError::SUCCESS;
    }
    */

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_COMMIT_H
#define CLIENT_EXAMPLE_TX_COMMIT_H

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session);
    // boltprotocol::BoltError rollback_transaction(ClientSession& session); // For future

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_COMMIT_H#include "client_example_tx_pull.h"

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server sending a RECORD message
    boltprotocol::BoltError simulate_server_record_response(std::stringstream& server_pipe, const std::vector<boltprotocol::Value>& record_fields) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            RecordMessageParams rec_p;
            try {
                rec_p.fields = record_fields;  // Copy
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            PackStreamStructure pss_rec_obj;
            pss_rec_obj.tag = static_cast<uint8_t>(MessageTag::RECORD);
            std::shared_ptr<BoltList> list_sptr;
            try {
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(rec_p.fields);
                pss_rec_obj.fields.emplace_back(Value(list_sptr));
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            std::shared_ptr<PackStreamStructure> pss_rec_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_rec_obj));
            if (!pss_rec_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_rec_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RECORD", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RECORD", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RECORD response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_pull_message_bytes;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_records.clear();

        std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << qid << " ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_pull_message_bytes);
            PullMessageParams pull_params;
            pull_params.n = -1;  // PULL ALL
            if (qid != -1) {     // qid is mandatory for PULL in explicit transaction
                pull_params.qid = qid;
            } else {
                // This is an issue if qid is expected.
                print_bolt_error_details_client("PULL: qid is -1, which is invalid for explicit TX PULL", BoltError::INVALID_ARGUMENT);
                session.last_error = BoltError::INVALID_ARGUMENT;
                return session.last_error;
            }

            session.last_error = serialize_pull_message(pull_params, ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing PULL", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        bool first_pull_interaction = true;
        bool has_more_server_says = true;

        while (has_more_server_says) {
            // --- Simulate Server Response for PULL ---
            // This simulation sends one record, then a SUCCESS summary.
            // A real server might send many records before a SUCCESS with has_more:true,
            // or end with has_more:false.
            if (first_pull_interaction) {
                // Simulate server sending one RECORD
                std::vector<Value> record_data;
                try {
                    record_data.emplace_back(Value(static_cast<int64_t>(12345)));
                }  // Dummy ID
                catch (...) {
                    session.last_error = BoltError::OUT_OF_MEMORY;
                    return session.last_error;
                }
                session.last_error = simulate_server_record_response(session.server_to_client_stream, record_data);
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            } else {
                // After the first (and only in this sim) record, server sends SUCCESS summary
                // Simulate has_more:false to end the loop.
                // In a real scenario, server might send SUCCESS with has_more:true if there are more batches.
                session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "PULL summary (final)", qid);
                // To make it more realistic, the success response should include "has_more":false
                // We'd need to modify simulate_server_simple_success_response or use a more specific one.
                // For now, our client loop will break when it gets a SUCCESS.
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            }

            // --- Client Sends PULL (first time) and Receives Response ---
            std::vector<uint8_t> message_to_send_this_iteration;
            if (first_pull_interaction) {
                message_to_send_this_iteration = raw_pull_message_bytes;
            }

            session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, message_to_send_this_iteration, raw_response_bytes_storage, first_pull_interaction ? "PULL (for RECORD)" : "PULL (for summary)");
            if (session.last_error != BoltError::SUCCESS) return session.last_error;
            first_pull_interaction = false;

            if (raw_response_bytes_storage.empty()) {
                print_bolt_error_details_client("PULL response empty", BoltError::DESERIALIZATION_ERROR);
                session.last_error = BoltError::DESERIALIZATION_ERROR;
                return session.last_error;
            }

            // --- Client Deserializes Response ---
            Value peek_value;
            PackStreamStructure received_pss;  // To store the actual structure
            {
                PackStreamReader peek_reader(raw_response_bytes_storage);
                // We need to get the actual PSS, not just the shared_ptr from Value for tag checking.
                BoltError temp_err = deserialize_message_structure_prelude(peek_reader, MessageTag::HELLO, 0, 1, received_pss);  // Tag doesn't matter for just getting fields
                if (peek_reader.has_error() && temp_err == BoltError::SUCCESS) temp_err = peek_reader.get_error();               // ensure err state is from reader if prelude was ok

                if (temp_err != BoltError::SUCCESS && temp_err != BoltError::INVALID_MESSAGE_FORMAT) {  // Allow tag mismatch
                    print_bolt_error_details_client("Peeking PULL response structure", temp_err, &peek_reader);
                    session.last_error = temp_err;
                    return session.last_error;
                }
                // If it was INVALID_MESSAGE_FORMAT due to tag, that's fine, we check tag below.
                // If it was another error (e.g. not a PSS at all), that's a problem.
                if (!peek_reader.has_error() && received_pss.fields.empty() && received_pss.tag == 0) {  // deserialize_message_structure_prelude failed to get a PSS
                    print_bolt_error_details_client("Peeking PULL response: not a valid PSS", BoltError::DESERIALIZATION_ERROR, &peek_reader);
                    session.last_error = BoltError::DESERIALIZATION_ERROR;
                    return session.last_error;
                }
            }

            if (static_cast<MessageTag>(received_pss.tag) == MessageTag::RECORD) {
                RecordMessageParams rec_params;
                PackStreamReader record_reader(raw_response_bytes_storage);
                session.last_error = deserialize_record_message(record_reader, rec_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing RECORD from PULL", session.last_error, &record_reader);
                    return session.last_error;
                }
                out_records.push_back(std::move(rec_params));
                std::cout << "Client: RECORD deserialized from PULL." << std::endl;
                // Check for "has_more" in record metadata if present (uncommon, usually in SUCCESS)
                // For this simulation, we assume has_more_server_says is true until SUCCESS says otherwise
            } else if (static_cast<MessageTag>(received_pss.tag) == MessageTag::SUCCESS) {
                SuccessMessageParams summary_params;
                PackStreamReader summary_reader(raw_response_bytes_storage);
                session.last_error = deserialize_success_message(summary_reader, summary_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing SUCCESS summary from PULL", session.last_error, &summary_reader);
                    return session.last_error;
                }
                std::cout << "Client: PULL summary SUCCESS deserialized." << std::endl;

                // Check for "has_more" in the SUCCESS metadata
                auto it_has_more = summary_params.metadata.find("has_more");
                if (it_has_more != summary_params.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more_server_says = std::get<bool>(it_has_more->second);
                    std::cout << "Client: PULL summary has_more=" << (has_more_server_says ? "true" : "false") << std::endl;
                } else {
                    has_more_server_says = false;  // If not present, assume no more (Bolt 3 behavior)
                    std::cout << "Client: PULL summary 'has_more' not found or not bool, assuming false." << std::endl;
                }
            } else {
                print_bolt_error_details_client("PULL response unexpected PSS tag: " + std::to_string(received_pss.tag), BoltError::INVALID_MESSAGE_FORMAT);
                session.last_error = BoltError::INVALID_MESSAGE_FORMAT;
                return session.last_error;
            }
        }
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_PULL_H
#define CLIENT_EXAMPLE_TX_PULL_H

#include <vector>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_PULL_H#include "client_example_tx_run.h"

#include "boltprotocol/chunking.h"  // For ChunkedWriter if server sim uses it directly
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server RUN response (SUCCESS with fields and qid)
    // This could also live in client_example_utils.cpp if it's more general
    boltprotocol::BoltError simulate_server_run_response_fields(std::stringstream& server_pipe, const std::vector<std::string>& field_names, int64_t qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            SuccessMessageParams fields_s_p;
            bool prep_ok = true;
            try {
                auto fields_list_sptr = std::make_shared<BoltList>();
                for (const auto& field_name : field_names) {
                    fields_list_sptr->elements.emplace_back(Value(field_name));
                }
                fields_s_p.metadata.emplace("fields", Value(fields_list_sptr));
                if (qid != -1) {
                    fields_s_p.metadata.emplace("qid", Value(qid));
                }
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields alloc", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc Sim Srv: RUN SUCCESS fields: " << e.what() << std::endl;
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields stdexc", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                return BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return BoltError::UNKNOWN_ERROR;

            PackStreamStructure pss_obj;
            pss_obj.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            std::shared_ptr<BoltMap> meta_map_sptr;
            try {
                meta_map_sptr = std::make_shared<BoltMap>();
                meta_map_sptr->pairs = std::move(fields_s_p.metadata);
                pss_obj.fields.emplace_back(Value(meta_map_sptr));
            } catch (...) {
                return BoltError::UNKNOWN_ERROR; /* Simplified error */
            }

            std::shared_ptr<PackStreamStructure> pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj));
            if (!pss_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RUN SUCCESS fields", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        // Prime server_pipe with the response
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RUN SUCCESS fields", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RUN SUCCESS (fields, qid=" << qid << ") response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params, int64_t& out_qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_qid = -1;

        std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            RunMessageParams run_params;
            bool prep_ok = true;
            try {
                run_params.cypher_query = query;
                run_params.parameters = params;
                // Example of setting specific extra fields for RUN
                // run_params.db = "mydb"; // If appropriate for the version
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("alloc RUN_IN_TX params", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                session.last_error = BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc RUN_IN_TX params: " << e.what() << std::endl;
                print_bolt_error_details_client("prep RUN_IN_TX params", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                session.last_error = BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return session.last_error;

            session.last_error = serialize_run_message(run_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing RUN_IN_TX", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        int64_t simulated_qid = 2;                              // Server would generate this
        std::vector<std::string> simulated_fields = {"id(a)"};  // Match "CREATE (a:Person {name: 'Alice'}) RETURN id(a)"
        session.last_error = simulate_server_run_response_fields(session.server_to_client_stream, simulated_fields, simulated_qid);
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "RUN_IN_TX");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("RUN_IN_TX resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams run_in_tx_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, run_in_tx_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser RUN_IN_TX SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }

        auto it_qid = run_in_tx_success_params.metadata.find("qid");
        if (it_qid != run_in_tx_success_params.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
            out_qid = std::get<int64_t>(it_qid->second);
        } else {
            std::cout << "Client: Warning - qid not found or not int64 in RUN SUCCESS metadata for TX." << std::endl;
            // For auto-commit RUN, qid might not be present if no results are expected or version is old.
            // For explicit TX RUN, qid is usually expected.
        }
        std::cout << "Client: RUN_IN_TX SUCCESS (fields) deserialized. qid: " << out_qid << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_RUN_H
#define CLIENT_EXAMPLE_TX_RUN_H

#include <map>
#include <string>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params,
                                                     int64_t& out_qid);  // Output parameter for query ID

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_RUN_H#include "client_example_utils.h"

// Helper to print BoltError and associated reader/writer errors
void print_bolt_error_details_client(const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer, boltprotocol::ChunkedReader* chunk_reader, boltprotocol::ChunkedWriter* chunk_writer) {
    std::cerr << "Error (Client) " << context << ": " << static_cast<int>(err_code);
    if (reader && reader->has_error() && reader->get_error() != err_code) {
        std::cerr << " (PackStreamReader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err_code) {
        std::cerr << " (PackStreamWriter specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    if (chunk_reader && chunk_reader->has_error() && chunk_reader->get_error() != err_code) {
        std::cerr << " (ChunkedReader specific error: " << static_cast<int>(chunk_reader->get_error()) << ")";
    }
    if (chunk_writer && chunk_writer->has_error() && chunk_writer->get_error() != err_code) {
        std::cerr << " (ChunkedWriter specific error: " << static_cast<int>(chunk_writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

// Helper function to print a byte vector
void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}

// Simulate sending a raw message (PackStream bytes) via ChunkedWriter
// and receiving a raw response (PackStream bytes) via ChunkedReader.
boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response) {
    using namespace boltprotocol;
    BoltError err;

    // --- Client Sends Message ---
    std::cout << "Client: Preparing to send " << message_description_for_log << "..." << std::endl;
    print_bytes_client("Client: Raw " + message_description_for_log + " to send: ", raw_message_to_send);

    // Clear client_to_server_pipe for this message (caller responsibility to manage overall pipe lifetime)
    // For this helper, we assume it's okay to clear before writing.
    if (!raw_message_to_send.empty()) {  // Only clear if we are actually sending something
        client_to_server_pipe.clear();
        client_to_server_pipe.str("");
    }

    if (!raw_message_to_send.empty()) {  // Only write if there's a message
        ChunkedWriter chunk_writer(client_to_server_pipe);
        err = chunk_writer.write_message(raw_message_to_send);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("ChunkedWriter writing " + message_description_for_log, err, nullptr, nullptr, nullptr, &chunk_writer);
            return err;
        }
        std::cout << "Client: " << message_description_for_log << " written to client_to_server_pipe (chunked)." << std::endl;
    } else if (expect_response) {  // If sending nothing but expecting response (e.g. implicit PULL after RUN)
        std::cout << "Client: Sending no explicit message, but expecting response for " << message_description_for_log << "." << std::endl;
    } else {  // Sending nothing, expecting nothing
        std::cout << "Client: No message to send and no response expected for " << message_description_for_log << "." << std::endl;
    }

    // --- Client Receiving Response (if expected) ---
    if (!expect_response) {
        std::cout << "Client: No response expected for " << message_description_for_log << "." << std::endl;
        // Even if no response expected, server_pipe might have old data; clear it.
        server_to_client_pipe.clear();
        server_to_client_pipe.str("");
        return BoltError::SUCCESS;
    }

    std::cout << "Client: Waiting for server response to " << message_description_for_log << "..." << std::endl;
    // Check if the server pipe is empty *before* trying to read.
    // Need to peek to see if there's content, as str() doesn't reflect read position.
    server_to_client_pipe.peek();  // This updates EOF state if at end
    if (server_to_client_pipe.str().empty() && server_to_client_pipe.eof()) {
        std::cout << "Client: Server_to_client_pipe is empty and at EOF. No response to read for " << message_description_for_log << "." << std::endl;
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log + " (pipe was empty)", BoltError::NETWORK_ERROR);
        return BoltError::NETWORK_ERROR;
    }

    out_raw_response_received.clear();
    ChunkedReader chunk_reader(server_to_client_pipe);
    err = chunk_reader.read_message(out_raw_response_received);

    if (err != BoltError::SUCCESS) {
        // If read_message fails, it might be due to an empty pipe that wasn't caught above, or actual error.
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log, err, nullptr, nullptr, &chunk_reader);
        return err;
    }
    print_bytes_client("Client: Raw response received for " + message_description_for_log + ": ", out_raw_response_received);

    // Clear the server_to_client_pipe after successful read, ready for next simulated server response.
    server_to_client_pipe.clear();
    server_to_client_pipe.str("");

    return BoltError::SUCCESS;
}

// Helper to simulate server sending a simple SUCCESS {} response
boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid) {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_server_response_bytes;
    BoltError err;
    {
        PackStreamWriter ps_writer(raw_server_response_bytes);
        SuccessMessageParams success_p;
        bool prep_ok = true;
        try {
            if (qid != -1) {
                success_p.metadata.emplace("qid", Value(qid));
            }
            // Add other common success fields if needed for simulation
            // success_p.metadata.emplace("type", Value(std::string("r"))); // For query summary
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        PackStreamStructure success_pss;
        success_pss.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
        std::shared_ptr<BoltMap> meta_map_sptr;
        try {
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_p.metadata);  // Move if success_p not used after
            success_pss.fields.emplace_back(Value(meta_map_sptr));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS PSS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(success_pss));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS sptr: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr null", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        err = ps_writer.write(Value(std::move(pss_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing " + context_log + " SUCCESS", err, nullptr, &ps_writer);
            return err;
        }
    }
    // "Server" puts its response into the server_pipe
    server_pipe.clear();
    server_pipe.str("");  // Clear for this specific response
    {
        ChunkedWriter server_chunk_writer(server_pipe);
        err = server_chunk_writer.write_message(raw_server_response_bytes);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunk writing " + context_log + " SUCCESS", err, nullptr, nullptr, nullptr, &server_chunk_writer);
            return err;
        }
    }
    std::cout << "Server (Simulated): Sent " << context_log << " SUCCESS response." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_UTILS_H
#define CLIENT_EXAMPLE_UTILS_H

#include <cstdint>    // For uint8_t
#include <exception>  // For std::bad_alloc, std::exception
#include <iomanip>    // For std::setw, std::setfill
#include <iostream>
#include <map>     // For std::map
#include <memory>  // For std::shared_ptr, std::make_shared
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"  // Needed for PackStreamReader in print_bolt_error_details_client
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_client(
    const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr, boltprotocol::ChunkedReader* chunk_reader = nullptr, boltprotocol::ChunkedWriter* chunk_writer = nullptr);

void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes);

boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response = true);

boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid = -1);

#endif  // CLIENT_EXAMPLE_UTILS_H# CMakeLists.txt for BoltProtocol module examples

add_executable(client_example
    client_example_main.cpp
    client_example_utils.h
    client_example_utils.cpp
    client_example_session.h
    client_example_session.cpp
    # client_example_transaction.h # This header is now split
    # client_example_transaction.cpp # This source is now split
    client_example_tx_begin.h
    client_example_tx_begin.cpp
    client_example_tx_run.h
    client_example_tx_run.cpp
    client_example_tx_pull.h
    client_example_tx_pull.cpp
    client_example_tx_commit.h
    client_example_tx_commit.cpp
)
target_link_libraries(client_example PUBLIC BoltProtocol)

add_executable(server_example
    server_example_main.cpp
    server_example_utils.h
    server_example_utils.cpp
    server_example_handlers.h
    server_example_handlers.cpp
)
target_link_libraries(server_example PUBLIC BoltProtocol)#include "server_example_handlers.h"

#include <exception>
#include <optional>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version from bolt_errors_versions.h

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version) {
        using namespace boltprotocol;
        std::cout << "  Server processing HELLO message from: " << parsed_hello_params.user_agent << std::endl;
        if (parsed_hello_params.bolt_agent.has_value()) {
            std::cout << "    Bolt Agent Product: " << parsed_hello_params.bolt_agent.value().product << std::endl;
        }
        if (parsed_hello_params.auth_scheme.has_value()) {
            std::cout << "    Auth Scheme: " << parsed_hello_params.auth_scheme.value() << std::endl;
        }

        SuccessMessageParams success_for_hello_params;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;
        bool server_resp_ok = true;

        try {
            success_for_hello_params.metadata.emplace("connection_id", Value(std::string("server-conn-xyz")));
            success_for_hello_params.metadata.emplace("server", Value(std::string("MyExampleBoltServer/0.1 (Bolt ") + std::to_string(server_negotiated_version.major) + "." + std::to_string(server_negotiated_version.minor) + ")"));

            if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
                if (parsed_hello_params.patch_bolt.has_value()) {
                    for (const auto& patch : parsed_hello_params.patch_bolt.value()) {
                        if (patch == "utc") {
                            auto agreed_patches_list = std::make_shared<BoltList>();
                            agreed_patches_list->elements.emplace_back(Value(std::string("utc")));
                            success_for_hello_params.metadata.emplace("patch_bolt", Value(agreed_patches_list));
                            std::cout << "    Server agreed to 'utc' patch." << std::endl;
                            break;
                        }
                    }
                }
            }

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_for_hello_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));
            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("server HELLO SUCCESS resp (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            server_resp_ok = false;
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server HELLO SUCCESS resp: " << e_std.what() << std::endl;
            print_bolt_error_details_server("server HELLO SUCCESS resp (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            server_resp_ok = false;
            return BoltError::UNKNOWN_ERROR;
        }

        if (!server_resp_ok || !pss_to_write_sptr) {
            if (server_resp_ok && !pss_to_write_sptr) {
                print_bolt_error_details_server("server HELLO SUCCESS resp (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
            }
            return response_writer.get_error();
        }

        BoltError err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server serializing SUCCESS for HELLO", err, nullptr, &response_writer);
        }
        return err;
    }

    // handle_run_message now receives fully parsed RunMessageParams.
    // It no longer needs to deserialize from a raw PackStreamStructure itself.
    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Already parsed
                                               boltprotocol::PackStreamWriter& response_writer) {
        using namespace boltprotocol;
        std::cout << "  Server processing RUN query: '" << run_params.cypher_query << "'" << std::endl;

        // Access typed optional fields
        if (run_params.db.has_value()) {
            std::cout << "    For database: " << run_params.db.value() << std::endl;
        }
        if (run_params.tx_timeout.has_value()) {
            std::cout << "    With tx_timeout: " << run_params.tx_timeout.value() << "ms" << std::endl;
        }

        // Access cypher parameters
        auto limit_it = run_params.parameters.find("limit");
        if (limit_it != run_params.parameters.end()) {
            if (const auto* limit_val_ptr = std::get_if<int64_t>(&(limit_it->second))) {
                std::cout << "    With limit parameter: " << *limit_val_ptr << std::endl;
            }
        }
        // Access other_extra_fields if needed
        if (!run_params.other_extra_fields.empty()) {
            std::cout << "    With other extra fields:" << std::endl;
            for (const auto& pair : run_params.other_extra_fields) {
                std::cout << "      " << pair.first << ": (type " << pair.second.index() << ")" << std::endl;
            }
        }

        BoltError err = BoltError::SUCCESS;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<BoltList> list_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;

        // 1. Send SUCCESS for RUN (contains field names)
        try {
            SuccessMessageParams run_success_params;
            list_sptr = std::make_shared<BoltList>();
            list_sptr->elements.emplace_back(Value(std::string("name")));
            run_success_params.metadata.emplace("fields", Value(list_sptr));
            // Optionally add qid for explicit transactions, or t_first for auto-commit
            // run_success_params.metadata.emplace("t_first", Value(static_cast<int64_t>(10))); // Example

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();

            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(run_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing RUN SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing RUN SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing RUN SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing RUN SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS for RUN", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS for RUN (with fields)." << std::endl;

        // 2. Send RECORD messages (dummy data)
        for (int i = 0; i < 2; ++i) {
            try {
                RecordMessageParams record_params;
                record_params.fields.emplace_back(Value(std::string("Node " + std::to_string(i))));

                pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::RECORD);
                pss_obj_on_stack.fields.clear();
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(record_params.fields);
                pss_obj_on_stack.fields.emplace_back(Value(list_sptr));

                pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

            } catch (const std::bad_alloc&) {
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e_std) {
                std::cerr << "Std exception server preparing RECORD " << std::to_string(i) << ": " << e_std.what() << std::endl;
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
                response_writer.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }

            if (!pss_to_write_sptr) {
                print_bolt_error_details_server("preparing RECORD (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            }
            err = response_writer.write(Value(std::move(pss_to_write_sptr)));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_server("serializing RECORD " + std::to_string(i), err, nullptr, &response_writer);
                return err;
            }
            std::cout << "  Server sent RECORD " << i << "." << std::endl;
        }
        // 3. Send final SUCCESS (summary)
        try {
            SuccessMessageParams summary_success_params;
            summary_success_params.metadata.emplace("type", Value(std::string("r")));
            // For auto-commit that's now finished:
            // summary_success_params.metadata.emplace("bookmark", Value(std::string("neo4j:bookmark:v1:tx42")));
            // summary_success_params.metadata.emplace("has_more", Value(false)); // If Bolt 4.0+

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(summary_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing summary SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing summary SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing summary SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing summary SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS summary", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS summary." << std::endl;
        return BoltError::SUCCESS;
    }

    // This helper is no longer strictly needed if server_example_main.cpp directly uses
    // deserialize_run_message_request. If it were kept, it would need significant rework
    // to populate the new RunMessageParams structure correctly from a raw PackStreamStructure.
    // For now, let's comment it out as its functionality is superseded.
    /*
    boltprotocol::BoltError deserialize_run_params_from_struct(
        const boltprotocol::PackStreamStructure& run_struct,
        boltprotocol::RunMessageParams& out_params) {
        // ... This would need to parse run_struct.fields and populate the new
        //     std::optional members of out_params and other_extra_fields ...
        print_bolt_error_details_server("deserialize_run_params_from_struct is deprecated", boltprotocol::BoltError::UNKNOWN_ERROR);
        return boltprotocol::BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace ServerHandlers#ifndef SERVER_EXAMPLE_HANDLERS_H
#define SERVER_EXAMPLE_HANDLERS_H

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_utils.h"

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version);

    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Now receives fully parsed params
                                               boltprotocol::PackStreamWriter& response_writer
                                               // const boltprotocol::versions::Version& server_negotiated_version // Optional: if needed
    );

    // Removed deserialize_run_params_from_struct as its functionality is now
    // part of deserialize_run_message_request from the core library.

}  // namespace ServerHandlers

#endif  // SERVER_EXAMPLE_HANDLERS_H#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/bolt_errors_versions.h"  // For direct use of versions::V5_X
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_handlers.h"
#include "server_example_utils.h"

// Helper to simulate client sending a HELLO message
boltprotocol::BoltError simulate_client_hello(const boltprotocol::versions::Version& client_simulated_target_version, std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_hello_writer(out_raw_bytes);

    HelloMessageParams client_hello_params;
    bool client_prep_ok = true;
    try {
        client_hello_params.user_agent = "MyExampleCppClient/1.0 (Simulated)";

        if (client_simulated_target_version < versions::V5_1) {
            client_hello_params.auth_scheme = "basic";
            client_hello_params.auth_principal = "neo4j";
            client_hello_params.auth_credentials = "password";
        }
        if (!(client_simulated_target_version < versions::V5_3)) {  // client_simulated_target_version >= V5_3
            HelloMessageParams::BoltAgentInfo agent_info;
            agent_info.product = "SimulatedClientDriver/0.5";
            client_hello_params.bolt_agent = agent_info;
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim HELLO (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim HELLO: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim HELLO (std::exception)", BoltError::UNKNOWN_ERROR);
        client_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_prep_ok) return BoltError::UNKNOWN_ERROR;

    BoltError err = serialize_hello_message(client_hello_params, client_hello_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing HELLO", err, nullptr, &client_hello_writer);
    }
    return err;
}

// Helper to simulate client sending a RUN message
boltprotocol::BoltError simulate_client_run(const boltprotocol::versions::Version& client_simulated_target_version,  // Added version
                                            std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_run_writer(out_raw_bytes);
    RunMessageParams client_run_params;
    bool client_run_prep_ok = true;
    try {
        client_run_params.cypher_query = "MATCH (n) RETURN n.name AS name LIMIT $limit";
        client_run_params.parameters.emplace("limit", Value(static_cast<int64_t>(5)));
        // Example: Populate some typed extra fields if simulating a client that sends them
        if (client_simulated_target_version.major >= 4) {
            client_run_params.db = "system";
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim RUN (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_run_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim RUN: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim RUN (std::exception)", BoltError::UNKNOWN_ERROR);
        client_run_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_run_prep_ok) return BoltError::UNKNOWN_ERROR;

    // Pass the target version for RUN serialization
    BoltError err = serialize_run_message(client_run_params, client_run_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing RUN", err, nullptr, &client_run_writer);
    }
    return err;
}

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Server Example (Refactored, No-Exception Mode)" << std::endl;
    std::cout << "------------------------------------------------------------" << std::endl;

    std::vector<uint8_t> server_receive_buffer_storage;
    std::vector<uint8_t> server_send_buffer_storage;
    BoltError err = BoltError::SUCCESS;

    versions::Version server_assumed_negotiated_version = versions::V5_3;  // Example version server operates as

    std::cout << "\nServer expecting HELLO message (simulating client targeting v" << static_cast<int>(server_assumed_negotiated_version.major) << "." << static_cast<int>(server_assumed_negotiated_version.minor) << ") ..." << std::endl;

    err = simulate_client_hello(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for HELLO (raw): ", server_receive_buffer_storage);

    HelloMessageParams actual_hello_params;
    {
        PackStreamReader hello_reader(server_receive_buffer_storage);
        err = deserialize_hello_message_request(hello_reader, actual_hello_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing HELLO request", err, &hello_reader);
            return 1;
        }
    }
    std::cout << "Server: HELLO message structure received and parsed." << std::endl;
    std::cout << "  User Agent from HELLO: " << actual_hello_params.user_agent << std::endl;
    if (actual_hello_params.bolt_agent.has_value()) {
        std::cout << "  Bolt Agent Product: " << actual_hello_params.bolt_agent.value().product << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter success_hello_writer(server_send_buffer_storage);
        err = ServerHandlers::handle_hello_message(actual_hello_params, success_hello_writer, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending SUCCESS (for HELLO) (raw): ", server_send_buffer_storage);

    // === Stage 2: Client sends RUN, Server processes and responds ===
    std::cout << "\nServer expecting RUN message..." << std::endl;
    // Client also simulates RUN targeting the assumed negotiated version
    err = simulate_client_run(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for RUN (raw): ", server_receive_buffer_storage);

    RunMessageParams actual_run_params;
    {
        PackStreamReader run_reader(server_receive_buffer_storage);
        // Server deserializes RUN based on the version it negotiated
        err = deserialize_run_message_request(run_reader, actual_run_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing RUN request", err, &run_reader);
            return 1;
        }
    }
    std::cout << "Server: RUN message structure received and parsed." << std::endl;
    if (actual_run_params.db.has_value()) {
        std::cout << "  RUN request for database: " << actual_run_params.db.value() << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter run_response_writer(server_send_buffer_storage);
        // Pass the negotiated version to the handler if it needs to make version-specific decisions
        // For now, handle_run_message doesn't use it, but good practice.
        err = ServerHandlers::handle_run_message(actual_run_params, run_response_writer /*, server_assumed_negotiated_version */);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending full response stream for RUN (raw): ", server_send_buffer_storage);

    std::cout << "\nServer example finished." << std::endl;
    return 0;
}#include "server_example_utils.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer) {
    std::cerr << "Error (Server) " << context << ": " << static_cast<int>(err);
    if (reader && reader->has_error() && reader->get_error() != err) {
        std::cerr << " (Reader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err) {
        std::cerr << " (Writer specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}#ifndef SERVER_EXAMPLE_UTILS_H
#define SERVER_EXAMPLE_UTILS_H

#include <cstdint>  // For uint8_t
#include <iomanip>  // For std::setw, std::setfill
#include <iostream>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr);

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes);

#endif  // SERVER_EXAMPLE_UTILS_H#ifndef BOLTPROTOCOL_CORE_TYPES_H
#define BOLTPROTOCOL_CORE_TYPES_H

#include <cstdint>  // For uintXX_t types
#include <map>
#include <memory>  // For std::shared_ptr
#include <string>
#include <variant>  // For std::variant
#include <vector>

// Forward declarations within this file if mutually dependent, or include necessary headers
// For now, PackStreamStructure, BoltList, BoltMap are defined before Value uses them with shared_ptr.

namespace boltprotocol {

    // Forward declarations for Value variant members
    struct BoltList;
    struct BoltMap;
    struct PackStreamStructure;

    // Core PackStream Value type
    using Value = std::variant<std::nullptr_t, bool, int64_t, double, std::string, std::shared_ptr<BoltList>, std::shared_ptr<BoltMap>, std::shared_ptr<PackStreamStructure> >;

    // Definition for BoltList
    struct BoltList {
        std::vector<Value> elements;
        bool operator==(const BoltList& other) const {
            // Simple comparison, might need deep comparison for shared_ptr<Value> elements if Value itself can be complex.
            // Current Value::operator== handles shared_ptr comparison correctly.
            return elements == other.elements;
        }
    };

    // Definition for BoltMap
    struct BoltMap {
        std::map<std::string, Value> pairs;
        bool operator==(const BoltMap& other) const {
            return pairs == other.pairs;
        }
    };

    // Definition for PackStreamStructure
    struct PackStreamStructure {
        uint8_t tag = 0;
        std::vector<Value> fields;
        bool operator==(const PackStreamStructure& other) const {
            return tag == other.tag && fields == other.fields;
        }
    };

    // Global operator== for Value, needs full definitions of BoltList, BoltMap, PackStreamStructure
    // This declaration should ideally be where Value is fully defined or usable.
    // If moved to a .cpp, it needs to be declared here.
    // Keeping it here for header-only convenience if types are simple enough.
    // bool operator==(const Value& lhs, const Value& rhs); // Definition will be in message_defs.cpp (or a new core_types.cpp)

    // Global Constants
    constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;
    // extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING; // Declaration here, definition in a .cpp file
    constexpr uint16_t MAX_CHUNK_PAYLOAD_SIZE = 65535;
    constexpr uint16_t CHUNK_HEADER_SIZE = 2;

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CORE_TYPES_H#ifndef BOLTPROTOCOL_ERRORS_VERSIONS_H
#define BOLTPROTOCOL_ERRORS_VERSIONS_H

#include <array>
#include <cstdint>
#include <string>  // For Version::to_string (建议添加)
#include <vector>

namespace boltprotocol {

    enum class BoltError {
        SUCCESS = 0,
        UNKNOWN_ERROR,
        INVALID_ARGUMENT,
        SERIALIZATION_ERROR,
        DESERIALIZATION_ERROR,
        INVALID_MESSAGE_FORMAT,
        UNSUPPORTED_PROTOCOL_VERSION,
        NETWORK_ERROR,
        HANDSHAKE_FAILED,
        HANDSHAKE_NO_COMMON_VERSION,
        HANDSHAKE_MAGIC_MISMATCH,
        CHUNK_TOO_LARGE,
        CHUNK_ENCODING_ERROR,
        CHUNK_DECODING_ERROR,
        OUT_OF_MEMORY,
        RECURSION_DEPTH_EXCEEDED,
        MESSAGE_TOO_LARGE
    };

    namespace versions {
        struct Version {
            uint8_t major = 0;
            uint8_t minor = 0;

            Version() = default;
            constexpr Version(uint8_t maj, uint8_t min) : major(maj), minor(min) {
            }

            // 核心比较操作符
            bool operator<(const Version& other) const;
            bool operator==(const Version& other) const;

            // 从核心操作符派生的其他比较操作符
            bool operator!=(const Version& other) const;
            bool operator>(const Version& other) const;
            bool operator<=(const Version& other) const;
            bool operator>=(const Version& other) const;

            std::string to_string() const;  // 便于调试

            std::array<uint8_t, 4> to_handshake_bytes() const;
            static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
        };

        // 声明版本常量
        extern const Version V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3;  // 确保 V4_3 也被声明
        // extern const Version V4_2, V4_1, V4_0, V3_0;

        // 声明函数以获取默认建议版本
        extern const std::vector<Version>& get_default_proposed_versions();
    }  // namespace versions

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_ERRORS_VERSIONS_H#ifndef BOLTPROTOCOL_MESSAGE_PARAMS_H
#define BOLTPROTOCOL_MESSAGE_PARAMS_H

#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Message Parameter Structures ---

    struct HelloMessageParams {
        std::string user_agent;
        std::optional<std::string> auth_scheme;
        std::optional<std::string> auth_principal;
        std::optional<std::string> auth_credentials;
        std::optional<std::map<std::string, Value>> auth_scheme_specific_tokens;  // For complex schemes like custom
        std::optional<std::map<std::string, Value>> routing_context;
        std::optional<std::vector<std::string>> patch_bolt;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        struct BoltAgentInfo {
            std::string product;
            std::optional<std::string> platform;
            std::optional<std::string> language;
            std::optional<std::string> language_details;
        };
        std::optional<BoltAgentInfo> bolt_agent;
        std::map<std::string, Value> other_extra_tokens;  // For any other non-standard tokens
    };

    struct RunMessageParams {
        std::string cypher_query;
        std::map<std::string, Value> parameters;
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the implicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the implicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt < 5.0)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct DiscardMessageParams {
        std::optional<int64_t> n;    // Number of records to discard (-1 for all)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct PullMessageParams {
        std::optional<int64_t> n;    // Number of records to pull (-1 for all remaining in current batch context)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct BeginMessageParams {
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the explicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the explicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt 5.0+)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct CommitMessageParams { /* PSS field is an empty map {} */
    };
    struct RollbackMessageParams { /* PSS field is an empty map {} */
    };

    struct RouteMessageParams {
        std::map<std::string, Value> routing_table_context;
        std::vector<std::string> bookmarks;
        std::optional<std::string> db_name_for_v43;  // Bolt 4.3: db (String or null)
        // Bolt 4.4+: extra map (can contain "db" and/or "imp_user")
        // Bolt 5.1+: extra map can also contain "notifications_min_severity", "notifications_disabled_categories"
        std::optional<std::map<std::string, Value>> extra_for_v44_plus;
    };

    struct TelemetryMessageParams {
        std::map<std::string, Value> metadata;  // api (int)
    };
    struct LogonMessageParams {
        std::map<std::string, Value> auth_tokens;
    };
    struct LogoffMessageParams { /* No fields */
    };

    struct SuccessMessageParams {
        std::map<std::string, Value> metadata;
    };
    struct RecordMessageParams {
        std::vector<Value> fields;
    };
    struct FailureMessageParams {
        std::map<std::string, Value> metadata;  // code (String), message (String)
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_PARAMS_H#ifndef BOLTPROTOCOL_MESSAGE_TAGS_H
#define BOLTPROTOCOL_MESSAGE_TAGS_H

#include <cstdint>

namespace boltprotocol {

    enum class MessageTag : uint8_t {
        HELLO = 0x01,
        RUN = 0x10,
        DISCARD = 0x2F,
        PULL = 0x3F,
        BEGIN = 0x11,
        COMMIT = 0x12,
        ROLLBACK = 0x13,
        RESET = 0x0F,
        GOODBYE = 0x02,
        ROUTE = 0x66,
        TELEMETRY = 0x54,
        LOGON = 0x6A,
        LOGOFF = 0x6B,
        SUCCESS = 0x70,
        RECORD = 0x71,
        IGNORED = 0x7E,
        FAILURE = 0x7F,
        // INIT = 0x01, // Same as HELLO tag
        // ACK_FAILURE = 0x0E // Bolt v1/v2 only
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_TAGS_H#ifndef BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H
#define BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_structure_types.h"

namespace boltprotocol {

    // --- Conversion from PackStreamStructure to Typed Struct ---

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    // For from_packstream, utc_patch_active might not be strictly needed if we rely on the tag ('I' vs 'F') primarily.
    // However, for to_packstream, it's crucial for Bolt 4.4.
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);

    // --- Conversion from Typed Struct to PackStreamStructure ---

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);               // <--- MODIFIED
    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);  // <--- MODIFIED
    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss);

    // Convenience template to extract from Value
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct, const versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Dispatch to the correct from_packstream overload based on T
        if constexpr (std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId> || std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath>) {
            // These types' from_packstream take bolt_version.
            // For DateTime/DateTimeZoneId, utc_patch_active is not directly used by from_packstream (tag driven).
            return from_packstream(*pss_sptr, out_typed_struct, bolt_version);
        } else {
            // For types like BoltDate, BoltTime, etc., that don't need bolt_version for from_packstream.
            return from_packstream(*pss_sptr, out_typed_struct);
        }
    }
    // Keep the overload for types not needing version or patch info for deserialization (tag-driven)
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // This simple overload is suitable for types whose from_packstream does not need a version.
        // For version-dependent types, the other overload must be used.
        return from_packstream(*pss_sptr, out_typed_struct);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H#ifndef BOLTPROTOCOL_STRUCTURE_TYPES_H
#define BOLTPROTOCOL_STRUCTURE_TYPES_H

#include <cstdint>
#include <map>
#include <memory>  // For std::shared_ptr in Path
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"  // For Value, BoltMap, BoltList, PackStreamStructure
// bolt_errors_versions.h might be needed if version checks are done during construction/conversion
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Graph Primitives ---

    // Tag: 0x4E ('N')
    struct BoltNode {
        int64_t id;                               // Field 0: id (Integer)
        std::vector<std::string> labels;          // Field 1: labels (List<String>)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        // Default constructor
        BoltNode() : id(0) {
        }

        bool operator==(const BoltNode& other) const {
            return id == other.id && labels == other.labels && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x52 ('R')
    struct BoltRelationship {
        int64_t id;                                        // Field 0: id (Integer)
        int64_t start_node_id;                             // Field 1: startNodeId (Integer)
        int64_t end_node_id;                               // Field 2: endNodeId (Integer)
        std::string type;                                  // Field 3: type (String)
        std::map<std::string, Value> properties;           // Field 4: properties (Map)
        std::optional<std::string> element_id;             // Field 5: element_id (String, Bolt 5.0+)
        std::optional<std::string> start_node_element_id;  // Field 6: start_node_element_id (String, Bolt 5.0+)
        std::optional<std::string> end_node_element_id;    // Field 7: end_node_element_id (String, Bolt 5.0+)

        BoltRelationship() : id(0), start_node_id(0), end_node_id(0) {
        }

        bool operator==(const BoltRelationship& other) const {
            return id == other.id && start_node_id == other.start_node_id && end_node_id == other.end_node_id && type == other.type && properties == other.properties && element_id == other.element_id && start_node_element_id == other.start_node_element_id &&
                   end_node_element_id == other.end_node_element_id;
        }
    };

    // Tag: 0x72 ('r') - Unbound Relationship (used within Path)
    struct BoltUnboundRelationship {
        int64_t id;                               // Field 0: id (Integer)
        std::string type;                         // Field 1: type (String)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        BoltUnboundRelationship() : id(0) {
        }

        bool operator==(const BoltUnboundRelationship& other) const {
            return id == other.id && type == other.type && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x50 ('P')
    struct BoltPath {
        std::vector<BoltNode> nodes;                // Field 0: nodes (List<Node>)
        std::vector<BoltUnboundRelationship> rels;  // Field 1: rels (List<UnboundRelationship>)
        std::vector<int64_t> indices;               // Field 2: indices (List<Integer>)
        // Note: For Path, nodes and rels are lists of *actual* BoltNode/BoltUnboundRelationship objects,
        // not shared_ptr<PackStreamStructure>. The conversion logic will handle this.

        bool operator==(const BoltPath& other) const {
            return nodes == other.nodes && rels == other.rels && indices == other.indices;
        }
    };

    // --- Temporal Types ---

    // Tag: 0x44 ('D') - Date
    struct BoltDate {
        int64_t days_since_epoch;  // days since Unix epoch (1970-01-01)

        BoltDate(int64_t days = 0) : days_since_epoch(days) {
        }
        bool operator==(const BoltDate& other) const {
            return days_since_epoch == other.days_since_epoch;
        }
    };

    // Tag: 0x54 ('T') - Time (with offset)
    struct BoltTime {
        int64_t nanoseconds_since_midnight;  // nanoseconds since midnight for the given offset
        int32_t tz_offset_seconds;           // offset in seconds from UTC

        BoltTime(int64_t nanos = 0, int32_t offset = 0) : nanoseconds_since_midnight(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x74 ('t') - LocalTime
    struct BoltLocalTime {
        int64_t nanoseconds_since_midnight;

        BoltLocalTime(int64_t nanos = 0) : nanoseconds_since_midnight(nanos) {
        }
        bool operator==(const BoltLocalTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight;
        }
    };

    // Tag: 0x49 ('I') - DateTime (with offset, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTime (tag 0x46 'F')
    struct BoltDateTime {
        int64_t seconds_epoch_utc;      // seconds since Unix epoch (UTC)
        int32_t nanoseconds_of_second;  // nanoseconds within the second (0 to 999,999,999)
        int32_t tz_offset_seconds;      // offset in seconds from UTC for the original instant

        BoltDateTime(int64_t secs = 0, int32_t nanos = 0, int32_t offset = 0) : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltDateTime& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x69 ('i') - DateTimeZoneId (with named zone, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTimeZoneId (tag 0x66 'f')
    struct BoltDateTimeZoneId {
        int64_t seconds_epoch_utc;
        int32_t nanoseconds_of_second;
        std::string tz_id;  // Timezone ID string (e.g., "Europe/Paris")

        BoltDateTimeZoneId(int64_t secs = 0, int32_t nanos = 0, std::string id = "") : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_id(std::move(id)) {
        }
        bool operator==(const BoltDateTimeZoneId& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_id == other.tz_id;
        }
    };

    // Tag: 0x64 ('d') - LocalDateTime
    struct BoltLocalDateTime {
        int64_t seconds_epoch_local;  // seconds since Unix epoch, interpreted as local datetime
        int32_t nanoseconds_of_second;

        BoltLocalDateTime(int64_t secs = 0, int32_t nanos = 0) : seconds_epoch_local(secs), nanoseconds_of_second(nanos) {
        }
        bool operator==(const BoltLocalDateTime& other) const {
            return seconds_epoch_local == other.seconds_epoch_local && nanoseconds_of_second == other.nanoseconds_of_second;
        }
    };

    // Tag: 0x45 ('E') - Duration
    struct BoltDuration {
        int64_t months;
        int64_t days;
        int64_t seconds;
        int32_t nanoseconds;  // nanoseconds adjustment for seconds component

        BoltDuration(int64_t m = 0, int64_t d = 0, int64_t s = 0, int32_t ns = 0) : months(m), days(d), seconds(s), nanoseconds(ns) {
        }
        bool operator==(const BoltDuration& other) const {
            return months == other.months && days == other.days && seconds == other.seconds && nanoseconds == other.nanoseconds;
        }
    };

    // --- Spatial Types ---

    // Tag: 0x58 ('X') - Point2D
    struct BoltPoint2D {
        uint32_t srid;  // Spatial Reference System Identifier
        double x;
        double y;

        BoltPoint2D(uint32_t id = 0, double px = 0.0, double py = 0.0) : srid(id), x(px), y(py) {
        }
        bool operator==(const BoltPoint2D& other) const {
            return srid == other.srid && x == other.x && y == other.y;
        }
    };

    // Tag: 0x59 ('Y') - Point3D
    struct BoltPoint3D {
        uint32_t srid;
        double x;
        double y;
        double z;

        BoltPoint3D(uint32_t id = 0, double px = 0.0, double py = 0.0, double pz = 0.0) : srid(id), x(px), y(py), z(pz) {
        }
        bool operator==(const BoltPoint3D& other) const {
            return srid == other.srid && x == other.x && y == other.y && z == other.z;
        }
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_TYPES_H#ifndef BOLTPROTOCOL_CHUNKING_H
#define BOLTPROTOCOL_CHUNKING_H

#include <cstdint>
#include <functional>  // For std::function
#include <iosfwd>      // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE

namespace boltprotocol {

    /**
     * @brief ChunkedWriter 用于将完整的 Bolt 消息分块写入输出流。
     */
    class ChunkedWriter {
      public:
        explicit ChunkedWriter(std::ostream& stream);

        // 禁止拷贝和移动，因为其持有流的引用
        ChunkedWriter(const ChunkedWriter&) = delete;
        ChunkedWriter& operator=(const ChunkedWriter&) = delete;
        ChunkedWriter(ChunkedWriter&&) = delete;
        ChunkedWriter& operator=(ChunkedWriter&&) = delete;

        /**
         * @brief 将提供的完整消息数据分块写入流。
         *        会自动添加块头和末尾的空块。
         * @param message_data 包含单个完整 Bolt 消息的字节向量。
         * @return BoltError::SUCCESS 如果所有块都成功写入。
         *         BoltError::NETWORK_ERROR 如果流写入失败。
         *         BoltError::SERIALIZATION_ERROR 如果内部逻辑错误（例如块大小计算）。
         */
        BoltError write_message(const std::vector<uint8_t>& message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }

        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError write_chunk(const uint8_t* data, uint16_t size);
        BoltError write_chunk_header(uint16_t chunk_payload_size);
        BoltError write_end_of_message_marker();  // Writes a zero-size chunk

        void set_error(BoltError err);

        std::ostream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
    };

    /**
     * @brief ChunkedReader 用于从输入流中读取分块的 Bolt 消息。
     */
    class ChunkedReader {
      public:
        explicit ChunkedReader(std::istream& stream);

        // 禁止拷贝和移动
        ChunkedReader(const ChunkedReader&) = delete;
        ChunkedReader& operator=(const ChunkedReader&) = delete;
        ChunkedReader(ChunkedReader&&) = delete;
        ChunkedReader& operator=(ChunkedReader&&) = delete;

        /**
         * @brief 从流中读取一个完整的 Bolt 消息。
         *        它会持续读取数据块，直到遇到表示消息结束的空块。
         * @param out_message_data 输出参数，用于存储组装好的完整消息字节。
         *                         如果发生错误，此参数的内容未定义。
         * @return BoltError::SUCCESS 如果成功读取并组装了一个完整的消息。
         *         BoltError::NETWORK_ERROR 如果流读取失败。
         *         BoltError::DESERIALIZATION_ERROR 如果块格式无效或消息过大。
         *         BoltError::CHUNK_TOO_LARGE 如果单个块的声明大小超过 MAX_CHUNK_PAYLOAD_SIZE.
         */
        BoltError read_message(std::vector<uint8_t>& out_message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }
        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError read_chunk_header(uint16_t& out_chunk_payload_size);
        BoltError read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to);

        void set_error(BoltError err);

        std::istream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
        // 可以在这里添加一个内部缓冲区来优化小块的读取，但为了简单起见，暂时直接追加到输出向量
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CHUNKING_H#ifndef BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H
#define BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H

#include <map>
#include <memory>  // For std::shared_ptr
#include <optional>
#include <string>
#include <variant>  // For std::holds_alternative, std::get
#include <vector>

#include "boltprotocol/bolt_core_types.h"       // For Value, BoltList, BoltMap, PackStreamStructure
#include "boltprotocol/bolt_errors_versions.h"  // For versions::Version, BoltError
#include "boltprotocol/bolt_structure_types.h"  // For forward declaring BoltNode etc. if needed, or full defs for recursion

// Forward declare from_packstream for recursive calls in get_typed_list_field
namespace boltprotocol {
    // We need to forward declare all from_packstream overloads that might be called recursively
    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);
}  // namespace boltprotocol

namespace boltprotocol {
    namespace detail {

        template <typename T>
        inline std::optional<T> get_typed_field(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<T>(field_value)) {
                    try {
                        return std::get<T>(field_value);
                    } catch (const std::bad_variant_access&) { /* Defensive */
                    }
                }
            }
            return std::nullopt;
        }

        // Specialization for shared_ptr<BoltMap> to return the inner map directly
        template <>
        inline std::optional<std::map<std::string, Value>> get_typed_field<std::map<std::string, Value>>(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltMap>>(field_value)) {
                    const auto& map_sptr = std::get<std::shared_ptr<BoltMap>>(field_value);
                    if (map_sptr) {
                        try {
                            return map_sptr->pairs;
                        } catch (...) { /* map copy failed */
                        }
                    }
                }
            }
            return std::nullopt;
        }

        template <typename T>  // T is the target strong type, e.g., BoltNode
        inline std::optional<std::vector<T>> get_typed_list_field(const std::vector<Value>& fields, size_t index, const versions::Version* bolt_version_for_nested = nullptr) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltList>>(field_value)) {
                    const auto& list_sptr = std::get<std::shared_ptr<BoltList>>(field_value);
                    if (list_sptr) {
                        std::vector<T> result;
                        result.reserve(list_sptr->elements.size());
                        bool conversion_ok = true;
                        for (const auto& list_element_value : list_sptr->elements) {
                            if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(list_element_value)) {
                                const auto& element_pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(list_element_value);
                                if (element_pss_sptr) {
                                    T typed_element;
                                    BoltError err = BoltError::UNKNOWN_ERROR;  // Initialize to an error state

                                    // Dispatch based on type T for version parameter
                                    if constexpr (std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath> || std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId>) {
                                        if (!bolt_version_for_nested) {  // Version is required for these types
                                            conversion_ok = false;
                                            break;
                                        }
                                        err = from_packstream(*element_pss_sptr, typed_element, *bolt_version_for_nested);
                                    } else {  // For types like BoltDate, BoltTime, etc., that don't need version for from_packstream
                                        err = from_packstream(*element_pss_sptr, typed_element);
                                    }

                                    if (err == BoltError::SUCCESS) {
                                        try {
                                            result.push_back(std::move(typed_element));
                                        } catch (...) {
                                            conversion_ok = false;
                                            break;
                                        }
                                    } else {
                                        conversion_ok = false;
                                        break;
                                    }
                                } else {
                                    conversion_ok = false;
                                    break;
                                }  // Null PSS in list
                            } else {
                                conversion_ok = false;
                                break;
                            }  // Element not a PSS
                        }
                        if (conversion_ok) return result;
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H#ifndef BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H
#define BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H

#include <algorithm>  // For std::reverse
#include <bit>        // For std::endian (C++20 and later)
#include <cstdint>
#include <type_traits>  // For std::is_integral_v, std::is_enum_v

namespace boltprotocol {
    namespace detail {

        // Helper to swap bytes of an integer type T
        template <typename T>
        inline T swap_bytes_helper(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "swap_bytes_helper requires an integral or enum type.");
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
            auto* bytes = reinterpret_cast<unsigned char*>(&value);
            std::reverse(bytes, bytes + sizeof(T));
            return value;
        }

        // --- Host to Big Endian (Network Order) ---
        inline uint16_t host_to_be(uint16_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {  // std::endian::big (or other, assuming network order is what we want if not little)
                return val;
            }
        }

        inline uint32_t host_to_be(uint32_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        inline uint64_t host_to_be(uint64_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        // --- Big Endian (Network Order) to Host ---
        inline uint16_t be_to_host(uint16_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint32_t be_to_host(uint32_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint64_t be_to_host(uint64_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H#ifndef BOLTPROTOCOL_HANDSHAKE_H
#define BOLTPROTOCOL_HANDSHAKE_H

#include <array>
#include <boost/asio/basic_socket_iostream.hpp>  // For boost::asio::basic_socket_iostream
#include <boost/asio/ip/tcp.hpp>                 // For boost::asio::ip::tcp
#include <boost/asio/read.hpp>
#include <boost/asio/ssl/stream.hpp>  // For boost::asio::ssl::stream
#include <boost/asio/write.hpp>
#include <boost/system/error_code.hpp>
#include <cstdint>
#include <cstring>  // For std::memcpy
#include <istream>  // For std::istream characteristics if needed
#include <ostream>  // For std::ostream characteristics if needed
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"

namespace boltprotocol {

    constexpr size_t HANDSHAKE_NUM_PROPOSED_VERSIONS = 4;
    constexpr size_t HANDSHAKE_VERSION_SIZE_BYTES = 4;
    constexpr size_t HANDSHAKE_REQUEST_SIZE_BYTES = sizeof(BOLT_MAGIC_PREAMBLE) + (HANDSHAKE_NUM_PROPOSED_VERSIONS * HANDSHAKE_VERSION_SIZE_BYTES);
    constexpr size_t HANDSHAKE_RESPONSE_SIZE_BYTES = HANDSHAKE_VERSION_SIZE_BYTES;

    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes);
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response, versions::Version& out_negotiated_version);

    template <typename StreamType>
    BoltError perform_handshake(StreamType& stream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version) {
        std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes;
        BoltError build_err = build_handshake_request(proposed_versions, handshake_request_bytes);
        if (build_err != BoltError::SUCCESS) {
            return build_err;
        }

        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes;
        boost::system::error_code ec;

        // 使用 if constexpr 根据 StreamType 选择不同的 IO 操作
        if constexpr (std::is_base_of_v<std::basic_iostream<char>, StreamType> &&
                      // 进一步区分 basic_socket_iostream 和其他可能继承 std::iostream 的 Boost 类型
                      (std::is_same_v<StreamType, boost::asio::ip::tcp::iostream> || std::is_same_v<StreamType, boost::asio::basic_socket_iostream<boost::asio::ip::tcp>>)) {
            // 这是 boost::asio::ip::tcp::iostream 或其基类 basic_socket_iostream
            // 使用标准的 iostream 成员函数
            stream.write(reinterpret_cast<const char*>(handshake_request_bytes.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
            if (stream.fail()) return BoltError::NETWORK_ERROR;
            stream.flush();
            if (stream.fail()) return BoltError::NETWORK_ERROR;

            stream.read(reinterpret_cast<char*>(server_response_bytes.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
            if (stream.fail() || static_cast<size_t>(stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
                return BoltError::NETWORK_ERROR;
            }
        } else {
            // 假设是其他 Boost.ASIO 同步流类型，如 ssl::stream 或 ip::tcp::socket
            // 使用 boost::asio::write 和 boost::asio::read 自由函数
            boost::asio::write(stream, boost::asio::buffer(handshake_request_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }

            boost::asio::read(stream, boost::asio::buffer(server_response_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }
        }

        return parse_handshake_response(server_response_bytes, out_negotiated_version);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_HANDSHAKE_H#ifndef BOLTPROTOCOL_MESSAGE_DEFS_H
#define BOLTPROTOCOL_MESSAGE_DEFS_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_message_params.h"
#include "bolt_message_tags.h"
#include "bolt_structure_types.h"  // <--- ADDED: For BoltNode, BoltDate etc.
// bolt_structure_serialization.h is for functions, not direct types needed by message_params generally

namespace boltprotocol {
    extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING;
    bool operator==(const Value& lhs, const Value& rhs);
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_DEFS_H#ifndef BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H
#define BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    // --- Client Message Serialization (Client -> Server) ---
    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version);
    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_goodbye_message(PackStreamWriter& writer);
    BoltError serialize_reset_message(PackStreamWriter& writer);
    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_commit_message(PackStreamWriter& writer);
    BoltError serialize_rollback_message(PackStreamWriter& writer);
    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version);
    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logoff_message(PackStreamWriter& writer);

    // --- Server Message Deserialization (Server -> Client) ---
    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params);
    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params);
    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params);
    BoltError deserialize_ignored_message(PackStreamReader& reader);

    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents);

    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count);

    // --- Server-Side Deserialization of Client Requests ---
    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params);
    BoltError deserialize_logoff_message_request(PackStreamReader& reader);
    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version);

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version);        // <--- MODIFIED
    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- MODIFIED
    BoltError deserialize_commit_message_request(PackStreamReader& reader);
    BoltError deserialize_rollback_message_request(PackStreamReader& reader);
    BoltError deserialize_reset_message_request(PackStreamReader& reader);
    BoltError deserialize_goodbye_message_request(PackStreamReader& reader);
    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- ADDED
    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params);                                              // <--- ADDED

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H

#include <cstdint>

namespace boltprotocol {

    // PackStream Marker Bytes
    constexpr uint8_t MARKER_NULL = 0xC0;
    constexpr uint8_t MARKER_FALSE = 0xC2;
    constexpr uint8_t MARKER_TRUE = 0xC3;
    constexpr uint8_t MARKER_FLOAT64 = 0xC1;

    // Integer markers
    // Tiny Int: -16 to 127 directly encoded in the marker byte
    // INT_8:  0xC8 <int8>
    // INT_16: 0xC9 <int16>
    // INT_32: 0xCA <int32>
    // INT_64: 0xCB <int64>
    constexpr uint8_t MARKER_INT_8 = 0xC8;
    constexpr uint8_t MARKER_INT_16 = 0xC9;
    constexpr uint8_t MARKER_INT_32 = 0xCA;
    constexpr uint8_t MARKER_INT_64 = 0xCB;

    // String markers
    // TINY_STRING: 0x80..0x8F (length 0-15)
    // STRING_8:    0xD0 <len_uint8> <utf8_bytes>
    // STRING_16:   0xD1 <len_uint16> <utf8_bytes>
    // STRING_32:   0xD2 <len_uint32> <utf8_bytes>
    constexpr uint8_t MARKER_TINY_STRING_BASE = 0x80;  // Base for 0x80 | len
    constexpr uint8_t MARKER_STRING_8 = 0xD0;
    constexpr uint8_t MARKER_STRING_16 = 0xD1;
    constexpr uint8_t MARKER_STRING_32 = 0xD2;

    // List markers
    // TINY_LIST:   0x90..0x9F (size 0-15)
    // LIST_8:      0xD4 <size_uint8>
    // LIST_16:     0xD5 <size_uint16>
    // LIST_32:     0xD6 <size_uint32>
    constexpr uint8_t MARKER_TINY_LIST_BASE = 0x90;  // Base for 0x90 | size
    constexpr uint8_t MARKER_LIST_8 = 0xD4;
    constexpr uint8_t MARKER_LIST_16 = 0xD5;
    constexpr uint8_t MARKER_LIST_32 = 0xD6;

    // Map markers
    // TINY_MAP:    0xA0..0xAF (size 0-15)
    // MAP_8:       0xD8 <size_uint8>
    // MAP_16:      0xD9 <size_uint16>
    // MAP_32:      0xDA <size_uint32>
    constexpr uint8_t MARKER_TINY_MAP_BASE = 0xA0;  // Base for 0xA0 | size
    constexpr uint8_t MARKER_MAP_8 = 0xD8;
    constexpr uint8_t MARKER_MAP_16 = 0xD9;
    constexpr uint8_t MARKER_MAP_32 = 0xDA;

    // Structure markers
    // TINY_STRUCT: 0xB0..0xBF (size 0-15) <tag_uint8>
    // STRUCT_8:    0xDC <size_uint8> <tag_uint8>
    // STRUCT_16:   0xDD <size_uint16> <tag_uint8>
    constexpr uint8_t MARKER_TINY_STRUCT_BASE = 0xB0;  // Base for 0xB0 | size
    constexpr uint8_t MARKER_STRUCT_8 = 0xDC;
    constexpr uint8_t MARKER_STRUCT_16 = 0xDD;

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamReader {
      public:
        explicit PackStreamReader(const std::vector<uint8_t>& buffer);
        explicit PackStreamReader(std::istream& stream);

        // 禁止拷贝和移动以避免对内部状态和流/缓冲区的复杂管理
        PackStreamReader(const PackStreamReader&) = delete;
        PackStreamReader& operator=(const PackStreamReader&) = delete;
        PackStreamReader(PackStreamReader&&) = delete;
        PackStreamReader& operator=(PackStreamReader&&) = delete;

        /**
         * @brief Reads a single PackStream Value from the input.
         * @param out_value Output parameter where the read Value will be stored if successful.
         *                  Its content is undefined if an error occurs.
         * @return BoltError::SUCCESS on successful read.
         *         BoltError::DESERIALIZATION_ERROR for format errors, unexpected EOF, etc.
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if reader not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails.
         */
        BoltError read(Value& out_value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

        /**
         * @brief Checks if the end of the underlying buffer or stream has been reached.
         *        Also returns true if an error has occurred, as further reading is not possible.
         * @return True if EOF or error, false otherwise.
         */
        bool eof() const;

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError peek_byte(uint8_t& out_byte);
        BoltError consume_byte(uint8_t& out_byte);
        BoltError consume_bytes(void* dest, size_t size);

        template <typename T>
        BoltError consume_network_int(T& out_val) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "consume_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;  // 如果已处于错误状态，则不继续

            // 初始化 out_val 以防早期返回
            out_val = T{};
            BoltError err;

            if constexpr (sizeof(T) == 1) {
                uint8_t byte_val;
                err = consume_byte(byte_val);
                if (err != BoltError::SUCCESS) return err;
                out_val = static_cast<T>(byte_val);
                return BoltError::SUCCESS;
            } else {
                typename std::conditional<sizeof(T) == 2, uint16_t, typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type>::type raw_be_val = 0;

                err = consume_bytes(&raw_be_val, sizeof(raw_be_val));
                if (err != BoltError::SUCCESS) return err;

                if constexpr (sizeof(T) == 2) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint16_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 4) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint32_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 8) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint64_t>(raw_be_val)));
                } else {
                    static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for consume_network_int.");
                    set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                    return BoltError::INVALID_ARGUMENT;
                }
                return BoltError::SUCCESS;
            }
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的读取辅助函数 (现在返回 BoltError 并通过 out_value 输出参数返回结果)
        BoltError read_null_value(Value& out_value);
        BoltError read_boolean_value(bool bool_val_from_marker, Value& out_value);
        BoltError read_float64_value(Value& out_value);
        BoltError read_integer_value(uint8_t marker, Value& out_value);
        BoltError read_string_value(uint8_t marker, Value& out_value);
        BoltError read_string_data_into(std::string& out_string, uint32_t size);
        BoltError read_list_value(uint8_t marker, Value& out_value);
        BoltError read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size);
        BoltError read_map_value(uint8_t marker, Value& out_value);
        BoltError read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size);
        BoltError read_struct_value(uint8_t marker, Value& out_value);
        BoltError read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size);

        const std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::istream* stream_ptr_ = nullptr;
        size_t buffer_pos_ = 0;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器，用于防止解析恶意构造的数据时栈溢出
        // (在实际的 read_list/map/struct_elements_into 中使用)
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 可配置
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamWriter {
      public:
        explicit PackStreamWriter(std::vector<uint8_t>& buffer);
        explicit PackStreamWriter(std::ostream& stream);

        // 禁止拷贝和移动
        PackStreamWriter(const PackStreamWriter&) = delete;
        PackStreamWriter& operator=(const PackStreamWriter&) = delete;
        PackStreamWriter(PackStreamWriter&&) = delete;
        PackStreamWriter& operator=(PackStreamWriter&&) = delete;

        /**
         * @brief Writes a single PackStream Value to the output.
         * @param value The Value to serialize and write.
         * @return BoltError::SUCCESS on successful write.
         *         BoltError::SERIALIZATION_ERROR for logical errors (e.g., string too long).
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if writer not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails (e.g. vector resize).
         */
        BoltError write(const Value& value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError append_byte(uint8_t byte);
        BoltError append_bytes(const void* data, size_t size);

        template <typename T>
        BoltError append_network_int(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "append_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;

            BoltError err;
            if constexpr (sizeof(T) == 1) {
                err = append_byte(static_cast<uint8_t>(value));
            } else if constexpr (sizeof(T) == 2) {
                uint16_t be_val = detail::host_to_be(static_cast<uint16_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 4) {
                uint32_t be_val = detail::host_to_be(static_cast<uint32_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 8) {
                uint64_t be_val = detail::host_to_be(static_cast<uint64_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else {
                static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for append_network_int.");
                set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                return BoltError::INVALID_ARGUMENT;
            }
            return err;  // 返回 append_byte 或 append_bytes 的结果
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的内部写入函数 (现在返回 BoltError)
        BoltError write_null_internal();
        BoltError write_boolean_internal(bool bool_value);
        BoltError write_integer_internal(int64_t int_value);
        BoltError write_float_internal(double float_value);
        BoltError write_string_header_internal(uint32_t size);
        BoltError write_string_data_internal(const std::string& value_str);  // 已改为 const ref
        BoltError serialize_string_internal(const std::string& str_value);
        BoltError write_list_header_internal(uint32_t size);
        BoltError serialize_list_internal(const BoltList& list_data);  // 已改为 const ref
        BoltError write_map_header_internal(uint32_t size);
        BoltError serialize_map_internal(const BoltMap& map_data);  // 已改为 const ref
        BoltError write_struct_header_internal(uint8_t tag, uint32_t size);
        BoltError serialize_structure_internal(const PackStreamStructure& struct_data);  // 已改为 const ref

        std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::ostream* stream_ptr_ = nullptr;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 与 Reader 保持一致
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {  // Anonymous namespace for internal linkage helper functions

        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                return std::get<std::string>(it->second);
            }
            return std::nullopt;
        }

        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            result.push_back(std::get<std::string>(element));
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }

        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    return inner_map_sptr->pairs;
                }
            }
            return std::nullopt;
        }
        // Note: get_optional_int64_from_map was defined in the previous full listing of this file
        // but it's not actually used by HELLO, LOGON, or LOGOFF deserialization.
        // If other functions in this file needed it, it would go here too.

    }  // anonymous namespace

    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version) {
        // ... (implementation remains the same, uses helpers from anonymous namespace) ...
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure hello_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::HELLO, 1, 1, hello_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (hello_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(hello_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(hello_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs = extra_map_sptr->pairs;
        // using namespace detail_server_request_deserialization; // No longer needed due to anonymous namespace

        auto ua_it = extra_map_pairs.find("user_agent");
        if (ua_it != extra_map_pairs.end() && std::holds_alternative<std::string>(ua_it->second)) {
            try {
                out_params.user_agent = std::get<std::string>(ua_it->second);
            } catch (...) {
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        bool expect_auth_in_hello = (server_negotiated_version < versions::V5_1);
        if (expect_auth_in_hello) {
            out_params.auth_scheme = get_optional_string_from_map(*extra_map_sptr, "scheme");
            out_params.auth_principal = get_optional_string_from_map(*extra_map_sptr, "principal");
            out_params.auth_credentials = get_optional_string_from_map(*extra_map_sptr, "credentials");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 1)) {
            out_params.routing_context = get_optional_map_from_map(*extra_map_sptr, "routing");
        }
        if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
            out_params.patch_bolt = get_optional_list_string_from_map(*extra_map_sptr, "patch_bolt");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        bool bolt_agent_expected = (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 3));
        auto bolt_agent_map_val_it = extra_map_pairs.find("bolt_agent");
        if (bolt_agent_map_val_it != extra_map_pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second)) {
            auto agent_map_sptr = std::get<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second);
            if (agent_map_sptr) {
                HelloMessageParams::BoltAgentInfo agent_info;
                auto product_val = get_optional_string_from_map(*agent_map_sptr, "product");
                if (!product_val.has_value() || product_val.value().empty()) {
                    if (bolt_agent_expected) {
                        reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                        return BoltError::INVALID_MESSAGE_FORMAT;
                    }
                } else {
                    agent_info.product = product_val.value();
                }
                agent_info.platform = get_optional_string_from_map(*agent_map_sptr, "platform");
                agent_info.language = get_optional_string_from_map(*agent_map_sptr, "language");
                agent_info.language_details = get_optional_string_from_map(*agent_map_sptr, "language_details");
                if (!agent_info.product.empty()) {
                    out_params.bolt_agent = agent_info;
                } else if (bolt_agent_expected) {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            } else if (bolt_agent_expected) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else if (bolt_agent_expected) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        for (const auto& pair : extra_map_pairs) {
            if (pair.first != "user_agent" && pair.first != "scheme" && pair.first != "principal" && pair.first != "credentials" && pair.first != "routing" && pair.first != "patch_bolt" && pair.first != "notifications_minimum_severity" && pair.first != "notifications_disabled_categories" &&
                pair.first != "bolt_agent") {
                try {
                    out_params.other_extra_tokens.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        out_params.auth_tokens.clear();

        PackStreamStructure logon_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGON, 1, 1, logon_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (logon_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(logon_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(logon_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!auth_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.auth_tokens = std::move(auth_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logoff_message_request(PackStreamReader& reader) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        PackStreamStructure logoff_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGOFF, 0, 0, logoff_struct_contents);
        return err;
    }

}  // namespace boltprotocol// Base/Protocol/BoltProtocol/Source/bolt_errors_versions.cpp
// 或者这个内容应该在您原有的 Source/message_defs.cpp 中，如果是，请恢复它

#include "boltprotocol/bolt_errors_versions.h"  // 包含 Version 结构和常量声明

#include <algorithm>  // For std::min (if needed, though not in current Version funcs)
#include <cstring>    // For std::memcpy in from_handshake_bytes (original version had it)
#include <stdexcept>  // For std::to_string in Version::to_string()
#include <string>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"  // 为了 to_handshake_bytes 和 from_handshake_bytes

namespace boltprotocol {
    namespace versions {

        // --- Definitions for Version struct methods ---
        bool Version::operator<(const Version& other) const {
            if (major != other.major) {
                return major < other.major;
            }
            return minor < other.minor;
        }

        bool Version::operator==(const Version& other) const {
            return major == other.major && minor == other.minor;
        }

        bool Version::operator!=(const Version& other) const {
            return !(*this == other);
        }

        bool Version::operator>(const Version& other) const {
            return other < *this;
        }

        bool Version::operator<=(const Version& other) const {
            return !(*this > other);
        }

        bool Version::operator>=(const Version& other) const {
            return !(*this < other);
        }

        std::string Version::to_string() const {
            return std::to_string(static_cast<int>(major)) + "." + std::to_string(static_cast<int>(minor));
        }

        std::array<uint8_t, 4> Version::to_handshake_bytes() const {
            // Per Bolt spec for handshake version slots (e.g., Bolt 4.0+):
            // Versions are 32-bit unsigned integers, big-endian.
            // Example: 5.4 is 0x00000504.
            // Your previous provided code for handshake.cpp used a similar construction:
            // uint32_t version_int32_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));
            // uint32_t version_be = detail::host_to_be(version_int32_for_handshake);
            // std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            // However, the example handshake code `server_response_b = server_chosen_version_sim.to_handshake_bytes();`
            // and `Version::to_handshake_bytes()` in `message_defs.cpp` (from previous full listing) used `{0, 0, minor, major}`.
            // The spec for *server response* says: "the response will contain that version encoded as a single 32-bit integer."
            // The client *proposal slots* also take 32-bit big-endian integers.
            // Let's assume the intent for Version::to_handshake_bytes is to produce the 4-byte representation of THIS version
            // as it would appear in a handshake slot or response.
            // The common interpretation is [0,0,Major,Minor] if thinking about it byte-wise to form 0x0000MMNN (big-endian)
            // or if using your earlier message_defs.cpp code: {0,0,minor,major} which means MM=minor, NN=major.
            // Let's stick to the [0,0,Major,Minor] that maps to a simple u32.
            std::array<uint8_t, 4> bytes = {0, 0, 0, 0};
            uint32_t version_val = (static_cast<uint32_t>(major) << 8) | static_cast<uint32_t>(minor);
            uint32_t version_val_be = detail::host_to_be(version_val);
            std::memcpy(bytes.data(), &version_val_be, sizeof(uint32_t));
            return bytes;  // This will be [0,0,major,minor] if major/minor are single bytes and host is little-endian
                           // or [major,minor,0,0] if host is big-endian and we want 0xMMNN0000.
                           // Re-evaluating: The spec example "00 00 00 01" means version 1.0 (major=1, minor=0).
                           // So the 32-bit int is 0x0000MMNN where MM=major, NN=minor.
                           // Therefore, this implementation is correct if `version_val` is structured as Major in MSB of the relevant part.
                           // `(static_cast<uint32_t>(major) << 8) | static_cast<uint32_t>(minor)` results in 0x0000MMNN.
                           // `detail::host_to_be` correctly converts this to big-endian.
        }

        BoltError Version::from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version) {
            // Server responds with a single 32-bit big-endian version.
            uint32_t version_val_be;
            std::memcpy(&version_val_be, bytes.data(), sizeof(uint32_t));
            uint32_t version_val_host = detail::be_to_host(version_val_be);

            // Expecting 0x0000MMNN format where MM is major, NN is minor.
            if ((version_val_host >> 16) != 0) {  // Top two bytes should be zero for modern single versions
                // This could be a range proposal format if we were parsing client proposals,
                // but server response is a single version.
                // If not 0.0.X.Y, it's an unsupported format for a single version response.
                out_version = Version(0, 0);  // Reset
                return BoltError::UNSUPPORTED_PROTOCOL_VERSION;
            }

            out_version.major = static_cast<uint8_t>((version_val_host >> 8) & 0xFF);
            out_version.minor = static_cast<uint8_t>(version_val_host & 0xFF);

            // Check for 0.0 specifically, which means "no common version" if all bytes were zero.
            if (out_version.major == 0 && out_version.minor == 0) {
                bool all_zero = true;
                for (uint8_t b : bytes)
                    if (b != 0) all_zero = false;
                if (all_zero) {
                    // The handshake.cpp `parse_handshake_response` already checks this and returns HANDSHAKE_NO_COMMON_VERSION.
                    // So, here, parsing 0.0.0.0 as Version(0,0) is fine.
                }
            }
            return BoltError::SUCCESS;
        }

        // --- Definitions for extern version constants ---
        const Version V5_4(5, 4);
        const Version V5_3(5, 3);
        const Version V5_2(5, 2);
        const Version V5_1(5, 1);
        const Version V5_0(5, 0);
        const Version V4_4(4, 4);
        const Version V4_3(4, 3);
        // Add other versions if they were declared, e.g.:
        // const Version V4_2(4,2);
        // const Version V4_1(4,1);
        // const Version V4_0(4,0);
        // const Version V3_0(3,0);

        // --- Definition for get_default_proposed_versions ---
        const std::vector<Version>& get_default_proposed_versions() {
            static const std::vector<Version> DEFAULT_PROPOSED_VERSIONS_LIST = {
                V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3  // Add others if defined and desired
            };
            return DEFAULT_PROPOSED_VERSIONS_LIST;
        }

    }  // namespace versions
}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field etc.

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version) {
        if (pss.tag != 0x4E) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto labels_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);  // Uses specialization

        if (!id_opt.has_value() || !labels_list_sptr_opt.has_value() || !props_map_opt.has_value()) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& labels_list_sptr = labels_list_sptr_opt.value();
        if (!labels_list_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_node.id = id_opt.value();

        out_node.labels.clear();
        out_node.labels.reserve(labels_list_sptr->elements.size());
        for (const auto& label_val : labels_list_sptr->elements) {
            if (std::holds_alternative<std::string>(label_val)) {
                try {
                    out_node.labels.push_back(std::get<std::string>(label_val));
                } catch (...) {
                    return BoltError::OUT_OF_MEMORY;
                }  // Or UNKNOWN_ERROR
            } else {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        try {
            out_node.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_node.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
            // If field 3 is present but not string, get_typed_field returns nullopt, element_id remains nullopt.
            // If it's present and is PackNull, it should also result in nullopt.
            // This needs to be handled carefully if PackNull should clear the optional vs. type mismatch.
            // Current get_typed_field will return nullopt if type is not string.
            if (pss.fields[3].index() != 0 && !out_node.element_id.has_value() && pss.fields[3].index() != detail::get_typed_field<std::string>(pss.fields, 3).has_value()) {
                // This condition means: field 3 is not PackNull, AND we didn't get a string, AND it wasn't because it was a string.
                // This is a bit complex, usually indicates a type mismatch that wasn't caught by holds_alternative if Value was more complex.
                // For string, if it's not string, get_typed_field returns nullopt.
            }
        } else {
            out_node.element_id = std::nullopt;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x4E;  // 'N'

            out_pss_sptr->fields.emplace_back(Value(node.id));

            auto labels_list_sptr = std::make_shared<BoltList>();
            labels_list_sptr->elements.reserve(node.labels.size());
            for (const auto& label : node.labels) {
                labels_list_sptr->elements.emplace_back(Value(label));
            }
            out_pss_sptr->fields.emplace_back(Value(labels_list_sptr));

            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = node.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                if (node.element_id.has_value()) {
                    out_pss_sptr->fields.emplace_back(Value(node.element_id.value()));
                } else {
                    out_pss_sptr->fields.emplace_back(nullptr);
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version) {
        if (pss.tag != 0x50) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nodes_vec_opt = detail::get_typed_list_field<BoltNode>(pss.fields, 0, &bolt_version);
        if (!nodes_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.nodes = std::move(nodes_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto rels_vec_opt = detail::get_typed_list_field<BoltUnboundRelationship>(pss.fields, 1, &bolt_version);
        if (!rels_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.rels = std::move(rels_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto indices_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 2);
        if (!indices_list_sptr_opt || !indices_list_sptr_opt.value()) return BoltError::INVALID_MESSAGE_FORMAT;

        const auto& indices_list_sptr = indices_list_sptr_opt.value();
        out_path.indices.clear();
        try {
            out_path.indices.reserve(indices_list_sptr->elements.size());
            for (const auto& idx_val : indices_list_sptr->elements) {
                if (std::holds_alternative<int64_t>(idx_val)) {
                    out_path.indices.push_back(std::get<int64_t>(idx_val));
                } else {
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::UNKNOWN_ERROR;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x50;

            auto nodes_list_sptr = std::make_shared<BoltList>();
            nodes_list_sptr->elements.reserve(path.nodes.size());
            for (const auto& node : path.nodes) {
                std::shared_ptr<PackStreamStructure> node_pss_sptr;
                BoltError err = to_packstream(node, bolt_version, node_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                nodes_list_sptr->elements.emplace_back(Value(node_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(nodes_list_sptr));

            auto rels_list_sptr = std::make_shared<BoltList>();
            rels_list_sptr->elements.reserve(path.rels.size());
            for (const auto& rel : path.rels) {
                std::shared_ptr<PackStreamStructure> rel_pss_sptr;
                BoltError err = to_packstream(rel, bolt_version, rel_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                rels_list_sptr->elements.emplace_back(Value(rel_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(rels_list_sptr));

            auto indices_list_sptr = std::make_shared<BoltList>();
            indices_list_sptr->elements.reserve(path.indices.size());
            for (const auto& idx : path.indices) {
                indices_list_sptr->elements.emplace_back(Value(idx));
            }
            out_pss_sptr->fields.emplace_back(Value(indices_list_sptr));

        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x52) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 5;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 8 : 5;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto start_id_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto end_id_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 3);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 4);

        if (!id_opt || !start_id_opt || !end_id_opt || !type_opt || !props_map_opt) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_rel.id = id_opt.value();
        out_rel.start_node_id = start_id_opt.value();
        out_rel.end_node_id = end_id_opt.value();
        out_rel.type = type_opt.value();
        try {
            out_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 8) {
            out_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 5);
            out_rel.start_node_element_id = detail::get_typed_field<std::string>(pss.fields, 6);
            out_rel.end_node_element_id = detail::get_typed_field<std::string>(pss.fields, 7);
        } else {
            out_rel.element_id = std::nullopt;
            out_rel.start_node_element_id = std::nullopt;
            out_rel.end_node_element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x52;
            out_pss_sptr->fields.emplace_back(Value(rel.id));
            out_pss_sptr->fields.emplace_back(Value(rel.start_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.end_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(rel.element_id.has_value() ? Value(rel.element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.start_node_element_id.has_value() ? Value(rel.start_node_element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.end_node_element_id.has_value() ? Value(rel.end_node_element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x72) return BoltError::INVALID_MESSAGE_FORMAT;
        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;
        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) return BoltError::INVALID_MESSAGE_FORMAT;

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);

        if (!id_opt || !type_opt || !props_map_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_unbound_rel.id = id_opt.value();
        out_unbound_rel.type = type_opt.value();
        try {
            out_unbound_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_unbound_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
        } else {
            out_unbound_rel.element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x72;
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.id));
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = unbound_rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));
            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(unbound_rel.element_id.has_value() ? Value(unbound_rel.element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point) {
        if (pss.tag != 0x58) return BoltError::INVALID_MESSAGE_FORMAT;  // 'X'
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);

        if (!srid_opt || !x_opt || !y_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x58;  // 'X'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point) {
        if (pss.tag != 0x59) return BoltError::INVALID_MESSAGE_FORMAT;  // 'Y'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);
        auto z_opt = detail::get_typed_field<double>(pss.fields, 3);

        if (!srid_opt || !x_opt || !y_opt || !z_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        out_point.z = z_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x59;  // 'Y'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
            out_pss_sptr->fields.emplace_back(Value(point.z));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date) {
        if (pss.tag != 0x44) return BoltError::INVALID_MESSAGE_FORMAT;  // 'D'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!days_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_date.days_since_epoch = days_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x44;  // 'D'
            out_pss_sptr->fields.emplace_back(Value(date.days_since_epoch));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <iostream>
#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    // DateTime (Modern 'I' - 0x49 and Legacy 'F' - 0x46)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version) {
        // bolt_version is available if subtle distinctions are needed, but tag is primary.
        if (pss.tag == 0x49) {  // Modern DateTime 'I'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.seconds_epoch_utc = secs_opt.value();
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x46) {  // Legacy DateTime 'F'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            out_datetime.seconds_epoch_utc = secs_adjusted_by_offset_opt.value() - out_datetime.tz_offset_seconds;
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            return BoltError::SUCCESS;
        }

        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);

        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x49;  // 'I'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            } else {                       // Use Legacy DateTime 'F'
                out_pss_sptr->tag = 0x46;  // 'F'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc + datetime.tz_offset_seconds));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // DateTimeZoneId (Modern 'i' - 0x69 and Legacy 'f' - 0x66)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version) {
        // bolt_version might be used for subtle interpretation differences if any beyond tag.
        if (pss.tag == 0x69) {  // Modern 'i'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x66) {  // Legacy 'f'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_adjusted_by_offset_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            // Caller should be aware that for legacy 'f', seconds_epoch_utc is not pure UTC.
            return BoltError::SUCCESS;
        }
        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x69;  // 'i'
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            } else {                       // Use Legacy DateTimeZoneId 'f'
                out_pss_sptr->tag = 0x66;  // 'f'
                // As discussed, serializing to legacy 'f' from UTC seconds + tz_id without a TZDB is problematic.
                // The stored datetime_zoneid.seconds_epoch_utc is assumed to be pure UTC.
                // To produce the correct legacy 'seconds' field, we'd need to add the offset for tz_id at that instant.
                // Lacking TZDB, we will return an error or serialize potentially incorrect data.
                // For now, return error to highlight the issue.
                // A user wanting to serialize to legacy 'f' must provide a `seconds_epoch_utc` value
                // that is ALREADY `actual_utc_seconds + offset_for_tz_id_at_that_instant`.
                // std::cerr << "Error: Cannot accurately serialize BoltDateTimeZoneId to legacy format (0x66) "
                //           << "without timezone database information or pre-adjusted seconds value." << std::endl;
                // return BoltError::SERIALIZATION_ERROR;
                // OR, proceed with caution:
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));  // This is UTC, not adjusted!
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // LocalDateTime ('d' - 0x64)
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime) {
        if (pss.tag != 0x64) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;
        auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        if (!secs_opt.has_value() || !nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;
        out_local_datetime.seconds_epoch_local = secs_opt.value();
        out_local_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x64;
            out_pss_sptr->fields.emplace_back(Value(local_datetime.seconds_epoch_local));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(local_datetime.nanoseconds_of_second)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration) {
        if (pss.tag != 0x45) return BoltError::INVALID_MESSAGE_FORMAT;  // 'E'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto months_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto seconds_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 3);

        if (!months_opt || !days_opt || !seconds_opt || !nanos_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_duration.months = months_opt.value();
        out_duration.days = days_opt.value();
        out_duration.seconds = seconds_opt.value();
        out_duration.nanoseconds = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x45;  // 'E'
            out_pss_sptr->fields.emplace_back(Value(duration.months));
            out_pss_sptr->fields.emplace_back(Value(duration.days));
            out_pss_sptr->fields.emplace_back(Value(duration.seconds));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(duration.nanoseconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time) {
        if (pss.tag != 0x54) return BoltError::INVALID_MESSAGE_FORMAT;  // 'T'
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 1);  // Spec: Integer

        if (!nanos_opt.has_value() || !offset_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_time.nanoseconds_since_midnight = nanos_opt.value();
        // tz_offset_seconds is int32_t in BoltTime struct. Check for overflow if necessary,
        // though unlikely for timezone offsets.
        out_time.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x54;  // 'T'
            out_pss_sptr->fields.emplace_back(Value(time.nanoseconds_since_midnight));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(time.tz_offset_seconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time) {
        if (pss.tag != 0x74) return BoltError::INVALID_MESSAGE_FORMAT;  // 't'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_local_time.nanoseconds_since_midnight = nanos_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x74;  // 't'
            out_pss_sptr->fields.emplace_back(Value(local_time.nanoseconds_since_midnight));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/chunking.h"

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy (though not strictly needed if only writing from vector)
#include <exception>  // For std::bad_alloc
#include <iostream>   // For stream operations (std::ostream, std::istream)
#include <vector>     // For std::vector manipulations

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host

namespace boltprotocol {

    // --- ChunkedWriter Implementation ---

    ChunkedWriter::ChunkedWriter(std::ostream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {                        // Initial check of stream state
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if stream is already bad
        }
    }

    void ChunkedWriter::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to write the 2-byte chunk header
    BoltError ChunkedWriter::write_chunk_header(uint16_t chunk_payload_size) {
        if (has_error()) return last_error_;  // Don't proceed if already in error state

        uint16_t size_be = detail::host_to_be(chunk_payload_size);
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.write(reinterpret_cast<const char*>(&size_be), sizeof(size_be));
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return BoltError::NETWORK_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write a data chunk (header + payload)
    BoltError ChunkedWriter::write_chunk(const uint8_t* data, uint16_t size) {
        // This function is internal. `write_message` ensures size <= MAX_CHUNK_PAYLOAD_SIZE.
        // `has_error()` check is done by caller or at the start of `write_message`.

        BoltError err = write_chunk_header(size);
        if (err != BoltError::SUCCESS) {
            // error already set by write_chunk_header
            return err;
        }

        if (size > 0) {             // Only write payload if size is non-zero
            if (data == nullptr) {  // Should not happen if size > 0
                set_error(BoltError::INVALID_ARGUMENT);
                return last_error_;
            }
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return last_error_;
            }
            stream_.write(reinterpret_cast<const char*>(data), size);
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return BoltError::NETWORK_ERROR;
            }
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write the end-of-message marker (a chunk with size 0)
    BoltError ChunkedWriter::write_end_of_message_marker() {
        return write_chunk_header(0);  // This writes a 2-byte header with 0x0000
    }

    // Public method to write a full message, chunked.
    BoltError ChunkedWriter::write_message(const std::vector<uint8_t>& message_data) {
        if (has_error()) return last_error_;  // Check if writer is already in an error state
        last_error_ = BoltError::SUCCESS;     // Reset error for this new operation

        const uint8_t* data_ptr = message_data.data();
        size_t total_message_size = message_data.size();
        size_t remaining_size = total_message_size;

        if (stream_.fail()) {  // Check stream before starting writes for this message
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        // Handle empty message payload: send a single EOM marker if message_data is empty.
        // Bolt messages are typically not empty (even GOODBYE has a PSS structure).
        // If message_data is empty, it means the PSS serialization resulted in zero bytes.
        // This case is unusual. A common interpretation would be to send *no* data chunks,
        // followed by the EOM marker.
        if (total_message_size == 0) {
            BoltError eom_err = write_end_of_message_marker();
            if (eom_err == BoltError::SUCCESS) {
                stream_.flush();  // Attempt to flush
                if (stream_.fail()) {
                    set_error(BoltError::NETWORK_ERROR);
                    return last_error_;
                }
            }
            return eom_err;  // Return error from writing EOM or SUCCESS
        }

        // Write data chunks
        while (remaining_size > 0) {
            uint16_t current_chunk_payload_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(MAX_CHUNK_PAYLOAD_SIZE)));

            BoltError chunk_write_err = write_chunk(data_ptr, current_chunk_payload_size);
            if (chunk_write_err != BoltError::SUCCESS) {
                // Error (and last_error_) already set by write_chunk or write_chunk_header
                return last_error_;
            }

            data_ptr += current_chunk_payload_size;
            remaining_size -= current_chunk_payload_size;
        }

        // After all data chunks are written, write the end-of-message marker
        BoltError eom_err = write_end_of_message_marker();
        if (eom_err != BoltError::SUCCESS) {
            return last_error_;  // Error already set
        }

        // Attempt to flush the stream to ensure all data is sent
        stream_.flush();
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        return BoltError::SUCCESS;
    }

    // --- ChunkedReader Implementation ---

    ChunkedReader::ChunkedReader(std::istream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void ChunkedReader::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to read the 2-byte chunk header
    BoltError ChunkedReader::read_chunk_header(uint16_t& out_chunk_payload_size) {
        out_chunk_payload_size = 0;  // Initialize output
        if (has_error()) return last_error_;

        uint16_t size_be;  // To store big-endian size from stream

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(&size_be), sizeof(size_be));

        if (stream_.fail()) {                     // Check failbit (which is set on EOF by read if not enough bytes)
            set_error(BoltError::NETWORK_ERROR);  // Could be EOF if connection closed cleanly mid-message
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != sizeof(size_be)) {
            // This case should ideally be caught by stream.fail() if not enough bytes were read.
            // But as a safeguard:
            set_error(BoltError::NETWORK_ERROR);  // Incomplete read for header
            return last_error_;
        }

        out_chunk_payload_size = detail::be_to_host(size_be);

        // As per spec, MAX_CHUNK_PAYLOAD_SIZE is 65535 (0xFFFF).
        // The chunk_payload_size read from header can be this max value.
        // There's no separate check for > MAX_CHUNK_PAYLOAD_SIZE here, as uint16_t naturally holds up to this.
        // A CHUNK_TOO_LARGE error would be if a spec defined a lower practical limit, but Bolt uses full uint16_t range.

        return BoltError::SUCCESS;
    }

    // Private helper to read the payload of a chunk
    BoltError ChunkedReader::read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to) {
        if (has_error()) return last_error_;
        if (payload_size == 0) return BoltError::SUCCESS;  // Nothing to read

        size_t current_buffer_capacity = buffer_to_append_to.capacity();
        size_t current_buffer_size = buffer_to_append_to.size();
        size_t required_capacity = current_buffer_size + payload_size;

        // Grow buffer if needed. This is where std::bad_alloc can occur.
        if (required_capacity > current_buffer_capacity) {
            try {
                // Reserve to avoid multiple small reallocations if reading many small chunks.
                // A growth factor could be used (e.g., 1.5x or 2x) for efficiency.
                // For simplicity here, just reserve what's immediately needed for this chunk.
                buffer_to_append_to.reserve(required_capacity);
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return last_error_;
            } catch (const std::length_error&) {          // If required_capacity is too large for vector
                set_error(BoltError::MESSAGE_TOO_LARGE);  // Or OUT_OF_MEMORY if more appropriate
                return last_error_;
            } catch (const std::exception&) {
                set_error(BoltError::UNKNOWN_ERROR);
                return last_error_;
            }
        }

        // Resize to exact size needed for appending, then read directly into new space.
        // This is less efficient than reading into a temporary buffer and then appending,
        // but simpler for now. A more optimized version might use a fixed-size read buffer.
        // We need to append, so we must first store current_buffer_size, then resize, then read.
        try {
            buffer_to_append_to.resize(required_capacity);  // Resize to make space
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return last_error_;
        } catch (const std::length_error&) {
            set_error(BoltError::MESSAGE_TOO_LARGE);
            return last_error_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return last_error_;
        }

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(buffer_to_append_to.data() + current_buffer_size), payload_size);

        if (stream_.fail()) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize on partial read/failure
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != payload_size) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize
            set_error(BoltError::NETWORK_ERROR);              // Incomplete read for payload
            return last_error_;
        }
        return BoltError::SUCCESS;
    }

    // Public method to read a full message, de-chunked.
    BoltError ChunkedReader::read_message(std::vector<uint8_t>& out_message_data) {
        if (has_error()) return last_error_;
        last_error_ = BoltError::SUCCESS;  // Reset error for this new operation

        out_message_data.clear();  // Ensure output vector starts empty for this message
        // Optionally, reserve a typical message size if known, e.g., out_message_data.reserve(4096);
        // This needs a try-catch for bad_alloc if done.

        uint16_t current_chunk_payload_size;
        BoltError err;

        while (true) {  // Loop to read chunks until EOM
            err = read_chunk_header(current_chunk_payload_size);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_header
                return last_error_;
            }

            if (current_chunk_payload_size == 0) {  // End-of-message marker (0x0000 chunk size)
                break;                              // Successfully read all chunks for this message
            }

            // Optional: Check against a max total message size to prevent OOM from malicious server
            // Example: constexpr size_t MAX_ALLOWED_TOTAL_MESSAGE_SIZE = 16 * 1024 * 1024; // 16MB
            // if (out_message_data.size() + current_chunk_payload_size > MAX_ALLOWED_TOTAL_MESSAGE_SIZE) {
            //    set_error(BoltError::MESSAGE_TOO_LARGE);
            //    out_message_data.clear();
            //    return last_error_;
            // }

            err = read_chunk_payload(current_chunk_payload_size, out_message_data);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_payload
                return last_error_;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/handshake.h"  // 包含声明

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
// <iostream> is not directly needed here anymore for perform_handshake

#include "boltprotocol/detail/byte_order_utils.h"  // For detail::host_to_be

namespace boltprotocol {

    // build_handshake_request: Constructs the 20-byte handshake request.
    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes) {
        if (proposed_versions.empty()) {
            return BoltError::INVALID_ARGUMENT;
        }

        // 1. Magic Preamble (4 bytes, Big Endian)
        uint32_t preamble_be = detail::host_to_be(BOLT_MAGIC_PREAMBLE);  // BOLT_MAGIC_PREAMBLE from message_defs.h
        std::memcpy(out_handshake_bytes.data(), &preamble_be, sizeof(preamble_be));
        size_t current_offset = sizeof(preamble_be);

        // 2. Proposed Versions (4 versions, each 4 bytes, Big Endian)
        size_t num_versions_to_write = std::min(proposed_versions.size(), HANDSHAKE_NUM_PROPOSED_VERSIONS);

        for (size_t i = 0; i < num_versions_to_write; ++i) {
            // Version::to_handshake_bytes() already returns the 4 bytes in the correct format (00 00 Maj Min)
            // and handles endianness *if* it were encoding a multi-byte representation of major/minor itself.
            // However, the Bolt spec for handshake versions is simpler: the 4-byte int is 0.0.Major.Minor.
            // So we construct this 32-bit int and then convert to big endian.
            uint32_t version_int32_for_handshake = 0;  // Example: For 5.4, this would be 0x00000504
            version_int32_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));

            uint32_t version_be = detail::host_to_be(version_int32_for_handshake);
            std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
        }

        // Fill remaining version slots with "No Version" (all zeros)
        if (num_versions_to_write < HANDSHAKE_NUM_PROPOSED_VERSIONS) {
            uint32_t no_version_int_be = detail::host_to_be(static_cast<uint32_t>(0));  // 0x00000000
            for (size_t i = num_versions_to_write; i < HANDSHAKE_NUM_PROPOSED_VERSIONS; ++i) {
                std::memcpy(out_handshake_bytes.data() + current_offset, &no_version_int_be, HANDSHAKE_VERSION_SIZE_BYTES);
                current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
            }
        }
        return BoltError::SUCCESS;
    }

    // parse_handshake_response: Parses the 4-byte server response.
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response_bytes, versions::Version& out_negotiated_version) {
        // Version::from_handshake_bytes directly uses the byte array.
        BoltError err = versions::Version::from_handshake_bytes(server_response_bytes, out_negotiated_version);

        if (err != BoltError::SUCCESS) {
            return err;  // Could be UNSUPPORTED_PROTOCOL_VERSION if format is unexpected by from_handshake_bytes
        }

        // Specific check for "No common version" which is represented by all zeros.
        // Version::from_handshake_bytes might return 0.0 as a valid version for all zeros.
        if (out_negotiated_version.major == 0 && out_negotiated_version.minor == 0) {
            // Check if all bytes in server_response_bytes are actually zero
            bool all_zero = true;
            for (uint8_t byte : server_response_bytes) {
                if (byte != 0) {
                    all_zero = false;
                    break;
                }
            }
            if (all_zero) {
                return BoltError::HANDSHAKE_NO_COMMON_VERSION;
            }
            // If it parsed as 0.0 but bytes weren't all zero, it's an odd case,
            // but Version::from_handshake_bytes should ideally handle invalid formats.
            // For now, if it parses to 0.0 and wasn't all zeros, treat as success with 0.0 (unlikely scenario).
        }
        return BoltError::SUCCESS;
    }

    // The definition of perform_handshake (template function) is now in handshake_impl.hpp

}  // namespace boltprotocol// Base/Protocol/BoltProtocol/Source/message_defs.cpp
#include "boltprotocol/message_defs.h"  // 主头文件，包含 Value, BoltList, BoltMap, PackStreamStructure 等

#include <string>
#include <variant>  // For std::visit

namespace boltprotocol {

    // 定义 DEFAULT_USER_AGENT_FORMAT_STRING
    const std::string DEFAULT_USER_AGENT_FORMAT_STRING = "BoltProtocolCppLib/0.2";  // 您可以自定义版本号

    // 实现 Value::operator==
    // 注意：这个实现假设 BoltList, BoltMap, PackStreamStructure 也有正确的 operator== 实现。
    // BoltList::operator== 和 BoltMap::operator== 已在 bolt_core_types.h 中基于其成员实现。
    // PackStreamStructure::operator== 也在 bolt_core_types.h 中基于其成员实现。
    bool operator==(const Value& lhs, const Value& rhs) {
        if (lhs.index() != rhs.index()) {
            return false;
        }

        // 使用 std::visit 来比较 variant 中实际持有的值
        return std::visit(
            [](const auto& l_val, const auto& r_val) -> bool {
                // 使用 if constexpr 来处理不同类型，特别是 shared_ptr
                using T1 = std::decay_t<decltype(l_val)>;
                using T2 = std::decay_t<decltype(r_val)>;

                if constexpr (std::is_same_v<T1, T2>) {
                    // 处理 shared_ptr 类型，需要比较它们指向的对象
                    if constexpr (std::is_same_v<T1, std::shared_ptr<BoltList>>) {
                        if (l_val && r_val) return *l_val == *r_val;  // 比较指向的对象
                        return !l_val && !r_val;                      // 两者都为空指针则相等
                    } else if constexpr (std::is_same_v<T1, std::shared_ptr<BoltMap>>) {
                        if (l_val && r_val) return *l_val == *r_val;
                        return !l_val && !r_val;
                    } else if constexpr (std::is_same_v<T1, std::shared_ptr<PackStreamStructure>>) {
                        if (l_val && r_val) return *l_val == *r_val;
                        return !l_val && !r_val;
                    } else {
                        // 对于其他非 shared_ptr 类型 (nullptr_t, bool, int64_t, double, std::string)
                        // 直接比较值
                        return l_val == r_val;
                    }
                } else {
                    // Variant 内部类型不匹配，但 index 相同，理论上不应发生
                    return false;
                }
            },
            lhs,
            rhs);
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure run_struct_obj;
        run_struct_obj.tag = static_cast<uint8_t>(MessageTag::RUN);

        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            // Field 1: Cypher query (string)
            run_struct_obj.fields.emplace_back(Value(params.cypher_query));

            // Field 2: Parameters map (cypher parameters)
            // It's okay if params.parameters is empty, it will serialize as an empty map.
            auto cypher_params_map_sptr = std::make_shared<BoltMap>();
            cypher_params_map_sptr->pairs = params.parameters;
            run_struct_obj.fields.emplace_back(Value(cypher_params_map_sptr));

            // Field 3: Extra metadata map
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
            }

            if (target_bolt_version.major > 4 || (target_bolt_version.major == 4 && target_bolt_version.minor >= 4)) {  // imp_user for RUN introduced in Bolt 4.4
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            run_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(run_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_pull_message and serialize_discard_message remain unchanged
    // ... (serialize_pull_message implementation) ...
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure pull_struct_obj;
        pull_struct_obj.tag = static_cast<uint8_t>(MessageTag::PULL);
        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            pull_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pull_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_discard_message implementation) ...
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure discard_struct_obj;
        discard_struct_obj.tag = static_cast<uint8_t>(MessageTag::DISCARD);
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            discard_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(discard_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version) {
        if (writer.has_error()) return writer.get_error();

        if (negotiated_bolt_version < versions::Version(4, 3)) {
            writer.set_error(BoltError::SERIALIZATION_ERROR);
            return writer.get_error();
        }

        PackStreamStructure route_struct_obj;
        route_struct_obj.tag = static_cast<uint8_t>(MessageTag::ROUTE);

        std::shared_ptr<BoltMap> routing_table_context_map_sptr;
        std::shared_ptr<BoltList> bookmarks_list_sptr;

        try {
            routing_table_context_map_sptr = std::make_shared<BoltMap>();
            routing_table_context_map_sptr->pairs = params.routing_table_context;
            route_struct_obj.fields.emplace_back(Value(routing_table_context_map_sptr));

            bookmarks_list_sptr = std::make_shared<BoltList>();
            for (const auto& bookmark_str : params.bookmarks) {
                bookmarks_list_sptr->elements.emplace_back(Value(bookmark_str));
            }
            route_struct_obj.fields.emplace_back(Value(bookmarks_list_sptr));

            if (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor == 3) {  // Bolt 4.3
                if (params.db_name_for_v43.has_value()) {
                    route_struct_obj.fields.emplace_back(Value(params.db_name_for_v43.value()));
                } else {
                    route_struct_obj.fields.emplace_back(nullptr);
                }
            } else if (negotiated_bolt_version.major > 4 || (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor >= 4)) {  // Bolt 4.4+
                std::shared_ptr<BoltMap> extra_map_sptr = std::make_shared<BoltMap>();                                                     // Always create the map
                if (params.extra_for_v44_plus.has_value()) {
                    extra_map_sptr->pairs = params.extra_for_v44_plus.value();
                }
                // The 'extra' dictionary field is always present for Bolt 4.4+, even if empty.
                route_struct_obj.fields.emplace_back(Value(extra_map_sptr));
            }
            // No other cases, as we checked for version < 4.3 at the beginning.

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(route_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            metadata_map_sptr->pairs = params.metadata;
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_hello_obj;
        pss_hello_obj.tag = static_cast<uint8_t>(MessageTag::HELLO);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& pairs = extra_map_sptr->pairs;

            pairs.emplace("user_agent", Value(params.user_agent));

            bool use_auth_in_hello = (client_target_version < versions::V5_1);  // Qualified comparison

            if (use_auth_in_hello) {
                if (params.auth_scheme.has_value()) pairs.emplace("scheme", Value(params.auth_scheme.value()));
                if (params.auth_principal.has_value()) pairs.emplace("principal", Value(params.auth_principal.value()));
                if (params.auth_credentials.has_value()) pairs.emplace("credentials", Value(params.auth_credentials.value()));
                if (params.auth_scheme_specific_tokens.has_value()) {
                    for (const auto& token_pair : params.auth_scheme_specific_tokens.value()) {
                        pairs.emplace(token_pair.first, token_pair.second);
                    }
                }
            }

            if (client_target_version.major > 4 || (client_target_version.major == 4 && client_target_version.minor >= 1)) {
                if (params.routing_context.has_value()) {
                    auto routing_map_val_sptr = std::make_shared<BoltMap>();
                    routing_map_val_sptr->pairs = params.routing_context.value();
                    pairs.emplace("routing", Value(routing_map_val_sptr));
                }
            }

            if (client_target_version.major == 4 && (client_target_version.minor == 3 || client_target_version.minor == 4)) {
                if (params.patch_bolt.has_value() && !params.patch_bolt.value().empty()) {
                    auto patch_list_sptr = std::make_shared<BoltList>();
                    for (const auto& patch_str : params.patch_bolt.value()) {
                        patch_list_sptr->elements.emplace_back(Value(patch_str));
                    }
                    pairs.emplace("patch_bolt", Value(patch_list_sptr));
                }
            }

            if (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 2)) {
                if (params.notifications_min_severity.has_value()) {
                    pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat_str : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat_str));
                    }
                    pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            bool bolt_agent_mandatory = (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 3));
            if (bolt_agent_mandatory) {
                if (!params.bolt_agent.has_value() || params.bolt_agent.value().product.empty()) {
                    writer.set_error(BoltError::SERIALIZATION_ERROR);
                    return BoltError::SERIALIZATION_ERROR;
                }
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            } else if (params.bolt_agent.has_value()) {
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));  // Product is mandatory in BoltAgentInfo itself
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            }

            for (const auto& token_pair : params.other_extra_tokens) {
                pairs.emplace(token_pair.first, token_pair.second);
            }
            pss_hello_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_hello_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_goodbye_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::GOODBYE);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_reset_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::RESET);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_logon_obj;
        pss_logon_obj.tag = static_cast<uint8_t>(MessageTag::LOGON);

        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::make_shared<BoltMap>();
            // The auth_tokens map in LogonMessageParams directly becomes the PSS field.
            auth_map_sptr->pairs = params.auth_tokens;

            pss_logon_obj.fields.emplace_back(Value(auth_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_logon_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logoff_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::LOGOFF);
            // LOGOFF PSS has no fields.
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <map>
#include <memory>  // For std::make_shared, std::shared_ptr
#include <vector>  // For PackStreamStructure fields

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For the function declaration
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;                                // Create on stack
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);  // Tag 0x54

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            // Copy the metadata from params. Telemetry typically has specific keys like "api".
            // The caller is responsible for ensuring params.metadata is correctly populated.
            metadata_map_sptr->pairs = params.metadata;

            // The TELEMETRY message PackStreamStructure has one field: the metadata map.
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Catch other potential exceptions from map copy or emplace_back
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // Consider logging e_std.what() for debugging if needed
            return BoltError::UNKNOWN_ERROR;
        }

        // Now, convert the stack-based PSS object to a shared_ptr to pass to writer.write()
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Other exceptions from make_shared or PSS move ctor
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {                                 // Should typically be caught by bad_alloc if make_shared fails
            writer.set_error(BoltError::OUT_OF_MEMORY);  // Or UNKNOWN_ERROR if make_shared could return null without exception
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure begin_struct_obj;
        begin_struct_obj.tag = static_cast<uint8_t>(MessageTag::BEGIN);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            // BEGIN shares many 'extra' fields with RUN's auto-commit extras
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {  // Defaults to "w" if not sent, but can be explicit
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db and imp_user for BEGIN introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            begin_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(begin_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_commit_message and serialize_rollback_message remain unchanged
    // ... (serialize_commit_message implementation) ...
    BoltError serialize_commit_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::COMMIT);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_rollback_message implementation) ...
    BoltError serialize_rollback_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::ROLLBACK);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get
#include <vector>     // For PackStreamStructure::fields

#include "boltprotocol/message_defs.h"           // For message structs, Value, MessageTag, BoltError
#include "boltprotocol/message_serialization.h"  // 主头文件，声明这些函数
#include "boltprotocol/packstream_reader.h"      // For PackStreamReader

namespace boltprotocol {

    // Helper to deserialize a structure from a reader and validate its basic properties
    // This function was originally in message_serialization_server.cpp
    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents) {
        if (reader.has_error()) return reader.get_error();

        Value raw_value;
        BoltError err = reader.read(raw_value);
        if (err != BoltError::SUCCESS) {
            // reader.read() should have set its internal error state.
            return err;
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(raw_value)) {
            try {
                struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(raw_value));
            } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            } catch (const std::exception&) {  // Other potential issues with std::get or Value move
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (!struct_sptr) {  // Null shared_ptr received in Value
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Move the contents from the object pointed to by shared_ptr into out_structure_contents.
        try {
            out_structure_contents = std::move(*struct_sptr);  // PackStreamStructure move assignment
        } catch (const std::bad_alloc&) {                      // If vector/map move assignment allocates and fails
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (static_cast<MessageTag>(out_structure_contents.tag) != expected_tag) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Tag mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (out_structure_contents.fields.size() < expected_fields_min || out_structure_contents.fields.size() > expected_fields_max) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Field count mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        return BoltError::SUCCESS;
    }

    // peek_message_structure_header remains problematic and likely unused as discussed.
    // If it were to be implemented and was general, it could go here.
    // For now, it's commented out or returns an error in message_serialization.h
    /*
    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count) {
        // ... implementation ...
        return BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::bad_variant_access
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get (though not strictly used for get if field is optional)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        // IGNORED message PSS has 0 or 1 field. If 1, it's a map (usually for future use or diagnostics).
        // The spec typically shows IGNORED {}, meaning 0 fields in its PSS, or IGNORED {<metadata_map>}.
        // A PSS with 0 fields is valid. A PSS with 1 field (the map) is also valid.
        // So, expected_fields_min = 0, expected_fields_max = 1.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // If there is a field, it must be a map.
        // Client usually doesn't need to parse this map, so we just validate its presence and type if it exists.
        if (!ignored_struct_contents.fields.empty()) {  // Field is present
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            // We don't need to extract the map's content for IGNORED typically.
            // std::shared_ptr<BoltMap> metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0]);
            // if (!metadata_map_sptr) { /* This would be an error if the field is present but map pointer is null */ }
        }
        // If fields is empty, it's a valid IGNORED {} message, nothing more to do.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_reset_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RESET message PSS (Bolt 1+) has 0 fields.
        PackStreamStructure reset_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RESET, 0, 0, reset_struct_contents);
        // No fields to parse further from reset_struct_contents.fields.
        return err;
    }

    BoltError deserialize_goodbye_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // GOODBYE message PSS (Bolt 3+) has 0 fields.
        PackStreamStructure goodbye_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::GOODBYE, 0, 0, goodbye_struct_contents);
        // No fields to parse further.
        return err;
    }

    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure telemetry_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::TELEMETRY, 1, 1, telemetry_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (telemetry_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(telemetry_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(telemetry_struct_contents.fields[0]));
        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        auto api_val_it = out_params.metadata.find("api");
        if (api_val_it == out_params.metadata.end() || !std::holds_alternative<int64_t>(api_val_it->second)) {
            // Specification: "unless it sends an invalid value for the api field, which results in a FAILURE response."
            // This deserializer can flag it, actual FAILURE is up to server logic.
            // For now, successful deserialization of the structure, content validation is next step.
            // reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Or a specific "TELEMETRY_INVALID_API_FIELD"
            // return reader.get_error();
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure run_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RUN, 3, 3, run_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (run_struct_contents.fields.size() < 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        if (!std::holds_alternative<std::string>(run_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.cypher_query = std::get<std::string>(std::move(run_struct_contents.fields[0]));
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto params_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[1]));
        if (!params_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.parameters = std::move(params_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[2])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[2]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;

        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && pair.first == "db") ||
                                   ((server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) && pair.first == "imp_user") ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory for map */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure pull_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ PULL has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 1, 1, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (pull_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(pull_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(pull_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ PULL
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT; // Be strict or allow for now?
            }
        } else {  // Bolt < 4.0 (PULL_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 0, 0, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            // For PULL_ALL, n is implicitly -1 (all), qid is implicitly -1 (last query)
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure discard_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ DISCARD has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 1, 1, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (discard_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(discard_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(discard_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ DISCARD
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else {  // Bolt < 4.0 (DISCARD_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 0, 0, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};  // Clear params

        // ROUTE message introduced in 4.3. PSS has 3 fields.
        if (server_negotiated_version < versions::Version(4, 3)) {
            reader.set_error(BoltError::UNSUPPORTED_PROTOCOL_VERSION);  // Or INVALID_MESSAGE_FORMAT
            return reader.get_error();
        }

        PackStreamStructure route_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROUTE, 3, 3, route_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (route_struct_contents.fields.size() != 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Field 0: routing_context (Map)
        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto route_context_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[0]));
        if (!route_context_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.routing_table_context = std::move(route_context_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 1: bookmarks (List<String>)
        if (!std::holds_alternative<std::shared_ptr<BoltList>>(route_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto bookmarks_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(route_struct_contents.fields[1]));
        if (!bookmarks_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        out_params.bookmarks.clear();
        try {
            out_params.bookmarks.reserve(bookmarks_list_sptr->elements.size());
            for (const auto& bm_val : bookmarks_list_sptr->elements) {
                if (std::holds_alternative<std::string>(bm_val)) {
                    out_params.bookmarks.push_back(std::get<std::string>(bm_val));
                } else {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;  // Bookmark not a string
                }
            }
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 2: Varies by version (db string for 4.3, extra map for 4.4+)
        if (server_negotiated_version.major == 4 && server_negotiated_version.minor == 3) {  // Bolt 4.3
            if (std::holds_alternative<std::string>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::get<std::string>(std::move(route_struct_contents.fields[2]));
            } else if (std::holds_alternative<std::nullptr_t>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::nullopt;
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Expected string or null
            }
        } else if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {  // Bolt 4.4+
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[2])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[2]));
            if (extra_map_sptr) {  // Map can be empty, but shared_ptr should be non-null
                out_params.extra_for_v44_plus = std::move(extra_map_sptr->pairs);
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Extra map field was null
            }
        }
        // For Bolt 5.0+, the PSS structure is like 4.4 (3 fields, 3rd is extra map).
        // The semantic meaning of routing_table_context and extra_for_v44_plus for ROUTE V2 is handled
        // by how the client populates RouteMessageParams and how server interprets them.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For deserialize_message_structure_prelude
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure begin_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::BEGIN, 1, 1, begin_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (begin_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(begin_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(begin_struct_contents.fields[0]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;
        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && (pair.first == "db" || pair.first == "imp_user")) ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_commit_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // CommitMessageParams is empty struct, no out_params needed.

        PackStreamStructure commit_struct_contents;
        // COMMIT PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::COMMIT, 1, 1, commit_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // Validate the field is indeed a map (preferably empty).
        if (commit_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map field was a null shared_ptr
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Specification: "Fields: No fields." but the PackStream structure for COMMIT is `COMMIT {}`
        // This means the PSS has one field, which is an empty map.
        // We can optionally check if map_sptr->pairs is empty for stricter validation.
        // if (!map_sptr->pairs.empty()) {
        //     reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Expected empty map
        //     return BoltError::INVALID_MESSAGE_FORMAT;
        // }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_rollback_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RollbackMessageParams is empty.

        PackStreamStructure rollback_struct_contents;
        // ROLLBACK PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROLLBACK, 1, 1, rollback_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }
        // Validate the field.
        if (rollback_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // The map should be empty.
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>
#include <vector>

#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_optional_list_string_from_map if used
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure success_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::SUCCESS, 1, 1, success_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (success_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(success_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(success_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Example of how an upper layer (e.g., ClientSession) might use this:
        // After calling deserialize_success_message for a HELLO response:
        // if (auto patch_list_val = boltprotocol::detail::get_optional_list_string_from_map(boltprotocol::BoltMap{out_params.metadata}, "patch_bolt")) {
        //    session.agreed_patches = patch_list_val.value();
        //    for(const auto& patch : session.agreed_patches) {
        //        if (patch == "utc") session.utc_patch_active_for_4_4 = true;
        //    }
        // }
        // This logic belongs in the consuming code, not the generic deserializer.

        return BoltError::SUCCESS;
    }

    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure failure_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::FAILURE, 1, 1, failure_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (failure_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(failure_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(failure_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.fields.clear();

        PackStreamStructure record_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RECORD, 1, 1, record_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (record_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltList>>(record_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltList> fields_list_sptr;
        try {
            fields_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(record_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!fields_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.fields = std::move(fields_list_sptr->elements);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (!ignored_struct_contents.fields.empty()) {
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_reader.h"  // 主声明

#include <cstring>    // For memcpy in consume_bytes (if used for non-trivial types, though here it's for raw bytes)
#include <exception>  // For std::bad_alloc (relevant for Value assignment in read() if target type allocates)
#include <iostream>   // For std::istream operations
// byte_order_utils.h is included via packstream_reader.h

namespace boltprotocol {

    // --- PackStreamReader Constructor and Basic IO ---

    PackStreamReader::PackStreamReader(const std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // No body needed if all initialization is in member initializer list
    }

    PackStreamReader::PackStreamReader(std::istream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {   // Basic stream validity check
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if appropriate
        }
    }

    void PackStreamReader::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    bool PackStreamReader::eof() const {
        if (has_error()) return true;  // If already in error, considered EOF for reading purposes
        if (buffer_ptr_) {
            return buffer_pos_ >= buffer_ptr_->size();
        }
        if (stream_ptr_) {
            // stream.eof() is only true after an attempt to read past EOF.
            // stream.peek() == EOF is a more reliable way to check without consuming.
            return stream_ptr_->peek() == EOF;
        }
        return true;  // No valid source
    }

    BoltError PackStreamReader::peek_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check stream state before peeking
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->peek();  // peek() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {  // badbit indicates a serious I/O error
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // eofbit, or (eofbit and failbit if formatting error also occurred)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_++];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->get();  // get() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_bytes(void* dest, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to read
        if (dest == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            if (buffer_pos_ + size <= buffer_ptr_->size()) {
                // Using reinterpret_cast for buffer_ptr_->data() is okay as it's uint8_t
                std::memcpy(dest, buffer_ptr_->data() + buffer_pos_, size);
                buffer_pos_ += size;
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // Buffer read out of bounds
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->read(static_cast<char*>(dest), static_cast<std::streamsize>(size));

            // Check if the read was successful and complete
            if (static_cast<size_t>(stream_ptr_->gcount()) != size) {
                // failbit will be set if gcount() < size and not EOF, or badbit is set.
                // eofbit will be set if EOF was reached during the read.
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // Could be failbit (less data than requested) or eofbit (hit EOF)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // Not enough data or other stream error
                }
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    // --- PackStreamReader Main Read Logic ---

    BoltError PackStreamReader::read(Value& out_value) {
        // Reset output value to a known state (nullptr for variant is a good default)
        try {
            out_value = nullptr;
        } catch (const std::bad_alloc&) {  // Should not happen for nullptr_t assignment
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        if (has_error()) return error_state_;
        if (eof()) {                                      // Check before attempting to consume any byte
            set_error(BoltError::DESERIALIZATION_ERROR);  // Attempt to read past EOF
            return error_state_;
        }

        uint8_t marker;
        BoltError err = consume_byte(marker);
        if (err != BoltError::SUCCESS) return err;  // error_state_ already set by consume_byte

        // Handle Tiny Positive Int (0 to 127) and Tiny Negative Int (-16 to -1) directly
        // These are outside the typical marker switch for performance and clarity.
        if (marker <= 0x7F) {  // Tiny Positive Int (0 to 127)
            try {
                out_value = static_cast<int64_t>(marker);
            } catch (const std::bad_alloc&) {  // Value variant assignment might allocate.
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        if (marker >= 0xF0) {  // Tiny Negative Int (-16 to -1)
            try {
                out_value = static_cast<int64_t>(static_cast<int8_t>(marker));
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }

        // Dispatch to type-specific handlers based on marker
        // These handlers are now in separate .cpp files but are still part of PackStreamReader class.
        switch (marker) {
            case MARKER_NULL:
                return read_null_value(out_value);
            case MARKER_FALSE:
                return read_boolean_value(false, out_value);
            case MARKER_TRUE:
                return read_boolean_value(true, out_value);
            case MARKER_FLOAT64:
                return read_float64_value(out_value);

            case MARKER_INT_8:
            case MARKER_INT_16:
            case MARKER_INT_32:
            case MARKER_INT_64:
                return read_integer_value(marker, out_value);

            // Ranged cases for C++20 and later (as per project requirement)
            case MARKER_TINY_STRING_BASE ...(MARKER_TINY_STRING_BASE + 0x0F):  // 0x80 to 0x8F
            case MARKER_STRING_8:
            case MARKER_STRING_16:
            case MARKER_STRING_32:
                return read_string_value(marker, out_value);

            case MARKER_TINY_LIST_BASE ...(MARKER_TINY_LIST_BASE + 0x0F):  // 0x90 to 0x9F
            case MARKER_LIST_8:
            case MARKER_LIST_16:
            case MARKER_LIST_32:
                return read_list_value(marker, out_value);

            case MARKER_TINY_MAP_BASE ...(MARKER_TINY_MAP_BASE + 0x0F):  // 0xA0 to 0xAF
            case MARKER_MAP_8:
            case MARKER_MAP_16:
            case MARKER_MAP_32:
                return read_map_value(marker, out_value);

            case MARKER_TINY_STRUCT_BASE ...(MARKER_TINY_STRUCT_BASE + 0x0F):  // 0xB0 to 0xBF
            case MARKER_STRUCT_8:
            case MARKER_STRUCT_16:
                return read_struct_value(marker, out_value);

            default:
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Unknown marker
                return error_state_;
        }
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error, std::bad_variant_access
#include <map>
#include <memory>  // For std::shared_ptr, std::make_shared
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read List elements into a pre-allocated BoltList shared_ptr
    BoltError PackStreamReader::read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!list_sptr) {  // Should be allocated by caller (read_list_value)
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = BoltError::SUCCESS;
        try {
            list_sptr->elements.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large for vector
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value element;
            err = this->read(element);  // Recursive call to PackStreamReader::read for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call
                return error_state_;
            }
            try {
                list_sptr->elements.push_back(std::move(element));  // Value move ctor/vector push_back
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other potential exceptions from push_back or Value move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_list_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_LIST_BASE) {  // Tiny List (0x90 to 0x9F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_LIST_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltList> list_sptr;
        try {
            list_sptr = std::make_shared<BoltList>();  // Potential std::bad_alloc
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other errors from make_shared construction
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        // No need to check if (!list_sptr) because make_shared throws on failure.

        err = read_list_elements_into(list_sptr, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set
            return error_state_;
        }

        try {
            out_value = std::move(list_sptr);  // Move shared_ptr into variant
        } catch (const std::bad_alloc&) {      // Variant assignment can allocate.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // Helper to read Map key-value pairs into a pre-allocated BoltMap shared_ptr
    BoltError PackStreamReader::read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!map_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        for (uint32_t i = 0; i < size; ++i) {
            Value key_as_value;
            err = this->read(key_as_value);  // Read map key
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            std::string key_str;
            if (std::holds_alternative<std::string>(key_as_value)) {
                try {
                    // std::get for rvalue variant returns rvalue ref or throws if type mismatch / bad state
                    key_str = std::get<std::string>(std::move(key_as_value));
                } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                    current_recursion_depth_--;
                    set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return error_state_;
                } catch (const std::bad_alloc&) {  // string move assignment/ctor
                    current_recursion_depth_--;
                    set_error(BoltError::OUT_OF_MEMORY);
                    return error_state_;
                } catch (const std::exception&) {
                    current_recursion_depth_--;
                    set_error(BoltError::UNKNOWN_ERROR);
                    return error_state_;
                }
            } else {
                current_recursion_depth_--;
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map key must be a string
                return error_state_;
            }

            Value map_value_element;
            err = this->read(map_value_element);  // Read map value
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            try {
                // map::emplace can throw (e.g. bad_alloc for node, or if Value copy/move throws)
                map_sptr->pairs.emplace(std::move(key_str), std::move(map_value_element));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other exceptions from emplace or Value's move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_map_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_MAP_BASE) {  // Tiny Map (0xA0 to 0xAF)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_MAP_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltMap> map_sptr;
        try {
            map_sptr = std::make_shared<BoltMap>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_map_pairs_into(map_sptr, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(map_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less likely here, more in complex types)
#include <limits>     // For std::numeric_limits (though not strictly needed for existing integer logic)

#include "boltprotocol/message_defs.h"       // For Value, BoltError
#include "boltprotocol/packstream_reader.h"  // For PackStreamReader class declaration and constants
// byte_order_utils.h is included via packstream_reader.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamReader::read_null_value(Value& out_value) {
        if (has_error()) return error_state_;
        out_value = nullptr;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_boolean_value(bool bool_val_from_marker, Value& out_value) {
        if (has_error()) return error_state_;
        out_value = bool_val_from_marker;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_float64_value(Value& out_value) {
        if (has_error()) return error_state_;
        uint64_t temp_int;
        BoltError err = consume_network_int(temp_int);  // consume_network_int handles byte swapping
        if (err != BoltError::SUCCESS) return err;

        double val;
        // Ensure that double is 64-bit and has the same endianness concerns as uint64_t
        // The value read into temp_int is already in host byte order.
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&val, &temp_int, sizeof(double));

        try {
            out_value = val;
        } catch (const std::bad_alloc&) {  // Value variant assignment might allocate if it's a complex type, though not for double. Defensive.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_integer_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        BoltError err;
        int64_t final_val = 0;

        switch (marker) {
            case MARKER_INT_8:
                {
                    int8_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_16:
                {
                    int16_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_32:
                {
                    int32_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_64:
                {
                    int64_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = val;
                    break;
                }
            default:
                // This case should ideally not be reached if dispatch in `read()` is correct
                set_error(BoltError::INVALID_ARGUMENT);
                return error_state_;
        }

        try {
            out_value = final_val;
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <string>
#include <vector>  // Though not directly used, good for context

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read string data of a given size into an std::string
    // This was originally in packstream_reader_types.cpp
    BoltError PackStreamReader::read_string_data_into(std::string& out_string, uint32_t size) {
        if (has_error()) return error_state_;
        out_string.clear();

        if (size == 0) {
            return BoltError::SUCCESS;
        }
        try {
            out_string.resize(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {              // String too long for std::string to handle
            set_error(BoltError::DESERIALIZATION_ERROR);  // Or MESSAGE_TOO_LARGE
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        // consume_bytes will set error_state_ on failure (e.g., not enough bytes)
        return consume_bytes(out_string.data(), size);
    }

    BoltError PackStreamReader::read_string_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRING_BASE) {  // Tiny String (0x80 to 0x8F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_STRING_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;  // Already uint32_t
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);  // Marker not a string marker
                    return error_state_;
            }
        }

        std::string s_val;
        err = read_string_data_into(s_val, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ is already set by read_string_data_into or consume_bytes
            return error_state_;
        }

        try {
            out_value = std::move(s_val);  // std::string move constructor into variant
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other potential exceptions from variant assignment
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <memory>     // For std::shared_ptr, std::make_shared
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read Structure fields into a pre-allocated PackStreamStructure shared_ptr
    BoltError PackStreamReader::read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        if (!struct_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        struct_sptr->tag = tag;  // Set the tag

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        try {
            struct_sptr->fields.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value field_val;
            err = this->read(field_val);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }
            try {
                struct_sptr->fields.push_back(std::move(field_val));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_struct_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        uint8_t tag = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRUCT_BASE) {  // Tiny Struct (0xB0 to 0xBF)
            size = marker & 0x0F;
            err = consume_byte(tag);  // Read the tag byte following the marker
            if (err != BoltError::SUCCESS) return err;
        } else {
            switch (marker) {
                case MARKER_STRUCT_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                case MARKER_STRUCT_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        try {
            struct_sptr = std::make_shared<PackStreamStructure>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_struct_fields_into(struct_sptr, tag, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(struct_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_writer.h"  // 主声明

#include <cstring>    // For memcpy (used in append_network_int indirectly via detail::host_to_be)
#include <exception>  // For std::bad_alloc (relevant for vector buffer operations)
#include <iostream>   // For std::ostream operations
#include <variant>    // For std::visit
// byte_order_utils.h is included via packstream_writer.h

namespace boltprotocol {

    // --- PackStreamWriter Constructor and Low-Level IO ---

    PackStreamWriter::PackStreamWriter(std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // Initialization in member initializer list
    }

    PackStreamWriter::PackStreamWriter(std::ostream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void PackStreamWriter::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    BoltError PackStreamWriter::append_byte(uint8_t byte) {
        if (has_error()) return error_state_;

        if (buffer_ptr_) {
            try {
                buffer_ptr_->push_back(byte);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other possible exceptions from vector
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->put(static_cast<char>(byte));
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);  // Error after writing
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::append_bytes(const void* data, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to append
        if (data == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            const auto* byte_data = static_cast<const uint8_t*>(data);
            try {
                // Insert range [first, last)
                buffer_ptr_->insert(buffer_ptr_->end(), byte_data, byte_data + size);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other vector exceptions
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->write(static_cast<const char*>(data), static_cast<std::streamsize>(size));
            if (stream_ptr_->fail()) {  // Error after writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // --- PackStreamWriter Main Dispatch Logic ---

    BoltError PackStreamWriter::write(const Value& value) {
        if (has_error()) return error_state_;  // Already in error

        // Visitor lambda to dispatch to internal type-specific writers
        auto visitor = [&](const auto& arg) -> BoltError {
            // std::decay_t to handle const& from variant's get/visit
            using T = std::decay_t<decltype(arg)>;

            if constexpr (std::is_same_v<T, std::nullptr_t>) {
                return write_null_internal();
            } else if constexpr (std::is_same_v<T, bool>) {
                return write_boolean_internal(arg);
            } else if constexpr (std::is_same_v<T, int64_t>) {
                return write_integer_internal(arg);
            } else if constexpr (std::is_same_v<T, double>) {
                return write_float_internal(arg);
            } else if constexpr (std::is_same_v<T, std::string>) {
                return serialize_string_internal(arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltList>>) {
                if (!arg) {  // Handle null shared_ptr as PackStream NULL
                    return write_null_internal();
                }
                return serialize_list_internal(*arg);  // Dereference shared_ptr
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltMap>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_map_internal(*arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<PackStreamStructure>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_structure_internal(*arg);
            } else {
                // This static_assert will fail at compile time if Value has an unhandled type.
                // static_assert(false, "Unhandled type in PackStreamWriter::write visitor");
                // For runtime, in case a type slips through somehow (shouldn't with variant):
                set_error(BoltError::SERIALIZATION_ERROR);  // Unknown type to serialize
                return error_state_;
            }
        };

        return std::visit(visitor, value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits
#include <map>
#include <memory>  // For std::shared_ptr (used in Value variant)
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_list_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny List
            err = append_byte(MARKER_TINY_LIST_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_LIST_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_LIST_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // LIST_32
            err = append_byte(MARKER_LIST_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_list_internal(const BoltList& list_data) {
        if (has_error()) return error_state_;
        const auto& list_elements = list_data.elements;

        if (list_elements.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // List too large for PackStream size encoding
            return error_state_;
        }
        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_list_header_internal(static_cast<uint32_t>(list_elements.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;  // Error already set
        }

        for (const auto& item : list_elements) {
            err = this->write(item);  // Recursive call to PackStreamWriter::write for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call to write()
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::write_map_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Map
            err = append_byte(MARKER_TINY_MAP_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_MAP_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_MAP_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // MAP_32
            err = append_byte(MARKER_MAP_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_map_internal(const BoltMap& map_data) {
        if (has_error()) return error_state_;
        const auto& map_pairs = map_data.pairs;

        if (map_pairs.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // Map too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_map_header_internal(static_cast<uint32_t>(map_pairs.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& pair : map_pairs) {
            // Write key (must be string for PackStream maps)
            err = serialize_string_internal(pair.first);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by serialize_string_internal
            }
            // Write value (recursive call)
            err = this->write(pair.second);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by recursive write()
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less direct here)
#include <limits>     // For std::numeric_limits

#include "boltprotocol/message_defs.h"       // For BoltError (though packstream_writer.h includes it)
#include "boltprotocol/packstream_writer.h"  // For PackStreamWriter class declaration and constants
// byte_order_utils.h is included via packstream_writer.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamWriter::write_null_internal() {
        if (has_error()) return error_state_;
        return append_byte(MARKER_NULL);
    }

    BoltError PackStreamWriter::write_boolean_internal(bool bool_value) {
        if (has_error()) return error_state_;
        return append_byte(bool_value ? MARKER_TRUE : MARKER_FALSE);
    }

    BoltError PackStreamWriter::write_integer_internal(int64_t int_value) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;  // Initialize err

        if (int_value >= -16 && int_value <= 127) {  // Tiny Int
            err = append_byte(static_cast<uint8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int8_t>::min() && int_value <= std::numeric_limits<int8_t>::max()) {
            err = append_byte(MARKER_INT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int16_t>::min() && int_value <= std::numeric_limits<int16_t>::max()) {
            err = append_byte(MARKER_INT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int16_t>(int_value));
        } else if (int_value >= std::numeric_limits<int32_t>::min() && int_value <= std::numeric_limits<int32_t>::max()) {
            err = append_byte(MARKER_INT_32);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int32_t>(int_value));
        } else {  // INT_64
            err = append_byte(MARKER_INT_64);
            if (err == BoltError::SUCCESS) err = append_network_int(int_value);
        }
        return err;  // Return the result of the last append operation
    }

    BoltError PackStreamWriter::write_float_internal(double float_value) {
        if (has_error()) return error_state_;
        BoltError err = append_byte(MARKER_FLOAT64);
        if (err != BoltError::SUCCESS) return err;  // If appending marker failed

        uint64_t temp_int;  // To hold byte representation of double
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&temp_int, &float_value, sizeof(double));

        // append_network_int will handle host-to-be conversion for temp_int
        return append_network_int(temp_int);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc (from vector operations if buffer_ptr_)
#include <limits>     // For std::numeric_limits
#include <string>
#include <vector>  // For buffer_ptr_ if used (though append_bytes handles it)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_string_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny String (0x80 to 0x8F)
            err = append_byte(MARKER_TINY_STRING_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_STRING_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_STRING_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // STRING_32 (uint32_t max is handled by PackStream spec)
            err = append_byte(MARKER_STRING_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);  // size is already uint32_t
        }
        return err;
    }

    BoltError PackStreamWriter::write_string_data_internal(const std::string& value_str) {
        if (has_error()) return error_state_;
        if (value_str.empty()) {
            return BoltError::SUCCESS;  // Nothing to append for an empty string's data
        }
        // append_bytes handles potential errors (like OUT_OF_MEMORY if writing to vector buffer)
        return append_bytes(value_str.data(), value_str.length());
    }

    BoltError PackStreamWriter::serialize_string_internal(const std::string& str_value) {
        if (has_error()) return error_state_;

        // PackStream strings are limited to 2^32 - 1 bytes (UINT32_MAX).
        // std::string::length() returns size_t.
        if (str_value.length() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // String too long for PackStream
            return error_state_;
        }
        uint32_t len = static_cast<uint32_t>(str_value.length());

        BoltError err = write_string_header_internal(len);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set by write_string_header_internal or its callees
            return error_state_;
        }
        // Only write data if length > 0 (handled by write_string_data_internal)
        return write_string_data_internal(str_value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits (for STRUCT_16 max size)
#include <memory>     // For std::shared_ptr (used in Value variant)
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_struct_header_internal(uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Struct (0xB0 to 0xBF)
            err = append_byte(MARKER_TINY_STRUCT_BASE | static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint8_t>::max()) {  // Struct 8
            err = append_byte(MARKER_STRUCT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint16_t>::max()) {  // Struct 16
            err = append_byte(MARKER_STRUCT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else {
            // PackStream v1 (which Bolt uses) does not define STRUCT_32.
            // Maximum number of fields for a structure is 65535 (0xFFFF).
            set_error(BoltError::SERIALIZATION_ERROR);  // Structure too large for PackStream v1 encoding
            return error_state_;
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_structure_internal(const PackStreamStructure& struct_data) {
        if (has_error()) return error_state_;

        // Max fields for a PackStream structure (STRUCT_16 limit)
        if (struct_data.fields.size() > std::numeric_limits<uint16_t>::max()) {  // 65535
            set_error(BoltError::SERIALIZATION_ERROR);                           // Structure too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_struct_header_internal(struct_data.tag, static_cast<uint32_t>(struct_data.fields.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& field : struct_data.fields) {
            err = this->write(field);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocolBolt Protocol handshake specification

All Bolt connections begin with a handshake to negotiate which version of the messaging protocol to use. Following a successful negotiation, the agreed messaging protocol then takes ownership of the connection for the remainder of its lifetime. The handshake itself is not versioned.

Bolt is a client-server protocol designed primarily for executing queries against a database server. Communication occurs through request-response exchanges, in much the same way as HTTP. Unlike HTTP, however, Bolt connections are stateful.

Bolt Protocol message specification

The message specification describes the message exchanges that take place on a connection following a successful Bolt handshake. For details of establishing a connection and performing a handshake, see Bolt Protocol handshake specification.

The Bolt protocol communicates with specific versioned messages.
Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.

For more information, see the corresponding version of the Bolt Protocol server state specification.
Server signals

Jump ahead means that the signal is immediately available before any messages are processed in the message queue.
Server signal 	Jump ahead 	Description

<INTERRUPT>


X

an interrupt signal

<DISCONNECT>


a disconnect signal
Protocol errors

If a server or client receives a message type that is unexpected, according to the transitions described in this document, it must treat that as a protocol error. Protocol errors are fatal and should immediately transition the server state to DEFUNCT, closing any open connections.
Session

Each connection to the server creates a new session that lives until that connection is closed. Each session is isolated and the server keeps track of the current state, based on the requests and responses exchanged within that session. A session ends when the socket for that connection is closed. Typically, this will be closed by the client.
Message exchange

Messages are exchanged in a request-response pattern between client and server. Each request consists of exactly one message and each response consists of zero or more detail messages followed by exactly one summary message. The presence or absence of detail messages in a response is directly related to the type of request message that has been sent. In other words, some request message types elicit a response that may contain detail messages, others do not.

Messages may also be pipelined. In other words, clients may send multiple requests eagerly without first waiting for responses. When a failure occurs in this scenario, servers must ignore all subsequent requests until the client has explicitly acknowledged receipt of the failure. This prevents inadvertent execution of queries that may not be valid. More details of this process can be found in the sections below.
Serialization

Messages and their contents are serialized into network streams using PackStream Specification Version 1. Each message is represented as a PackStream structure that contains a fixed number of fields. The message type is denoted by the PackStream structure tag byte and each message is defined in the Bolt protocol. Serialization is specified with PackStream Version 1.
Chunking

A layer of chunking is also applied to message transmissions as a way to more predictably manage packets of data. The chunking process allows the message to be broken into one or more pieces, each of an arbitrary size, and for those pieces to be transmitted within separate chunks. Each chunk consists of a two-byte header, detailing the chunk size in bytes followed by the chunk data itself. Chunk headers are 16-bit unsigned integers, meaning that the maximum theoretical chunk size permitted is 65,535 bytes.

Each encoded message must be terminated with a chunk of zero size, i.e.

00 00

This is used to signal message boundaries to a receiving parties, allowing blocks of data to be fully received without requiring that the message is parsed immediately. This also allows for unknown message types to be received and handled without breaking the messaging chain.

The Bolt protocol encodes each message using a chunked transfer encoding.

Each message is transferred as one or more chunks of data.

Each chunk starts with a two-byte header, an unsigned big-endian 16-bit integer, representing the size of the chunk not including the header.

A message can be divided across multiple chunks, allowing client and server alike to transfer large messages without having to determine the length of the entire message in advance.

Chunking applies on each message individually.

One chunk cannot contain more than one message.

Each message ends with two bytes with the value 00 00, these are not counted towards the chunk size (you may consider them as individual chunks of size 0).

With version 4.1+, the NOOP chunk (empty chunk) is used to send an empty chunk and the purpose is to be able to support a keep alive behaviour on the connection.


Examples of how Bolt chunks messages
Example of a message in one chunk

Message data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

results in the following chunk:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00

with the chunk header 00 10 and the end marker 00 00.
Example of a message split in two chunks

Message data containing 20 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 02 03 04

results in chunk 1 and chunk 2:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00 04 01 02 03 04 00 00

with the chunk 1 header 00 01 and no end marker for chunk 1, still message data. Chunk 2 has a header 00 04 and an end marker 00 00.
Example with two messages

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

are both encoded with chunking:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Example with two messages with a NOOP in between

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

The two messages encoded with chunking and a NOOP(empty chunk) in between:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Pipelining

The client may send multiple requests eagerly without first waiting for responses.
Transaction

A transaction is the concept of atomic units of work.

The concept of Transaction is when the server is in the READY state and the transaction is opened with the request message RUN and the response of a summary message SUCCESS. The Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL.

Version 3 of the Bolt Protocol introduces the concept of Auto-commit Transaction and Explicit Transaction. Auto-commit Transaction is the server in the READY state and the transition to the STREAMING state. The transaction is opened with the request message RUN and the response of a summary message SUCCESS.

The Auto-commit Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL. Thus, the Auto-commit Transaction can only contain one RUN request message.

In version 4 of the Bolt Protocol, the DISCARD_ALL and PULL_ALL messages are renamed to DISCARD and PULL and new fields are introduced.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: RUN ...      // Open a new Auto-commit Transaction
S: SUCCESS ...  // Server is in STREAMING state

C: PULL ...
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in STREAMING state

C: PULL
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in READY state and this implies that the Auto-commit Transaction is closed.

In version 1, HELLO is called INIT and Auto-commit Transaction is just Transaction. The field has_more=true/false is introduced in version 4. See also the corresponding version of the Bolt Protocol server state specification.

The Explicit Transaction is introduced in version 3 of Bolt and is a more generic transaction that can contain several RUN request messages. The concept of Explicit Transaction is when the server is in the READY state and the transaction is opened with the request message BEGIN and the response of a summary message SUCCESS (thus transition into the TX_READY server state).

The Explicit Transaction is successfully closed with the request message COMMIT and the response of a summary message SUCCESS. The result stream (detail messages) must be fully consumed or discarded by a client before the server can transition to the TX_READY state and thus be able to close the transaction with a COMMIT request message. It can be gracefully discarded and set to the initial server state of READY with the request message ROLLBACK.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: BEGIN ...    // Open a new Explicit Transaction
S: SUCCESS ...  // Server is in TX_READY state

C: RUN ...
S: SUCCESS {"qid": 123, ...} // Server is in TX_STREAMING state, one stream is open

C: RUN ...
S: SUCCESS {"qid": 456, ...} // Server is in TX_STREAMING state, two streams are open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in TX_STREAMING state, two streams are still open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is still in TX_STREAMING state, one stream is still open

C: PULL {"qid": 456, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in TX_READY state, all streams have been fully consumed

C: COMMIT   // Close the Explicit Transaction
S: SUCCESS  // Server is in READY state

In version 3, PULL is called PULL_ALL. Additionally, there are no fields, e.g qid=123 and has_more=true/false available in version 3 of the Bolt Protocol.

More examples of message exchanges can be found in Appendix — Message exchange examples.
Messages

There are three different kinds of messages:

Request message - the client sends a message.

Summary message - the server always responds with one summary message if the connection is still open.

Detail message - the server always responds with zero or more detail messages before sending a summary message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Message 	Signature 	Type of message 	Fields 	Description

HELLO

01

Request

extra::Dictionary(user_agent::String, routing::Dictionary(address::String), notifications_minimum_severity::String, notifications_disabled_categories::List<String>, bolt_agent::Dictionary(product::String, platform::String, language::String, language_details::String))

initialize connection (replaces INIT of v1 & v2)(routing::Dictionary(address::String) added in v4.1) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)(bolt_agent::Dictionary added in v5.3)

LOGON

6A

Request

scheme::String, …​

authenticates the user you send with the message

LOGOFF

6B

Request

logs off current user, becomes ready for another LOGON message

TELEMETRY

54

Request

api::Integer

transmit usage telemetry (added in v5.4)

GOODBYE

02

Request

close the connection, triggers a <DISCONNECT> signal

ACK_FAILURE (only v1 and v2)

0E

Request

acknowledge a failure response (deprecated, use RESET instead with v3+)

RESET

0F

Request

reset the connection, triggers an <INTERRUPT> signal

RUN

10

Request

query::String, parameters::Dictionary, extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db:String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

execute a query (extra::Dictionary added in v3)(db:String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

DISCARD

2F

Request

extra::Dictionary(n::Integer, qid::Integer)

discard records (replaces DISCARD_ALL of v1, v2 & v3)(fields added in v4.0)

PULL

3F

Request

extra::Dictionary(n::Integer, qid::Integer)

fetch records (replaces PULL_ALL of v1, v2 & v3)(fields added in v4.0)

BEGIN

11

Request

extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db::String, imp_user::String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

begin a new transaction (added in v3)(db::String, imp_user::String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

COMMIT

12

Request

commit a transaction (added in v3)

ROLLBACK

13

Request

rollback a transaction (added in v3)

ROUTE

66

Request

routing::Dictionary(address::String), bookmarks::List<String>, extra::Dictionary(db::String, imp_user::String)

fetch the current routing table (added in v4.3)

SUCCESS

70

Summary

metadata::Dictionary

request succeeded

IGNORED

7E

Summary

request was ignored

FAILURE

7F

Summary

metadata::Dictionary

request failed

RECORD

71

Detail

data::List

data values
Request message HELLO

Introduced in bolt 3

The HELLO message request the connection to be authorized for use with the remote database and replaces the INIT request message of version 1 and 2. See below for more information on INIT.

The server must be in the CONNECTED state to be able to process a HELLO message. For any other states, receipt of an HELLO request must be considered a protocol violation and lead to connection closure.

Clients should send HELLO message to the server immediately after connection and process the corresponding response before using that connection in any other way.

Clients wishing to retry initialization should establish a new connection.

In version 4.1, routing::Dictionary(address::String) was added to indicate an indicator if the server should carry out routing, according to the given routing context.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

In version 5.3, bolt_agent::Dictionary was added to indicate the underlying driver and its version as opposed to the application using the driver in `user_agent.

On versions earlier than 5.1, the authentication token described on the LOGON message should be sent as part of the HELLO message instead.
routing values 	Description

{"routing": null} or {}

the server should not carry out routing

{"routing": {}}

the server should carry out routing

{"routing": {"address": "x.example.com:9001", "region": "example", …​}}

the server should carry out routing according to the given routing context

Signature: 01
Fields:

extra::Dictionary(
scheme::String,
...
user_agent::String,
patch_bolt::List<String>,
routing::Dictionary(address::String),
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>,
bolt_agent::Dictionary(
product::String,
platform::String,
language::String,
language_details::String
)
)

scheme is the authentication scheme, alongside any additional entries (...) specific to the chosen scheme. Predefined schemes are: "none", "basic", "bearer", "kerberos" (depending on the server’s capabilities). See LOGON message for more information. Removed after bolt 5.0

The user_agent should conform to "Name/Version" for example "Example/4.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information). Drivers should allow application code to set this value as it is meant to identify the application using the driver.

patch_bolt lets the driver request a patch to the protocol from the server. The patch must not be applied until the server acknowledges it in the SUCCESS response. Default: []. Introduced in bolt 4.3 Removed after bolt 4.4

    "utc" is currently the only supported patch. If successfully negotiated, server and driver will use DateTime and DateTimeZoneId as defined in Bolt version 5.0.

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string. Setting routing to null indicates that the server should not carry out any routing. Default: null. Introduced in bolt 4.1

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

bolt_agent::Dictionary, as opposed to user_agent, is meant to identify the driver rather than the application using it. Drivers should not allow applications to change this value. When populating the fields, drivers should be careful not to include anything that could be used to identify a single machine or user. This field is mandatory. Introduced in bolt 5.3

    product::String should conform to "Name/Version" and identify the driver for example "neo4j-fortran-alice-doe/42.69.0". This field is mandatory.

    platform::String should describe the platform the driver is running on for example "Linux 5.15.0-58-generic; x86_64". Send null (or omit) if no platform information is available. Default: null.

    language::String should conform to "Name/Version" and describe the language the driver/application is written in for example "Fortran/77". Send null (or omit) if no language information is available. Default: null.

    language_details::String can contain further information about the language the driver/application is written in for example compiler, runtime, or interpreter and respective versions. Send null (or omit) if no language details are available. Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

HELLO {extra}

Example 1

HELLO {"user_agent": "Example/4.1.0", "routing": {"address": "x.example.com:9001"}, "bolt_agent": {"product": "neo4j-fortran-alice-doe/42.69.0", "platform": "Linux 5.15.0-58-generic; x86_64", "language": "Fortran/77", "language_details": "gfortran 9.3.0"}}

Example 2

HELLO {"user_agent": "Example/4.2.0", "patch_bolt": ["utc"], "routing": {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"}, "notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata:

server::String (server agent string, example "Neo4j/4.1.0")

connection_id::String (unique identifier of the bolt connection used on the server side, example: "bolt-61")

patch_bolt::List<String> only if the client requested patches in the patch_bolt field of the request. The server will include the subset of requested patches (with the exact same string the client requests) if it supports it. From that point onward, the server-client communication must only use the patched protocol. Introduced in bolt 4.3 Removed after bolt 4.4

hints::Dictionary (set of optional configuration hints to be considered by the driver) Introduced in bolt 4.3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The hints dictionary may contain a set of optional configuration hints which may be interpreted or ignored by drivers at their own discretion in order to augment operations where applicable. A full listing of the available hints may be found in Appendix — Connection hints. Hints remain valid throughout the lifetime of a given connection and cannot be changed. As such, newly established connections may observe different hints and/or hint values as the server configuration is adjusted.
Example

SUCCESS {"server": "Neo4j/4.0.0", "hints": {"connection.recv_timeout_seconds": 120}}

Example 2

SUCCESS {"server": "Neo4j/4.4.0", "patch_bolt": ["utc"], "hints": {"connection.recv_timeout_seconds": 120}}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages. Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1+

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message INIT

Introduced in bolt 1 Removed after bolt 2

The INIT message is a request for the connection to be authorized for use with the remote database.

The request message INIT is only valid in version 1 and 2 and is replaced by the request message HELLO in version 3+.

The INIT message uses the structure signature 01 and passes two fields: user agent (String) and auth_token (Dictionary).

The server must be in the CONNECTED state to be able to process an INIT request. For any other states, receipt of an INIT request must be considered a protocol violation and lead to connection closure.

Clients should send INIT requests to the network immediately after connection and process the corresponding response before using that connection in any other way.

A receiving server may choose to register or otherwise log the user agent but may also ignore it if preferred.

The auth token should be used by the server to determine whether the client is permitted to exchange further messages. If this authentication fails, the server must respond with a FAILURE message and immediately close the connection. Clients wishing to retry initialization should establish a new connection.

Signature: 01
Fields:

user_agent::String,
auth_token::Dictionary(
scheme::String,
principal::String,
credentials::String,
)

The user_agent should conform to "Name/Version" for example "Example/1.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information).

The scheme is the authentication scheme. Predefined schemes are "none" and "basic". If no scheme is provided, it defaults to "none".

The auth_token must contain either just the entry {"scheme" : "none"} or the keys scheme, principal and credentials.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid Summary Messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

INIT "user_agent" {auth_token}

Example 1

INIT "Example/1.0.0" {"scheme": "none"}

Example 2

INIT "Example/1.0.0" {"scheme": "basic", "principal": "neo4j", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata.

server::String (server agent string, example "Neo4j/3.4.0")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"server": "Neo4j/3.4.0"}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages.

Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message LOGON

Introduced in bolt 5.1

A LOGON message carries an authentication request.

This message is new in version 5.1. In previous versions, authentication was part of the HELLO message.

Signature: 6A
Fields:

auth::Dictionary(
scheme::String,
...
)

The scheme is the authentication scheme. Predefined schemes are none, basic, bearer and kerberos (depending on the server’s capabilities).

Further entries in the message are passed to the implementation of the chosen authentication scheme. Their names, types, and defaults depend on that choice.

    The scheme basic requires a username principal::String and a password credentials::String.

    The scheme bearer merely requires a token credentials::String.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

If authentication fails, the server responds with a FAILURE message and immediately closes the connection.
Examples
Synopsis

LOGON {auth}

Example 1

LOGON {"scheme": "basic", "principal": "user", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client has been successfully authenticated.

The following fields are defined for inclusion in the SUCCESS metadata.

advertised_address::String? - the configured advertised address of the database server. Introduced in bolt 5.8

credentials_expired::Boolean - the sent credentials are expired, the user must update them. If this field is not present, it should be considered to be false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v5.8+

SUCCESS {"advertised_address": "graphz.example.com:7687"}

Example v5.1+

SUCCESS {}

Request message LOGOFF

Introduced in bolt 5.1

A LOGOFF message logs off the currently authenticated user. The connection is then ready for another LOGON message.

This message is new in version 5.1. No equivalent exists in previous versions.

Signature: 6B

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

LOGOFF

Example

LOGOFF

Server response SUCCESS

If a LOGOFF message request has been successfully received, the server should respond with a SUCCESS message and enter the AUTHENTICATION state.
Example

SUCCESS {}

Server response FAILURE

If LOGOFF message is received while the server is not in the READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to LOGOFF should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by a session in the FAILED state."}

Example v5.1+

FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by session in the READY state", "gql_status": "08N06", "description": "error: connection exception - protocol error. General network protocol error.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}, "cause": {"message": "08N10: Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "gql_status": "08N10", "description": "error: connection exception - invalid server state. Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Request message TELEMETRY

Introduced in bolt 5.4

The TELEMETRY message contains an integer representing which driver API was used.

The telemetry information is stored on the server’s metrics system. The client receives a SUCCESS response, unless it sends an invalid value for the api field, which results in a FAILURE response.

Clients should offer the user the option to disable sending telemetry. Further, the server might opt out of receiving telemetry from the client by sending the corresponding configuration hint in the SUCCESS message of the HELLO message. See Appendix — Connection hints for more information. If the client ignores the hint, the server must still accept the TELEMETRY message.

The message may only be sent in the READY state.

Signature: 54
Fields:

api::Integer

Valid values for api and the corresponding API associations are:

0 — Managed transaction

1 — Explicit transaction

2 — Implicit transaction

3 — Driver-level execute_query()
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

TELEMETRY api

Example 1

TELEMETRY 0

Server response SUCCESS

If a TELEMETRY message request is successfully received, the server responds with a SUCCESS and remains in its current state.
Example

SUCCESS {}

Server response FAILURE

If a TELEMETRY message contains a value that is not a valid api value or is sent in the wrong state, the server responds with a FAILURE message and enters the FAILED state.
Example 1 v5.7+

C: TELEMETRY 2
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state.", "gql_status": "50N42", "description": "error: general processing exception - unexpected error. Unexpected error has occurred. See debug log for details."}

Example 1 v5.4+

C: TELEMETRY 2
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state."}

Example 2 v5.7+

C: TELEMETRY "oh no!"
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING", "gql_status": "22G03", "description": "error: data exception - invalid value type", "cause": {"message": "22N01: Expected the value 128 to be of type INT, but was of type STRING.", "gql_status": "22N01", "description": "error: data exception - invalid type. Expected the value 128 to be of type INT, but was of type STRING.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Example 2 v5.4+

C: TELEMETRY "oh no!"
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING"}

Example 3 v5.7+

C: TELEMETRY 9001
S: FAILURE {"neo4j_code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "gql_status": "50N00", "description": "error: general processing exception - internal error. Internal exception raised DecoderException: org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "cause": {"message": "50N09: The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "gql_status": "50N09", "description": "error: general processing exception - invalid server state transition. The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "diagnostic_record": {"_classification": "DATABASE_ERROR"}}}

Example 3 v5.4+

C: TELEMETRY 9001
S: FAILURE {"code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001"}

Request message GOODBYE

Introduced in bolt 3

The GOODBYE message notifies the server that the connection is terminating gracefully. On receipt of this message, the server should immediately shut down the socket on its side without sending a response.

A client may shut down the socket at any time after sending the GOODBYE message. This message interrupts the server current work if there is any.

Signature: 02

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

No summary messages should be returned.
Examples
Synopsis

GOODBYE

Example

GOODBYE

Request message ACK_FAILURE

Introduced in bolt 1 Removed after bolt 2

The request message ACK_FAILURE signals to the server that the client has acknowledged a previous failure and should return to a READY state.

The request message ACK_FAILURE is only valid in version 1 and 2 and the request message RESET should be used in its place in version 3+.

Signature: 0E

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a FAILED state to be able to successfully process an ACK_FAILURE request. For any other states, receipt of an ACK_FAILURE request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

ACK_FAILURE

Example

ACK_FAILURE

Server response SUCCESS

If an ACK_FAILURE request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.

The server may attach metadata to the SUCCESS message.
Example

SUCCESS {}

Server response message FAILURE

If an ACK_FAILURE request is received while not in the FAILED state, the server should respond with a FAILURE message and immediately close the connection.

The server may attach metadata to the message to provide more detail on the nature of the failure.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RESET

Introduced in bolt 1

The RESET message requests that the connection should be set back to its initial RESET state, as if a HELLO (INIT in v1 and v2) (and a LOGON in v5.1+) had just successfully completed. The RESET message is unique in that, on arrival at the server, it jumps ahead in the message queue, stopping any unit of work that happens to be executing. All the queued messages originally in front of the RESET message will then be IGNORED until the RESET position is reached. Then from this point, the server state is reset to a state that is ready for a new session.

In version 1 and 2, the RESET message splits into two separate signals. First, an <INTERRUPT> signal jumps ahead in the message queue, stopping any unit of work that happens to be executing, and putting the state machine into an INTERRUPTED state. Second, the RESET queues along with all other incoming messages and is used to put the state machine back to READY when its turn for processing arrives. This essentially means that the INTERRUPTED state exists only transitionally between the arrival of a RESET in the message queue and the later processing of that RESET in its proper position. The INTERRUPTED state is therefore the only state to automatically resolve without any further input from the client and whose entry does not generate a response message.

Signature: 0F

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

RESET

Example

RESET

Server response SUCCESS

If a RESET message request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example

SUCCESS {}

Server response FAILURE

If RESET message is received before the server enters a READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to RESET should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1-v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RUN

Introduced in bolt 1

The RUN message requests that a Cypher query is executed with a set of parameters and additional extra data.

In version 3+, this message can both be used in an Explicit Transaction or an Auto-commit Transaction. The transaction type is implied by the message sequence:

Explicit Transaction: RUN while inside a transaction context started with BEGIN first.

Auto-commit Transaction: RUN without having started an explicit transaction with BEGIN first.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 10
Fields:

query::String,
parameters::Dictionary,
extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The query can be any Cypher query (including a procedure call).

The parameters is a dictionary of parameters to be used in the query string.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

An Explicit Transaction (BEGIN+RUN) does not carry any data in the extra field.

For Auto-commit Transaction (RUN) the extra field carries:

extra contains additional options. Introduced in bolt 3

    The bookmarks is a list of strings containing some kind of bookmark identification, e.g., ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

    The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

    The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

    The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Default: "w".

    The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

    The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

    The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

    The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a READY or READY_TX (v3+) state to be able to successfully process a RUN request. If the server is in a FAILED or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a RUN request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

RUN "query" {parameters} {extra}

Example 1

RUN "RETURN $x AS x" {"x": 1} {"bookmarks": [], "tx_timeout": 123, "tx_metadata": {"log": "example_message"}, "mode": "r"}

Example 2

RUN "RETURN $x AS x" {"x": 1} {}

Example 3

RUN "CALL dbms.procedures()" {} {}

Example 3

RUN "RETURN 42" {} {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages.

The following fields are defined for inclusion in the SUCCESS metadata.

fields::List<String>, the fields of the return result. e.g. [“name”, “age”, …]

t_first::Integer, the time, specified in ms, which the first record in the result stream is available after.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Implicit Transaction (RUN):

db::String? - resolved user’s home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Explicit Transaction (BEGIN+RUN):

qid::Integer specifies the server assigned statement ID to reference the server side result-set with commencing BEGIN`RUN`PULL and BEGIN`RUN`DISCARD messages. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.0+

SUCCESS {"fields": ["x"], "t_first": 123, "qid": 7000}

Example v3+

SUCCESS {"fields": ["x"], "t_first": 123}

For v1 and v2, if a RUN request has been successfully received and is considered valid by the server, the server should respond with a SUCCESS message and enter the STREAMING state. The server may attach metadata to the message to provide header detail for the results that follow. Clients should not consider a SUCCESS response to indicate completion of the execution of that query, merely acceptance of it. The following fields are defined for inclusion in the metadata:

`fields` (e.g. ["name", "age"])

`result_available_after` (e.g. 123)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v1 and v2

SUCCESS {"fields": ["x"], "result_available_after": 123}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message DISCARD

Introduced in bolt 1

The DISCARD message requests that the remainder of the result stream should be thrown away.

In v1, v2 and v3, this message is called DISCARD_ALL, has no fields and issues a request to discard the outstanding result and return to a READY state. A receiving server should not abort the request but continue to process it without streaming any detail messages back to the client.

Signature: 2F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to throw away. n=-1 will throw away all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

DISCARD {extra}

Example 1

DISCARD {"n": -1, "qid": -1}

Example 2

DISCARD {"n": 1000}

Example 3 v1, v2 or v3

DISCARD_ALL

In version 1 and 2, the server must be in a STREAMING or STREAMING_TX (v3+) state to be able to successfully process a DISCARD request. If the server is in a FAILED state or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a DISCARD request will be considered a protocol violation and will lead to connection closure.
Server response SUCCESS

has_more::Boolean, true if there are no more records to stream. If this field is not present, it should be considered to default to false. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::String — the bookmark after committing this transaction (Autocommit Transaction only).

db::String — the database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary> — a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Introduced in bolt 3 Removed after bolt 5.4

statuses::List<Dictionary> — a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionary — plan result. Introduced in bolt 3

profile::Dictionary — profile result. Introduced in bolt 3

result_consumed_after::Integer — same as t_last. Removed after bolt 2

result_available_after::Integer — same as t_first. Removed after bolt 2

stats::Dictionary — counter information, such as db-hits etc. Introduced in bolt 3

t_last::Integer — the time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integer — the time (in ms) after which the DBMS was ready to stream the first record in the result. Introduced in bolt 3

type::String — the type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example 1 v4+

SUCCESS {"has_more": true}

Example 2 v4+

SUCCESS {"bookmark": "example-bookmark:1", "db": "example_database"}

Example v3

SUCCESS {"bookmark": "example-bookmark:1"}

In version 1 and 2, if a DISCARD_ALL request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example v1 and v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Request message PULL

The PULL message requests data from the remainder of the result stream.

In v1, v2, and v3, this message is called PULL_ALL and has no fields. In v1 and v2, this message issues a request to stream the outstanding result back to the client, before returning to a READY state. Result detail consists of zero or more detail messages being sent before the summary message. This version of the protocol defines one such detail message, namely RECORD (described below).

Signature: 3F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to fetch. n=-1 will fetch all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

Zero or more RECORD.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

PULL {extra}

Synopsis v1 - v3

PULL_ALL

Example 1

PULL {"n": -1, "qid": -1}

Example 2

PULL {"n": 1000}

Example v1 - v3

PULL_ALL

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

has_more::Boolean, true if there are more records to stream. If this field is not present it should be considered to default to false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::String — the bookmark after committing this transaction (Autocommit Transaction only).

db::String — the database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary> — a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Removed after bolt 5.4

statuses::List<Dictionary> — a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionary — plan result. Introduced in bolt 3

profile::Dictionary — profile result. Introduced in bolt 3

result_consumed_after::Integer — same as t_last. Removed after bolt 2

result_available_after::Integer — same as t_first. Removed after bolt 2

stats::Dictionary — counter information, such as db-hits etc. Introduced in bolt 3

t_last::Integer — the time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integer — the time (in ms) after which the first record in the result stream is available. Introduced in bolt 3

type::String — the type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v3+

SUCCESS {"bookmark": "example-bookmark:1", "t_last": 123}

Example v1 - v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Server response IGNORED

For v1 and v2, a server that receives a PULL_ALL request while in FAILED state or INTERRUPTED state, should respond with an IGNORED message and discard the request without processing it. No state change should occur.
Example

IGNORED

Server response FAILURE

For v1 and v2, a PULL_ALL message request cannot be processed successfully, the server should respond with a FAILURE message and enter the FAILED state. The server may attach metadata to the message to provide more detail on the nature of the failure.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Server response RECORD (in v1 and v2)

Zero or more RECORD messages may be returned in response to a PULL_ALL prior to the trailing summary message. Each record carries with it a list of values which form the data content of the record. The order of the values within the list should be meaningful to the client, perhaps based on a requested ordering for that result, but no guarantees should be made around the order of records within the result. A record should only be considered valid if followed by a SUCCESS summary message. Until this summary has been received, the record’s validity should be considered tentative.
Example

RECORD [1, 2, 3]

Request massage BEGIN

Introduced in bolt 1

The BEGIN message request the creation of a new Explicit Transaction. This message should then be followed by a RUN message. The Explicit Transaction is closed with either the COMMIT message or ROLLBACK message.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 11
Fields:

extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Defaults to write access if no mode is sent. Default: "w".

The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see the Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

BEGIN {extra}

Example 1

BEGIN {"tx_timeout": 123, "mode": "r", "db": "example_database", "tx_metadata": {"log": "example_log_data"}, "imp_user" : "bob"}

Example 2

BEGIN {"db": "example_database", "tx_metadata": {"log": "example_log_data"}, "bookmarks": ["example-bookmark:1", "example-bookmark2"]}

Example 3

BEGIN {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

db::String? - resolved user’s home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {}

Example with Home Database Resolution

SUCCESS {"db": "my_home_db"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message COMMIT

The COMMIT message request that the Explicit Transaction is done.

The COMMIT message does not exist in v1 and v2.

Signature: 12

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

COMMIT

Example

COMMIT

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was completed:

bookmark::String, the bookmark after committing this transaction.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"bookmark": "example-bookmark:1"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROLLBACK

The ROLLBACK message requests that the Explicit Transaction rolls back.

The ROLLBACK message does not exist in v1 and v2.

Signature: 13

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROLLBACK

Example

ROLLBACK

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was rolled back.
Example

SUCCESS

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROUTE

Introduced in bolt 4.3

The ROUTE instructs the server to return the current routing table. In previous versions there was no explicit message for this and a procedure had to be invoked using Cypher through the RUN and PULL messages.

This message can only be sent after successful authentication and outside of transactions.

Signature: 66
Fields:

routing::Dictionary,
bookmarks::List<String>,
db::String,
extra::Dictionary(
db::String,
imp_user::String,
)

Note that in v4.4, the db parameter is migrated into a dedicated dictionary named extra that also includes the imp_user and thus, in v4.3 the fields are:

routing::Dictionary,
bookmarks::List<String>,
db::String

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string.

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"].

The db specifies the database name for multi-database to select where the transaction takes place. null denotes the server-side configured default database. Removed after bolt 4.3

extra contains additional options. Introduced in bolt 4.4

    db as above. Default: null.

    The imp_user specifies the impersonated user for the purposes of resolving their home database. null denotes no impersonation (execution takes place as the current user). Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROUTE {routing} [bookmarks] {extra}

Example v4.4+

ROUTE {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"} ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"] {"db": "example_database", "imp_user": "bob"}

Example v4.3

ROUTE {"address": "x.example.com:7687"} [] null

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. The following fields are defined for inclusion in the SUCCESS metadata:

rt::Dictionary(ttl::Integer, db::String, servers::List<Dictionary(addresses::List<String>, role::String)>), the current routing table.

    ttl::Integer specifies for how many seconds this routing table should be considered valid.

    db::String identifies the database for which this routing table applies. Introduced in bolt 4.4

    servers have three elements of the type Dictionary(addresses::List<String>, role::String), where role is one of "ROUTE", "READ", "WRITE" for exactly one entry each.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.4+

SUCCESS {
"rt": {"ttl": 1000,
"db": "foo",
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Example v4.3

SUCCESS {
"rt": {"ttl": 1000,
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Server message IGNORED
Example

IGNORED

Server message FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v4.3 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Summary message SUCCESS

The SUCCESS message indicates that the corresponding request has succeeded as intended. It may contain metadata relating to the outcome. Metadata keys are described in the section of this document relating to the message that began the exchange.

Signature: 70
Fields:

metadata::Dictionary

Examples
Synopsis

SUCCESS {metadata}

Example

SUCCESS {"example": "see specific message for server response metadata"}

Summary message IGNORED

The IGNORED message indicates that the corresponding request has not been carried out.

Signature: 7E

Fields: No fields.
Examples
Synopsis

IGNORED

Example

IGNORED

Summary message FAILURE

Signature: 7F
Fields:

metadata::Dictionary

The following fields are defined in the metadata:

message::String - the human readable description of the failure.

code::String - the neo4j code identifying the failure. Removed after bolt 5.6

neo4j_code::String - the neo4j code identifying the failure. Introduced in bolt 5.7

gql_status::String - the GQL status which identifies the error. This should be used in favor of neo4j_code. See more about GQL-status notification object. Introduced in bolt 5.7

description::String - describes the failure represented by gql_status. Introduced in bolt 5.7

diagnostic_record::Dictionary - contains fields for helping diagnosing the status. Omitted when content is default. Introduced in bolt 5.7

    OPERATION::String - GQL standard field. Default: ""

    OPERATION_CODE::String - GQL standard field. Default: "0"

    CURRENT_SCHEMA::String - GQL standard field. Default: "/"

    _classification::String? - classifies the failure.

cause:Dictionary(message::String, gql_status::String, description::String, diagnostic_record::Dictionary, cause::Dictionary?)? - the inner cause of the error. This fields provides more specific details and context about the failure. Introduced in bolt 5.7

The diagnostic_record field can contain extra and undocumented entries. This information can be important for diagnosing failures.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

FAILURE {metadata}

Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Detail message RECORD

A RECORD message carries a sequence of values corresponding to a single entry in a result.

Signature: 71

These messages are currently only ever received in response to a PULL (PULL_ALL in v1, v2, and v3) message and will always be followed by a summary message.
Examples
Synopsis

RECORD [data]

Example 1

RECORD ["1", "2", "3"]

Example 2

RECORD [{"point": [1, 2]}, "example_data", 123]

Summary of changes per version

The sections below list the changes of messages compared to the previous version. Please also check for changes in Structure Semantics.
Version 5.8

Introduce connection hint ssr.enabled

Introduce advertised_address as response metadata of LOGON

SUCCESS message of begin transaction messages (BEGIN or RUN) contains resolved home database as db.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.7

FAILURE message was changed to have gql_status, description, diagnostic_record and cause. code was renamed to neo4j_code.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.6

SUCCESS messages that contain a notifications field were changed to have a field statuses instead.

    SUCCESS on PULL

    SUCCESS on DISCARD
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.5

Unsupported (and undocumented 😏) protocol version

Version 5.5 was only ever released in some drivers, but has a flawed design. No Neo4j server will negotiate this protocol version.
Version 5.4

A new message TELEMETRY is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.3

A new field bolt_agent is added to the HELLO message’s extra dictionary.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.2

HELLO, BEGIN and RUN messages now accept notifications options notifications_minimum_severity and notifications_disabled_categories.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.1

HELLO message no longer accepts authentication.

LOGON message has been added and accepts authentication.

LOGOFF message has been added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5

No changes from version 4.4
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.4

The db parameter within the ROUTE message is migrated into a dedicated dictionary named extra.

An imp_user parameter is added to the meta fields within ROUTE, RUN and BEGIN messages respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.3

NOOP chunks may now be transmitted in all connection states when a connection remains in idle for extended periods of time while the server is busy processing a request.

An additional hints dictionary is added to the metadata property of the SUCCESS structure transmitted in response to the HELLO command in order to provide optional configuration hints to drivers.

A new message ROUTE to query the routing table is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

The HELLO message, defines the sub-field routing::Dictionary(address::String) to indicate if server side routing should be performed and can include routing context data.

Support for NOOP chunk (empty chunk). Both server and client should support this.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.0

DISCARD_ALL message renamed to DISCARD and introduced new fields.

PULL_ALL message renamed to PULL and introduced new fields.

The BEGIN message now have a field db::String to specify a database name.

The RUN message now have a field db::String to specify a database name.

Explicit Transaction (BEGIN+RUN) can now get a server response with a SUCCESS and metadata key qid (query identification).

The DISCARD message can now discard an arbitrary number of records. New fields n and qid.

The DISCARD message can now get a server response with a SUCCESS and metadata key has_more.

The PULL message can now fetch an arbitrary number of records. New fields n and qid.

The PULL message can now get a server response with a SUCCESS and metadata key has_more.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 3

The INIT request message is replaced with HELLO message.

The ACK_FAILURE request message is removed. Use RESET message instead.

Added extra::Dictionary field to RUN message.

Added extra::Dictionary field to BEGIN message.

New HELLO request message.

New GOODBYE request message.

New BEGIN request message.

New COMMIT request message.

New ROLLBACK request message.

New RESET request message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

Byte values are represented using hexadecimal notation unless otherwise specified.
Endianness

Bolt requires that all values that can vary by endianness should be transmitted using network byte order, also known as big-endian byte order. This means that the most significant part of the value is written to the network or memory space first and the least significant part is written last.
Connection and disconnection

Bolt communication is intended to take place over a TCP connection. The default port is TCP 7687 but any port can be used.

There is no formal shutdown procedure for a Bolt connection. Either peer may close the connection at TCP level at any time. Both client and server should be prepared for that to occur and should handle it appropriately.
Handshake

Immediately following a successful connection, the client MUST initiate a handshake. This handshake is a fixed exchange used to determine the version of messaging protocol that follows.
Bolt identification

The first part of the handshake is used to identify to the server that this is a Bolt connection. It should be sent by a client immediately following the establishment of a successful connection and does not require a server response.

The identification consists of the following four bytes:

C: 60 60 B0 17

Version negotiation

After identification, a small client-server exchange occurs to determine which version of the messaging protocol to use. In this, the client submits exactly four protocol versions, each encoded as a big-endian 32-bit unsigned integer for a total of 128 bits. Protocol version zero can be used as a placeholder if fewer than four versions are required in the exchange. Should a match be found for a version supported by the server, the response will contain that version encoded as a single 32-bit integer. If no match is found, a zero value is returned followed by immediate closure of the connection by the server.

Within this exchange, a zero value (four zero bytes) always represents “no protocol version”. For the client, this can be used as a filler if fewer than four protocol versions are known. For the server, this indicates no version match has been found.

A server should assume that the versions contained within a client’s request have been sent in order of preference. Therefore, if a match occurs for more than one version, the first match should be selected.
Example where the client is aware of the Bolt protocol version 1 and the server responds with version 1.

C: 60 60 B0 17
C: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 01

Example where the client is aware of the Bolt protocol versions 1 and 2, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol versions 1, 2 and 3, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 02 00 00 00 01 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol version 3 but the server responds with no version, the server do not support communication with the client.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 00

Bolt version 4.3

With Bolt version 4.3, the version scheme supports ranges of minor versions. The first 8 bits are reserved. The next 8 bits represent the number of consecutive minor versions below the specified minor (next 8 bits) and major (next 8 bits) version that are supported.

The range cannot span multiple major versions.
Example with versions 4.3 plus two previous minor versions, 4.2 and 4.1

00 02 03 04

Example where the client is aware of five Bolt versions; 3, 4.0, 4.1, 4.2 and 4.3, and the server responds with 4.1

C: 60 60 B0 17
C: 00 03 03 04 00 00 01 04 00 00 00 04 00 00 00 03
S: 00 00 01 04

The client has to specify all versions prior to 4.3 explicitly since servers that only support those protocol versions might not support ranges. The example makes use of the fact that Bolt 4.1 and 4.2 are equivalent and only offer 4.3, 4.2, 4.0, and 3, but specify a range (4.3-4.0), in case the server supports ranges.
Bolt version 4.0

With Bolt version 4.0 the version scheme supports major and minor versioning number. The first 16 bits are reserved. 8 bits represents the minor version. 8 bits represents the major version.
Example with version 4.1

00 00 01 04

Example where the client is aware of three Bolt versions; 3, 4.0 and 4.1, and the server responds with 4.1.

C: 60 60 B0 17
C: 00 00 01 04 00 00 00 04 00 00 00 03 00 00 00 00
S: 00 00 01 04

Structure Semantics

While PackStream defines what a Structure looks like, it does not define what it means. The semantics of Structures are bound to the Bolt Protocol version.

The table below lists the PackStream specified structures and their code and tag byte across all currently existing Bolt Protocol versions.
Structures
Structure name 	Code 	tag byte

Node

N

4E

Relationship

R

52

UnboundRelationship

r

72

Path

P

50

Date

D

44

Time

T

54

LocalTime

t

74

DateTime

I

49

DateTimeZoneId

i

69

LocalDateTime

d

64

Duration

E

45

Point2D

X

58

Point3D

Y

59

Legacy Structures

Legacy DateTime

F

46

Legacy DateTimeZoneId

f

66
Node

A snapshot of a node within a graph database.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 4E

Number of fields: 4 (3 before version 5.0)

Node::Structure(
id::Integer,
labels::List<String>,
properties::Dictionary,
element_id::String,
)

Example of a node structure

Node(
id = 3,
labels = ["Example", "Node"],
properties = {"name": "example"},
element_id = "abc123",
)

B4 4E
...

Relationship

A snapshot of a relationship within a graph database.

The fields element_id, start_node_element_id, and end_node_element_id were added with version 5.0 and do not exist in earlier versions.

tag byte: 52

Number of fields: 8 (5 before version 5.0)

Relationship::Structure(
id::Integer,
startNodeId::Integer,
endNodeId::Integer,
type::String,
properties::Dictionary,
element_id::String,
start_node_element_id::String,
end_node_element_id::String,
)

Example of a relationship structure

Relationship(
id = 11,
startNodeId = 2,
endNodeId = 3,
type = "KNOWS",
properties = {"name": "example"},
element_id = "abc123",
start_node_element_id = "def456",
end_node_element_id = "ghi789",
)

B8 52
...

UnboundRelationship

A relationship without start or end node ID. It is used internally for Path serialization.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 72

Number of fields: 4 (3 before version 5.0)

UnboundRelationship::Structure(
id::Integer,
type::String,
properties::Dictionary,
element_id::String,
)

Example of unbound relationship structure

UnboundRelationship(
id = 17,
type = "KNOWS",
properties = {"name": "example"},
element_id = "foo"
)

B4 72
...

Path

An alternating sequence of nodes and relationships.

tag byte: 50

Number of fields: 3

Path::Structure(
nodes::List<Node>,
rels::List<UnboundRelationship>,
indices::List<Integer>,
)

Where the nodes field contains a list of nodes and the rels field is a list of unbound relationships. The indices are a list of integers describing how to construct the path from nodes and rels. The first node in nodes is always the first node in the path and is not referenced in indices. indices always has an even number of entries. The 1st, 3rd, …​ entry in indices refers to an entry in rels (1-indexed), for example, a 3 would refer to the 3rd element of rels. The number can also be negative which should be treated like the positive equivalent, except for denoting the relationship in the inverse direction. The number is never 0. The 2nd, 4th, …​ entry in indices refers to an entry in nodes (0-indexed), for example, a 3 would refer to the 4th element of nodes. The number is always ≥ 0.
Example (simplified notation for <Node> and <UnboundRelationship>)

Path::Structure(
nodes: [Node::Structure(42, ...), Node::Structure(69, ...), Node::Structure(1, ...)],
rels: [UnboundRelationship::Structure(1000, ...), UnboundRelationship::Structure(1001, ...)],
indices: [1, 1, 1, 0, -2, 2],

This represents the path (42)-[1000]→(69)-[1000]→(42)←[1001]-(1), where (n) denotes a node with id n and [n] a relationship with id n (→ or ← denotes the direction of each relationship).
Date

A date without a time-zone in the ISO-8601 calendar system, e.g. 2007-12-03.

tag byte: 44

Number of fields: 1

Date::Structure(
days::Integer,
)

Where the days are days since Unix epoch. 0 for example represents 1970-01-01 while 1 represents 1970-01-02.
Time

An instant capturing the time of day, and the timezone, but not the date.

tag byte: 54

Number of fields: 2

Time::Structure(
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight (this time is not UTC) and the tz_offset_seconds are an offset in seconds from UTC.
LocalTime

An instant capturing the time of day, but neither the date nor the time zone.

tag byte: 74

Number of fields: 1

LocalTime::Structure(
nanoseconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight.
DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure is new in version 5.0. It replaces Legacy DateTime and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 49

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_offset_seconds specifies the offset in seconds from UTC.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+01:00 can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00.000000042+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure is new in version 5.0. It replaces Legacy DateTimeZoneId and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 69

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_id specifies the timezone name as understood by the timezone database.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+0100[Europe/Paris] can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3_600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone specified by tz_id, giving 1970-01-01T02:15:00.000000042+0100[Europe/Paris]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

LocalDateTime

An instant capturing the date and the time but not the time zone.

tag byte: 64

Number of fields: 2

LocalDateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
)

Where the seconds are seconds since the Unix epoch.
Duration

A temporal amount. This captures the difference in time between two instants. It only captures the amount of time between two instants, it does not capture a start time and end time. A unit capturing the start time and end time would be a Time Interval and is out of scope for this proposal.

A duration can be negative.

tag byte: 45

Number of fields: 4

Duration::Structure(
months::Integer,
days::Integer,
seconds::Integer,
nanoseconds::Integer,
)

Point2D

A representation of a single location in 2-dimensional space.

tag byte: 58

Number of fields: 3

Point2D::Structure(
srid::Integer,
x::Float,
y::Float,
)

Where the srid is a Spatial Reference System Identifier.
Point3D

A representation of a single location in 3-dimensional space.

tag byte: 59

Number of fields: 4

Point3D::Structure(
srid::Integer,
x::Float,
y::Float,
z::Float,
)

Where the srid is a Spatial Reference System Identifier.
Legacy Structures
Legacy DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure got removed in version 5.0 in favor of DateTime.

tag byte: 46

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The tz_offset_seconds specifies the offset in seconds from UTC.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the above offset.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+01:00 (and 42 nanoseconds) can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

remove the offset from the seconds field, which gives here 8100

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp, giving 1970-01-01T01:15:00Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Legacy DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure got removed in version 5.0 in favor of DateTimeZoneId.

tag byte: 66

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The tz_id specifies the timezone name as understood by the timezone database.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the offset derived from the named timezone and specified the point in time.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+0100[Europe/Paris] (and 42 nanoseconds) can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the resolved offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens as follows:

instantiate the idiomatic equivalent of DateTime assuming the seconds denote a Unix timestamp, giving 1970-01-01T02:15:00Z.

set the timezone of the resulting instance, without changing the date/time components, giving 1970-01-01T02:15:00+0100[Europe/Paris] (this may lead to ambiguities, refer to the Known Limitations section below for more information).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Time Shifts

Note: these issues have been resolved with the introduction of DateTimeZoneId in version 5.0.

Not all instances of DateTimeZoneId map to a single valid point in time.

During time shifts like going from 2AM to 3AM in a given day and timezone, 2:30AM e.g. does not happen.

Similarly, when going from 3AM to 2AM in a given day and timezone, 2:30AM happens twice.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In the first case, a DateTimeZoneId specifying a time between 2AM and 3AM does not correspond to any actual points in time for that timezone and is invalid.

In the second case, all points in the time between 2AM and 3AM exist twice, but with a different offset. Therefore, the timezone name is not sufficient to resolve the ambiguity, the timezone offset is also needed. Since DateTimeZoneId does not include the timezone offset, the resolution of these particular datetimes is undefined behavior.
Summary of changes per version

The sections below list the changes of structure semantics in versions where they changed. Please also check for changes in Bolt Messages.
Version 5.0

The element_id field was added to Node.

The fields element_id, start_node_element_id, and end_node_element_id were added to Relationship.

The element_id field was added to UnboundRelationship.

Replaced Legacy DateTime and Legacy DateTimeZoneId with DateTime and DateTimeZoneId respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime.

This state is used to determine what actions may be undertaken by the client. Each server state specification corresponds to a message specification with the same version.

For a summary of all available server state transitions in each version of the Bolt Protocol, see the Appendix pages.
Server states

Each connection maintained by a Bolt server will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.
State 	Logic state 	Description

DISCONNECTED

X

no socket connection

DEFUNCT

X

the socket connection is permanently closed

NEGOTIATION

protocol handshake is completed successfully; ready to accept a HELLO message

AUTHENTICATION

HELLO or LOGOFF message accepted; ready to accept a LOGON message

READY

ready to accept a RUN message

STREAMING

Auto-commit Transaction, a result is available for streaming from the server

TX_READY

Explicit Transaction, ready to accept a RUN message

TX_STREAMING

Explicit Transaction, a result is available for streaming from the server

FAILED

a connection is in a temporarily unusable state

INTERRUPTED

the server got an <INTERRUPT> signal
Server state DISCONNECTED

No socket connection has yet been established. This is the initial state and exists only in a logical sense prior to the socket being opened.
Transitions from DISCONNECTED

Bolt handshake completed successfully to NEGOTIATION

Bolt handshake did not complete successfully to DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state NEGOTIATION

After a new protocol connection has been established and handshake has been completed successfully, the server enters the NEGOTIATION state. The connection has not yet been authenticated and permits only one transition, through successful initialization using the HELLO message, into the AUTHENTICATION state.
Transitions from NEGOTIATION

<DISCONNECT> to DEFUNCT

HELLO to AUTHENTICATION or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state AUTHENTICATION

Connection has been established and metadata has been sent back from the HELLO message or a LOGOFF message was received whilst in ready state. Ready to accept a LOGON message with authentication information.
Transitions from NEGOTIATION

LOGON to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Transitions from READY

LOGOFF to AUTHENTICATION
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state DEFUNCT

This is not strictly a connection state, but is instead a logical state that exists after a connection has been closed. When DEFUNCT, a connection is permanently not usable. This may arise due to a graceful shutdown or can occur after an unrecoverable error or protocol violation. Clients and servers should clear up any resources associated with a connection on entering this state, including closing any open sockets. This is a terminal state on which no further transitions may be carried out. The <DISCONNECT> signal will set the connection in the DEFUNCT server state.
Server state READY

The READY state can handle the request messages RUN and BEGIN and receive a query.
Transitions from READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to STREAMING or FAILED

BEGIN to TX_READY or FAILED (v3+)

LOGOFF to AUTHENTICATION (v5.1+)

TELEMETRY to READY (v5.4+)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state STREAMING

When STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can re-enter the READY state and allow any further queries to be executed.
Transitions from STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL to READY, FAILED, or STREAMING

DISCARD to READY, FAILED, or STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1, v2 and v3, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL_ALL to READY or FAILED

DISCARD_ALL to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 1. Request message DISCARD state transitions State 	New state 	Response

STREAMING

READY

SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

FAILURE {}

STREAMING

STREAMING

SUCCESS {"has_more": true}
Table 2. Request message PULL state transitions State 	New state 	Response

STREAMING

READY

[RECORD …] SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

[RECORD …] FAILURE {}

STREAMING

STREAMING

[RECORD …] SUCCESS {"has_more": true}
Table 3. Request message DISCARD_ALL state transitions in v1, v2, and v3 only State 	New state 	Response

STREAMING

READY

`SUCCESS {}

STREAMING

FAILED

FAILURE {}
Table 4. Request message PULL_ALL state transitions in v1. v2 and v3 only State 	New state 	Response

STREAMING

READY

[RECORD …] SUCCESS {}

STREAMING

FAILED

[RECORD …] FAILURE {}
Server state TX_READY
Transitions from TX_READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

COMMIT to READY or FAILED

ROLLBACK to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 5. Request message RUN state transitions State 	New state 	Response

TX_READY

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_READY

FAILED

FAILURE{}

The TX_READY server state does not exist in v1 or v2.
Server state TX_STREAMING

When TX_STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can transition to the TX_READY state.
Transitions from TX_STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

PULL to TX_READY, FAILED or TX_STREAMING

DISCARD to TX_READY, FAILED or TX_STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 6. Request message RUN state transitions State 	New state 	Response

TX_STREAMING

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_STREAMING

FAILED

FAILURE{}
Table 7. Request message DISCARD state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

FAILURE {}

TX_STREAMING

TX_STREAMING

SUCCESS {"has_more": true}
Table 8. Request messages PULL state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

[RECORD …] SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

[RECORD …] FAILURE {}

TX_STREAMING

TX_STREAMING

[RECORD …] SUCCESS {"has_more": true}

The TX_STREAMING server state does not exist in v1 or v2.
Server state FAILED

When FAILED, a connection is in a temporarily unusable state. This is generally as the result of encountering a recoverable error. This mode ensures that only one failure can exist at a time, preventing cascading issues from batches of work.
Transitions from FAILED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to FAILED

PULL to FAILED

DISCARD to FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, in a FAILED state, no more work will be processed until the failure has been acknowledged by ACK_FAILURE or until the connection has been RESET.

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

ACK_FAILURE to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state INTERRUPTED

This state occurs between the server receiving the jump-ahead <INTERRUPT> and the queued RESET message, (the RESET message triggers an <INTERRUPT>). Most incoming messages are ignored when the server are in an INTERRUPTED state, with the exception of the RESET that allows transition back to READY. The <INTERRUPT> signal will set the connection in the INTERRUPTED server state.
Transitions from INTERRUPTED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD to INTERRUPTED

PULL to INTERRUPTED

BEGIN to INTERRUPTED

COMMIT to INTERRUPTED

ROLLBACK to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD_ALL to INTERRUPTED

PULL_ALL to INTERRUPTED

ACK_FAILURE to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Summary of changes per version

The sections below list the changes compared to the previous version.
Version 5.2

No changes compared to version 5.1.
Version 5.1

CONNECTED state has been renamed to NEGOTIATION but still accepts the HELLO message.

HELLO message no longer accepts authentication and transitions to the AUTHENTICATION state from NEGOTIATION.

LOGON message has been added. It can only be received in the AUTHENTICATION state and transitions to the READY state.

LOGOFF message has be added. It can only be received in the READY state and transitions to the AUTHENTICATION state.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.0

No changes compared to version 4.4.
Version 4.4

No changes compared to version 4.3.
Version 4.3

The ROUTE message was added. It can only be received in the READY state and causes no transition.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

No changes compared to version 4.0.
Version 4.0

Compared to version 3 the RUN, PULL and DISCARD now can re-enter STREAMING or TX_STREAMING. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 4.0.
Version 3

Compared to version 2 there are new server states:

TX_READY

TX_STREAMING These states are introduced to handle the concept of Explicit Transaction. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 3.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

这是完整的bolt协议文档，你看看现有代码还有哪些问题，还有哪些待实现file(GLOB_RECURSE NEO4J_BOLT_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(Neo4jBoltTransport ${NEO4J_BOLT_TRANSPORT_SOURCE})

target_include_directories(Neo4jBoltTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(Neo4jBoltTransport PUBLIC Boost::asio Boost::system)
target_link_libraries(Neo4jBoltTransport PUBLIC Protocol)
target_compile_definitions(Neo4jBoltTransport PUBLIC SPDLOG_USE_STD_FORMAT)
target_link_libraries(Neo4jBoltTransport
    PUBLIC
    spdlog::spdlog_header_only
)#ifndef NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H
#define NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H

#include <map>
#include <memory>  // For std::shared_ptr for field_names
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/bolt_structure_types.h"
#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {

    class BoltRecord {
      public:
        // Constructor takes rvalue refs to move data if possible.
        // field_names_ptr is shared because multiple records from the same result stream share it.
        BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> field_names_ptr);

        BoltRecord(const BoltRecord&) = delete;  // Typically records are not copied once created
        BoltRecord& operator=(const BoltRecord&) = delete;
        BoltRecord(BoltRecord&&) noexcept = default;
        BoltRecord& operator=(BoltRecord&&) noexcept = default;

        // Access by index
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(size_t index) const;

        // Access by name
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(const std::string& field_name) const;

        // Typed access by index
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(size_t index) const;

        // Typed access by name
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(const std::string& field_name) const;

        // Typed access for Bolt Structures (Node, Relationship, etc.)
        // These require the Bolt version for correct deserialization of version-dependent fields.
        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(size_t index,
                                                                                  const boltprotocol::versions::Version& bolt_version,
                                                                                  bool utc_patch_active_for_4_4 = false  // Relevant for DateTime types in Bolt 4.4
        ) const;

        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) const;

        size_t field_count() const noexcept {
            return fields_.size();
        }
        const std::vector<std::string>& field_names() const;  // Returns empty if no names available

      private:
        std::vector<boltprotocol::Value> fields_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_;  // Pointer to shared field names
        // Optional: Cache field name to index map for faster named lookups if records are long-lived
        // mutable std::optional<std::map<std::string, size_t>> field_name_to_index_cache_;
        // const std::map<std::string, size_t>& get_field_name_map() const;
    };

    // --- Template Implementations for BoltRecord ---
    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(size_t index) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T{}};
        }
        if (std::holds_alternative<T>(value_result.second)) {
            try {
                return {boltprotocol::BoltError::SUCCESS, std::get<T>(value_result.second)};
            } catch (const std::bad_variant_access&) {                         // Should not happen if holds_alternative is true
                return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
            }
        }
        // Special case for int64_t, allow conversion from other integral types if safe (e.g. int32_t -> int64_t)
        // This requires more complex logic or a dedicated conversion utility.
        // For now, strict type match.
        return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
    }

    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // No field names available
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // Field name not found
        }
        return get_as<T>(static_cast<size_t>(index));
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(size_t index, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T_BoltStructure{}};
        }

        T_BoltStructure typed_struct;
        boltprotocol::BoltError conversion_err;

        // Use the value_to_typed_struct that takes version and patch info
        if constexpr (std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTime> || std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTimeZoneId> || std::is_same_v<T_BoltStructure, boltprotocol::BoltNode> || std::is_same_v<T_BoltStructure, boltprotocol::BoltRelationship> ||
                      std::is_same_v<T_BoltStructure, boltprotocol::BoltUnboundRelationship> || std::is_same_v<T_BoltStructure, boltprotocol::BoltPath>) {
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct, bolt_version, utc_patch_active_for_4_4);
        } else {  // For types like BoltDate, BoltTime that don't need version for deserialization
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct);
        }

        if (conversion_err != boltprotocol::BoltError::SUCCESS) {
            return {conversion_err, T_BoltStructure{}};
        }
        return {boltprotocol::BoltError::SUCCESS, typed_struct};
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        return get_bolt_structure_as<T_BoltStructure>(static_cast<size_t>(index), bolt_version, utc_patch_active_for_4_4);
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H

#include <map>
#include <optional>
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For boltprotocol::Value

namespace neo4j_bolt_transport {
    namespace config {

        struct NoAuth {};

        struct BasicAuth {
            std::string username;
            std::string password;
            std::optional<std::string> realm;
        };

        struct KerberosAuth {
            std::string base64_ticket;
        };

        struct CustomAuth {
            std::string principal;
            std::string credentials;
            std::optional<std::string> realm;
            std::string scheme;  // The custom scheme name, e.g., "custom_sso"
            std::optional<std::map<std::string, boltprotocol::Value>> parameters;
        };

        struct BearerAuth {
            std::string token;  // The bearer token
        };

        // Variant to hold different authentication types
        using AuthTokenVariant = std::variant<NoAuth, BasicAuth, KerberosAuth, BearerAuth, CustomAuth>;

        // Factory class for creating AuthTokenVariant instances easily
        class AuthTokens {
          public:
            AuthTokens() = delete;  // Static factory methods only

            static AuthTokenVariant none();
            static AuthTokenVariant basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm = std::nullopt);
            static AuthTokenVariant kerberos(const std::string& base64_ticket);
            static AuthTokenVariant bearer(const std::string& token);
            static AuthTokenVariant custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters = std::nullopt);
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {
    namespace config {

        enum class AccessMode { READ, WRITE };

        struct SessionParameters {
            std::optional<std::string> database_name;
            AccessMode default_access_mode = AccessMode::WRITE;
            std::vector<std::string> initial_bookmarks;
            std::optional<std::string> impersonated_user;

            // Default number of records to fetch in each PULL message.
            // -1 typically means "fetch all remaining".
            // Drivers often have a default like 1000.
            int64_t default_fetch_size = 1000;

            SessionParameters() = default;

            static SessionParameters for_database(const std::string& db_name) {
                SessionParameters p;
                p.database_name = db_name;
                return p;
            }

            SessionParameters& with_database(const std::string& db_name) {
                database_name = db_name;
                return *this;
            }
            SessionParameters& with_default_access_mode(AccessMode mode) {
                default_access_mode = mode;
                return *this;
            }
            SessionParameters& with_bookmarks(const std::vector<std::string>& new_bookmarks) {
                initial_bookmarks = new_bookmarks;
                return *this;
            }
            SessionParameters& with_impersonated_user(const std::string& user) {
                impersonated_user = user;
                return *this;
            }
            SessionParameters& with_fetch_size(int64_t size) {
                default_fetch_size = size;
                return *this;
            }
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H

#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <set>  // For set of ServerAddress
#include <string>
#include <vector>

#include "auth_token.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/routing/server_address.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    namespace uri {
        struct ParsedUri;
    }

    namespace config {

        struct TransportConfig {
            std::string uri_string;
            AuthTokenVariant auth_token = AuthTokens::none();
            std::string user_agent_override;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info;

            enum class EncryptionStrategy { NEGOTIATE_FROM_URI_SCHEME, FORCE_PLAINTEXT, FORCE_ENCRYPTED_SYSTEM_CERTS, FORCE_ENCRYPTED_TRUST_ALL_CERTS, FORCE_ENCRYPTED_CUSTOM_CERTS };
            EncryptionStrategy encryption_strategy = EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            std::size_t max_connection_pool_size = 100;
            uint32_t connection_acquisition_timeout_ms = 60000;  // Timeout for acquiring a connection from the pool
            uint32_t max_connection_lifetime_ms = 3600000;       // Max lifetime of a pooled connection
            uint32_t idle_timeout_ms = 600000;                   // Max idle time for a pooled connection
            uint32_t idle_time_before_health_check_ms = 30000;   // Idle time after which a health check (ping) is performed before reuse

            // Socket level timeouts
            uint32_t tcp_connect_timeout_ms = 5000;  // Timeout for establishing the TCP connection
            uint32_t socket_read_timeout_ms = 0;     // Timeout for socket read operations (0 = system default/infinite)
            uint32_t socket_write_timeout_ms = 0;    // Timeout for socket write operations (0 = system default/infinite)
            bool tcp_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;

            // Bolt protocol level timeouts
            uint32_t hello_timeout_ms = 15000;   // Timeout for HELLO message exchange
            uint32_t goodbye_timeout_ms = 5000;  // Timeout for GOODBYE message exchange (if sent)

            // Transaction related configurations
            uint32_t max_transaction_retry_time_ms = 30000;  // Max total time for retrying a managed transaction
            uint32_t transaction_retry_delay_initial_ms = 1000;
            uint32_t transaction_retry_delay_multiplier = 2;
            uint32_t transaction_retry_delay_max_ms = 60000;
            uint32_t explicit_transaction_timeout_default_ms = 0;  // Default timeout for explicit transactions if not specified per-transaction (0 = server default)

            // --- Routing ---
            bool client_side_routing_enabled = true;
            uint32_t routing_table_refresh_ttl_margin_ms = 5000;
            uint32_t routing_max_retry_attempts = 3;
            std::function<routing::ServerAddress(const routing::ServerAddress&)> server_address_resolver;
            std::map<std::string, std::vector<routing::ServerAddress>> initial_router_addresses_override;

            // --- Bolt Protocol ---
            std::vector<boltprotocol::versions::Version> preferred_bolt_versions;

            // --- Logging ---
            std::shared_ptr<spdlog::logger> logger;
            spdlog::level::level_enum log_level = spdlog::level::info;

            TransportConfig(const std::string& uri_str = "bolt://localhost:7687");
            TransportConfig();

            boltprotocol::BoltError apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri);
            void prepare_agent_strings(const std::string& default_transport_name_version = "Neo4jBoltTransportCpp/0.6.0");  // Version bump

            std::shared_ptr<spdlog::logger> get_or_create_logger(const std::string& logger_name = "Neo4jBoltTransport");
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H
#define NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H

#include <optional>
#include <string>

#include "boltprotocol/message_defs.h"  // For BoltError and FailureMessageParams

namespace neo4j_bolt_transport {
    namespace error {

        // Creates a detailed error message string from FailureMessageParams
        inline std::string format_server_failure(const boltprotocol::FailureMessageParams& failure_params) {
            std::string server_code = "Unknown.Error";
            std::string server_message = "An error occurred on the server.";

            auto extract_string_from_value = [](const boltprotocol::Value& val) -> std::optional<std::string> {
                if (std::holds_alternative<std::string>(val)) {
                    return std::get<std::string>(val);
                }
                return std::nullopt;
            };

            auto it_code = failure_params.metadata.find("neo4j_code");  // Bolt 5.7+
            if (it_code == failure_params.metadata.end() || !extract_string_from_value(it_code->second).has_value()) {
                it_code = failure_params.metadata.find("code");  // Legacy
            }
            if (it_code != failure_params.metadata.end()) {
                if (auto code_opt = extract_string_from_value(it_code->second)) {
                    server_code = *code_opt;
                }
            }

            auto it_msg = failure_params.metadata.find("message");
            if (it_msg != failure_params.metadata.end()) {
                if (auto msg_opt = extract_string_from_value(it_msg->second)) {
                    server_message = *msg_opt;
                }
            }

            return "[" + server_code + "] " + server_message;
        }

        // Converts BoltError enum to a human-readable string (basic version)
        inline std::string bolt_error_to_string(boltprotocol::BoltError err_code) {
            switch (err_code) {
                case boltprotocol::BoltError::SUCCESS:
                    return "SUCCESS";
                case boltprotocol::BoltError::UNKNOWN_ERROR:
                    return "UNKNOWN_ERROR";
                case boltprotocol::BoltError::INVALID_ARGUMENT:
                    return "INVALID_ARGUMENT";
                case boltprotocol::BoltError::SERIALIZATION_ERROR:
                    return "SERIALIZATION_ERROR";
                case boltprotocol::BoltError::DESERIALIZATION_ERROR:
                    return "DESERIALIZATION_ERROR";
                case boltprotocol::BoltError::INVALID_MESSAGE_FORMAT:
                    return "INVALID_MESSAGE_FORMAT";
                case boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION:
                    return "UNSUPPORTED_PROTOCOL_VERSION";
                case boltprotocol::BoltError::NETWORK_ERROR:
                    return "NETWORK_ERROR";
                case boltprotocol::BoltError::HANDSHAKE_FAILED:
                    return "HANDSHAKE_FAILED";
                // ... add all other BoltError codes ...
                default:
                    return "UNRECOGNIZED_BOLT_ERROR (" + std::to_string(static_cast<int>(err_code)) + ")";
            }
        }

        // Combines a BoltError with a context message and potentially a server failure message
        inline std::string format_error_message(const std::string& context, boltprotocol::BoltError err_code, const std::optional<std::string>& server_failure_detail = std::nullopt) {
            std::string msg = context + ": " + bolt_error_to_string(err_code) + " (code " + std::to_string(static_cast<int>(err_code)) + ")";
            if (server_failure_detail && !server_failure_detail->empty()) {
                msg += "; Server detail: " + *server_failure_detail;
            }
            return msg;
        }

    }  // namespace error
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H

#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <memory>  // For std::weak_ptr
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version

namespace neo4j_bolt_transport {
    namespace internal {

        // Represents an established, active asynchronous stream and its parameters.
        // Ownership of the stream object is held by this context.
        struct ActiveAsyncStreamContext {
            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> stream;

            boltprotocol::versions::Version negotiated_bolt_version;
            std::string server_agent_string;
            std::string server_connection_id;
            bool utc_patch_active = false;
            bool encryption_was_used = false;

            ActiveAsyncStreamContext(std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> s, boltprotocol::versions::Version bv, std::string sa, std::string cid, bool utc, bool enc_used)
                : stream(std::move(s)), negotiated_bolt_version(bv), server_agent_string(std::move(sa)), server_connection_id(std::move(cid)), utc_patch_active(utc), encryption_was_used(enc_used) {
            }

            explicit ActiveAsyncStreamContext(boost::asio::io_context& ioc) : stream(boost::asio::ip::tcp::socket(ioc)) {
            }
            ActiveAsyncStreamContext() = delete;

            ActiveAsyncStreamContext(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext& operator=(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext(ActiveAsyncStreamContext&&) = default;
            ActiveAsyncStreamContext& operator=(ActiveAsyncStreamContext&&) = default;

            boost::asio::any_io_executor get_executor() {
                return std::visit(
                    [](auto& s) {
                        return s.get_executor();
                    },
                    stream);
            }
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H// Include/neo4j_bolt_transport/internal/async_utils_decl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/buffer.hpp>  // For buffer concepts
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <chrono>
#include <string>
#include <utility>

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Timeout wrapper for read operations
            template <typename Stream, typename MutableBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_read_with_timeout(IAsyncContextCallbacks* callbacks,
                                                                                                            Stream& stream,
                                                                                                            MutableBufferSequence buffers,  // Must be mutable
                                                                                                            std::chrono::milliseconds timeout_duration,
                                                                                                            const std::string& operation_name);

            // Timeout wrapper for write operations
            template <typename Stream, typename ConstBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_write_with_timeout(IAsyncContextCallbacks* callbacks,
                                                                                                             Stream& stream,
                                                                                                             ConstBufferSequence buffers,  // Can be const
                                                                                                             std::chrono::milliseconds timeout_duration,
                                                                                                             const std::string& operation_name);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#include "async_utils_impl.h"

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H

#include <spdlog/spdlog.h>

#include <boost/asio/as_tuple.hpp>
#include <boost/asio/buffer.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>
#include <tuple>
#include <type_traits>  // For std::invoke_result_t

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Internal helper for timed I/O operations that return awaitable<tuple<ec, size_t>>
            template <typename Stream, typename IoOperation>
            boost::asio::awaitable<std::tuple<boost::system::error_code, std::size_t>> perform_timed_io(IAsyncContextCallbacks* callbacks,
                                                                                                        Stream& stream,
                                                                                                        std::chrono::milliseconds timeout_duration,
                                                                                                        const std::string& operation_name_for_log,
                                                                                                        IoOperation io_op  // Lambda returning awaitable<tuple<ec, size_t>>
            ) {
                std::shared_ptr<spdlog::logger> logger = nullptr;
                if (callbacks) {
                    logger = callbacks->get_logger();
                }

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtilTimed {}] Op on closed stream (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::not_connected, 0);  // Or appropriate error
                }

                if (timeout_duration.count() <= 0) {  // No timeout
                    try {
                        co_return co_await io_op();
                    } catch (const boost::system::system_error& e_sys) {
                        if (logger) logger->error("[AsyncUtilTimed {}] Exception (no timeout, obj id {}): {}", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0, e_sys.what());
                        co_return std::make_tuple(e_sys.code(), 0);
                    }
                }

                boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
                timer.expires_after(timeout_duration);

                std::optional<std::tuple<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        std::tuple<boost::system::error_code, std::size_t> temp_io_res;
                        try {
                            temp_io_res = co_await io_op();
                        } catch (const boost::system::system_error& e_sys) {
                            std::get<0>(temp_io_res) = e_sys.code();
                            std::get<1>(temp_io_res) = 0;
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = temp_io_res;
                            timer.cancel();
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec_val;
                        std::tie(timer_ec_val) = co_await timer.async_wait(boost::asio::as_tuple(boost::asio::use_awaitable));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {timer_ec_val};
                            if (timer_ec_val != boost::asio::error::operation_aborted) {
                                stream.lowest_layer().cancel();
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(co_await boost::asio::this_coro::executor, boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    co_return io_result_opt.value();
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    if (logger) logger->warn("[AsyncUtilTimed {}] Op timed out (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::timed_out, 0);
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        if (logger) logger->error("[AsyncUtilTimed {}] Logic error: Timer aborted, no I/O (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                        co_return std::make_tuple(boost::asio::error::fault, 0);
                    }
                    // This should be caught by the first if (io_result_opt.has_value())
                    if (logger) logger->error("[AsyncUtilTimed {}] Logic error: Timer aborted, but io_result_opt is somehow still empty (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::fault, 0);
                } else {
                    if (logger) logger->error("[AsyncUtilTimed {}] Unexpected fallthrough (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::fault, 0);
                }
            }

            template <typename Stream, typename MutableBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_read_with_timeout(IAsyncContextCallbacks* callbacks, Stream& stream, MutableBufferSequence buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name) {
                static_assert(boost::asio::is_mutable_buffer_sequence<MutableBufferSequence>::value, "async_read_with_timeout requires a MutableBufferSequence.");

                auto completion_token = boost::asio::as_tuple(boost::asio::use_awaitable);
                auto io_op_lambda = [&]() {  // Lambda for the actual read operation
                    return boost::asio::async_read(stream, buffers, completion_token);
                };

                auto [ec, bytes_transferred] = co_await perform_timed_io(callbacks, stream, timeout_duration, operation_name, io_op_lambda);

                if (ec) {
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::invalid_argument)
                        mapped_error = boltprotocol::BoltError::INVALID_ARGUMENT;
                    else if (ec == boost::asio::error::not_connected)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::fault)
                        mapped_error = boltprotocol::BoltError::UNKNOWN_ERROR;

                    if (callbacks) {  // callbacks might be null if initial check failed
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{mapped_error, 0};
                    }
                }
                co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

            template <typename Stream, typename ConstBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_write_with_timeout(IAsyncContextCallbacks* callbacks, Stream& stream, ConstBufferSequence buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name) {
                static_assert(boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value, "async_write_with_timeout requires a ConstBufferSequence.");

                auto completion_token = boost::asio::as_tuple(boost::asio::use_awaitable);
                auto io_op_lambda = [&]() {  // Lambda for the actual write operation
                    return boost::asio::async_write(stream, buffers, completion_token);
                };

                auto [ec, bytes_transferred] = co_await perform_timed_io(callbacks, stream, timeout_duration, operation_name, io_op_lambda);

                if (ec) {
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::invalid_argument)
                        mapped_error = boltprotocol::BoltError::INVALID_ARGUMENT;
                    else if (ec == boost::asio::error::not_connected)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::fault)
                        mapped_error = boltprotocol::BoltError::UNKNOWN_ERROR;

                    if (callbacks) {
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{mapped_error, 0};
                    }
                }
                co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"                     // For Value, Version
#include "neo4j_bolt_transport/config/transport_config.h"  // For AuthTokenVariant, EncryptionStrategy

namespace neo4j_bolt_transport {
    namespace internal {

        struct BoltConnectionConfig {
            std::string target_host;
            uint16_t target_port;

            config::AuthTokenVariant auth_token;
            std::string user_agent_for_hello;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info_for_hello;

            bool encryption_enabled = false;
            config::TransportConfig::EncryptionStrategy resolved_encryption_strategy = config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            uint32_t tcp_connect_timeout_ms = 5000;
            uint32_t socket_read_timeout_ms = 0;   // Added
            uint32_t socket_write_timeout_ms = 0;  // Added
            bool socket_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;
            uint32_t bolt_handshake_timeout_ms = 10000;
            uint32_t hello_timeout_ms = 15000;   // Added
            uint32_t goodbye_timeout_ms = 5000;  // Added

            std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_context;
            std::optional<std::vector<boltprotocol::versions::Version>> preferred_bolt_versions;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H

#include <atomic>
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl/context.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "bolt_connection_config.h"
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "neo4j_bolt_transport/internal/async_types.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    class SessionHandle;

    namespace internal {

        class BoltPhysicalConnection : public std::enable_shared_from_this<BoltPhysicalConnection>, public IAsyncContextCallbacks {
          public:
            using PooledConnection = std::unique_ptr<BoltPhysicalConnection>;
            enum class InternalState {
                FRESH,
                TCP_CONNECTING,
                ASYNC_TCP_CONNECTING,
                TCP_CONNECTED,
                SSL_CONTEXT_SETUP,
                SSL_HANDSHAKING,
                ASYNC_SSL_HANDSHAKING,
                SSL_HANDSHAKEN,
                BOLT_HANDSHAKING,
                ASYNC_BOLT_HANDSHAKING,
                BOLT_HANDSHAKEN,
                ASYNC_BOLT_HANDSHAKEN,
                HELLO_AUTH_SENT,
                ASYNC_HELLO_AUTH_SENT,
                READY,
                ASYNC_READY,
                STREAMING,
                ASYNC_STREAMING,
                AWAITING_SUMMARY,
                ASYNC_AWAITING_SUMMARY,
                FAILED_SERVER_REPORTED,
                DEFUNCT
            };

            BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr);
            ~BoltPhysicalConnection() override;

            BoltPhysicalConnection(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection& operator=(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept;
            BoltPhysicalConnection& operator=(BoltPhysicalConnection&& other) noexcept;

            // --- Synchronous API ---
            boltprotocol::BoltError establish();
            boltprotocol::BoltError terminate(bool send_goodbye = true);
            boltprotocol::BoltError ping(std::chrono::milliseconds timeout);
            bool is_ready_for_queries() const;
            bool is_defunct() const;
            boltprotocol::BoltError get_last_error_code() const {
                return last_error_code_;
            }
            std::string get_last_error_message() const {
                return last_error_message_;
            }
            uint64_t get_id() const {
                return id_;
            }
            const boltprotocol::versions::Version& get_bolt_version() const {
                return negotiated_bolt_version_;
            }
            bool is_utc_patch_active() const {
                return utc_patch_active_;
            }
            const std::string& get_server_agent() const {
                return server_agent_string_;
            }
            const std::string& get_connection_id() const {
                return server_assigned_conn_id_;
            }
            const BoltConnectionConfig& get_config() const {
                return conn_config_;
            }
            boost::asio::io_context& get_io_context() {
                return io_context_ref_;
            }
            std::chrono::steady_clock::time_point get_creation_timestamp() const {
                return creation_timestamp_;
            }
            std::chrono::steady_clock::time_point get_last_used_timestamp() const {
                return last_used_timestamp_.load(std::memory_order_relaxed);
            }
            void mark_as_used();
            bool is_encrypted() const;

            using MessageHandler = std::function<boltprotocol::BoltError(boltprotocol::MessageTag tag, const std::vector<uint8_t>& payload, BoltPhysicalConnection& connection)>;
            boltprotocol::BoltError send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError perform_reset();
            boltprotocol::BoltError perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success);
            boltprotocol::BoltError perform_logoff(boltprotocol::SuccessMessageParams& out_success);

            // --- Asynchronous API ---
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> establish_async();
            boost::asio::awaitable<boltprotocol::BoltError> terminate_async(bool send_goodbye = true);
            boost::asio::awaitable<boltprotocol::BoltError> ping_async(std::chrono::milliseconds timeout);

            // --- IAsyncContextCallbacks implementation ---
            std::shared_ptr<spdlog::logger> get_logger() const override {
                return logger_;
            }
            uint64_t get_id_for_logging() const override {
                return id_;
            }
            void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) override;
            boltprotocol::BoltError get_last_error_code_from_async() const override {
                return last_error_code_;
            }

            void _mark_as_defunct_internal(boltprotocol::BoltError reason, const std::string& message = "");

          private:
            friend class neo4j_bolt_transport::SessionHandle;

            boltprotocol::BoltError _stage_tcp_connect();
            boltprotocol::BoltError _stage_ssl_context_setup();
            boltprotocol::BoltError _stage_ssl_handshake();
            boltprotocol::BoltError _stage_bolt_handshake();
            boltprotocol::BoltError _stage_send_hello_and_initial_auth();

            boost::asio::awaitable<boltprotocol::BoltError> _stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout);
            // --- 关键修正：确保这里的声明与定义一致 ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket>& stream,  // 应该是 stream<tcp::socket>&
                                                                                       std::chrono::milliseconds timeout);
            // --- 结束关键修正 ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_send_hello_and_initial_auth_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);

            void _prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const;
            boltprotocol::BoltError _execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> _execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                        std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> perform_logon_async(boltprotocol::LogonMessageParams logon_params,
                                                                                                                               std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> perform_logoff_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);

            boltprotocol::BoltError _write_to_active_sync_stream(const uint8_t* data, size_t size);
            boltprotocol::BoltError _read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read);

            boost::asio::awaitable<boltprotocol::BoltError> _write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read);

            boltprotocol::BoltError _send_chunked_payload_sync(const std::vector<uint8_t>& payload);
            boltprotocol::BoltError _receive_chunked_payload_sync(std::vector<uint8_t>& out_payload);

            boost::asio::awaitable<boltprotocol::BoltError> _send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, std::vector<uint8_t> payload);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref);

            boltprotocol::BoltError _peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const;

            void _reset_resources_and_state(bool called_from_destructor = false);
            void _update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta);
            void _update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta);
            boltprotocol::BoltError _classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta);
            std::string _get_current_state_as_string() const;

            uint64_t id_;
            BoltConnectionConfig conn_config_;
            boost::asio::io_context& io_context_ref_;
            std::shared_ptr<spdlog::logger> logger_;

            std::unique_ptr<boost::asio::ip::tcp::socket> owned_socket_for_sync_plain_;
            std::unique_ptr<boost::asio::ip::tcp::iostream> plain_iostream_wrapper_;
            std::unique_ptr<boost::asio::ssl::context> ssl_context_sync_;
            std::unique_ptr<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ssl_stream_sync_;

            std::atomic<InternalState> current_state_;
            boltprotocol::versions::Version negotiated_bolt_version_;
            std::string server_agent_string_;
            std::string server_assigned_conn_id_;
            bool utc_patch_active_ = false;

            std::chrono::steady_clock::time_point creation_timestamp_;
            std::atomic<std::chrono::steady_clock::time_point> last_used_timestamp_;

            boltprotocol::BoltError last_error_code_ = boltprotocol::BoltError::SUCCESS;
            std::string last_error_message_;

            static std::atomic<uint64_t> next_connection_id_counter_;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H

#include <cstdint>  // For uint64_t
#include <memory>
#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "spdlog/fwd.h"                         // Forward declaration for spdlog::logger

namespace neo4j_bolt_transport {
    namespace internal {

        class IAsyncContextCallbacks {
          public:
            virtual ~IAsyncContextCallbacks() = default;

            virtual std::shared_ptr<spdlog::logger> get_logger() const = 0;
            virtual uint64_t get_id_for_logging() const = 0;
            virtual void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) = 0;
            virtual boltprotocol::BoltError get_last_error_code_from_async() const = 0;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H

#include <atomic>
#include <boost/asio/executor_work_guard.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/asio/steady_timer.hpp>  // For eviction_timer_
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include "config/transport_config.h"
#include "internal/bolt_physical_connection.h"
#include "routing/routing_table.h"
#include "routing/server_address.h"
#include "session_handle.h"
#include "uri/parsed_uri.h"

// 暂时移除异步相关的 Boost.Asio include，因为具体实现被推迟
// #include <boost/asio/co_spawn.hpp>
// #include <boost/asio/detached.hpp>
// #include <boost/asio/awaitable.hpp>

namespace neo4j_bolt_transport {

    namespace config {
        struct SessionParameters;
    }
    class AsyncSessionHandle;  // 前向声明，即使实现被推迟，头文件可能仍需它

    class Neo4jBoltTransport {
      public:
        explicit Neo4jBoltTransport(config::TransportConfig config);
        ~Neo4jBoltTransport();

        Neo4jBoltTransport(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport& operator=(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport(Neo4jBoltTransport&&) = delete;
        Neo4jBoltTransport& operator=(Neo4jBoltTransport&&) = delete;

        // --- Synchronous API ---
        boltprotocol::BoltError verify_connectivity();
        std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> acquire_session(const config::SessionParameters& params);
        void close();

        const config::TransportConfig& get_config() const {
            return config_;
        }
        boost::asio::io_context& get_io_context() {
            return io_context_;
        }

        void release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy = true);

        // --- Asynchronous API (占位符) ---
        // 实际返回类型可能是 boost::asio::awaitable<...>
        // 为了编译通过（即使AsyncSessionHandle不完整），暂时用一个可以构造的类型
        // 或者完全注释掉，直到 AsyncSessionHandle 准备好
        // boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
        // acquire_async_session(const config::SessionParameters& params);

      private:
        // --- 连接池与路由辅助函数 ---
        std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> _acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        // boost::asio::awaitable<std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection>>
        // _acquire_async_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        std::pair<boltprotocol::BoltError, routing::ServerAddress> _get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint);
        std::shared_ptr<routing::RoutingTable> _get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user);
        boltprotocol::BoltError _fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update, const std::vector<routing::ServerAddress>& initial_routers_for_context, const std::string& database_name_hint, const std::optional<std::string>& impersonated_user_hint);
        void _handle_routing_failure(const routing::ServerAddress& failed_address, const std::string& database_context_key);

        void _evict_stale_connections_task();
        internal::BoltConnectionConfig _create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const;

        // 静态私有辅助函数，用于生成路由上下文键
        static std::string _make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user);

        config::TransportConfig config_;
        uri::ParsedUri parsed_initial_uri_;

        boost::asio::io_context io_context_;
        std::unique_ptr<std::thread> io_thread_;
        bool own_io_thread_ = false;
        std::unique_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> work_guard_;

        std::deque<internal::BoltPhysicalConnection::PooledConnection> idle_connections_;
        std::size_t total_connections_currently_pooled_ = 0;
        std::size_t total_connections_ever_created_ = 0;
        std::mutex pool_mutex_;
        std::condition_variable pool_condition_;
        std::atomic<bool> closing_{false};

        std::string finalized_user_agent_;
        boltprotocol::HelloMessageParams::BoltAgentInfo finalized_bolt_agent_info_;

        std::map<std::string, std::shared_ptr<routing::RoutingTable>> routing_tables_;
        std::mutex routing_table_mutex_;

        std::unique_ptr<boost::asio::steady_timer> eviction_timer_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H

#include <functional>  // For std::function
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For Value, SuccessMessageParams, FailureMessageParams
// BoltRecord and BoltResultStream are needed for the 'run' method's return type
#include "bolt_record.h"
#include "result_stream.h"

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // TransactionContext is passed to user-provided transaction functions (lambdas).
    // It provides methods to execute queries within the scope of the managed transaction.
    class TransactionContext {
      public:
        // Constructor taking a non-owning pointer to the SessionHandle that manages this transaction.
        // The SessionHandle must outlive the TransactionContext.
        explicit TransactionContext(SessionHandle& session);
        virtual ~TransactionContext() = default;  // Good practice for base classes if inherited

        // Executes a query within the current transaction.
        // Returns a pair: { {Error, ErrorMsg}, ResultStreamUniquePtr }.
        // The ResultStream unique_ptr is null if an error occurred before streaming could start.
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters = {}  // Default empty parameters
        );

        // Executes a query and consumes its result, returning only the summary.
        // Useful for DML statements (CREATE, MERGE, DELETE, SET).
        // Returns {Error, ErrorMsg}. out_summary and out_failure are populated.
        std::pair<boltprotocol::BoltError, std::string> run_consume(const std::string& cypher,
                                                                    const std::map<std::string, boltprotocol::Value>& parameters,  // No default for params here
                                                                    boltprotocol::SuccessMessageParams& out_summary,
                                                                    boltprotocol::FailureMessageParams& out_failure);

        // Note: A full-fledged TransactionContext in official drivers often mirrors
        // many methods of the Session object (like run, commit, rollback, close).
        // However, for the managed transaction function pattern, the Session handles
        // commit/rollback/close based on the lambda's outcome.
        // If we want the lambda to have more control, these methods could be added here,
        // and they would signal the Session to perform the action.
        // For now, we keep it to query execution.

        // boltprotocol::BoltError commit(); // Example: Signals the managing Session to commit
        // boltprotocol::BoltError rollback(); // Example: Signals the managing Session to rollback
        // bool is_open() const; // Example: Checks if the underlying transaction is still active

      private:
        SessionHandle& owner_session_;  // Non-owning reference to the session managing the transaction
    };

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return a TransactionWorkResult indicating success or application-level failure.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H

#include <functional>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

namespace neo4j_bolt_transport {

    // Forward declare TransactionContext (defined in neo4j_transaction_context.h)
    class TransactionContext;

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return SUCCESS if work is done, or an error code + message if app logic fails.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

    // REMOVED conflicting TransactionContext class definition from here.
    // The primary definition is in neo4j_transaction_context.h

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H
#define NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H

#include <deque>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "bolt_record.h"
#include "boltprotocol/message_defs.h"
#include "result_summary.h"  // <--- NEW

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    class BoltResultStream {
      public:
        // Constructor now takes initial raw summary and connection info for typed summary
        BoltResultStream(SessionHandle* session,
                         std::optional<int64_t> query_id_for_streaming,
                         boltprotocol::SuccessMessageParams run_summary_params,  // Raw params from RUN
                         std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                         std::vector<boltprotocol::RecordMessageParams> initial_records,
                         bool server_might_have_more,
                         const boltprotocol::versions::Version& bolt_version,          // For ResultSummary
                         bool utc_patch_active,                                        // For ResultSummary
                         const std::string& server_address_for_summary,                // For ResultSummary
                         const std::optional<std::string>& database_name_for_summary,  // For ResultSummary
                         boltprotocol::BoltError initial_error = boltprotocol::BoltError::SUCCESS,
                         const std::string& initial_error_message = "",
                         const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details = std::nullopt);

        ~BoltResultStream();

        BoltResultStream(const BoltResultStream&) = delete;
        BoltResultStream& operator=(const BoltResultStream&) = delete;
        BoltResultStream(BoltResultStream&& other) noexcept;
        BoltResultStream& operator=(BoltResultStream&& other) noexcept;

        std::pair<boltprotocol::BoltError, std::string> has_next(bool& out_has_next);
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> next();
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> single();  // <--- NEW

        std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> list_all();
        std::tuple<boltprotocol::BoltError, std::string, ResultSummary> consume();  // <--- MODIFIED to return typed ResultSummary

        const ResultSummary& get_run_summary() const {
            return run_summary_typed_;
        }  // <--- MODIFIED
        const ResultSummary& get_final_summary() const {
            return final_summary_typed_;
        }  // <--- MODIFIED (after full consumption/discard)

        bool is_fully_consumed_or_failed() const;
        bool has_failed() const;
        boltprotocol::BoltError get_failure_reason() const;
        const std::string& get_failure_message() const;
        const boltprotocol::FailureMessageParams& get_failure_details() const;  // For raw server failure
        const std::vector<std::string>& field_names() const;

      private:
        friend class SessionHandle;
        friend class TransactionContext;

        std::pair<boltprotocol::BoltError, std::string> _fetch_more_records(int64_t n);
        std::pair<boltprotocol::BoltError, std::string> _discard_all_remaining_records();
        void _set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details = std::nullopt);
        void _update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary);

        SessionHandle* owner_session_;
        std::optional<int64_t> query_id_;

        std::deque<boltprotocol::RecordMessageParams> raw_record_buffer_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_cache_;

        ResultSummary run_summary_typed_;    // Summary from RUN message (available immediately)
        ResultSummary final_summary_typed_;  // Summary from final PULL/DISCARD (available after consumption)
                                             // This needs careful initialization.

        boltprotocol::FailureMessageParams failure_details_raw_;  // Store raw failure

        bool server_has_more_records_ = false;
        bool initial_server_has_more_records_ = false;
        bool stream_fully_consumed_or_discarded_ = false;
        bool stream_failed_ = false;
        boltprotocol::BoltError failure_reason_ = boltprotocol::BoltError::SUCCESS;
        std::string failure_message_;
        bool is_first_pull_attempt_ = true;

        // For ResultSummary creation
        boltprotocol::versions::Version bolt_version_cache_;
        bool utc_patch_active_cache_;
        std::string server_address_cache_;
        std::optional<std::string> database_name_cache_;
    };

    // Inline simple getters
    inline bool BoltResultStream::is_fully_consumed_or_failed() const {
        return stream_fully_consumed_or_discarded_ || stream_failed_;
    }
    inline bool BoltResultStream::has_failed() const {
        return stream_failed_;
    }
    inline boltprotocol::BoltError BoltResultStream::get_failure_reason() const {
        return failure_reason_;
    }
    inline const std::string& BoltResultStream::get_failure_message() const {
        return failure_message_;
    }
    inline const boltprotocol::FailureMessageParams& BoltResultStream::get_failure_details() const {
        return failure_details_raw_;
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H
#define NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For SuccessMessageParams, Value, Version

namespace neo4j_bolt_transport {

    // Forward declarations for Plan, ProfiledPlan, Notification if they become complex classes
    // struct Plan;
    // struct ProfiledPlan;
    // struct Notification;

    struct QueryCounters {
        int64_t nodes_created = 0;
        int64_t nodes_deleted = 0;
        int64_t relationships_created = 0;
        int64_t relationships_deleted = 0;
        int64_t properties_set = 0;
        int64_t labels_added = 0;
        int64_t labels_removed = 0;
        int64_t indexes_added = 0;
        int64_t indexes_removed = 0;
        int64_t constraints_added = 0;
        int64_t constraints_removed = 0;
        bool contains_updates = false;
        bool contains_system_updates = false;
        int64_t system_updates = 0;

        QueryCounters() = default;
    };

    enum class QueryType { UNKNOWN, READ_ONLY, READ_WRITE, WRITE_ONLY, SCHEMA_WRITE };

    // Simplified notification structure
    struct ServerNotification {
        std::string code;
        std::string title;
        std::string description;
        std::optional<std::map<std::string, boltprotocol::Value>> position;  // e.g., {"offset": <int>, "line": <int>, "column": <int>}
        std::string severity;                                                // e.g., "WARNING", "INFORMATION"
        std::string category;                                                // e.g., "HINT", "UNRECOGNIZED" (Bolt 5.2+)

        ServerNotification() = default;
    };

    class ResultSummary {
      public:
        // Constructor takes the raw success message params and connection info
        ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params,
                      const boltprotocol::versions::Version& bolt_version,
                      bool utc_patch_active,
                      const std::string& server_address,                            // Address of the server that executed the query
                      const std::optional<std::string>& database_name_from_session  // DB name from session config
        );

        const boltprotocol::SuccessMessageParams& raw_params() const {
            return raw_params_;
        }

        QueryType query_type() const {
            return query_type_;
        }
        const QueryCounters& counters() const {
            return counters_;
        }

        const std::string& server_address() const {
            return server_address_;
        }
        const std::string& database_name() const {
            return database_name_;
        }  // Effective DB name for the query

        std::optional<std::chrono::milliseconds> result_available_after() const {
            return result_available_after_ms_;
        }
        std::optional<std::chrono::milliseconds> result_consumed_after() const {
            return result_consumed_after_ms_;
        }

        const std::vector<ServerNotification>& notifications() const {
            return notifications_;
        }

        // std::optional<Plan> plan() const; // TODO if Plan parsing is added
        // std::optional<ProfiledPlan> profiled_plan() const; // TODO if ProfiledPlan parsing is added

      private:
        void parse_metadata(const boltprotocol::versions::Version& bolt_version, bool utc_patch_active);
        void parse_query_type(const boltprotocol::Value& type_val);
        void parse_counters(const boltprotocol::Value& counters_val);
        void parse_notifications(const boltprotocol::Value& notifications_val, const boltprotocol::versions::Version& bolt_version);

        boltprotocol::SuccessMessageParams raw_params_;
        QueryType query_type_ = QueryType::UNKNOWN;
        QueryCounters counters_;
        std::vector<ServerNotification> notifications_;

        std::string server_address_;  // Server that executed the query
        std::string database_name_;   // Effective database for the query

        std::optional<std::chrono::milliseconds> result_available_after_ms_;
        std::optional<std::chrono::milliseconds> result_consumed_after_ms_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H

#include <atomic>
#include <chrono>
#include <mutex>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError (used in status)
#include "server_address.h"

namespace neo4j_bolt_transport {
    namespace routing {

        enum class ServerRole { ROUTER, READER, WRITER };

        class RoutingTable {
          public:
            RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds);

            // Tries to get a server for the given role.
            // Returns nullopt if no suitable server or table is stale.
            std::optional<ServerAddress> get_server(ServerRole role);

            // Updates the table with new data from a ROUTE message response.
            // Returns BoltError::SUCCESS or an error code if parsing fails.
            boltprotocol::BoltError update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds);

            bool is_stale() const;
            void mark_as_stale();  // Forcefully mark as stale, e.g., after a connection error

            const std::string& get_database_context_key() const {
                return database_context_key_;
            }
            const std::vector<ServerAddress>& get_routers() const;

            // Remove a server from all lists (e.g., if it becomes unreachable)
            void forget_server(const ServerAddress& address);

          private:
            std::string database_context_key_;  // e.g., "mydatabase@user" or "system"
            std::vector<ServerAddress> routers_;
            std::vector<ServerAddress> readers_;
            std::vector<ServerAddress> writers_;

            std::chrono::steady_clock::time_point last_updated_time_;
            std::chrono::seconds ttl_;

            std::atomic<std::size_t> next_reader_index_ = 0;
            std::atomic<std::size_t> next_writer_index_ = 0;
            std::atomic<std::size_t> next_router_index_ = 0;  // For trying different routers

            mutable std::mutex mutex_;  // Protects access to server lists and indices
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H

#include <cstdint>
#include <functional>  // For std::hash
#include <string>

namespace neo4j_bolt_transport {
    namespace routing {

        struct ServerAddress {
            std::string host;
            std::uint16_t port;

            ServerAddress(std::string h = "", std::uint16_t p = 0) : host(std::move(h)), port(p) {
            }

            bool operator==(const ServerAddress& other) const {
                return host == other.host && port == other.port;
            }

            bool operator<(const ServerAddress& other) const {
                if (host != other.host) {
                    return host < other.host;
                }
                return port < other.port;
            }

            std::string to_string() const {
                return host + ":" + std::to_string(port);
            }
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

namespace std {
    template <>
    struct hash<neo4j_bolt_transport::routing::ServerAddress> {
        size_t operator()(const neo4j_bolt_transport::routing::ServerAddress& addr) const noexcept {
            size_t h1 = std::hash<std::string>{}(addr.host);
            size_t h2 = std::hash<std::uint16_t>{}(addr.port);
            return h1 ^ (h2 << 1);  // Basic combination
        }
    };
}  // namespace std

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H#ifndef NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H
#define NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H

#include <chrono>
#include <deque>
#include <map>  // For parameters
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "config/session_parameters.h"
#include "internal/bolt_physical_connection.h"
#include "neo4j_transaction_work.h"
#include "result_stream.h"  // Includes ResultSummary transitively

namespace neo4j_bolt_transport {

    class Neo4jBoltTransport;  // Forward declaration

    struct TransactionConfigOverrides {  // New struct for clarity
        std::optional<std::map<std::string, boltprotocol::Value>> metadata;
        std::optional<std::chrono::milliseconds> timeout;
    };

    class SessionHandle {
      public:
        SessionHandle(Neo4jBoltTransport* transport_manager, internal::BoltPhysicalConnection::PooledConnection connection, config::SessionParameters params);
        ~SessionHandle();

        SessionHandle(const SessionHandle&) = delete;
        SessionHandle& operator=(const SessionHandle&) = delete;
        SessionHandle(SessionHandle&& other) noexcept;
        SessionHandle& operator=(SessionHandle&& other) noexcept;

        // --- Explicit Transaction Management ---
        std::pair<boltprotocol::BoltError, std::string> begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt,
                                                                          const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt  // Already present
        );
        std::pair<boltprotocol::BoltError, std::string> commit_transaction();
        std::pair<boltprotocol::BoltError, std::string> rollback_transaction();
        bool is_in_transaction() const {
            return in_explicit_transaction_;
        }

        // --- Managed Transaction Functions ---
        TransactionWorkResult execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);
        TransactionWorkResult execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);

        // --- Query Execution (Auto-commit transactions) ---
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run_query(const std::string& cypher,
                                                                                                                const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                                                const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> run_query_and_consume(const std::string& cypher,
                                                                                                        const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                        const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<boltprotocol::BoltError, std::string> run_query_without_result(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                 const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        const std::vector<std::string>& get_last_bookmarks() const;
        void update_bookmarks(const std::vector<std::string>& new_bookmarks);

        void close();
        bool is_closed() const {
            return is_closed_;
        }
        bool is_connection_valid() const {
            return connection_is_valid_;
        }

        friend class BoltResultStream;
        friend class TransactionContext;

      private:
        std::pair<boltprotocol::BoltError, std::string> _prepare_auto_commit_run(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                 const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,  // Kept for RunMessageParams
                                                                                 const std::optional<std::chrono::milliseconds>& tx_timeout,                    // Kept for RunMessageParams
                                                                                 boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                 boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw);
        std::pair<boltprotocol::BoltError, std::string> _stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw);

        void _release_connection_to_pool(bool mark_healthy = true);
        void _invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message);
        internal::BoltPhysicalConnection* _get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context);

        TransactionWorkResult _execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout);

        Neo4jBoltTransport* transport_manager_;
        internal::BoltPhysicalConnection::PooledConnection connection_;
        config::SessionParameters session_params_;

        bool in_explicit_transaction_ = false;
        std::optional<int64_t> current_transaction_query_id_;

        std::vector<std::string> current_bookmarks_;
        bool is_closed_ = false;
        bool connection_is_valid_ = true;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H#ifndef NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H
#define NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace neo4j_bolt_transport {
    namespace uri {

        // Holds the deconstructed parts of a Neo4j connection URI.
        struct ParsedUri {
            std::string input_uri;
            std::string scheme;

            // For non-routing schemes, hosts will contain one entry.
            // For routing schemes (neo4j://, neo4j+s://), hosts can contain multiple seed router addresses.
            std::vector<std::pair<std::string, uint16_t>> hosts_with_ports;

            // Userinfo extracted from URI (if present)
            std::optional<std::string> username_from_uri;
            std::optional<std::string> password_from_uri;

            // Query parameters from the URI
            std::map<std::string, std::string> query_parameters;

            // Interpretation of the scheme
            bool is_valid = false;
            bool is_routing_scheme = false;
            bool tls_enabled_by_scheme = false;
            enum class SchemeTrustStrategy {
                NONE,            // e.g. bolt, neo4j (depends on server default or further config)
                SYSTEM_CAS,      // e.g. bolt+s, neo4j+s
                TRUST_ALL_CERTS  // e.g. bolt+ssc, neo4j+ssc (discouraged)
            };
            SchemeTrustStrategy trust_strategy_hint = SchemeTrustStrategy::NONE;

            // Standard default ports
            static constexpr uint16_t DEFAULT_BOLT_PORT = 7687;
            // Neo4j typically uses the same port for TLS-enabled Bolt (server-side config)
            static constexpr uint16_t DEFAULT_BOLTS_PORT = 7687;
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H#ifndef NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H
#define NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H

#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "parsed_uri.h"

namespace neo4j_bolt_transport {
    namespace uri {

        class UriParser {
          public:
            UriParser() = delete;  // Static methods only

            // Parses the given URI string and populates the ParsedUri struct.
            // Returns BoltError::SUCCESS on success, or an error code if parsing fails.
            static boltprotocol::BoltError parse(const std::string& uri_string, ParsedUri& out_parsed_uri);
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H#include "neo4j_bolt_transport/bolt_record.h"

namespace neo4j_bolt_transport {

    BoltRecord::BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> names_ptr) : fields_(std::move(fields_data)), field_names_ptr_(std::move(names_ptr)) {
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(size_t index) const {
        if (index >= fields_.size()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Or a more specific "IndexOutOfBounds"
        }
        // Return a copy of the Value, or handle lifetime if Value contains non-copyable shared_ptrs carefully.
        // std::variant copy semantics should handle this correctly.
        return {boltprotocol::BoltError::SUCCESS, fields_[index]};
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // No field names available
        }
        // Could optimize with a cached map if records are accessed by name frequently
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                if (i < fields_.size()) {  // Should always be true if names match fields
                    return {boltprotocol::BoltError::SUCCESS, fields_[i]};
                } else {
                    // This indicates an internal inconsistency (more names than fields)
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
            }
        }
        return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Field name not found
    }

    const std::vector<std::string>& BoltRecord::field_names() const {
        static const std::vector<std::string> empty_field_names;  // For returning if no names ptr
        if (field_names_ptr_) {
            return *field_names_ptr_;
        }
        return empty_field_names;
    }

    // Template method implementations are in the header due to template instantiation.

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/auth_token.h"

namespace neo4j_bolt_transport {
    namespace config {

        AuthTokenVariant AuthTokens::none() {
            return NoAuth{};
        }

        AuthTokenVariant AuthTokens::basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm) {
            return BasicAuth{username, password, realm};
        }

        AuthTokenVariant AuthTokens::kerberos(const std::string& base64_ticket) {
            return KerberosAuth{base64_ticket};
        }

        AuthTokenVariant AuthTokens::bearer(const std::string& token) {
            return BearerAuth{token};
        }

        AuthTokenVariant AuthTokens::custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters) {
            return CustomAuth{principal, credentials, realm, scheme, parameters};
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/transport_config.h"

#include <iostream>

#include "boltprotocol/bolt_errors_versions.h"  // For default versions
#include "neo4j_bolt_transport/uri/parsed_uri.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {
    namespace config {

        TransportConfig::TransportConfig(const std::string& a_uri_string) : uri_string(a_uri_string.empty() ? "bolt://localhost:7687" : a_uri_string) {
            uri::ParsedUri parsed_uri_info;
            if (uri::UriParser::parse(uri_string, parsed_uri_info) == boltprotocol::BoltError::SUCCESS) {
                apply_parsed_uri_settings(parsed_uri_info);
            } else {
                if (logger) {
                    logger->error("Failed to parse URI '{}' during TransportConfig construction. Using defaults where possible.", uri_string);
                } else {
                    std::cerr << "Error: Failed to parse URI '" << uri_string << "' during TransportConfig construction." << std::endl;
                }
            }
            if (preferred_bolt_versions.empty()) {
                preferred_bolt_versions = boltprotocol::versions::get_default_proposed_versions();
            }
            prepare_agent_strings();          // Call prepare_agent_strings before get_or_create_logger
            logger = get_or_create_logger();  // Ensure logger is initialized
        }

        TransportConfig::TransportConfig() : TransportConfig("bolt://localhost:7687") {
        }

        boltprotocol::BoltError TransportConfig::apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri) {
            if (!parsed_uri.is_valid) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            if (encryption_strategy == EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME) {
                if (parsed_uri.tls_enabled_by_scheme) {
                    if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::SYSTEM_CAS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    } else if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS;
                    } else {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    }
                } else {
                    encryption_strategy = EncryptionStrategy::FORCE_PLAINTEXT;
                }
            }

            if (!parsed_uri.is_routing_scheme) {
                client_side_routing_enabled = false;
            }

            if (std::holds_alternative<NoAuth>(auth_token)) {
                if (parsed_uri.username_from_uri.has_value()) {
                    auth_token = AuthTokens::basic(parsed_uri.username_from_uri.value(), parsed_uri.password_from_uri.value_or(""), std::nullopt);
                }
            }

            if (client_side_routing_enabled && initial_router_addresses_override.empty() && !parsed_uri.hosts_with_ports.empty()) {
                std::string initial_context_key = parsed_uri.scheme + "://";
                if (!parsed_uri.hosts_with_ports.empty()) {
                    initial_context_key += parsed_uri.hosts_with_ports.front().first;  // Simplified context key
                }

                std::vector<routing::ServerAddress> initial_routers;
                for (const auto& host_port_pair : parsed_uri.hosts_with_ports) {
                    initial_routers.emplace_back(host_port_pair.first, host_port_pair.second);
                }
                initial_router_addresses_override[initial_context_key] = initial_routers;
            }

            auto it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout");  // Renamed in spec sometimes
            if (it_conn_timeout == parsed_uri.query_parameters.end()) {                     // try alternative name
                it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout_ms");
            }
            if (it_conn_timeout != parsed_uri.query_parameters.end()) {
                try {
                    tcp_connect_timeout_ms = static_cast<uint32_t>(std::stoul(it_conn_timeout->second));
                } catch (const std::exception&) { /* ignore invalid param */
                }
            }

            auto it_max_retry_time = parsed_uri.query_parameters.find("max_transaction_retry_time");
            if (it_max_retry_time != parsed_uri.query_parameters.end()) {
                try {
                    // Assuming time is in ms if specified like "15s" or "15000ms" this needs parsing logic
                    // For simplicity, assume it's just ms for now if it's a number
                    max_transaction_retry_time_ms = static_cast<uint32_t>(std::stoul(it_max_retry_time->second));
                } catch (const std::exception&) { /* ignore */
                }
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        void TransportConfig::prepare_agent_strings(const std::string& default_transport_name_version) {
            if (bolt_agent_info.product.empty()) {
                bolt_agent_info.product = default_transport_name_version;
            }
        }

        std::shared_ptr<spdlog::logger> TransportConfig::get_or_create_logger(const std::string& logger_name) {
            if (logger) {
                logger->set_level(log_level);
                return logger;
            }
            auto default_logger = spdlog::get(logger_name);
            if (!default_logger) {
                try {
                    default_logger = spdlog::stdout_color_mt(logger_name);                            // Or any other default sink
                    default_logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%n] [tid %t] %v");  // Added thread id
                    default_logger->set_level(log_level);
                } catch (const spdlog::spdlog_ex& ex) {
                    std::cerr << "Logger (" << logger_name << ") initialization failed: " << ex.what() << std::endl;
                    return nullptr;  // Or throw
                }
            } else {
                default_logger->set_level(log_level);
            }
            return default_logger;
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,
                                                                                                            std::vector<uint8_t> payload) {  // payload 传值拷贝

            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async send chunked payload on defunct connection.", get_id_for_logging());
                co_return last_error_code_;
            }

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            std::vector<uint8_t> chunk_header_bytes(boltprotocol::CHUNK_HEADER_SIZE);

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);
                std::memcpy(chunk_header_bytes.data(), &chunk_size_be, boltprotocol::CHUNK_HEADER_SIZE);

                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                std::vector<uint8_t> current_chunk_data(data_ptr, data_ptr + chunk_size);
                err = co_await _write_to_active_async_stream(stream_variant_ref, current_chunk_data);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;  // Correctly initialized
                std::memcpy(chunk_header_bytes.data(), &zero_chunk_be, boltprotocol::CHUNK_HEADER_SIZE);
                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
            }

            // _write_to_active_async_stream -> async_io_with_timeout -> callbacks->mark_as_defunct_from_async
            // 所以这里不需要再次调用 mark_as_defunct
            co_return err;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref) {
            std::vector<uint8_t> out_payload_vec;
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async receive chunked payload on defunct connection.", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{last_error_code_, {}};
            }

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;
            std::pair<boltprotocol::BoltError, std::vector<uint8_t>> read_result;

            while (true) {
                read_result = co_await _read_from_active_async_stream(stream_variant_ref, boltprotocol::CHUNK_HEADER_SIZE);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& header_bytes = read_result.second;
                if (header_bytes.size() != boltprotocol::CHUNK_HEADER_SIZE) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    mark_as_defunct_from_async(err, "Async receive chunk header: incorrect size read.");  // 使用接口
                    break;
                }
                uint16_t chunk_size_be;
                std::memcpy(&chunk_size_be, header_bytes.data(), boltprotocol::CHUNK_HEADER_SIZE);
                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Async received chunk larger than max: " + std::to_string(chunk_payload_size);
                    mark_as_defunct_from_async(err, msg);  // 使用接口
                    if (logger_) logger_->error("[ConnAsyncChunking {}] {}", get_id_for_logging(), msg);
                    break;
                }

                read_result = co_await _read_from_active_async_stream(stream_variant_ref, chunk_payload_size);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& chunk_data = read_result.second;
                if (chunk_data.size() != chunk_payload_size) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    mark_as_defunct_from_async(err, "Async receive chunk payload: incorrect size read.");  // 使用接口
                    break;
                }
                try {
                    out_payload_vec.insert(out_payload_vec.end(), chunk_data.begin(), chunk_data.end());
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory appending async chunk to payload buffer.";
                    mark_as_defunct_from_async(err, msg);  // 使用接口
                    if (logger_) logger_->critical("[ConnAsyncChunking {}] {}", get_id_for_logging(), msg);
                    break;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{err, {}};
            } else if (total_bytes_read_for_message == 0 && out_payload_vec.empty()) {
                if (logger_) logger_->trace("[ConnAsyncChunking {}] Async received NOOP message.", get_id_for_logging());
            }
            co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, std::move(out_payload_vec)};
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/post.hpp>
// #include <boost/asio/read.hpp> // 不再直接需要
// #include <boost/asio/write.hpp>// 不再直接需要
#include <cstring>
#include <iostream>
#include <optional>
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_utils_decl.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async write on defunct connection.", get_id_for_logging());
                co_return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (data.empty()) {
                co_return boltprotocol::BoltError::SUCCESS;
            }

            std::chrono::milliseconds timeout(conn_config_.socket_write_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Write {} bytes. Timeout: {}ms", get_id_for_logging(), data.size(), timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async write: stream_ptr in variant is null.", get_id_for_logging());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // 调用 async_write_with_timeout
                    co_return co_await async_utils::async_write_with_timeout(this, *stream_ptr, boost::asio::buffer(data), timeout, "Async Write");
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return get_last_error_code_from_async();
            }
            if (result.second != data.size()) {
                std::string msg = "Partial async write. Expected " + std::to_string(data.size()) + ", wrote " + std::to_string(result.second);
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", get_id_for_logging(), msg);
                co_return get_last_error_code_from_async();
            }
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async read on defunct connection.", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            if (size_to_read == 0) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, {}};
            }

            std::vector<uint8_t> buffer_vec(size_to_read);
            std::chrono::milliseconds timeout(conn_config_.socket_read_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Read {} bytes. Timeout: {}ms", get_id_for_logging(), size_to_read, timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async read: stream_ptr in variant is null.", get_id_for_logging());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // 调用 async_read_with_timeout
                    co_return co_await async_utils::async_read_with_timeout(this, *stream_ptr, boost::asio::buffer(buffer_vec), timeout, "Async Read");
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{get_last_error_code_from_async(), {}};
            }
            if (result.second < size_to_read) {
                std::string msg = "Incomplete async read. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(result.second);
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", get_id_for_logging(), msg);
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{get_last_error_code_from_async(), {}};
            }
            co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, std::move(buffer_vec)};
        }
    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <iostream>
#include <variant>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _prepare_logon_params_from_config, _execute_logon_message, perform_logon, perform_logoff 保持不变
        // ... (代码同上一批)

        void BoltPhysicalConnection::_prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const {
            out_params.auth_tokens.clear();
            std::visit(
                [&](auto&& arg) {
                    using T = std::decay_t<decltype(arg)>;
                    if constexpr (std::is_same_v<T, config::BasicAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("basic");
                        out_params.auth_tokens["principal"] = arg.username;
                        out_params.auth_tokens["credentials"] = arg.password;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                    } else if constexpr (std::is_same_v<T, config::BearerAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("bearer");
                        out_params.auth_tokens["credentials"] = arg.token;
                    } else if constexpr (std::is_same_v<T, config::KerberosAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("kerberos");
                        out_params.auth_tokens["credentials"] = arg.base64_ticket;
                    } else if constexpr (std::is_same_v<T, config::CustomAuth>) {
                        out_params.auth_tokens["scheme"] = arg.scheme;
                        out_params.auth_tokens["principal"] = arg.principal;
                        out_params.auth_tokens["credentials"] = arg.credentials;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                        if (arg.parameters) {
                            for (const auto& pair_ : *arg.parameters) {  // Renamed pair to pair_
                                if (pair_.first != "scheme" && pair_.first != "principal" && pair_.first != "credentials" && pair_.first != "realm") {
                                    out_params.auth_tokens[pair_.first] = pair_.second;
                                }
                            }
                        }
                    } else if constexpr (std::is_same_v<T, config::NoAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("none");
                    }
                },
                conn_config_.auth_token);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure) {
            InternalState state_before_logon = current_state_.load();
            if (state_before_logon != InternalState::HELLO_AUTH_SENT && state_before_logon != InternalState::READY && state_before_logon != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "LOGON executed in invalid state: " + _get_current_state_as_string());
                if (logger_) logger_->error("[ConnAuth {}] LOGON in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }

            std::vector<uint8_t> logon_payload;
            boltprotocol::PackStreamWriter ps_writer(logon_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnAuth {}] Sending LOGON message (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            err = send_request_receive_summary(logon_payload, out_success, out_failure);

            if (err == boltprotocol::BoltError::SUCCESS) {
                if (last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                    _update_metadata_from_logon_success(out_success);
                    if (current_state_.load() != InternalState::DEFUNCT) {
                        current_state_.store(InternalState::READY);
                    }
                    if (logger_) logger_->info("[ConnAuth {}] LOGON successful.", id_);
                } else {
                    if (logger_) logger_->warn("[ConnAuth {}] LOGON server response not SUCCESS. Code: {}, Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                }
            } else {
                if (logger_) logger_->error("[ConnAuth {}] LOGON message send/receive summary failed. Error: {}", id_, static_cast<int>(err));
            }
            return last_error_code_;
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGON message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }

            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::READY && current_s != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon called in invalid state " + _get_current_state_as_string());
                if (logger_) logger_->warn("[ConnAuth {}] perform_logon in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }
            mark_as_used();

            boltprotocol::FailureMessageParams ignored_failure_details;
            return _execute_logon_message(logon_params, out_success, ignored_failure_details);
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logoff(boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGOFF message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }
            if (!is_ready_for_queries()) {
                std::string msg = "perform_logoff called when connection not ready. Current state: " + _get_current_state_as_string();
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, msg);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuth {}] Performing LOGOFF.", id_);

            std::vector<uint8_t> logoff_payload;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            boltprotocol::FailureMessageParams ignored_failure_details;
            err = send_request_receive_summary(logoff_payload, out_success, ignored_failure_details);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuth {}] LOGOFF successful.", id_);
                current_state_.store((negotiated_bolt_version_ < boltprotocol::versions::V5_1) ? InternalState::HELLO_AUTH_SENT : InternalState::BOLT_HANDSHAKEN);
            } else {
                if (logger_) logger_->warn("[ConnAuth {}] LOGOFF failed. Error: {}, Server Msg: {}", id_, static_cast<int>(err), last_error_message_);
            }
            return last_error_code_;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::_execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                                            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (logger_) logger_->debug("[ConnAuthAsync {}] Executing LOGON message async (scheme: {}).", get_id_for_logging(), params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            bool stream_valid = std::visit(
                [](auto* stream_ptr) {
                    return stream_ptr != nullptr && stream_ptr->lowest_layer().is_open();
                },
                async_stream_variant_ref);
            if (!stream_valid) {
                if (logger_) logger_->error("[ConnAuthAsync {}] _execute_logon_message_async: No valid async stream provided.", get_id_for_logging());
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_ARGUMENT, "_execute_logon_message_async: No valid async stream provided.");
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            std::vector<uint8_t> logon_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logon_payload_storage);

            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                mark_as_defunct_from_async(err, "Async LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGON serialization failed: {}", get_id_for_logging(), static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            boltprotocol::BoltError send_err = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logon_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON send failed: {}", get_id_for_logging(), static_cast<int>(send_err));
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON receive summary failed: {}", get_id_for_logging(), static_cast<int>(recv_err));
                    summary_err = last_error_code_;
                    break;
                }
                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnAuthAsync {}] Received NOOP while awaiting LOGON summary.", get_id_for_logging());
                    continue;
                }

                boltprotocol::MessageTag tag;
                boltprotocol::BoltError peek_err = _peek_message_tag(response_payload, tag);
                if (peek_err != boltprotocol::BoltError::SUCCESS) {
                    mark_as_defunct_from_async(peek_err, "Async LOGON: Failed to peek tag for summary response.");
                    summary_err = last_error_code_;
                    break;
                }

                boltprotocol::PackStreamReader reader(response_payload);
                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) {
                        mark_as_defunct_from_async(summary_err, "Async LOGON: Failed to deserialize SUCCESS summary.");
                        summary_err = last_error_code_;
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    boltprotocol::BoltError deser_fail_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (deser_fail_err != boltprotocol::BoltError::SUCCESS) {
                        mark_as_defunct_from_async(deser_fail_err, "Async LOGON: Failed to deserialize FAILURE summary.");
                        summary_err = last_error_code_;
                    } else {
                        summary_err = _classify_and_set_server_failure(failure_meta);
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    // 使用 INVALID_MESSAGE_FORMAT 因为 MESSAGE_IGNORED_BY_SERVER 不在标准 BoltError 枚举中
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Received IGNORED instead of SUCCESS/FAILURE.");
                    summary_err = last_error_code_;
                    break;
                } else {
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Unexpected message tag " + std::to_string(static_cast<int>(tag)) + " for summary.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                _update_metadata_from_logon_success(success_meta);
                if (current_state_.load() != InternalState::DEFUNCT) {
                    current_state_.store(InternalState::ASYNC_READY);
                }
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGON successful.", get_id_for_logging());
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGON server response not SUCCESS. Final Error: {}, Server/Conn Msg: {}", get_id_for_logging(), static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logon_async(boltprotocol::LogonMessageParams logon_params,
                                                                                                                                                   std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async: LOGON not supported in Bolt < 5.1", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, {}};
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN && current_s != InternalState::ASYNC_BOLT_HANDSHAKEN && current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async in invalid state {}", get_id_for_logging(), _get_current_state_as_string());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon_async in invalid state " + _get_current_state_as_string());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }
            mark_as_used();
            co_return co_await _execute_logon_message_async(std::move(logon_params), async_stream_variant_ref);
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logoff_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async: LOGOFF not supported in Bolt < 5.1", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, {}};
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY && current_s != InternalState::STREAMING && current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::AWAITING_SUMMARY && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async called when not ready/streaming. State: {}", get_id_for_logging(), _get_current_state_as_string());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logoff_async in invalid state " + _get_current_state_as_string());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuthAsync {}] Performing LOGOFF async.", get_id_for_logging());

            std::vector<uint8_t> logoff_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload_storage);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                mark_as_defunct_from_async(err, "Async LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGOFF serialization failed: {}", get_id_for_logging(), static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            boltprotocol::BoltError send_err = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logoff_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGOFF send failed: {}", get_id_for_logging(), static_cast<int>(send_err));
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    summary_err = last_error_code_;
                    break;
                }
                if (response_payload.empty()) continue;

                boltprotocol::MessageTag tag;
                // 假设 _peek_message_tag 总是成功或我们处理其错误
                if (_peek_message_tag(response_payload, tag) != boltprotocol::BoltError::SUCCESS) {
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGOFF: Peek tag failed.");
                    summary_err = last_error_code_;
                    break;
                }
                boltprotocol::PackStreamReader reader(response_payload);

                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) mark_as_defunct_from_async(summary_err, "Async LOGOFF: Failed to deserialize SUCCESS.");
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    summary_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (summary_err == boltprotocol::BoltError::SUCCESS)
                        summary_err = _classify_and_set_server_failure(failure_meta);
                    else
                        mark_as_defunct_from_async(summary_err, "Async LOGOFF: Failed to deserialize FAILURE.");
                    break;
                } else {  // IGNORED or other unexpected
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGOFF: Unexpected summary tag.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGOFF successful.", get_id_for_logging());
                current_state_.store((negotiated_bolt_version_ < boltprotocol::versions::V5_1) ? InternalState::ASYNC_HELLO_AUTH_SENT : InternalState::ASYNC_BOLT_HANDSHAKEN);
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGOFF failed. Error: {}, Server Msg: {}", get_id_for_logging(), static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // For initial logger checks
#include <utility>   // For std::move

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        std::atomic<uint64_t> BoltPhysicalConnection::next_connection_id_counter_(0);

        BoltPhysicalConnection::BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr)
            : id_(next_connection_id_counter_++),
              conn_config_(std::move(config)),
              io_context_ref_(io_ctx),
              logger_(logger_ptr),  // Directly use passed logger
              current_state_(InternalState::FRESH),
              negotiated_bolt_version_(0, 0),
              creation_timestamp_(std::chrono::steady_clock::now()) {
            if (!logger_) {  // Fallback if a null logger was somehow passed
                std::cerr << "Warning: BoltPhysicalConnection " << id_ << " created with a null logger." << std::endl;
                // Optionally create a default emergency logger here if critical
            }

            last_used_timestamp_.store(creation_timestamp_, std::memory_order_relaxed);
            if (logger_) {
                logger_->debug("[ConnConstruct {}] Constructed. Target: {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            }
        }

        BoltPhysicalConnection::~BoltPhysicalConnection() {
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destructing. Current state: {}", id_, _get_current_state_as_string());
            }
            // Ensure resources are cleaned up. terminate(false) handles most of it.
            // _reset_resources_and_state(true) is a fallback if terminate wasn't called or state is already DEFUNCT/FRESH.
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::DEFUNCT && current_s != InternalState::FRESH) {
                terminate(false);  // Don't send GOODBYE from destructor
            } else {
                // If already defunct or fresh, still ensure resources are reset, especially if construction failed partway.
                _reset_resources_and_state(true);  // called_from_destructor = true
            }
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destruction complete.", id_);
            }
        }

        BoltPhysicalConnection::BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept
            : id_(other.id_),
              conn_config_(std::move(other.conn_config_)),
              io_context_ref_(other.io_context_ref_),
              logger_(std::move(other.logger_)),  // Move the logger
              owned_socket_for_sync_plain_(std::move(other.owned_socket_for_sync_plain_)),
              plain_iostream_wrapper_(std::move(other.plain_iostream_wrapper_)),
              ssl_context_sync_(std::move(other.ssl_context_sync_)),
              ssl_stream_sync_(std::move(other.ssl_stream_sync_)),
              // current_state_ is atomic, needs load/store
              negotiated_bolt_version_(other.negotiated_bolt_version_),
              server_agent_string_(std::move(other.server_agent_string_)),
              server_assigned_conn_id_(std::move(other.server_assigned_conn_id_)),
              utc_patch_active_(other.utc_patch_active_),
              creation_timestamp_(other.creation_timestamp_),
              // last_used_timestamp_ is atomic
              last_error_code_(other.last_error_code_),
              last_error_message_(std::move(other.last_error_message_)) {
            current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
            last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);

            // Invalidate 'other' to prevent double resource management
            other.id_ = static_cast<uint64_t>(-1);  // Mark as moved-from
            other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
            // Logger in 'other' is now nullptr due to move.
            // other's unique_ptrs are now nullptr due to move.

            if (logger_) {
                logger_->trace("[ConnMoveConstruct {}] Move constructed from (now defunct) old connection {}.", id_, other.id_);
            }
        }

        BoltPhysicalConnection& BoltPhysicalConnection::operator=(BoltPhysicalConnection&& other) noexcept {
            if (this != &other) {
                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assigning from old ID {}. Current state before: {}", id_, other.id_, _get_current_state_as_string());
                }
                // Properly terminate current connection's resources before overwriting
                InternalState current_s_before_assign = current_state_.load(std::memory_order_relaxed);
                if (current_s_before_assign != InternalState::DEFUNCT && current_s_before_assign != InternalState::FRESH) {
                    terminate(false);  // Gracefully terminate self if active
                } else {
                    _reset_resources_and_state(false);  // Clean up if FRESH but resources might exist
                }

                id_ = other.id_;
                conn_config_ = std::move(other.conn_config_);
                // io_context_ref_ is a reference, assumed to be compatible and not changed.
                logger_ = std::move(other.logger_);

                owned_socket_for_sync_plain_ = std::move(other.owned_socket_for_sync_plain_);
                plain_iostream_wrapper_ = std::move(other.plain_iostream_wrapper_);
                ssl_context_sync_ = std::move(other.ssl_context_sync_);
                ssl_stream_sync_ = std::move(other.ssl_stream_sync_);

                current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                negotiated_bolt_version_ = other.negotiated_bolt_version_;
                server_agent_string_ = std::move(other.server_agent_string_);
                server_assigned_conn_id_ = std::move(other.server_assigned_conn_id_);
                utc_patch_active_ = other.utc_patch_active_;
                creation_timestamp_ = other.creation_timestamp_;
                last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                last_error_code_ = other.last_error_code_;
                last_error_message_ = std::move(other.last_error_message_);

                // Invalidate 'other'
                other.id_ = static_cast<uint64_t>(-1);
                other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
                // Logger in 'other' is now nullptr.
                // other's unique_ptrs are now nullptr.

                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assignment complete.", id_);
                }
            }
            return *this;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <variant>

#include "boltprotocol/handshake.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_bolt_handshake() {
            InternalState expected_prev_state;
            bool is_ssl = conn_config_.encryption_enabled;

            if (is_ssl) {
                expected_prev_state = InternalState::SSL_HANDSHAKEN;
                if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] SSL stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            } else {
                expected_prev_state = InternalState::TCP_CONNECTED;
                if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] Plain stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            }

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state) {
                std::string msg = "Bolt handshake (sync) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            current_state_.store(InternalState::BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHS {}] Performing (sync) Bolt handshake.", id_);

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for handshake.");
                if (logger_) logger_->error("[ConnBoltHS {}] No Bolt versions to propose.", id_);
                return last_error_code_;
            }

            boltprotocol::BoltError err;
            if (is_ssl) {
                err = boltprotocol::perform_handshake(*ssl_stream_sync_, proposed_versions, negotiated_bolt_version_);
            } else {
                err = boltprotocol::perform_handshake(*plain_iostream_wrapper_, proposed_versions, negotiated_bolt_version_);
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Sync Bolt handshake failed: " + error::bolt_error_to_string(err);
                _mark_as_defunct_internal(err, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (logger_) logger_->debug("[ConnBoltHS {}] Sync Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);

            current_state_.store(InternalState::BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref, std::chrono::milliseconds timeout) {
            bool is_ssl_stream = std::holds_alternative<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>(async_stream_variant_ref);
            InternalState expected_prev_state = is_ssl_stream ? InternalState::SSL_HANDSHAKEN : InternalState::TCP_CONNECTED;

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            // Allow if just finished async SSL HS or async TCP connect, or if already in correct pre-state
            bool correct_prev_state = (current_s == expected_prev_state) || (is_ssl_stream && current_s == InternalState::ASYNC_SSL_HANDSHAKING) || (!is_ssl_stream && current_s == InternalState::ASYNC_TCP_CONNECTING);

            if (!correct_prev_state) {
                std::string msg = "Bolt handshake (async) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl_stream ? "SSL_HANDSHAKEN/ASYNC_SSL_HANDSHAKING" : "TCP_CONNECTED/ASYNC_TCP_CONNECTING");
                mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Performing (async) Bolt handshake. Timeout: {}ms", get_id_for_logging(), timeout.count());

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for async handshake.");
                if (logger_) logger_->error("[ConnBoltHSAsync {}] No Bolt versions to propose.", get_id_for_logging());
                co_return last_error_code_;
            }

            std::vector<uint8_t> handshake_bytes;
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0xB0);
            handshake_bytes.push_back(0x17);
            for (const auto& version : proposed_versions) {
                handshake_bytes.push_back(version.minor);
                handshake_bytes.push_back(version.major);
                handshake_bytes.push_back(0);
                handshake_bytes.push_back(0);
            }
            while (handshake_bytes.size() < 20) {
                handshake_bytes.push_back(0);
            }

            boltprotocol::BoltError err = co_await _write_to_active_async_stream(async_stream_variant_ref, handshake_bytes);
            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to send proposed versions: " + error::bolt_error_to_string(err);
                // _write_to_active_async_stream calls mark_as_defunct_from_async
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            auto [read_err, negotiated_version_bytes] = co_await _read_from_active_async_stream(async_stream_variant_ref, 4);
            if (read_err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to read negotiated version: " + error::bolt_error_to_string(read_err);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (negotiated_version_bytes.size() != 4) {
                std::string msg = "Async Bolt handshake: received incorrect size for negotiated version.";
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            // Assuming Version struct does not have patch member, as per previous clarification.
            negotiated_bolt_version_.minor = negotiated_version_bytes[1];
            negotiated_bolt_version_.major = negotiated_version_bytes[0];
            // negotiated_bolt_version_.patch = 0; // No patch field

            bool version_supported = false;
            for (const auto& proposed : proposed_versions) {
                if (proposed.major == negotiated_bolt_version_.major && proposed.minor == negotiated_bolt_version_.minor) {
                    version_supported = true;
                    break;
                }
            }

            if (negotiated_bolt_version_.major == 0 && negotiated_bolt_version_.minor == 0) {
                std::string msg = "Async Bolt handshake: Server rejected all proposed Bolt versions (responded with 0.0).";
                mark_as_defunct_from_async(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (!version_supported) {
                std::string msg = "Async Bolt handshake: Server chose an unsupported Bolt version: " + negotiated_bolt_version_.to_string();
                mark_as_defunct_from_async(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Async Bolt handshake successful. Negotiated version: {}.{}", get_id_for_logging(), (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);  // Corrected enum member was added
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <variant>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_types.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> BoltPhysicalConnection::establish_async() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::ASYNC_TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::ASYNC_READY || current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCAsync {}] Establish_async called but connection is already READY.", get_id_for_logging());
                    std::string msg = "Establish_async called but connection is already READY. Cannot provide a new ActiveAsyncStreamContext.";
                    if (logger_) logger_->warn("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                    mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                std::string msg = "Establish_async called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{(current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (logger_) logger_->info("[ConnLCAsync {}] Establishing (async) connection to {}:{}", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port);

            _reset_resources_and_state(false);
            current_state_.store(InternalState::ASYNC_TCP_CONNECTING, std::memory_order_relaxed);

            boost::asio::ip::tcp::socket temp_socket(io_context_ref_);  // Socket will be moved
            boltprotocol::BoltError err = boltprotocol::BoltError::UNKNOWN_ERROR;

            err = co_await _stage_tcp_connect_async(temp_socket, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async TCP connect stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> final_stream_variant{std::move(temp_socket)};
            bool encryption_used_for_context = false;

            if (conn_config_.encryption_enabled) {
                encryption_used_for_context = true;
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }

                // temp_socket has been moved into final_stream_variant.
                // We need to extract it, construct ssl_socket_stream, and then move ssl_socket_stream back into final_stream_variant.
                boost::asio::ip::tcp::socket plain_socket_for_ssl = std::get<boost::asio::ip::tcp::socket>(std::move(final_stream_variant));
                // Create SSL stream on the stack or as a local unique_ptr before moving
                boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket_stream(std::move(plain_socket_for_ssl), *ssl_context_sync_);

                current_state_.store(InternalState::ASYNC_SSL_HANDSHAKING);
                // _stage_ssl_handshake_async's first parameter should be boost::asio::ssl::stream<boost::asio::ip::tcp::socket>&
                err = co_await _stage_ssl_handshake_async(ssl_socket_stream, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
                if (err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnLCAsync {}] Async SSL handshake stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                final_stream_variant = std::move(ssl_socket_stream);
                current_state_.store(InternalState::SSL_HANDSHAKEN);
            }

            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> active_async_stream_ptr_variant;
            if (std::holds_alternative<boost::asio::ip::tcp::socket>(final_stream_variant)) {
                active_async_stream_ptr_variant = &std::get<boost::asio::ip::tcp::socket>(final_stream_variant);
            } else {
                active_async_stream_ptr_variant = &std::get<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(final_stream_variant);
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING);
            err = co_await _stage_bolt_handshake_async(active_async_stream_ptr_variant, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async Bolt handshake stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);

            current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            err = co_await _stage_send_hello_and_initial_auth_async(active_async_stream_ptr_variant);
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async HELLO/Auth stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (current_state_.load(std::memory_order_relaxed) != InternalState::ASYNC_READY && current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Async connection did not reach READY/ASYNC_READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            mark_as_used();
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCAsync {}] Async Connection established and ready. Bolt version: {}.{}. Server: {}", get_id_for_logging(), (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);

            ActiveAsyncStreamContext async_context(std::move(final_stream_variant), negotiated_bolt_version_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_, encryption_used_for_context);
            co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{boltprotocol::BoltError::SUCCESS, std::move(async_context)};
        }

        // terminate_async and ping_async保持不变
        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::terminate_async(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) {
                logger_->debug("[ConnLCAsync {}] Terminating (async). Previous state was {}. Send goodbye: {}", get_id_for_logging(), (int)previous_state, send_goodbye);
            }

            if (previous_state == InternalState::DEFUNCT) {
                _reset_resources_and_state(false);
                co_return boltprotocol::BoltError::SUCCESS;
            }

            if (send_goodbye && previous_state >= InternalState::ASYNC_BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT && !(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                if (logger_) logger_->trace("[ConnLCAsync {}] Async GOODBYE logic placeholder: This operation would require the ActiveAsyncStreamContext to be passed or managed by the caller of terminate_async. Not sending GOODBYE from BoltPhysicalConnection directly.", get_id_for_logging());
            }

            _reset_resources_and_state(false);
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::ping_async(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCAsync {}] Pinging (async) connection (via async RESET). Timeout hint: {}ms", get_id_for_logging(), timeout.count());
            if (logger_) logger_->error("[ConnLCAsync {}] ping_async is a placeholder and requires an active async stream context to perform a true async RESET.", get_id_for_logging());
            co_return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/ssl.h>  // For SSL_get_shutdown, SSL_RECEIVED_SHUTDOWN, SSL_SENT_SHUTDOWN (needed by _reset_resources_and_state)

#include <boost/asio/ip/tcp.hpp>  // For socket::shutdown_both

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_reset_resources_and_state(bool called_from_destructor) {
            // This function is critical for cleaning up resources.
            // It's called from establish() before new attempt, terminate(), destructor, and move assignment.

            // 1. Close SSL stream (if exists and open)
            if (ssl_stream_sync_) {
                boost::system::error_code ec_ssl_shutdown, ec_tcp_close;
                if (ssl_stream_sync_->lowest_layer().is_open()) {
                    // Attempt graceful SSL shutdown only if not already shut down by peer.
                    // SSL_get_shutdown checks SSL state.
                    if (!(SSL_get_shutdown(ssl_stream_sync_->native_handle()) & (SSL_RECEIVED_SHUTDOWN | SSL_SENT_SHUTDOWN))) {
                        try {
                            ssl_stream_sync_->shutdown(ec_ssl_shutdown);                                                                                                     // Graceful SSL shutdown
                            if (logger_ && ec_ssl_shutdown && ec_ssl_shutdown != boost::asio::error::eof && ec_ssl_shutdown != boost::asio::ssl::error::stream_truncated) {  // EOF/truncated is common on close
                                logger_->trace("[ConnReset {}] SSL shutdown error: {}", id_, ec_ssl_shutdown.message());
                            }
                        } catch (const boost::system::system_error& e) {
                            if (logger_) logger_->trace("[ConnReset {}] Exception during SSL stream shutdown: {}", id_, e.what());
                        }
                    }
                    // Close the underlying socket
                    try {
                        ssl_stream_sync_->lowest_layer().close(ec_tcp_close);
                        if (logger_ && ec_tcp_close) {
                            logger_->trace("[ConnReset {}] SSL lowest_layer close error: {}", id_, ec_tcp_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during SSL lowest_layer close: {}", id_, e.what());
                    }
                }
                ssl_stream_sync_.reset();  // Release the unique_ptr
            }

            // 2. Reset SSL context (if exists)
            if (ssl_context_sync_) {
                ssl_context_sync_.reset();
            }

            // 3. Close plain iostream wrapper (if exists, it owns its socket if not SSL)
            if (plain_iostream_wrapper_) {
                // Destroying iostream wrapper will close its associated socket if it has one.
                plain_iostream_wrapper_.reset();
            }

            // 4. Close the raw owned socket (if it still exists and wasn't moved to iostream/ssl_stream)
            if (owned_socket_for_sync_plain_) {
                if (owned_socket_for_sync_plain_->is_open()) {
                    boost::system::error_code ec_shutdown, ec_close;
                    try {
                        owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_shutdown);
                        if (logger_ && ec_shutdown) {
                            logger_->trace("[ConnReset {}] Plain socket shutdown error: {}", id_, ec_shutdown.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket shutdown: {}", id_, e.what());
                    }
                    try {
                        owned_socket_for_sync_plain_->close(ec_close);
                        if (logger_ && ec_close) {
                            logger_->trace("[ConnReset {}] Plain socket close error: {}", id_, ec_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket close: {}", id_, e.what());
                    }
                }
                owned_socket_for_sync_plain_.reset();
            }

            // 5. Reset Bolt protocol specific state
            negotiated_bolt_version_ = boltprotocol::versions::Version(0, 0);
            server_agent_string_.clear();
            server_assigned_conn_id_.clear();
            utc_patch_active_ = false;

            // 6. Reset error state, unless in destructor of an already defunct connection
            //    or if we want to preserve the "original sin" error.
            //    For a full reset to FRESH for reuse, error should be cleared.
            if (!called_from_destructor || current_state_.load(std::memory_order_relaxed) != InternalState::DEFUNCT) {
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
            }

            // 7. Set state to FRESH, unless in destructor and already DEFUNCT (don't revive it)
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (!called_from_destructor || current_s != InternalState::DEFUNCT) {
                current_state_.store(InternalState::FRESH, std::memory_order_relaxed);
            }

            if (logger_) logger_->trace("[ConnReset {}] Resources and state reset. Current state for reuse (if not dtor): {}", id_, _get_current_state_as_string());
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::establish() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCSync {}] Establish called but connection is already READY.", id_);
                    return boltprotocol::BoltError::SUCCESS;
                }
                std::string msg = "Establish (sync) called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCSync {}] {}", id_, msg);
                return (current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR;
            }

            if (logger_) logger_->info("[ConnLCSync {}] Establishing (sync) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            _reset_resources_and_state(false);
            current_state_.store(InternalState::TCP_CONNECTING, std::memory_order_relaxed);

            boltprotocol::BoltError err = _stage_tcp_connect();
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            if (conn_config_.encryption_enabled) {
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
                err = _stage_ssl_handshake();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
            }

            err = _stage_bolt_handshake();
            if (err != boltprotocol::BoltError::SUCCESS) {
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            err = _stage_send_hello_and_initial_auth();
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {  // Ensure it's FRESH if not READY
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                }
                return last_error_code_;
            }

            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Sync connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCSync {}] {}", id_, msg);
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // 使用 internal
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            mark_as_used();
            if (last_error_code_ != boltprotocol::BoltError::SUCCESS && logger_) {
                logger_->warn("[ConnLCSync {}] Established but last_error_code_ is {}. Overriding to SUCCESS as state is READY.", id_, static_cast<int>(last_error_code_));
            }
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCSync {}] Sync Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::terminate(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) logger_->debug("[ConnLCSync {}] Terminating (sync). Previous state was {}. Send goodbye: {}", id_, (previous_state == InternalState::DEFUNCT ? "already DEFUNCT" : _get_current_state_as_string()), send_goodbye);

            if (previous_state == InternalState::DEFUNCT) {
                if (logger_) logger_->trace("[ConnLCSync {}] Already defunct, ensuring resources are clean.", id_);
                _reset_resources_and_state(false);
                return boltprotocol::BoltError::SUCCESS;
            }

            if (send_goodbye && previous_state >= InternalState::BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT) {
                if (!(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                    bool can_send = false;
                    if (conn_config_.encryption_enabled) {
                        can_send = ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                    } else {
                        can_send = plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                    }
                    if (can_send) {
                        if (logger_) logger_->trace("[ConnLCSync {}] Attempting to send GOODBYE.", id_);
                        std::vector<uint8_t> goodbye_payload;
                        boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                        if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                            boltprotocol::BoltError goodbye_err = _send_chunked_payload_sync(goodbye_payload);
                            if (goodbye_err != boltprotocol::BoltError::SUCCESS && logger_) {
                                logger_->warn("[ConnLCSync {}] Sending GOODBYE failed: {}", id_, error::bolt_error_to_string(goodbye_err));
                            } else if (logger_ && goodbye_err == boltprotocol::BoltError::SUCCESS) {
                                logger_->trace("[ConnLCSync {}] GOODBYE message sent.", id_);
                            }
                        }
                    } else {
                        if (logger_) logger_->trace("[ConnLCSync {}] Cannot send GOODBYE (stream not ready or Bolt version too low). Previous state was {}.", id_, (int)previous_state);
                    }
                } else {
                    if (logger_) logger_->trace("[ConnLCSync {}] GOODBYE not applicable for Bolt version {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
                }
            }
            _reset_resources_and_state(false);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCSync {}] Pinging (sync) connection (via RESET). Timeout hint: {}ms", id_, timeout.count());
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>
#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const {
            if (payload.empty()) {
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
            }
            boltprotocol::PackStreamReader temp_reader(payload);
            uint8_t raw_tag_byte = 0;
            uint32_t num_fields = 0;

            boltprotocol::BoltError peek_err = boltprotocol::peek_message_structure_header(temp_reader, raw_tag_byte, num_fields);
            if (peek_err != boltprotocol::BoltError::SUCCESS) {
                return peek_err;
            }
            out_tag = static_cast<boltprotocol::MessageTag>(raw_tag_byte);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_summary called in invalid state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;  // _send_chunked_payload_sync calls _mark_as_defunct_internal
            }

            current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);

            std::vector<uint8_t> response_payload;
            while (true) {
                err = _receive_chunked_payload_sync(response_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;  // _receive_chunked_payload_sync calls _mark_as_defunct_internal
                }
                if (!response_payload.empty()) break;
                if (logger_) logger_->trace("[ConnMsg {}] Received NOOP while awaiting summary.", id_);
            }

            boltprotocol::MessageTag tag;
            err = _peek_message_tag(response_payload, tag);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "Failed to peek tag for summary response.");  // 使用 internal
                return last_error_code_;
            }

            boltprotocol::PackStreamReader reader(response_payload);
            if (tag == boltprotocol::MessageTag::SUCCESS) {
                err = boltprotocol::deserialize_success_message(reader, out_summary);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize SUCCESS summary.");  // 使用 internal
                    return last_error_code_;
                }
                if (current_state_.load(std::memory_order_relaxed) == InternalState::AWAITING_SUMMARY) {
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                }
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
                return boltprotocol::BoltError::SUCCESS;

            } else if (tag == boltprotocol::MessageTag::FAILURE) {
                err = boltprotocol::deserialize_failure_message(reader, out_failure);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize FAILURE summary.");  // 使用 internal
                    return last_error_code_;
                }
                return _classify_and_set_server_failure(out_failure);  // This handles defunct state

            } else if (tag == boltprotocol::MessageTag::IGNORED) {
                err = boltprotocol::deserialize_ignored_message(reader);  // Assuming this exists
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize IGNORED summary.");  // 使用 internal
                    return last_error_code_;
                }
                out_failure.metadata.clear();
                out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");  // Example
                out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = boltprotocol::BoltError::UNKNOWN_ERROR;  // Or a specific IGNORED code if added
                last_error_message_ = "Operation ignored by server.";
                return boltprotocol::BoltError::UNKNOWN_ERROR;  // Treat IGNORED as an operational error for summary
            } else {
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag for summary: " + std::to_string(static_cast<int>(tag)));  // 使用 internal
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            if (!is_ready_for_queries()) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_stream called when not ready. State: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::STREAMING, std::memory_order_relaxed);

            while (true) {
                std::vector<uint8_t> response_payload;
                err = _receive_chunked_payload_sync(response_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }

                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnMsg {}] Received NOOP during stream.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                err = _peek_message_tag(response_payload, tag);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to peek tag during streaming.");  // 使用 internal
                    return last_error_code_;
                }

                if (tag == boltprotocol::MessageTag::RECORD) {
                    if (record_handler) {
                        err = record_handler(tag, response_payload, *this);
                        if (err != boltprotocol::BoltError::SUCCESS) {
                            std::string msg = "Record handler returned error: " + error::bolt_error_to_string(err);
                            _mark_as_defunct_internal(err, msg);  // 使用 internal
                            return last_error_code_;
                        }
                    } else {
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, "Received RECORD but no handler provided.");  // 使用 internal
                        return last_error_code_;
                    }
                } else if (tag == boltprotocol::MessageTag::SUCCESS) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_success_message(reader, out_summary);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize SUCCESS summary in stream.");  // 使用 internal
                        return last_error_code_;
                    }
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_.clear();
                    return boltprotocol::BoltError::SUCCESS;

                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_failure_message(reader, out_failure);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize FAILURE summary in stream.");  // 使用 internal
                        return last_error_code_;
                    }
                    return _classify_and_set_server_failure(out_failure);

                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_ignored_message(reader);  // Assuming this exists
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize IGNORED summary in stream.");  // 使用 internal
                        return last_error_code_;
                    }
                    out_failure.metadata.clear();
                    out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                    out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                    current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::UNKNOWN_ERROR;  // Or a specific IGNORED code if added
                    last_error_message_ = "Operation ignored by server.";
                    return boltprotocol::BoltError::UNKNOWN_ERROR;

                } else {
                    _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag in stream: " + std::to_string(static_cast<int>(tag)));  // 使用 internal
                    return last_error_code_;
                }
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_reset() {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT || current_s < InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] perform_reset called in unsuitable state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (logger_) logger_->debug("[ConnMsg {}] Performing RESET...", id_);
            mark_as_used();

            std::vector<uint8_t> reset_payload_bytes;
            boltprotocol::PackStreamWriter writer(reset_payload_bytes);
            boltprotocol::BoltError err = boltprotocol::serialize_reset_message(writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "RESET serialization failed.");  // 使用 internal
                return last_error_code_;
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;

            err = send_request_receive_summary(reset_payload_bytes, success_meta, failure_meta);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                current_state_.store(InternalState::READY, std::memory_order_relaxed);
                if (logger_) logger_->info("[ConnMsg {}] RESET successful. Connection is READY.", id_);
                return boltprotocol::BoltError::SUCCESS;
            } else {
                // send_request_receive_summary already handles defunct state
                if (logger_) logger_->error("[ConnMsg {}] RESET failed. Error: {}, Last Conn Error Code: {}, Msg: {}", id_, static_cast<int>(err), static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_;
            }
        }

        // ping is an alias for perform_reset
        // boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds /*timeout_placeholder*/) {
        //     if (logger_) logger_->debug("[ConnMsg {}] Pinging connection (via RESET)...", id_);
        //     return perform_reset();
        // }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ssl.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_context_setup() {
            if (!conn_config_.encryption_enabled) {
                if (logger_) logger_->debug("[ConnSSLCTX {}] SSL encryption not enabled, skipping context setup.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::TCP_CONNECTED) {
                std::string msg = "SSL context setup called but TCP not connected. Current state: " + _get_current_state_as_string();
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // 使用 internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_CONTEXT_SETUP, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLCTX {}] Setting up SSL context.", id_);

            try {
                ssl_context_sync_ = std::make_unique<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12_client);
                boost::system::error_code ec_ssl_setup;

                switch (conn_config_.resolved_encryption_strategy) {
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_none, ec_ssl_setup);
                        if (logger_ && !ec_ssl_setup) logger_->warn("[ConnSSLCTX {}] SSL configured to TRUST_ALL_CERTIFICATES (verify_none). THIS IS INSECURE.", id_);
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS:
                        ssl_context_sync_->set_default_verify_paths(ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_CUSTOM_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            if (conn_config_.trusted_certificates_pem_files.empty() && logger_) {
                                logger_->warn("[ConnSSLCTX {}] SSL configured for custom CAs but no CA certificate files provided. Verification will likely fail.", id_);
                            }
                            for (const auto& cert_path : conn_config_.trusted_certificates_pem_files) {
                                ssl_context_sync_->load_verify_file(cert_path, ec_ssl_setup);
                                if (ec_ssl_setup) {
                                    if (logger_) logger_->error("[ConnSSLCTX {}] Failed to load custom CA certificate file '{}': {}", id_, cert_path, ec_ssl_setup.message());
                                    break;
                                }
                                if (logger_) logger_->debug("[ConnSSLCTX {}] Successfully loaded custom CA certificate file: {}", id_, cert_path);
                            }
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT:
                    case config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME:
                    default:
                        std::string msg = "Invalid or unresolved encryption strategy for SSL context setup: " + std::to_string(static_cast<int>(conn_config_.resolved_encryption_strategy));
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  // 使用 internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                }

                if (ec_ssl_setup) {
                    std::string msg = "SSL context verification setup failed: " + ec_ssl_setup.message();
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                    if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                    return last_error_code_;
                }

                if (conn_config_.client_certificate_pem_file.has_value()) {
                    if (!conn_config_.client_private_key_pem_file.has_value()) {
                        std::string msg = "Client certificate provided, but client private key is missing.";
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  // 使用 internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client certificate: {}", id_, conn_config_.client_certificate_pem_file.value());
                    ssl_context_sync_->use_certificate_chain_file(conn_config_.client_certificate_pem_file.value(), ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client certificate chain file '" + conn_config_.client_certificate_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  // 使用 internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client private key: {}", id_, conn_config_.client_private_key_pem_file.value());
                    if (conn_config_.client_private_key_password.has_value() && !conn_config_.client_private_key_password.value().empty()) {
                        ssl_context_sync_->set_password_callback(
                            [pwd = conn_config_.client_private_key_password.value()](std::size_t, boost::asio::ssl::context_base::password_purpose) {
                                return pwd;
                            },
                            ec_ssl_setup);
                        if (ec_ssl_setup) {
                            std::string msg = "Failed to set password callback for client private key: " + ec_ssl_setup.message();
                            _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  // 使用 internal
                            if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    }
                    ssl_context_sync_->use_private_key_file(conn_config_.client_private_key_pem_file.value(), boost::asio::ssl::context::pem, ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client private key file '" + conn_config_.client_private_key_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  // 使用 internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }
                    if (logger_) logger_->info("[ConnSSLCTX {}] Client certificate and private key loaded successfully for mTLS.", id_);
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL context setup: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL context setup: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // 使用 internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLCTX {}] SSL context setup complete.", id_);
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/err.h>
#include <openssl/ssl.h>

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/asio/ssl/host_name_verification.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// run_with_timeout_sync_internal_hs 辅助函数保持不变 (来自上次修复)
namespace {
    template <typename AsyncOperation>
    boost::system::error_code run_with_timeout_sync_internal_hs(
        boost::asio::io_context& io_ctx, std::chrono::milliseconds timeout_duration, AsyncOperation op, std::shared_ptr<spdlog::logger> logger, uint64_t conn_id, const std::string& op_name, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>* stream_to_cancel_on_timeout = nullptr) {
        boost::system::error_code result_ec = boost::asio::error::would_block;
        std::atomic<bool> operation_completed_flag{false};

        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_ref;
                try {
                    co_await op(op_ec_ref);
                } catch (const boost::system::system_error& e) {
                    op_ec_ref = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' sys_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_ref = boost::asio::error::fault;
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_ref;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&](const boost::system::error_code& ec_timer) {
                if (ec_timer != boost::asio::error::operation_aborted) {
                    if (!operation_completed_flag.load(std::memory_order_acquire)) {
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timed out.", conn_id, op_name);
                        timed_out_flag = true;
                        result_ec = boost::asio::error::timed_out;
                        if (stream_to_cancel_on_timeout && stream_to_cancel_on_timeout->lowest_layer().is_open()) {
                            stream_to_cancel_on_timeout->lowest_layer().cancel();
                        }
                        operation_completed_flag.store(true, std::memory_order_release);
                    }
                }
            });
        }

        io_ctx.restart();
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilHS {}] io_ctx stopped during op '{}'.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {
                    result_ec = boost::asio::error::interrupted;
                }
                break;
            }
            io_ctx.poll_one();
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();
                if (io_ctx.stopped()) io_ctx.restart();
            }
        }
        timer.cancel();
        return result_ec;
    }
}  // namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_handshake() {
            if (!conn_config_.encryption_enabled) {
                if (logger_) logger_->debug("[ConnSSLHS {}] SSL encryption not enabled, skipping handshake.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::SSL_CONTEXT_SETUP) {
                std::string msg = "SSL handshake called in unexpected state: " + _get_current_state_as_string() + ". Expected SSL_CONTEXT_SETUP.";
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (!ssl_context_sync_ || !owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                std::string msg = "SSL handshake attempted without a valid SSL context or a connected TCP socket.";
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLHS {}] Performing SSL handshake for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, conn_config_.bolt_handshake_timeout_ms);

            try {
                ssl_stream_sync_ = std::make_unique<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(std::move(*owned_socket_for_sync_plain_), *ssl_context_sync_);
                owned_socket_for_sync_plain_.reset();

                if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                    if (!SSL_set_tlsext_host_name(ssl_stream_sync_->native_handle(), conn_config_.target_host.c_str())) {
                        boost::system::error_code sni_ec(static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category());
                        if (logger_) logger_->warn("[ConnSSLHS {}] Failed to set SNI extension for host {}: {}. Handshake will proceed.", id_, conn_config_.target_host, sni_ec.message());
                    } else {
                        if (logger_) logger_->trace("[ConnSSLHS {}] SNI hostname set to: {}", id_, conn_config_.target_host);
                    }
                    ssl_stream_sync_->set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
                    if (logger_) logger_->trace("[ConnSSLHS {}] Hostname verification enabled for: {}", id_, conn_config_.target_host);
                } else {
                    if (logger_) logger_->debug("[ConnSSLHS {}] Hostname verification skipped (disabled or trust_all_certs).", id_);
                }

                boost::system::error_code handshake_ec;
                auto handshake_op = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    try {
                        co_await ssl_stream_sync_->async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    } catch (const boost::system::system_error& e) {
                        op_ec_ref = e.code();
                    }
                    co_return;
                };

                handshake_ec = run_with_timeout_sync_internal_hs(io_context_ref_, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms), handshake_op, logger_, id_, "SSL Handshake", ssl_stream_sync_.get());

                if (handshake_ec) {
                    std::string msg;
                    if (handshake_ec == boost::asio::error::timed_out) {
                        msg = "SSL handshake timed out for host " + conn_config_.target_host + " after " + std::to_string(conn_config_.bolt_handshake_timeout_ms) + "ms.";
                    } else {
                        msg = "SSL handshake failed for host " + conn_config_.target_host + ": " + handshake_ec.message();
                        unsigned long openssl_err_code = ERR_get_error();
                        while (openssl_err_code != 0) {
                            char err_buf[256];
                            ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                            msg += " (OpenSSL: " + std::string(err_buf) + ")";
                            openssl_err_code = ERR_get_error();
                        }
                    }
                    _mark_as_defunct_internal(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                    if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                    return last_error_code_;
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL handshake: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL handshake: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLHS {}] SSL handshake successful for {}.", id_, conn_config_.target_host);
            return boltprotocol::BoltError::SUCCESS;
        }

        // 定义中确保第一个参数是 boost::asio::ssl::stream<boost::asio::ip::tcp::socket>&
        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket>& stream_ref, std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Performing SSL handshake async for host {} (Timeout: {}ms)...", get_id_for_logging(), conn_config_.target_host, timeout.count());
            boost::system::error_code ec;

            if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                if (!SSL_set_tlsext_host_name(stream_ref.native_handle(), conn_config_.target_host.c_str())) {
                    if (logger_) logger_->warn("[ConnSSLHSAsync {}] Failed to set SNI (async) for host {}", get_id_for_logging(), conn_config_.target_host);
                }
                stream_ref.set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
            }

            boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
            std::atomic<bool> handshake_timed_out{false};
            std::atomic<bool> handshake_completed{false};

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            if (!handshake_completed.load(std::memory_order_acquire)) {
                                handshake_timed_out.store(true, std::memory_order_release);
                                stream_ref.lowest_layer().cancel();
                                if (logger_) logger_->warn("[ConnSSLHSAsync {}] SSL handshake async timed out, lowest_layer cancelled.", get_id_for_logging());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await stream_ref.async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            handshake_completed.store(true, std::memory_order_release);
            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (handshake_timed_out.load(std::memory_order_acquire) || ec == boost::asio::error::operation_aborted) {
                    msg = "Async SSL handshake for host " + conn_config_.target_host + " timed out or was cancelled.";
                    ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async SSL handshake failed: " + ec.message();
                    unsigned long openssl_err_code = ERR_get_error();
                    while (openssl_err_code != 0) {
                        char err_buf[256];
                        ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                        msg += " (OpenSSL: " + std::string(err_buf) + ")";
                        openssl_err_code = ERR_get_error();
                    }
                }
                if (logger_) logger_->error("[ConnSSLHSAsync {}] {}", get_id_for_logging(), msg);
                mark_as_defunct_from_async(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                co_return boltprotocol::BoltError::HANDSHAKE_FAILED;
            }

            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Async SSL handshake successful.", get_id_for_logging());
            current_state_.store(InternalState::SSL_HANDSHAKEN);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _update_metadata_from_hello_success 和 _update_metadata_from_logon_success 保持不变

        void BoltPhysicalConnection::_update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_server = meta.metadata.find("server");
            if (it_server != meta.metadata.end() && std::holds_alternative<std::string>(it_server->second)) {
                server_agent_string_ = std::get<std::string>(it_server->second);
            } else {
                server_agent_string_.clear();
            }

            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                server_assigned_conn_id_ = std::get<std::string>(it_conn_id->second);
            } else {
                server_assigned_conn_id_.clear();
            }

            utc_patch_active_ = false;
            if (negotiated_bolt_version_ == boltprotocol::versions::Version(4, 3) || negotiated_bolt_version_ == boltprotocol::versions::Version(4, 4)) {
                auto it_patch = meta.metadata.find("patch_bolt");
                if (it_patch != meta.metadata.end()) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second)) {
                        auto list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second);
                        if (list_ptr) {
                            for (const auto& val : list_ptr->elements) {
                                if (std::holds_alternative<std::string>(val)) {
                                    if (std::get<std::string>(val) == "utc") {
                                        utc_patch_active_ = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (negotiated_bolt_version_ >= boltprotocol::versions::Version(5, 0)) {
                utc_patch_active_ = true;
            }

            if (logger_) logger_->debug("[ConnState {}] Metadata updated from HELLO. Server: '{}', ConnId: '{}', UTC Patch Active: {}", id_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_);
        }

        void BoltPhysicalConnection::_update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                std::string new_conn_id = std::get<std::string>(it_conn_id->second);
                if (server_assigned_conn_id_ != new_conn_id && logger_) {
                    logger_->debug("[ConnState {}] Connection ID changed by LOGON from '{}' to '{}'", id_, server_assigned_conn_id_, new_conn_id);
                }
                server_assigned_conn_id_ = new_conn_id;
            }
            if (logger_) logger_->debug("[ConnState {}] Metadata updated from LOGON. ConnId: '{}'", id_, server_assigned_conn_id_);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta) {
            std::string neo4j_code = "Unknown.Error";
            std::string message = "An unspecified error occurred on the server.";

            auto extract_string_from_map = [&](const std::string& key) -> std::optional<std::string> {
                auto it = meta.metadata.find(key);
                if (it != meta.metadata.end() && std::holds_alternative<std::string>(it->second)) {
                    return std::get<std::string>(it->second);
                }
                return std::nullopt;
            };

            if (auto code_opt = extract_string_from_map("neo4j_code")) {
                neo4j_code = *code_opt;
            } else if (auto legacy_code_opt = extract_string_from_map("code")) {
                neo4j_code = *legacy_code_opt;
            }

            if (auto msg_opt = extract_string_from_map("message")) {
                message = *msg_opt;
            }

            std::string full_error_message = "Server error: [" + neo4j_code + "] " + message;
            // 默认使用 UNKNOWN_ERROR 或 NETWORK_ERROR，因为 SERVER_FAILURE 等可能未定义
            boltprotocol::BoltError classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            InternalState next_state = InternalState::FAILED_SERVER_REPORTED;

            // 映射到已有的错误码
            if (neo4j_code.find("TransientError") != std::string::npos || neo4j_code.find("DatabaseUnavailable") != std::string::npos || neo4j_code.find("NotALeader") != std::string::npos || neo4j_code.find("ForbiddenOnReadOnlyDatabase") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::NETWORK_ERROR;  // 可重试的网络/服务问题
            } else if (neo4j_code.find("ClientError.Security") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::HANDSHAKE_FAILED;  // 安全相关问题，可视为握手/认证失败
                next_state = InternalState::DEFUNCT;
            } else if (neo4j_code.find("ClientError.Statement") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::INVALID_ARGUMENT;  // 语句错误通常是参数问题
            } else if (neo4j_code.find("ClientError.Transaction") != std::string::npos) {
                // 对于事务错误，没有非常匹配的现有通用 BoltError，使用 UNKNOWN_ERROR
                classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            }
            // 其他错误保持为 UNKNOWN_ERROR

            if (next_state == InternalState::DEFUNCT) {
                _mark_as_defunct_internal(classified_error_code, full_error_message);
            } else {
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = classified_error_code;
                last_error_message_ = full_error_message;
            }

            if (logger_) logger_->warn("[ConnState {}] Server reported failure. Code: '{}', Msg: '{}'. Classified as: {}, Next state: {}", id_, neo4j_code, message, error::bolt_error_to_string(last_error_code_), _get_current_state_as_string());
            return last_error_code_;
        }

        // _mark_as_defunct_internal, mark_as_defunct_from_async, _get_current_state_as_string,
        // is_ready_for_queries, is_defunct 保持上次修复后的状态。

        void BoltPhysicalConnection::_mark_as_defunct_internal(boltprotocol::BoltError reason, const std::string& message) {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT && last_error_code_ != boltprotocol::BoltError::SUCCESS && reason == last_error_code_) {
                if (!message.empty() && last_error_message_.find(message) == std::string::npos) {
                    last_error_message_ += "; Additional info: " + message;
                }
                if (message == last_error_message_ && reason == last_error_code_ && logger_) {
                    logger_->trace("[ConnState {}] _mark_as_defunct_internal called again with same reason and message for already defunct connection.", id_);
                }
                return;
            }
            current_state_.store(InternalState::DEFUNCT, std::memory_order_acq_rel);
            last_error_code_ = reason;
            last_error_message_ = message;
            if (logger_) {
                logger_->error("[ConnState {}] Marked as DEFUNCT. Reason: {} ({}), Message: {}", id_, static_cast<int>(reason), error::bolt_error_to_string(reason), message);
            }
        }

        void BoltPhysicalConnection::mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) {
            _mark_as_defunct_internal(reason, message);
        }

        std::string BoltPhysicalConnection::_get_current_state_as_string() const {
            switch (current_state_.load(std::memory_order_relaxed)) {
                case InternalState::FRESH:
                    return "FRESH";
                case InternalState::TCP_CONNECTING:
                    return "TCP_CONNECTING";
                case InternalState::ASYNC_TCP_CONNECTING:
                    return "ASYNC_TCP_CONNECTING";
                case InternalState::TCP_CONNECTED:
                    return "TCP_CONNECTED";
                case InternalState::SSL_CONTEXT_SETUP:
                    return "SSL_CONTEXT_SETUP";
                case InternalState::SSL_HANDSHAKING:
                    return "SSL_HANDSHAKING";
                case InternalState::ASYNC_SSL_HANDSHAKING:
                    return "ASYNC_SSL_HANDSHAKING";
                case InternalState::SSL_HANDSHAKEN:
                    return "SSL_HANDSHAKEN";
                case InternalState::BOLT_HANDSHAKING:
                    return "BOLT_HANDSHAKING";
                case InternalState::ASYNC_BOLT_HANDSHAKING:
                    return "ASYNC_BOLT_HANDSHAKING";
                case InternalState::BOLT_HANDSHAKEN:
                    return "BOLT_HANDSHAKEN";
                case InternalState::ASYNC_BOLT_HANDSHAKEN:
                    return "ASYNC_BOLT_HANDSHAKEN";
                case InternalState::HELLO_AUTH_SENT:
                    return "HELLO_AUTH_SENT";
                case InternalState::ASYNC_HELLO_AUTH_SENT:
                    return "ASYNC_HELLO_AUTH_SENT";
                case InternalState::READY:
                    return "READY";
                case InternalState::ASYNC_READY:
                    return "ASYNC_READY";
                case InternalState::STREAMING:
                    return "STREAMING";
                case InternalState::ASYNC_STREAMING:
                    return "ASYNC_STREAMING";
                case InternalState::AWAITING_SUMMARY:
                    return "AWAITING_SUMMARY";
                case InternalState::ASYNC_AWAITING_SUMMARY:
                    return "ASYNC_AWAITING_SUMMARY";
                case InternalState::FAILED_SERVER_REPORTED:
                    return "FAILED_SERVER_REPORTED";
                case InternalState::DEFUNCT:
                    return "DEFUNCT";
                default:
                    return "UNKNOWN_STATE_" + std::to_string(static_cast<int>(current_state_.load(std::memory_order_relaxed)));
            }
        }

        bool BoltPhysicalConnection::is_ready_for_queries() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                return false;
            }
            if (current_s == InternalState::READY) {
                if (conn_config_.encryption_enabled) {
                    return ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                } else {
                    return plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                }
            }
            if (current_s == InternalState::ASYNC_READY) {
                return true;
            }
            return false;
        }

        bool BoltPhysicalConnection::is_defunct() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT) {
                return true;
            }
            if (current_s > InternalState::FRESH && current_s < InternalState::DEFUNCT) {
                if (current_s != InternalState::ASYNC_TCP_CONNECTING && current_s != InternalState::ASYNC_SSL_HANDSHAKING && current_s != InternalState::ASYNC_BOLT_HANDSHAKING && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::ASYNC_READY &&
                    current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                    if (conn_config_.encryption_enabled) {
                        if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                            return true;
                        }
                    } else {
                        if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_send_chunked_payload_sync(const std::vector<uint8_t>& payload) {
            if (is_defunct()) return last_error_code_;

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);

                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                err = _write_to_active_sync_stream(data_ptr, chunk_size);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&zero_chunk_be), boltprotocol::CHUNK_HEADER_SIZE);
            }
            // _write_to_active_sync_stream calls _mark_as_defunct_internal if needed
            return err;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_receive_chunked_payload_sync(std::vector<uint8_t>& out_payload) {
            out_payload.clear();
            if (is_defunct()) return last_error_code_;

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (true) {
                uint16_t chunk_size_be = 0;
                size_t bytes_read_header = 0;
                err = _read_from_active_sync_stream(reinterpret_cast<uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE, bytes_read_header);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }

                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Received chunk larger than max allowed size: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct_internal(err, msg);  // 使用 internal 版本
                    if (logger_) logger_->error("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t current_payload_offset = out_payload.size();
                try {
                    out_payload.resize(current_payload_offset + chunk_payload_size);
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory resizing payload buffer for chunk.";
                    _mark_as_defunct_internal(err, msg);  // 使用 internal 版本
                    if (logger_) logger_->critical("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t bytes_read_payload = 0;
                err = _read_from_active_sync_stream(out_payload.data() + current_payload_offset, chunk_payload_size, bytes_read_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (total_bytes_read_for_message == 0 && out_payload.empty()) {
                if (logger_) logger_->trace("[ConnSyncChunking {}] Received NOOP message (empty payload from chunks).", id_);
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_write_to_active_sync_stream(const uint8_t* data, size_t size) {
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Write attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            boost::system::error_code ec;
            size_t bytes_written = 0;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Write {} bytes", id_, size);
                    bytes_written = boost::asio::write(*ssl_stream_sync_, boost::asio::buffer(data, size), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Write {} bytes via iostream", id_, size);
                    plain_iostream_wrapper_->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
                    if (plain_iostream_wrapper_->fail()) {
                        int stream_errno = errno;
                        ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EPIPE, boost::system::system_category());
                    } else {
                        bytes_written = size;
                        plain_iostream_wrapper_->flush();
                        if (plain_iostream_wrapper_->fail()) {
                            int stream_errno_flush = errno;
                            ec = boost::system::error_code(stream_errno_flush != 0 ? stream_errno_flush : EPIPE, boost::system::system_category());
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync write: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync write: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg = "Sync write to stream failed: " + ec.message();
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_written != size) {
                std::string msg = "Partial sync write to stream. Expected " + std::to_string(size) + ", wrote " + std::to_string(bytes_written);
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read) {
            bytes_read = 0;
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Read attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (size_to_read == 0) return boltprotocol::BoltError::SUCCESS;

            boost::system::error_code ec;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Read {} bytes", id_, size_to_read);
                    bytes_read = boost::asio::read(*ssl_stream_sync_, boost::asio::buffer(buffer, size_to_read), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Read {} bytes via iostream", id_, size_to_read);
                    plain_iostream_wrapper_->read(reinterpret_cast<char*>(buffer), static_cast<std::streamsize>(size_to_read));
                    bytes_read = static_cast<size_t>(plain_iostream_wrapper_->gcount());

                    if (bytes_read < size_to_read) {
                        if (plain_iostream_wrapper_->eof()) {
                            ec = boost::asio::error::eof;
                        } else if (plain_iostream_wrapper_->fail()) {
                            int stream_errno = errno;
                            ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                        } else {
                            ec = boost::asio::error::fault;
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync read: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync read: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg;
                if (ec == boost::asio::error::eof) {
                    msg = "Sync read from stream failed: EOF reached prematurely. Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                } else {
                    msg = "Sync read from stream failed: " + ec.message() + ". Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                }
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_read < size_to_read) {
                std::string msg = "Incomplete sync read from stream. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(bytes_read) + ". No specific stream error reported.";
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <thread>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// run_sync_op_with_timeout_tcp 辅助函数保持不变 (来自上次修复)
namespace {
    template <typename AsyncOperation>
    boost::system::error_code run_sync_op_with_timeout_tcp(
        boost::asio::io_context& io_ctx, std::chrono::milliseconds timeout_duration, AsyncOperation op, std::shared_ptr<spdlog::logger> logger, uint64_t conn_id, const std::string& op_name, boost::asio::ip::tcp::socket* socket_to_cancel_on_timeout) {
        boost::system::error_code result_ec = boost::asio::error::would_block;
        std::atomic<bool> operation_completed_flag{false};

        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_local;
                try {
                    co_await op(op_ec_local);
                } catch (const boost::system::system_error& e) {
                    op_ec_local = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_local = boost::asio::error::fault;
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_local;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&, logger, conn_id, op_name, socket_to_cancel_on_timeout](const boost::system::error_code& ec_timer) {
                if (ec_timer != boost::asio::error::operation_aborted) {
                    if (!operation_completed_flag.load(std::memory_order_acquire)) {
                        if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timed out.", conn_id, op_name);
                        timed_out_flag = true;
                        result_ec = boost::asio::error::timed_out;
                        if (socket_to_cancel_on_timeout && socket_to_cancel_on_timeout->is_open()) {
                            socket_to_cancel_on_timeout->cancel();
                        }
                        operation_completed_flag.store(true, std::memory_order_release);
                    }
                }
            });
        }

        io_ctx.restart();
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilTCP {}] io_context stopped during op '{}' before completion.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {
                    result_ec = boost::asio::error::interrupted;
                }
                break;
            }
            io_ctx.poll_one();
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();
                if (io_ctx.stopped()) io_ctx.restart();
            }
        }
        timer.cancel();
        return result_ec;
    }
}  // namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_tcp_connect() {
            if (plain_iostream_wrapper_) plain_iostream_wrapper_.reset();
            if (ssl_stream_sync_) ssl_stream_sync_.reset();
            if (owned_socket_for_sync_plain_ && owned_socket_for_sync_plain_->is_open()) {
                boost::system::error_code ignored_ec;
                try {
                    owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
                    owned_socket_for_sync_plain_->close(ignored_ec);
                } catch (...) {
                }
            }
            owned_socket_for_sync_plain_ = std::make_unique<boost::asio::ip::tcp::socket>(io_context_ref_);

            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, conn_config_.tcp_connect_timeout_ms);

            boost::system::error_code ec;
            try {
                boost::asio::ip::tcp::resolver resolver(io_context_ref_);
                boost::asio::ip::tcp::resolver::results_type endpoints = resolver.resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), ec);

                if (ec) {
                    std::string msg = "DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }
                if (endpoints.empty()) {
                    std::string msg = "DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                auto connect_op_lambda = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    co_await boost::asio::async_connect(*owned_socket_for_sync_plain_, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    co_return;
                };

                ec = run_sync_op_with_timeout_tcp(io_context_ref_, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms), connect_op_lambda, logger_, id_, "Sync TCP Connect", owned_socket_for_sync_plain_.get());

                if (ec) {
                    std::string msg;
                    if (ec == boost::asio::error::timed_out) {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out after " + std::to_string(conn_config_.tcp_connect_timeout_ms) + "ms.";
                    } else {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                    }
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                if (conn_config_.socket_keep_alive_enabled) {
                    boost::system::error_code keep_alive_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                    if (keep_alive_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                    }
                }
                if (conn_config_.tcp_no_delay_enabled) {
                    boost::system::error_code no_delay_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                    if (no_delay_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                    }
                }

                if (!conn_config_.encryption_enabled) {
                    if (!owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Socket not open for plain stream wrapper after connect.");  // 使用 internal
                        if (logger_) logger_->error("[ConnTCP {}] Socket not open for plain iostream wrapper post-connect.", id_);
                        return last_error_code_;
                    }
                    try {
                        plain_iostream_wrapper_ = std::make_unique<boost::asio::ip::tcp::iostream>(std::move(*owned_socket_for_sync_plain_));
                        owned_socket_for_sync_plain_.reset();
                        if (!plain_iostream_wrapper_->good()) {
                            std::string msg = "Failed to initialize plain iostream wrapper after TCP connect (stream not good).";
                            _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                            if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    } catch (const std::exception& e) {
                        std::string msg = "Exception creating plain iostream wrapper: " + std::string(e.what());
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                        if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                        return last_error_code_;
                    }
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用 internal
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // 使用 internal
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP Connecting to {}:{} (Timeout: {}ms)", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port, timeout.count());

            boost::system::error_code ec;
            boost::asio::ip::tcp::resolver resolver(socket.get_executor());

            auto endpoints = co_await resolver.async_resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            if (ec) {
                std::string msg = "Async DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用异步版本
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }
            if (endpoints.empty()) {
                std::string msg = "Async DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用异步版本
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            boost::asio::steady_timer timer(socket.get_executor());
            bool timed_out = false;

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    socket.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            timed_out = true;
                            socket.cancel();
                            if (logger_) logger_->trace("[ConnTCPAsync {}] Connect op socket cancel called due to timeout.", get_id_for_logging());
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await boost::asio::async_connect(socket, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, ec));

            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (timed_out || ec == boost::asio::error::operation_aborted) {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out or was cancelled.";
                    if (timed_out) ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                }
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 使用异步版本
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (conn_config_.socket_keep_alive_enabled) {
                boost::system::error_code keep_alive_ec;
                socket.set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                if (keep_alive_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set SO_KEEPALIVE: {}", get_id_for_logging(), keep_alive_ec.message());
                }
            }
            if (conn_config_.tcp_no_delay_enabled) {
                boost::system::error_code no_delay_ec;
                socket.set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                if (no_delay_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set TCP_NODELAY: {}", get_id_for_logging(), no_delay_ec.message());
                }
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP connection established to {}:{}.", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 调试用

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {

    // Static private helper method definition
    std::string Neo4jBoltTransport::_make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string db_part = database_name.empty() ? "system" : database_name;
        if (impersonated_user && !impersonated_user->empty()) {
            return db_part + "@" + *impersonated_user;
        }
        return db_part;
    }

    Neo4jBoltTransport::Neo4jBoltTransport(config::TransportConfig a_config) : config_(std::move(a_config)) {
        if (!config_.logger) {
            config_.logger = config_.get_or_create_logger();
            if (!config_.logger) {
                std::cerr << "CRITICAL ERROR: Logger creation/retrieval failed during Neo4jBoltTransport initialization!" << std::endl;
                throw std::runtime_error("Logger initialization failed for Neo4jBoltTransport.");
            }
        }

        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initializing with URI: '{}'", config_.uri_string);

        if (uri::UriParser::parse(config_.uri_string, parsed_initial_uri_) != boltprotocol::BoltError::SUCCESS) {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty()) {
                if (config_.logger) config_.logger->error("[TransportLC] URI '{}' parsing failed and no initial router override provided. Routing may not work.", config_.uri_string);
            } else if (config_.logger) {
                config_.logger->warn("[TransportLC] URI '{}' parsing failed, but routing is disabled or initial router override is provided.", config_.uri_string);
            }
        } else {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty() && parsed_initial_uri_.is_routing_scheme && !parsed_initial_uri_.hosts_with_ports.empty()) {
                std::vector<routing::ServerAddress> initial_routers_from_uri;
                for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                    initial_routers_from_uri.emplace_back(hp.first, hp.second);
                }
                std::string default_context_key = _make_routing_context_key("", std::nullopt);
                config_.initial_router_addresses_override[default_context_key] = initial_routers_from_uri;
                if (config_.logger) config_.logger->info("[TransportLC] Set {} initial routers from URI for context '{}'.", initial_routers_from_uri.size(), default_context_key);
            }
        }

        config_.prepare_agent_strings();
        finalized_user_agent_ = config_.user_agent_override.empty() ? config_.bolt_agent_info.product : config_.user_agent_override;
        finalized_bolt_agent_info_ = config_.bolt_agent_info;

        if (io_context_.stopped()) {
            io_context_.restart();
        }
        work_guard_ = std::make_unique<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(boost::asio::make_work_guard(io_context_));

        if (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0) {
            eviction_timer_ = std::make_unique<boost::asio::steady_timer>(io_context_);

            uint32_t first_eviction_delay_ms = 10000;
            if (config_.idle_timeout_ms > 0) {
                first_eviction_delay_ms = config_.idle_timeout_ms / 2;
            } else if (config_.max_connection_lifetime_ms > 0) {
                first_eviction_delay_ms = config_.max_connection_lifetime_ms / 4;
            }
            first_eviction_delay_ms = std::max(1000u, first_eviction_delay_ms);

            eviction_timer_->expires_after(std::chrono::milliseconds(first_eviction_delay_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec_lambda) {
                if (ec_lambda != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->info("[TransportLC] Connection eviction task scheduled in {}ms.", first_eviction_delay_ms);
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initialized.");
    }

    Neo4jBoltTransport::~Neo4jBoltTransport() {
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destructing.");
        close();
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destruction complete.");
    }

    void Neo4jBoltTransport::close() {
        bool already_closing = closing_.exchange(true);
        if (already_closing) {
            if (config_.logger) config_.logger->debug("[TransportLC] Close already called or in progress.");
            return;
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closing...");

        if (eviction_timer_) {
            try {
                std::size_t cancelled_count = eviction_timer_->cancel();  // No error_code parameter
                if (config_.logger) {
                    config_.logger->trace("[TransportLC] Eviction timer cancelled {} pending operations.", cancelled_count);
                }
            } catch (const boost::system::system_error& e) {
                if (config_.logger) {
                    config_.logger->warn("[TransportLC] Exception during eviction_timer_.cancel(): {}", e.what());
                }
            }
            eviction_timer_.reset();
            if (config_.logger) config_.logger->trace("[TransportLC] Eviction timer reset.");
        }

        {
            std::lock_guard<std::mutex> lock(pool_mutex_);
            if (config_.logger) config_.logger->debug("[TransportLC] Terminating {} idle connections.", idle_connections_.size());
            for (auto& conn_ptr : idle_connections_) {
                if (conn_ptr) {
                    conn_ptr->terminate(true);
                }
            }
            idle_connections_.clear();
            total_connections_currently_pooled_ = 0;
        }
        pool_condition_.notify_all();

        {
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            routing_tables_.clear();
            if (config_.logger) config_.logger->debug("[TransportLC] Routing tables cleared.");
        }

        if (work_guard_) {
            work_guard_->reset();
        }
        if (!io_context_.stopped()) {
            io_context_.stop();
        }

        if (own_io_thread_ && io_thread_ && io_thread_->joinable()) {
            if (config_.logger) config_.logger->debug("[TransportLC] Joining IO thread...");
            try {
                io_thread_->join();
                if (config_.logger) config_.logger->debug("[TransportLC] IO thread joined.");
            } catch (const std::system_error& e) {
                if (config_.logger) config_.logger->error("[TransportLC] Error joining IO thread: {}", e.what());
            }
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closed.");
    }

    boltprotocol::BoltError Neo4jBoltTransport::verify_connectivity() {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[TransportVerify] Attempting to verify connectivity on a closing transport.");
            return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Verifying connectivity...");

        routing::ServerAddress address_to_verify;
        bool use_routing_for_verify = config_.client_side_routing_enabled && (parsed_initial_uri_.scheme != "bolt" && parsed_initial_uri_.scheme != "bolt+s" && parsed_initial_uri_.scheme != "bolt+ssc");

        if (use_routing_for_verify) {
            auto [addr_err, router_addr] = _get_server_address_for_session(config::SessionParameters{}.with_database("system"), routing::ServerRole::ROUTER);
            if (addr_err != boltprotocol::BoltError::SUCCESS || router_addr.host.empty()) {
                if (config_.logger) config_.logger->warn("[TransportVerify] Failed to get a router address for verification. Error: {}. Falling back to initial URI if possible.", neo4j_bolt_transport::error::bolt_error_to_string(addr_err));
                if (!parsed_initial_uri_.hosts_with_ports.empty()) {
                    const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
                    address_to_verify = routing::ServerAddress(hp.first, hp.second);
                    if (config_.logger) config_.logger->debug("[TransportVerify] Using direct address from URI for verification: {}", address_to_verify.to_string());
                } else {
                    if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No router available and no direct address in URI.");
                    return boltprotocol::BoltError::NETWORK_ERROR;
                }
            } else {
                address_to_verify = router_addr;
            }
        } else {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No direct address in URI for non-routing scheme.");
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
            address_to_verify = routing::ServerAddress(hp.first, hp.second);
        }

        if (address_to_verify.host.empty()) {
            if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: Final address to verify is empty.");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        routing::ServerAddress resolved_address_to_verify = address_to_verify;
        if (config_.server_address_resolver) {
            resolved_address_to_verify = config_.server_address_resolver(address_to_verify);
        }

        if (config_.logger) config_.logger->debug("[TransportVerify] Attempting to acquire connection to {} (resolved from {}) for verification.", resolved_address_to_verify.to_string(), address_to_verify.to_string());

        auto [conn_err, conn] = _acquire_pooled_connection(resolved_address_to_verify, std::nullopt);

        if (conn_err != boltprotocol::BoltError::SUCCESS || !conn) {
            if (config_.logger) config_.logger->error("[TransportVerify] Failed to acquire connection to {} for verification. Error: {}", resolved_address_to_verify.to_string(), neo4j_bolt_transport::error::bolt_error_to_string(conn_err));
            return conn_err;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Connectivity to {} verified successfully (connection {} acquired).", resolved_address_to_verify.to_string(), conn->get_id());
        release_connection(std::move(conn), true);
        return boltprotocol::BoltError::SUCCESS;
    }

    internal::BoltConnectionConfig Neo4jBoltTransport::_create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const {
        internal::BoltConnectionConfig physical_conf;
        physical_conf.target_host = target_address.host;
        physical_conf.target_port = target_address.port;
        physical_conf.auth_token = config_.auth_token;
        physical_conf.user_agent_for_hello = finalized_user_agent_;
        physical_conf.bolt_agent_info_for_hello = finalized_bolt_agent_info_;

        physical_conf.resolved_encryption_strategy = config_.encryption_strategy;
        if (config_.encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT) {
            physical_conf.encryption_enabled = true;
            physical_conf.trusted_certificates_pem_files = config_.trusted_certificates_pem_files;
            physical_conf.client_certificate_pem_file = config_.client_certificate_pem_file;
            physical_conf.client_private_key_pem_file = config_.client_private_key_pem_file;
            physical_conf.client_private_key_password = config_.client_private_key_password;
            physical_conf.hostname_verification_enabled = config_.hostname_verification_enabled;
        } else {
            physical_conf.encryption_enabled = false;
        }

        physical_conf.tcp_connect_timeout_ms = config_.tcp_connect_timeout_ms;
        physical_conf.socket_read_timeout_ms = config_.socket_read_timeout_ms;
        physical_conf.socket_write_timeout_ms = config_.socket_write_timeout_ms;
        physical_conf.socket_keep_alive_enabled = config_.tcp_keep_alive_enabled;
        physical_conf.tcp_no_delay_enabled = config_.tcp_no_delay_enabled;
        physical_conf.bolt_handshake_timeout_ms = config_.hello_timeout_ms;  // Note: This was hello_timeout_ms, perhaps should be a dedicated handshake_timeout_ms in TransportConfig?
        physical_conf.hello_timeout_ms = config_.hello_timeout_ms;
        physical_conf.goodbye_timeout_ms = config_.goodbye_timeout_ms;

        if (routing_context_for_hello.has_value()) {
            physical_conf.hello_routing_context = routing_context_for_hello;
        }

        if (!config_.preferred_bolt_versions.empty()) {
            physical_conf.preferred_bolt_versions = config_.preferred_bolt_versions;
        }

        if (config_.logger) {
            std::string preferred_versions_str = "default";
            if (physical_conf.preferred_bolt_versions.has_value() && !physical_conf.preferred_bolt_versions->empty()) {
                preferred_versions_str.clear();
                for (const auto& v : physical_conf.preferred_bolt_versions.value()) {
                    preferred_versions_str += v.to_string() + " ";
                }
            }
            config_.logger->trace("[TransportLC] Created physical connection config: Host={}, Port={}, Enc={}, Strategy={}, ReadTimeout={}, WriteTimeout={}, HelloTimeout={}, TCPNoDelay={}, HelloRoutingCtx={}, PreferredBoltVersions=[{}]",
                                  physical_conf.target_host,
                                  physical_conf.target_port,
                                  physical_conf.encryption_enabled,
                                  static_cast<int>(physical_conf.resolved_encryption_strategy),
                                  physical_conf.socket_read_timeout_ms,
                                  physical_conf.socket_write_timeout_ms,
                                  physical_conf.hello_timeout_ms,
                                  physical_conf.tcp_no_delay_enabled,
                                  physical_conf.hello_routing_context.has_value() ? "Yes" : "No",
                                  preferred_versions_str);
        }
        return physical_conf;
    }

}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _acquire_pooled_connection: 从池中获取或创建一个到 *特定已知地址* 的连接。
    // 路由选择逻辑在此函数之前完成。
    std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> Neo4jBoltTransport::_acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint /*用于日志和未来可能的优化*/) {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[PoolCore] 尝试在关闭的 transport 上获取到 {} 的连接。", target_address.to_string());
            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
        }

        std::unique_lock<std::mutex> lock(pool_mutex_);
        auto start_time = std::chrono::steady_clock::now();

        while (true) {
            // 1. 尝试从空闲连接中查找一个到 target_address 的可用连接
            for (auto it = idle_connections_.begin(); it != idle_connections_.end(); /* manual increment */) {
                internal::BoltPhysicalConnection::PooledConnection& conn_ptr_ref = *it;

                if (conn_ptr_ref->get_config().target_host == target_address.host && conn_ptr_ref->get_config().target_port == target_address.port) {
                    internal::BoltPhysicalConnection::PooledConnection conn_to_check = std::move(conn_ptr_ref);
                    it = idle_connections_.erase(it);  // 从池中移除
                    total_connections_currently_pooled_--;

                    bool healthy = true;
                    std::string unhealthy_reason;

                    if (conn_to_check->is_defunct()) {
                        healthy = false;
                        unhealthy_reason = "is_defunct";
                    } else if (config_.max_connection_lifetime_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms))) {
                        healthy = false;
                        unhealthy_reason = "exceeded max lifetime";
                    } else if (config_.idle_time_before_health_check_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_time_before_health_check_ms))) {
                        if (config_.logger) config_.logger->trace("[PoolCore] 空闲连接 {} (到 {}) 需要健康检查 (ping)。", conn_to_check->get_id(), target_address.to_string());

                        lock.unlock();
                        boltprotocol::BoltError ping_err = conn_to_check->ping(std::chrono::milliseconds(config_.tcp_connect_timeout_ms));
                        lock.lock();

                        if (closing_.load(std::memory_order_acquire)) {
                            if (config_.logger) config_.logger->warn("[PoolCore] Ping 后 transport 关闭。");
                            if (conn_to_check) conn_to_check->terminate(false);
                            total_connections_ever_created_--;
                            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                        }

                        if (ping_err != boltprotocol::BoltError::SUCCESS) {
                            healthy = false;
                            unhealthy_reason = "ping failed (" + error::bolt_error_to_string(ping_err) + ")";
                        } else {
                            if (config_.logger) config_.logger->trace("[PoolCore] 空闲连接 {} (到 {}) ping 成功。", conn_to_check->get_id(), target_address.to_string());
                        }
                    }

                    if (healthy) {
                        if (config_.logger) config_.logger->debug("[PoolCore] 复用空闲连接 {} 到 {} (数据库提示: '{}')", conn_to_check->get_id(), target_address.to_string(), database_name_hint.value_or("<无>"));
                        conn_to_check->mark_as_used();
                        return {boltprotocol::BoltError::SUCCESS, std::move(conn_to_check)};
                    } else {
                        if (config_.logger) config_.logger->info("[PoolCore] 终止过时/不健康的空闲连接 {} (到 {}) (原因: {}).", (conn_to_check ? conn_to_check->get_id() : 0), target_address.to_string(), unhealthy_reason);
                        if (conn_to_check) conn_to_check->terminate(false);
                        total_connections_ever_created_--;
                        // 继续在 idle_connections_ 中查找 (迭代器已通过 erase 更新)
                        // it = idle_connections_.erase(it) 已经移动了迭代器，所以不需要 it++
                        continue;
                    }
                }
                ++it;  // 检查下一个空闲连接
            }

            // 2. 如果池中没有到 target_address 的合适连接，并且池未满，则创建新连接
            if (total_connections_ever_created_ < config_.max_connection_pool_size) {
                std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_ctx_opt;
                if (config_.client_side_routing_enabled) {
                    std::map<std::string, boltprotocol::Value> ctx_map;
                    ctx_map["address"] = target_address.to_string();  // HELLO 上下文是目标地址
                    hello_routing_ctx_opt = ctx_map;
                }

                internal::BoltConnectionConfig physical_conn_conf = _create_physical_connection_config(target_address, hello_routing_ctx_opt);
                std::shared_ptr<spdlog::logger> conn_logger = config_.get_or_create_logger("BoltConnection");

                lock.unlock();
                if (config_.logger) config_.logger->debug("[PoolCore] 创建到 {} 的新连接 (数据库提示: '{}')", target_address.to_string(), database_name_hint.value_or("<无>"));

                auto new_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(physical_conn_conf), io_context_, conn_logger);
                boltprotocol::BoltError establish_err = new_conn->establish();
                lock.lock();

                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] Transport 在新连接建立期间关闭。");
                    if (new_conn) new_conn->terminate(false);
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }

                if (establish_err == boltprotocol::BoltError::SUCCESS) {
                    if (config_.logger) config_.logger->info("[PoolCore] 到 {} 的新连接 {} 已建立。", target_address.to_string(), new_conn->get_id());
                    total_connections_ever_created_++;
                    new_conn->mark_as_used();
                    return {boltprotocol::BoltError::SUCCESS, std::move(new_conn)};
                } else {
                    if (config_.logger) config_.logger->error("[PoolCore] 无法建立到 {} 的新连接。错误: {} ({})", target_address.to_string(), static_cast<int>(establish_err), new_conn ? new_conn->get_last_error_message() : error::bolt_error_to_string(establish_err));
                    // 连接失败不应该直接在这里处理路由表，因为此函数只负责连接到 *给定* 地址。
                    // 调用此函数的上层（例如路由逻辑）应该处理地址不可达的情况。
                    return {establish_err, nullptr};
                }
            }

            // 3. 如果池已满，等待
            auto time_waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time);
            auto remaining_timeout_ms = std::chrono::milliseconds(config_.connection_acquisition_timeout_ms) - time_waited;

            if (remaining_timeout_ms <= std::chrono::milliseconds(0)) {
                if (config_.logger) config_.logger->error("[PoolCore] 等待到 {} 的连接超时 (最大池大小: {})。", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // TODO: 更具体的超时错误码
            }

            if (config_.logger) {
                config_.logger->trace("[PoolCore] 池已满 ({}/{})，等待 {}ms 获取到 {} 的连接。",
                                      total_connections_ever_created_,
                                      config_.max_connection_pool_size,  // 使用 ever_created 作为当前“正在使用或空闲”的总数上限
                                      remaining_timeout_ms.count(),
                                      target_address.to_string());
            }

            if (pool_condition_.wait_for(lock, remaining_timeout_ms, [this] {
                    return closing_.load(std::memory_order_relaxed) || !idle_connections_.empty();  // 等待有任何空闲连接或关闭
                })) {
                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] 等待期间 transport 关闭。");
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
                if (config_.logger) config_.logger->trace("[PoolCore] 被唤醒，可能有空闲连接或 transport 关闭。");
            } else {
                if (config_.logger) config_.logger->error("[PoolCore] 等待到 {} 的连接在 wait_for 后超时 (最大池大小: {})。", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // 超时
            }
            // 继续循环
        }
    }

    void Neo4jBoltTransport::release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy) {
        if (!connection) return;

        bool transport_is_closing = closing_.load(std::memory_order_acquire);
        uint64_t conn_id = connection->get_id();
        routing::ServerAddress conn_target(connection->get_config().target_host, connection->get_config().target_port);

        if (transport_is_closing) {
            if (config_.logger) config_.logger->debug("[PoolCore] 在 transport 关闭期间释放连接 {} (到 {}), 将其终止。", conn_id, conn_target.to_string());
            connection->terminate(false);  // 不发送 GOODBYE
            // total_connections_ever_created_ 应该在这里减少，因为这个连接不再存在于系统中。
            // 加锁是为了保护 total_connections_ever_created_
            std::lock_guard<std::mutex> lock(pool_mutex_);
            total_connections_ever_created_ = std::max(0, (int)total_connections_ever_created_ - 1);  // 确保不为负
            return;
        }

        std::lock_guard<std::mutex> lock(pool_mutex_);

        if (!mark_as_healthy || connection->is_defunct()) {
            if (config_.logger) config_.logger->info("[PoolCore] 释放不健康/失效的连接 {} (到 {}), 将其终止。健康标记: {}, 失效: {}", conn_id, conn_target.to_string(), mark_as_healthy, connection->is_defunct());
            connection->terminate(false);
            total_connections_ever_created_--;
            pool_condition_.notify_one();
            return;
        }

        bool should_retire_due_to_age = false;
        if (config_.max_connection_lifetime_ms > 0) {
            auto age = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - connection->get_creation_timestamp());
            if (age.count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                should_retire_due_to_age = true;
                if (config_.logger) config_.logger->info("[PoolCore] 连接 {} (到 {}) 因达到最大生命周期而淘汰。", conn_id, conn_target.to_string());
            }
        }

        // 如果空闲连接数已达到池上限（max_connection_pool_size 通常指总连接数，但这里也可理解为空闲连接上限）
        // 或者连接已老化，则关闭此连接
        // 注意：max_connection_pool_size 应该与 total_connections_ever_created_ 比较。
        // total_connections_currently_pooled_ 是当前空闲的连接数。
        if (should_retire_due_to_age || total_connections_currently_pooled_ >= config_.max_connection_pool_size) {
            if (config_.logger) config_.logger->debug("[PoolCore] 终止连接 {} (到 {})。淘汰: {}, 当前空闲: {}, 配置池大小(上限): {}", conn_id, conn_target.to_string(), should_retire_due_to_age, total_connections_currently_pooled_, config_.max_connection_pool_size);
            connection->terminate(true);  // 发送 GOODBYE
            total_connections_ever_created_--;
            pool_condition_.notify_one();
        } else {
            if (config_.logger) config_.logger->debug("[PoolCore] 将连接 {} (到 {}) 返回到空闲池。当前空闲池大小: {}", conn_id, conn_target.to_string(), total_connections_currently_pooled_);
            connection->mark_as_used();  // 更新最后使用时间戳
            idle_connections_.push_back(std::move(connection));
            total_connections_currently_pooled_++;
            pool_condition_.notify_one();
        }
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::remove_if
#include <chrono>
#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 虽然这里可能不需要，但保持一致性
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    void Neo4jBoltTransport::_evict_stale_connections_task() {
        if (closing_.load(std::memory_order_acquire)) return;

        if (config_.logger) config_.logger->trace("[PoolEvictor] 开始检查过期的空闲连接...");

        std::unique_lock<std::mutex> lock(pool_mutex_);
        if (closing_.load(std::memory_order_acquire)) return;  // 再次检查，因为获取锁可能耗时

        auto now = std::chrono::steady_clock::now();
        int evicted_count = 0;

        auto it_remove = std::remove_if(idle_connections_.begin(), idle_connections_.end(), [&](const internal::BoltPhysicalConnection::PooledConnection& conn_ptr) {
            if (!conn_ptr) return true;  // 防御性编程

            bool evict = false;
            std::string reason;
            routing::ServerAddress conn_target(conn_ptr->get_config().target_host, conn_ptr->get_config().target_port);

            if (config_.max_connection_lifetime_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                    evict = true;
                    reason = "达到最大生命周期";
                }
            }
            if (!evict && config_.idle_timeout_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_timeout_ms)) {
                    evict = true;
                    reason = "空闲超时";
                }
            }
            if (!evict && conn_ptr->is_defunct()) {  // 安全检查，理论上不应在池中
                evict = true;
                reason = "在池中发现失效连接";
            }

            if (evict) {
                if (config_.logger) config_.logger->info("[PoolEvictor] 驱逐连接 {} (到 {}) 原因: {}.", conn_ptr->get_id(), conn_target.to_string(), reason);
                conn_ptr->terminate(false);  // 终止，不发送 GOODBYE
                return true;                 // 标记为移除
            }
            return false;  // 保留
        });

        evicted_count = std::distance(it_remove, idle_connections_.end());
        if (evicted_count > 0) {
            idle_connections_.erase(it_remove, idle_connections_.end());
            total_connections_currently_pooled_ -= evicted_count;
            total_connections_ever_created_ -= evicted_count;
            if (config_.logger) config_.logger->debug("[PoolEvictor] 驱逐了 {} 个连接。当前空闲: {}. 总创建数: {}", evicted_count, total_connections_currently_pooled_, total_connections_ever_created_);
            pool_condition_.notify_all();  // 通知可能因池满而等待的线程
        }
        lock.unlock();  // 手动解锁

        // 重新调度驱逐任务 (如果 transport 未关闭)
        if (!closing_.load(std::memory_order_acquire) && eviction_timer_ && (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0)) {
            // 计算下一个合理的检查时间，例如最短超时的一半，但不小于1秒
            uint32_t next_check_interval_ms = 10000;  // 默认10秒
            if (config_.idle_timeout_ms > 0 && config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = std::min(config_.idle_timeout_ms, config_.max_connection_lifetime_ms);
            } else if (config_.idle_timeout_ms > 0) {
                next_check_interval_ms = config_.idle_timeout_ms;
            } else if (config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = config_.max_connection_lifetime_ms;
            }
            next_check_interval_ms = std::max(1000u, next_check_interval_ms / 2);

            eviction_timer_->expires_after(std::chrono::milliseconds(next_check_interval_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec) {
                if (ec != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->trace("[PoolEvictor] 下一次连接驱逐检查已调度在 {}ms 后。", next_check_interval_ms);
        } else if (config_.logger) {
            config_.logger->trace("[PoolEvictor] 连接驱逐任务未重新调度 (transport关闭或定时器/配置禁用)。");
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/session_parameters.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/session_handle.h"
// #include "neo4j_bolt_transport/async_session_handle.h" // 暂时移除
#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"

namespace neo4j_bolt_transport {

    // --- Neo4jBoltTransport - acquire_session (同步) ---
    std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> Neo4jBoltTransport::acquire_session(const config::SessionParameters& params) {
        if (closing_.load(std::memory_order_acquire)) {
            std::string err_msg = "尝试在关闭的 transport 上获取会话。";
            if (config_.logger) config_.logger->warn("[SessionAcq] {}", err_msg);
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->debug("[SessionAcq] 尝试获取会话，数据库: '{}', 访问模式: {}", params.database_name.value_or("<默认>"), (params.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"));

        routing::ServerRole role_hint = (params.default_access_mode == config::AccessMode::READ) ? routing::ServerRole::READER : routing::ServerRole::WRITER;

        auto [addr_err, target_server_address] = _get_server_address_for_session(params, role_hint);

        if (addr_err != boltprotocol::BoltError::SUCCESS || target_server_address.host.empty()) {
            std::string err_msg = "无法为会话确定服务器地址 (DB: " + params.database_name.value_or("<默认>") + ", 角色: " + (role_hint == routing::ServerRole::READER ? "R" : "W") + "): " + error::bolt_error_to_string(addr_err);
            if (!target_server_address.host.empty()) {
                err_msg += " (目标地址尝试: " + target_server_address.to_string() + ")";
            }
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);
            return {{addr_err, err_msg}, SessionHandle(this, nullptr, params)};
        }

        auto [conn_err_code, pooled_conn] = _acquire_pooled_connection(target_server_address, params.database_name);

        if (conn_err_code != boltprotocol::BoltError::SUCCESS || !pooled_conn) {
            std::string err_msg = "无法从池中获取到 " + target_server_address.to_string() + " 的连接: (" + error::bolt_error_to_string(conn_err_code) + ")";
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);

            if (config_.client_side_routing_enabled && conn_err_code == boltprotocol::BoltError::NETWORK_ERROR) {
                std::string db_name_for_routing_key = params.database_name.value_or("");
                // 调用 Neo4jBoltTransport 的静态私有方法
                _handle_routing_failure(target_server_address, Neo4jBoltTransport::_make_routing_context_key(db_name_for_routing_key, params.impersonated_user));
            }
            return {{conn_err_code, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->info("[SessionAcq] 会话已成功获取，使用连接 {} 到 {}", pooled_conn->get_id(), target_server_address.to_string());
        return {{boltprotocol::BoltError::SUCCESS, ""}, SessionHandle(this, std::move(pooled_conn), params)};
    }

    // acquire_async_session 的函数体暂时移除，只保留声明在头文件中（或也从头文件中移除，后续添加）
    /*
    boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
    Neo4jBoltTransport::acquire_async_session(const config::SessionParameters& params) {
        // ... (之前的占位符或完全移除) ...
        if (config_.logger) config_.logger->debug("[SessionAcqAsync] 异步获取会话 (当前未实现)。");
        co_return std::make_pair(std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, "Async session acquisition not implemented."), AsyncSessionHandle(this, nullptr, params));
    }
    */

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/neo4j_transaction_context.h"

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能需要
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionContext::TransactionContext(SessionHandle& session) : owner_session_(session) {
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> TransactionContext::run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters) {
        if (!owner_session_.is_in_transaction()) {
            std::string err_msg = "TransactionContext::run called, but SessionHandle is not in an active explicit transaction.";
            boltprotocol::SuccessMessageParams dummy_run_summary_raw;
            auto dummy_field_names = std::make_shared<const std::vector<std::string>>();
            std::vector<boltprotocol::RecordMessageParams> empty_records;

            // 获取创建 BoltResultStream 所需的附加参数
            std::string server_addr = "unknown_server";
            boltprotocol::versions::Version bolt_ver(0, 0);
            bool utc_patch = false;
            if (owner_session_.connection_ && owner_session_.connection_->is_ready_for_queries()) {  // 检查连接有效性
                server_addr = owner_session_.connection_->get_config().target_host + ":" + std::to_string(owner_session_.connection_->get_config().target_port);
                bolt_ver = owner_session_.connection_->get_bolt_version();
                utc_patch = owner_session_.connection_->is_utc_patch_active();
            }

            // 使用更新后的构造函数
            auto failed_stream = std::make_unique<BoltResultStream>(&owner_session_,
                                                                    std::nullopt,
                                                                    std::move(dummy_run_summary_raw),
                                                                    dummy_field_names,
                                                                    std::move(empty_records),
                                                                    false,  // server_might_have_more
                                                                    bolt_ver,
                                                                    utc_patch,
                                                                    server_addr,
                                                                    owner_session_.session_params_.database_name,  // session_params_ 是 SessionHandle 的成员
                                                                    boltprotocol::BoltError::INVALID_ARGUMENT,     // initial_error
                                                                    err_msg,                                       // initial_error_message
                                                                    std::nullopt                                   // initial_failure_details
            );
            // failed_stream->_set_failure_state(boltprotocol::BoltError::INVALID_ARGUMENT, err_msg); // 这行现在由构造函数处理

            return {{boltprotocol::BoltError::INVALID_ARGUMENT, err_msg}, std::move(failed_stream)};
        }
        return owner_session_.run_query(cypher, parameters, std::nullopt);
    }

    // 注意：SessionHandle 中 run_consume 已改为 run_query_and_consume，并且返回 ResultSummary
    // TransactionContext::run_consume 的职责可能需要重新评估。
    // 如果它仍然需要返回原始的 SuccessMessageParams 和 FailureMessageParams，
    // 那么 SessionHandle 可能需要一个保留这种行为的底层方法，或者 TransactionContext 需要从 ResultSummary 中提取这些。
    // 为了简单修复编译错误，假设我们仍然希望 TransactionContext::run_consume 返回原始参数，
    // 这意味着 SessionHandle 需要一个类似 run_query_and_get_raw_summary 的方法，或者我们调整接口。
    //
    // 简单的修复：让 TransactionContext::run_consume 调用 run_query 然后 consume，然后从 ResultSummary 提取原始数据。
    // 但这有点低效。更好的方法是 SessionHandle 提供一个直接返回原始参数的 consume 方法。
    //
    // 假设我们修改 TransactionContext::run_consume 的目标是获取最终的 ResultSummary。
    // 如果要保持原接口，SessionHandle 需要一个不同的方法。
    //
    // 当前修复：修改 TransactionContext::run_consume 以匹配 SessionHandle::run_query_and_consume 的返回类型，
    // 或者，如果必须保持原始签名，则进行适配。
    //
    // **方案1: 修改 TransactionContext::run_consume 签名 (推荐)**
    // std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary>
    // TransactionContext::run_consume(const std::string& cypher,
    //                                 const std::map<std::string, boltprotocol::Value>& parameters) {
    //     if (!owner_session_.is_in_transaction()) {
    //         // ... 构造一个失败的 ResultSummary ...
    //         return {{boltprotocol::BoltError::INVALID_ARGUMENT, "Not in transaction"}, ResultSummary(...)};
    //     }
    //     return owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);
    // }

    // **方案2: 尝试适配现有签名 (更复杂，可能不完全符合预期)**
    std::pair<boltprotocol::BoltError, std::string> TransactionContext::run_consume(const std::string& cypher,
                                                                                    const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                    boltprotocol::SuccessMessageParams& out_summary_raw,  // 注意这是原始参数
                                                                                    boltprotocol::FailureMessageParams& out_failure_raw) {
        if (!owner_session_.is_in_transaction()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "TransactionContext::run_consume called, but SessionHandle is not in an active explicit transaction."};
        }

        // 调用 SessionHandle 的 run_query_and_consume
        auto [err_pair, result_summary_typed] = owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);

        // 从 ResultSummary 中获取原始参数
        out_summary_raw = result_summary_typed.raw_params();  // 这需要 ResultSummary 暴露 raw_params()
                                                              // 并且需要处理 ResultSummary 失败的情况

        if (err_pair.first != boltprotocol::BoltError::SUCCESS) {
            // 如果操作失败，尝试从 ResultStream 的失败详情中填充 out_failure_raw
            // BoltResultStream *stream_ptr_for_failure = nullptr; // 如何获取？
            // if (stream_ptr_for_failure && stream_ptr_for_failure->has_failed()){
            //    out_failure_raw = stream_ptr_for_failure->get_failure_details();
            // } else {
            out_failure_raw.metadata["message"] = boltprotocol::Value(err_pair.second);
            // }
        } else {
            out_failure_raw.metadata.clear();  // 成功时清除
        }
        return err_pair;
    }

}  // namespace neo4j_bolt_transport#include <iostream>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::tuple<boltprotocol::BoltError, std::string, ResultSummary> BoltResultStream::consume() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consuming stream.", (void*)this);

        if (stream_failed_) {
            // If failed, final_summary_typed_ might not be meaningful or might be from RUN.
            // Return run_summary_typed_ or a default-constructed ResultSummary if even that is bad.
            // For now, return existing final_summary_typed_ which should be default/run summary.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }
        if (stream_fully_consumed_or_discarded_) {
            return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
        }

        auto discard_result_pair = _discard_all_remaining_records();  // This will update final_summary_typed_ internally via _update_final_summary

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            // _set_failure_state was called by _discard_all_remaining_records
            // final_summary_typed_ might reflect the RUN summary in this case.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }

        // Update session bookmarks from the final summary for auto-commit sessions.
        // This happens only if consume was successful and it was an auto-commit query.
        if (owner_session_ && !owner_session_->is_in_transaction() && !stream_failed_) {
            auto it_bookmark = final_summary_typed_.raw_params().metadata.find("bookmark");
            if (it_bookmark != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                owner_session_->update_bookmarks({std::get<std::string>(it_bookmark->second)});
            } else {
                if (failure_reason_ == boltprotocol::BoltError::SUCCESS) {  // Only clear if server operation was success
                    owner_session_->update_bookmarks({});
                }
            }
        }
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consume successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_fetch_more_records(int64_t n) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            std::string msg = "Fetch records: Invalid session or connection.";
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, msg);
            if (logger) logger->warn("[ResultStreamFETCH {}] {}", (void*)this, msg);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || (stream_fully_consumed_or_discarded_ && !is_first_pull_attempt_)) {
            if (logger) logger->trace("[ResultStreamFETCH {}] Already failed or consumed. Failed: {}, Consumed: {}, FirstPull: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_, is_first_pull_attempt_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::UNKNOWN_ERROR, failure_message_};
        }

        if (logger) logger->trace("[ResultStreamFETCH {}] Fetching {} records. QID: {}", (void*)this, n, (query_id_ ? std::to_string(*query_id_) : "auto"));

        std::vector<boltprotocol::RecordMessageParams> fetched_records;
        boltprotocol::SuccessMessageParams current_pull_summary_raw;  // 从 _stream_pull_records 获取原始摘要

        std::optional<int64_t> qid_for_this_pull = query_id_;

        // 调用 SessionHandle 的方法来实际与物理连接交互
        auto pull_result_pair = owner_session_->_stream_pull_records(qid_for_this_pull, n, fetched_records, current_pull_summary_raw);
        is_first_pull_attempt_ = false;  // 无论成功与否，都已经尝试过 PULL

        if (pull_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            // 尝试从连接获取更具体的服务器错误信息（如果与 PULL 操作的错误不同）
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != pull_result_pair.first) {  // 仅当连接错误更具体时
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    // temp_fail.metadata["code"] = ... (如果可以从 BoltPhysicalConnection 获取 Neo4j 错误码)
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(pull_result_pair.first, pull_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamFETCH {}] _stream_pull_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(pull_result_pair.first), pull_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        // PULL 消息交换成功，服务器返回了 SUCCESS 摘要
        _update_final_summary(std::move(current_pull_summary_raw));  // 使用收到的原始摘要更新类型化的 final_summary_typed_

        for (auto& rec : fetched_records) {
            raw_record_buffer_.push_back(std::move(rec));
        }

        // 从更新后的 final_summary_typed_ 中检查 has_more
        auto it_has_more = final_summary_typed_.raw_params().metadata.find("has_more");
        if (it_has_more != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
            server_has_more_records_ = std::get<bool>(it_has_more->second);
        } else {
            server_has_more_records_ = false;  // 如果 PULL 摘要中没有 "has_more"，则假定没有更多了
        }

        if (!server_has_more_records_ && raw_record_buffer_.empty()) {
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamFETCH {}] Fetched {}. Buffer: {}. ServerMore: {}", (void*)this, fetched_records.size(), raw_record_buffer_.size(), server_has_more_records_);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_discard_all_remaining_records() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discarding. QID: {}", (void*)this, (query_id_ ? std::to_string(*query_id_) : "auto"));

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Discard: Invalid session/connection.");
            if (logger) logger->warn("[ResultStreamDISCARD {}] Invalid session/connection.", (void*)this);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamDISCARD {}] Already failed or consumed. Failed: {}, Consumed: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::SUCCESS, failure_message_};
        }

        raw_record_buffer_.clear();  // 清空本地缓冲的记录

        // 检查是否真的需要向服务器发送 DISCARD
        // server_has_more_records_ 反映了上一个 PULL/DISCARD 的 has_more 标志
        // initial_server_has_more_records_ 反映了 RUN 响应的 has_more 标志
        // is_first_pull_attempt_ 表示是否还没有执行过 PULL 或 DISCARD
        bool needs_server_discard = false;
        if (is_first_pull_attempt_) {  // 第一次操作（之前没有PULL/DISCARD）
            needs_server_discard = initial_server_has_more_records_;
        } else {  // 已经有过PULL/DISCARD
            needs_server_discard = server_has_more_records_;
        }

        if (!needs_server_discard) {
            stream_fully_consumed_or_discarded_ = true;
            // 如果这是第一次操作（例如，RUN 后直接 consume，且 RUN 表明没有记录），
            // final_summary_typed_ 应该等于 run_summary_typed_。
            // _update_final_summary 在构造时已经用 run_summary 初始化了 final_summary。
            // 如果之前有PULL，final_summary_typed_ 已经被该PULL的摘要更新。
            if (is_first_pull_attempt_) {
                // 确保 final_summary_typed_ 反映的是 run_summary_typed_ 的状态，因为它没有发生网络交互
                // _update_final_summary(boltprotocol::SuccessMessageParams(run_summary_typed_.raw_params()));
                // 上面这行可能不必要，因为构造时 final_summary_typed_ 已经是 run_summary_typed_ 的一个副本了。
            }
            if (logger) logger->trace("[ResultStreamDISCARD {}] No records on server to discard. FirstPull: {}, InitialServerMore: {}, CurrentServerMore: {}", (void*)this, is_first_pull_attempt_, initial_server_has_more_records_, server_has_more_records_);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        // 需要向服务器发送 DISCARD
        boltprotocol::SuccessMessageParams discard_summary_raw;  // 用于接收原始摘要
        std::optional<int64_t> qid_for_discard = query_id_;

        auto discard_result_pair = owner_session_->_stream_discard_records(qid_for_discard, -1, discard_summary_raw);
        is_first_pull_attempt_ = false;              // 标记已尝试过 PULL/DISCARD
        stream_fully_consumed_or_discarded_ = true;  // DISCARD 意味着流结束

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != discard_result_pair.first) {
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(discard_result_pair.first, discard_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamDISCARD {}] _stream_discard_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(discard_result_pair.first), discard_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        _update_final_summary(std::move(discard_summary_raw));  // 使用收到的原始摘要更新类型化的 final_summary_typed_
        server_has_more_records_ = false;                       // DISCARD 后，服务器肯定没有更多记录了
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discard successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // ... (has_next 实现) ...
    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::has_next(bool& out_has_next) {
        out_has_next = false;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream already failed. Reason: {}", (void*)this, static_cast<int>(failure_reason_));
            return {failure_reason_, failure_message_};
        }
        if (stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream fully consumed/discarded.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }
        if (!raw_record_buffer_.empty()) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Records in buffer.", (void*)this);
            out_has_next = true;
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        bool effectively_has_more_on_server = is_first_pull_attempt_ ? initial_server_has_more_records_ : server_has_more_records_;

        if (!effectively_has_more_on_server) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, server indicates no more records.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
            // 如果这是流的末尾，并且没有发生错误，确保 final_summary_typed_ 是最新的
            // （它可能已经是 run_summary_typed_ 或者上一次 PULL 的结果）
            // 如果之前没有 PULL/DISCARD，并且 RUN 表明没有更多记录，final_summary 应该等于 run_summary
            if (is_first_pull_attempt_) {
                // 确保 final_summary_typed_ 反映的是 run_summary_typed_ 的状态
                // 在 BoltResultStream 构造函数中，final_summary_typed_ 已经用 run_summary_params_raw 初始化
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        int64_t fetch_n = 1000;  // 默认的拉取大小
        if (owner_session_ && owner_session_->session_params_.default_fetch_size != 0) {
            fetch_n = (owner_session_->session_params_.default_fetch_size > 0 || owner_session_->session_params_.default_fetch_size == -1) ? owner_session_->session_params_.default_fetch_size : 1000;
        }

        if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, attempting to fetch {} records.", (void*)this, fetch_n);
        auto fetch_result = _fetch_more_records(fetch_n);  // 这个方法内部会更新 final_summary_typed_

        if (fetch_result.first != boltprotocol::BoltError::SUCCESS) {
            return fetch_result;  // _fetch_more_records 内部已设置失败状态
        }

        out_has_next = !raw_record_buffer_.empty();
        if (!out_has_next && !server_has_more_records_) {  // 拉取后，缓冲区仍为空，且服务器确认没有更多
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Fetched, buffer still empty, PULL confirms no more.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamITER {}] has_next: After fetch, out_has_next={}", (void*)this, out_has_next);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::next() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        bool has_more = false;
        auto has_next_res_pair = has_next(has_more);  // has_next_res_pair 是 std::pair

        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);  // 从 pair 中移动

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            return {err_code_has_next, std::move(err_msg_has_next), std::nullopt};
        }
        if (!has_more) {
            if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};
            if (logger) logger->trace("[ResultStreamITER {}] next: No more records.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, "No more records in stream.", std::nullopt};
        }

        if (raw_record_buffer_.empty() && !stream_failed_) {
            _set_failure_state(boltprotocol::BoltError::UNKNOWN_ERROR, "Internal error: has_next() was true but buffer is empty and not failed.");
            if (logger) logger->error("[ResultStreamITER {}] next: Internal error - has_next true but buffer empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }
        if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};

        boltprotocol::RecordMessageParams raw_record_params = std::move(raw_record_buffer_.front());
        raw_record_buffer_.pop_front();

        if (logger) logger->trace("[ResultStreamITER {}] next: Popped one record. Buffer size: {}", (void*)this, raw_record_buffer_.size());

        BoltRecord record(std::move(raw_record_params.fields), field_names_ptr_cache_);
        return {boltprotocol::BoltError::SUCCESS, "", std::make_optional<BoltRecord>(std::move(record))};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::single() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] single() called.", (void*)this);

        auto next_result_tuple = next();  // 调用 next()
        boltprotocol::BoltError err_code_next = std::get<0>(next_result_tuple);
        std::string err_msg_next = std::get<1>(std::move(next_result_tuple));
        std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_result_tuple));

        if (err_code_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error from first next(): {}.", (void*)this, err_msg_next);
            return {err_code_next, std::move(err_msg_next), std::nullopt};
        }
        if (!record_opt.has_value()) {
            if (stream_failed_) {  // 如果流因为 next() 内部的 has_next() -> _fetch_more_records() 失败
                if (logger) logger->trace("[ResultStreamITER {}] single(): No record, stream failed. Reason: {}.", (void*)this, failure_message_);
                return {failure_reason_, failure_message_, std::nullopt};
            }
            // 如果没有失败，但 next() 返回空，意味着流是空的
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but stream was empty.");
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, stream empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        // 成功获取一个记录，现在检查是否还有更多
        bool has_more_records = false;
        auto has_next_res_pair = has_next(has_more_records);
        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error checking for more records after finding one: {}.", (void*)this, err_msg_has_next);
            _set_failure_state(err_code_has_next, "Error checking for subsequent records in single(): " + err_msg_has_next);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (has_more_records) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, but more found. Discarding rest.", (void*)this);
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamITER {}] single(): Discarding extra records failed: {}", (void*)this, discard_res.second);
            }
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but found more.");
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (logger) logger->trace("[ResultStreamITER {}] single() successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", std::move(record_opt)};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> BoltResultStream::list_all() {
        std::vector<BoltRecord> all_records_converted;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] list_all: Starting.", (void*)this);

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] list_all: Stream already failed.", (void*)this);
            return {failure_reason_, failure_message_, std::move(all_records_converted)};
        }

        while (true) {
            auto next_res_tuple = next();
            boltprotocol::BoltError err_code = std::get<0>(next_res_tuple);
            std::string err_msg = std::get<1>(std::move(next_res_tuple));                   // 可以移动
            std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_res_tuple));  // 可以移动

            if (err_code != boltprotocol::BoltError::SUCCESS) {
                if (logger) logger->warn("[ResultStreamITER {}] list_all: Error from next(): {}.", (void*)this, err_msg);
                // 返回已收集的记录以及错误
                return {err_code, std::move(err_msg), std::move(all_records_converted)};
            }
            if (!record_opt.has_value()) {  // 流结束
                if (logger) logger->trace("[ResultStreamITER {}] list_all: End of stream reached by next().", (void*)this);
                break;
            }
            all_records_converted.push_back(std::move(*record_opt));  // 从 optional 中移动 BoltRecord
        }

        if (logger) logger->trace("[ResultStreamITER {}] list_all: Finished. Records: {}", (void*)this, all_records_converted.size());
        return {boltprotocol::BoltError::SUCCESS, "", std::move(all_records_converted)};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    BoltResultStream::BoltResultStream(SessionHandle* session,
                                       std::optional<int64_t> query_id_for_streaming,
                                       boltprotocol::SuccessMessageParams run_summary_params_raw,
                                       std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                                       std::vector<boltprotocol::RecordMessageParams> initial_records,
                                       bool server_might_have_more,
                                       const boltprotocol::versions::Version& bolt_version,
                                       bool utc_patch_active,
                                       const std::string& server_address_for_summary,
                                       const std::optional<std::string>& database_name_for_summary,
                                       boltprotocol::BoltError initial_error,
                                       const std::string& initial_error_message,
                                       const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details)
        : owner_session_(session),
          query_id_(query_id_for_streaming),
          field_names_ptr_cache_(std::move(field_names_ptr)),
          // Initialize run_summary_typed_ with a copy of raw params for now
          run_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          // final_summary_typed_ initialized similarly, will be updated by _update_final_summary
          final_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          initial_server_has_more_records_(server_might_have_more),
          server_has_more_records_(server_might_have_more),
          bolt_version_cache_(bolt_version),
          utc_patch_active_cache_(utc_patch_active),
          server_address_cache_(server_address_for_summary),
          database_name_cache_(database_name_for_summary) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        for (auto&& rec_param : initial_records) {
            raw_record_buffer_.push_back(std::move(rec_param));
        }

        if (initial_error != boltprotocol::BoltError::SUCCESS) {
            _set_failure_state(initial_error, initial_error_message, initial_failure_details);
        } else if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Session or connection invalid at ResultStream creation.");
        }

        // Ensure field_names_ptr_cache_ is populated from run_summary_typed_ if it was null
        if (!field_names_ptr_cache_ || field_names_ptr_cache_->empty()) {
            auto it_fields = run_summary_typed_.raw_params().metadata.find("fields");
            if (it_fields != run_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
                auto temp_field_names = std::make_shared<std::vector<std::string>>();
                const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
                if (list_ptr) {
                    temp_field_names->reserve(list_ptr->elements.size());
                    for (const auto& field_val : list_ptr->elements) {
                        if (std::holds_alternative<std::string>(field_val)) {
                            temp_field_names->push_back(std::get<std::string>(field_val));
                        }
                    }
                }
                field_names_ptr_cache_ = std::const_pointer_cast<const std::vector<std::string>>(temp_field_names);
            } else {
                field_names_ptr_cache_ = std::make_shared<const std::vector<std::string>>();  // Empty
            }
        }

        if (!stream_failed_) {
            // If no records were pipelined and server RUN summary says no more, then stream is done.
            if (raw_record_buffer_.empty() && !initial_server_has_more_records_) {
                stream_fully_consumed_or_discarded_ = true;
                // final_summary_typed_ is already a copy of run_summary_typed_ here
            }
        }

        // A PULL/DISCARD is needed if: buffer is empty AND server might have more records (initial_server_has_more_records_) AND not failed
        is_first_pull_attempt_ = raw_record_buffer_.empty() && initial_server_has_more_records_ && !stream_failed_;

        if (logger) {
            logger->debug("[ResultStreamLC {}] Created. QID: {}. InitRecs: {}. InitialSrvMore: {}. Failed: {}. FirstPullAttempt: {}", (void*)this, query_id_ ? std::to_string(*query_id_) : "N/A", raw_record_buffer_.size(), initial_server_has_more_records_, stream_failed_, is_first_pull_attempt_);
        }
    }

    BoltResultStream::~BoltResultStream() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->debug("[ResultStreamLC {}] Destructing. Consumed: {}, Failed: {}", (void*)this, stream_fully_consumed_or_discarded_, stream_failed_);
        }

        if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
            if (logger) logger->trace("[ResultStreamLC {}] Auto-discarding in dtor.", (void*)this);
            // This will update final_summary_typed_
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamLC {}] Auto-discard in dtor failed: {}", (void*)this, discard_res.second);
            }
        }
    }

    BoltResultStream::BoltResultStream(BoltResultStream&& other) noexcept
        : owner_session_(other.owner_session_),
          query_id_(other.query_id_),
          raw_record_buffer_(std::move(other.raw_record_buffer_)),
          field_names_ptr_cache_(std::move(other.field_names_ptr_cache_)),
          run_summary_typed_(std::move(other.run_summary_typed_)),
          final_summary_typed_(std::move(other.final_summary_typed_)),
          failure_details_raw_(std::move(other.failure_details_raw_)),
          server_has_more_records_(other.server_has_more_records_),
          initial_server_has_more_records_(other.initial_server_has_more_records_),
          stream_fully_consumed_or_discarded_(other.stream_fully_consumed_or_discarded_),
          stream_failed_(other.stream_failed_),
          failure_reason_(other.failure_reason_),
          failure_message_(std::move(other.failure_message_)),
          is_first_pull_attempt_(other.is_first_pull_attempt_),
          bolt_version_cache_(other.bolt_version_cache_),
          utc_patch_active_cache_(other.utc_patch_active_cache_),
          server_address_cache_(std::move(other.server_address_cache_)),
          database_name_cache_(std::move(other.database_name_cache_)) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamLC {}] Move constructed from ResultStream {}.", (void*)this, (void*)&other);

        other.owner_session_ = nullptr;  // Invalidate other
        other.stream_fully_consumed_or_discarded_ = true;
        other.stream_failed_ = true;  // Mark other as unusable
    }

    BoltResultStream& BoltResultStream::operator=(BoltResultStream&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
            if (logger) logger->trace("[ResultStreamLC {}] Move assigning from ResultStream {}.", (void*)this, (void*)&other);

            // Discard current stream's resources if it's still active
            if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
                _discard_all_remaining_records();
            }

            owner_session_ = other.owner_session_;
            query_id_ = other.query_id_;
            raw_record_buffer_ = std::move(other.raw_record_buffer_);
            field_names_ptr_cache_ = std::move(other.field_names_ptr_cache_);
            run_summary_typed_ = std::move(other.run_summary_typed_);
            final_summary_typed_ = std::move(other.final_summary_typed_);
            failure_details_raw_ = std::move(other.failure_details_raw_);
            server_has_more_records_ = other.server_has_more_records_;
            initial_server_has_more_records_ = other.initial_server_has_more_records_;
            stream_fully_consumed_or_discarded_ = other.stream_fully_consumed_or_discarded_;
            stream_failed_ = other.stream_failed_;
            failure_reason_ = other.failure_reason_;
            failure_message_ = std::move(other.failure_message_);
            is_first_pull_attempt_ = other.is_first_pull_attempt_;
            bolt_version_cache_ = other.bolt_version_cache_;
            utc_patch_active_cache_ = other.utc_patch_active_cache_;
            server_address_cache_ = std::move(other.server_address_cache_);
            database_name_cache_ = std::move(other.database_name_cache_);

            other.owner_session_ = nullptr;  // Invalidate other
            other.stream_fully_consumed_or_discarded_ = true;
            other.stream_failed_ = true;
        }
        return *this;
    }

    const std::vector<std::string>& BoltResultStream::field_names() const {
        static const std::vector<std::string> empty_names_singleton;
        return field_names_ptr_cache_ ? *field_names_ptr_cache_ : empty_names_singleton;
    }

    void BoltResultStream::_set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details) {
        if (stream_failed_ && failure_reason_ != boltprotocol::BoltError::SUCCESS) {
            // Already in a more specific failure state, don't override with a potentially less specific one unless reason is new.
            // However, allow updating message if new details are provided.
            if (!detailed_message.empty() && failure_message_.find(detailed_message) == std::string::npos) {
                failure_message_ += "; Additional detail: " + detailed_message;
            }
            if (details.has_value() && failure_details_raw_.metadata.empty()) {  // Only update raw details if not already set
                failure_details_raw_ = *details;
            }
            return;
        }
        stream_failed_ = true;
        failure_reason_ = reason;
        failure_message_ = std::move(detailed_message);

        if (details.has_value()) {
            failure_details_raw_ = *details;
        } else {
            failure_details_raw_.metadata.clear();  // Ensure it's clear
            if (!failure_message_.empty() && reason != boltprotocol::BoltError::SUCCESS) {
                // Create a minimal failure detail from the message
                failure_details_raw_.metadata["message"] = boltprotocol::Value(failure_message_);
            }
        }
        stream_fully_consumed_or_discarded_ = true;  // A failed stream is considered consumed

        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->warn("[ResultStreamLC {}] Failure state set. Reason: {} ({}), Msg: {}", (void*)this, static_cast<int>(reason), error::bolt_error_to_string(reason), failure_message_);
        }
    }

    // New private helper to update final_summary_typed_
    void BoltResultStream::_update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary) {
        final_summary_typed_ = ResultSummary(std::move(pull_or_discard_raw_summary), bolt_version_cache_, utc_patch_active_cache_, server_address_cache_, database_name_cache_);
    }

}  // namespace neo4j_bolt_transport// Source/result_stream_state.cpp
// This file is intentionally left empty or can be removed from the build
// if its only purpose was to define methods now inlined in result_stream.h
// (has_failed, get_failure_reason, get_failure_message, get_failure_details).

// #include "neo4j_bolt_transport/result_stream.h"
// namespace neo4j_bolt_transport {} // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/result_summary.h"

#include <iostream>  // For potential debug

namespace neo4j_bolt_transport {

    // Helper to safely get a string from a Bolt Value
    std::optional<std::string> get_string_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<std::string>(val)) {
            return std::get<std::string>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get an int64 from a Bolt Value
    std::optional<int64_t> get_int64_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<int64_t>(val)) {
            return std::get<int64_t>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get a bool from a Bolt Value
    std::optional<bool> get_bool_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<bool>(val)) {
            return std::get<bool>(val);
        }
        return std::nullopt;
    }

    ResultSummary::ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active, const std::string& srv_address, const std::optional<std::string>& db_name_from_session)
        : raw_params_(std::move(server_summary_params)), server_address_(srv_address) {
        // Determine effective database name
        auto db_it = raw_params_.metadata.find("db");
        if (db_it != raw_params_.metadata.end()) {
            if (auto db_str = get_string_val(db_it->second)) {
                database_name_ = *db_str;
            }
        }
        if (database_name_.empty() && db_name_from_session.has_value()) {
            database_name_ = *db_name_from_session;
        }
        if (database_name_.empty()) {
            // Fallback if not in summary and not in session (e.g. system db for older Neo4j)
            database_name_ = "system";  // Or "" if that's preferred for default
        }

        parse_metadata(bolt_version, utc_patch_active);
    }

    void ResultSummary::parse_query_type(const boltprotocol::Value& type_val_variant) {
        if (auto type_str_opt = get_string_val(type_val_variant)) {
            const std::string& type_str = *type_str_opt;
            if (type_str == "r")
                query_type_ = QueryType::READ_ONLY;
            else if (type_str == "rw")
                query_type_ = QueryType::READ_WRITE;
            else if (type_str == "w")
                query_type_ = QueryType::WRITE_ONLY;
            else if (type_str == "s")
                query_type_ = QueryType::SCHEMA_WRITE;
            else
                query_type_ = QueryType::UNKNOWN;
        }
    }

    void ResultSummary::parse_counters(const boltprotocol::Value& counters_val_variant) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant)) {
            const auto& counters_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant);
            if (counters_map_ptr) {
                const auto& m = counters_map_ptr->pairs;
                auto get_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_int64_val(it->second).value_or(0);
                    }
                    return int64_t{0};
                };
                auto get_bool_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_bool_val(it->second).value_or(false);
                    }
                    return false;
                };

                counters_.nodes_created = get_counter("nodes-created");
                counters_.nodes_deleted = get_counter("nodes-deleted");
                counters_.relationships_created = get_counter("relationships-created");
                counters_.relationships_deleted = get_counter("relationships-deleted");
                counters_.properties_set = get_counter("properties-set");
                counters_.labels_added = get_counter("labels-added");
                counters_.labels_removed = get_counter("labels-removed");
                counters_.indexes_added = get_counter("indexes-added");
                counters_.indexes_removed = get_counter("indexes-removed");
                counters_.constraints_added = get_counter("constraints-added");
                counters_.constraints_removed = get_counter("constraints-removed");
                counters_.system_updates = get_counter("system-updates");                         // Bolt 4.3+
                counters_.contains_system_updates = get_bool_counter("contains-system-updates");  // Bolt 5.0+

                // contains-updates logic:
                // True if any of the specific counters > 0 OR if "contains-updates" is explicitly true
                counters_.contains_updates = (counters_.nodes_created > 0 || counters_.nodes_deleted > 0 || counters_.relationships_created > 0 || counters_.relationships_deleted > 0 || counters_.properties_set > 0 || counters_.labels_added > 0 || counters_.labels_removed > 0 ||
                                              counters_.indexes_added > 0 || counters_.indexes_removed > 0 || counters_.constraints_added > 0 || counters_.constraints_removed > 0);
                // If server provides "contains-updates", respect it
                auto it_contains_updates = m.find("contains-updates");
                if (it_contains_updates != m.end()) {
                    if (auto b_val = get_bool_val(it_contains_updates->second)) {
                        counters_.contains_updates = *b_val;
                    }
                }

                if (counters_.system_updates > 0 && !counters_.contains_system_updates) {
                    // if system_updates > 0, contains_system_updates should be true.
                    // This might indicate an older server version or an inconsistency.
                    // For safety, set contains_system_updates if system_updates is positive.
                    counters_.contains_system_updates = true;
                }
            }
        }
    }

    void ResultSummary::parse_notifications(const boltprotocol::Value& notifications_val_variant, const boltprotocol::versions::Version& bolt_version) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant);
            if (list_ptr) {
                notifications_.reserve(list_ptr->elements.size());
                for (const auto& item_val : list_ptr->elements) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(item_val)) {
                        const auto& map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(item_val);
                        if (map_ptr) {
                            ServerNotification notif;
                            const auto& m = map_ptr->pairs;
                            auto find_str = [&](const std::string& key) -> std::optional<std::string> {
                                auto it = m.find(key);
                                if (it != m.end()) return get_string_val(it->second);
                                return std::nullopt;
                            };

                            notif.code = find_str("code").value_or("");
                            notif.title = find_str("title").value_or("");
                            notif.description = find_str("description").value_or("");
                            notif.severity = find_str("severity").value_or("");  // Bolt 4.1+
                            if (bolt_version.major > 5 || (bolt_version.major == 5 && bolt_version.minor >= 2)) {
                                notif.category = find_str("category").value_or("");
                            }

                            auto pos_it = m.find("position");
                            if (pos_it != m.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second)) {
                                const auto& pos_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second);
                                if (pos_map_ptr) notif.position = pos_map_ptr->pairs;
                            }
                            notifications_.push_back(std::move(notif));
                        }
                    }
                }
            }
        }
    }

    void ResultSummary::parse_metadata(const boltprotocol::versions::Version& bolt_version, bool /*utc_patch_active*/) {
        // Extract common fields
        auto t_start_it = raw_params_.metadata.find("t_first");  // Time to first record (RUN response) or available (PULL/DISCARD response)
        if (t_start_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_start_it->second)) {
                result_available_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto t_end_it = raw_params_.metadata.find("t_last");  // Time to last record (PULL/DISCARD response)
        if (t_end_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_end_it->second)) {
                result_consumed_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto type_it = raw_params_.metadata.find("type");
        if (type_it != raw_params_.metadata.end()) {
            parse_query_type(type_it->second);
        }

        auto counters_it = raw_params_.metadata.find("stats");
        if (counters_it != raw_params_.metadata.end()) {
            parse_counters(counters_it->second);
        }

        auto notifications_it = raw_params_.metadata.find("notifications");
        if (notifications_it != raw_params_.metadata.end()) {
            parse_notifications(notifications_it->second, bolt_version);
        }

        // Plan and Profile parsing would go here if implemented
        // auto plan_it = raw_params_.metadata.find("plan");
        // if (plan_it != raw_params_.metadata.end()) { ... parse plan ... }
        // auto profile_it = raw_params_.metadata.find("profile"); // or "profiled-plan"
        // if (profile_it != raw_params_.metadata.end()) { ... parse profile ... }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _get_server_address_for_session: 获取会话的服务器地址，可能会使用路由
    std::pair<boltprotocol::BoltError, routing::ServerAddress> Neo4jBoltTransport::_get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint) {
        if (config_.logger) {
            config_.logger->trace(
                "[AddrSelect] 获取服务器地址, 数据库: '{}', 角色提示: {}, 模拟用户: '{}'", params.database_name.value_or("<默认>"), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), params.impersonated_user.value_or("<无>"));
        }

        // 如果未启用客户端路由，或者使用的是直接的 bolt:// 方案
        if (!config_.client_side_routing_enabled || parsed_initial_uri_.scheme == "bolt" || parsed_initial_uri_.scheme == "bolt+s" || parsed_initial_uri_.scheme == "bolt+ssc") {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[AddrSelect] 无可用主机用于直接连接。");
                return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            }
            // 对于直接连接，使用URI中的第一个主机
            const auto& host_port = parsed_initial_uri_.hosts_with_ports.front();
            routing::ServerAddress resolved_address(host_port.first, host_port.second);

            // 应用自定义地址解析器（如果提供）
            if (config_.server_address_resolver) {
                routing::ServerAddress original_address = resolved_address;
                resolved_address = config_.server_address_resolver(original_address);
                if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                    config_.logger->debug("[AddrSelect] 直接连接地址已解析: {} -> {}", original_address.to_string(), resolved_address.to_string());
                }
            }
            if (config_.logger) config_.logger->debug("[AddrSelect] 直接连接，使用地址: {}", resolved_address.to_string());
            return {boltprotocol::BoltError::SUCCESS, resolved_address};
        }

        // --- 需要路由 ---
        // 确定用于路由的数据库名称。对于 neo4j:// 方案，空数据库名通常指默认集群/数据库，
        // 或者需要先连接到 system 数据库获取集群信息。
        // 驱动通常会为每个 (database_name, impersonated_user) 组合维护一个路由表。
        std::string db_name_for_routing_key = params.database_name.value_or("");

        // 尝试获取或刷新路由表
        std::shared_ptr<routing::RoutingTable> routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);

        if (!routing_table) {
            if (config_.logger) config_.logger->error("[AddrSelect] 无法获取或刷新数据库 '{}' 的路由表 (模拟用户: '{}')", db_name_for_routing_key, params.impersonated_user.value_or("<无>"));
            return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 或者更具体的路由错误
        }

        // 从路由表中选择一个服务器
        // 尝试多次，因为表可能在两次调用之间变得陈旧，或者选中的服务器刚好失效
        int attempts = 0;
        const int max_selection_attempts = config_.routing_max_retry_attempts > 0 ? config_.routing_max_retry_attempts : 3;  // 至少尝试1次

        while (attempts < max_selection_attempts) {
            attempts++;
            if (routing_table->is_stale() && attempts > 1) {  // 如果不是第一次尝试且表已过时
                if (config_.logger) config_.logger->info("[AddrSelect] 路由表 '{}' 在选择期间已过时，第 {} 次尝试刷新。", routing_table->get_database_context_key(), attempts);
                // 重新获取/刷新路由表
                routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);
                if (!routing_table) {
                    if (config_.logger) config_.logger->error("[AddrSelect] 路由表 '{}' 刷新失败。", db_name_for_routing_key);
                    return {boltprotocol::BoltError::NETWORK_ERROR, {}};
                }
            }

            std::optional<routing::ServerAddress> server_address_opt = routing_table->get_server(role_hint);

            if (server_address_opt) {
                routing::ServerAddress resolved_address = *server_address_opt;
                // 应用自定义地址解析器
                if (config_.server_address_resolver) {
                    routing::ServerAddress original_address = resolved_address;
                    resolved_address = config_.server_address_resolver(original_address);
                    if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                        config_.logger->debug("[AddrSelect] 路由选定地址已解析: {} -> {}", original_address.to_string(), resolved_address.to_string());
                    }
                }
                if (config_.logger) config_.logger->info("[AddrSelect] 选定服务器地址: {} (角色: {}), 尝试次数: {}", resolved_address.to_string(), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), attempts);
                return {boltprotocol::BoltError::SUCCESS, resolved_address};
            } else {
                if (config_.logger) config_.logger->warn("[AddrSelect] 第 {} 次尝试: 路由表 '{}' 中没有找到角色 {} 的可用服务器。", attempts, routing_table->get_database_context_key(), static_cast<int>(role_hint));
                if (attempts < max_selection_attempts) {
                    routing_table->mark_as_stale();  // 强制下次迭代时刷新
                                                     // 可以选择在这里短暂 sleep，或者让上层（如连接获取）处理重试
                }
            }
        }  // end while attempts

        if (config_.logger) config_.logger->error("[AddrSelect] 多次尝试后，路由表 '{}' 中仍无法为角色 {} 找到服务器。", routing_table->get_database_context_key(), static_cast<int>(role_hint));
        return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 或者 "No suitable server found"
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能用于日志
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 当连接到某个服务器失败时，或服务器返回特定的可路由错误时，调用此函数
    void Neo4jBoltTransport::_handle_routing_failure(const routing::ServerAddress& failed_address,
                                                     const std::string& database_context_key) {  // database_context_key 用于定位正确的路由表

        if (!config_.client_side_routing_enabled) {
            return;  // 如果路由未启用，则不执行任何操作
        }

        if (config_.logger) {
            config_.logger->info("[RoutingFail] 处理路由失败: 地址 {}, 上下文键 {}", failed_address.to_string(), database_context_key);
        }

        std::lock_guard<std::mutex> lock(routing_table_mutex_);
        auto it = routing_tables_.find(database_context_key);
        if (it != routing_tables_.end()) {
            std::shared_ptr<routing::RoutingTable> table = it->second;
            if (table) {
                table->forget_server(failed_address);  // 从路由表中移除失败的服务器
                // 忘记服务器后，路由表可能会变得不健康（例如，没有可用的writer了）
                // RoutingTable::forget_server 内部可能会调用 mark_as_stale()
                // 如果需要更主动的刷新，可以在这里调用 table->mark_as_stale();
                if (config_.logger) {
                    config_.logger->debug("[RoutingFail] 从路由表 '{}' 中移除了地址 {}。", database_context_key, failed_address.to_string());
                    if (table->is_stale()) {
                        config_.logger->info("[RoutingFail] 路由表 '{}' 在移除地址后被标记为过时。", database_context_key);
                    }
                }
            }
        } else {
            if (config_.logger) {
                config_.logger->warn("[RoutingFail] 未找到上下文键为 '{}' 的路由表来处理失败。", database_context_key);
            }
        }
    }

}  // namespace neo4j_bolt_transport#include <chrono>  // For std::chrono::seconds default TTL

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能需要用于日志
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 静态辅助函数，已在 pool_core.cpp 中定义，这里为保持独立性可重新声明或包含一个通用头文件
    // static std::string make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
    //     std::string db_part = database_name.empty() ? "system" : database_name;
    //     if (impersonated_user && !impersonated_user->empty()) {
    //         return db_part + "@" + *impersonated_user;
    //     }
    //     return db_part;
    // }
    // ^^^ 如果这个函数在多个 .cpp 文件中需要，最好放到一个共享的辅助头文件中，或者作为 Neo4jBoltTransport 的私有静态成员。
    // 为简单起见，暂时假设它在 neo4j_bolt_transport_pool_core.cpp 中定义的版本可以被链接器找到，
    // 或者直接在 Neo4jBoltTransport 类中定义它。
    // 这里我们直接在类作用域外（或在一个辅助命名空间）定义它，假设它是一个全局辅助函数。
    // (在实际项目中，会放到一个 util.h 或类似文件中)
    namespace detail {  // 使用一个内部命名空间避免冲突
        std::string make_routing_context_key_for_manager(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
            std::string db_part = database_name.empty() ? "system" : database_name;
            if (impersonated_user && !impersonated_user->empty()) {
                return db_part + "@" + *impersonated_user;
            }
            return db_part;
        }
    }  // namespace detail

    // 获取或创建（如果不存在）并可能刷新路由表
    std::shared_ptr<routing::RoutingTable> Neo4jBoltTransport::_get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string context_key = detail::make_routing_context_key_for_manager(database_name, impersonated_user);
        std::shared_ptr<routing::RoutingTable> table;
        std::vector<routing::ServerAddress> initial_routers_for_this_context;  // 用于刷新

        {  // 作用域锁保护 routing_tables_ 的访问
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            auto it = routing_tables_.find(context_key);
            if (it != routing_tables_.end()) {
                table = it->second;
            } else {
                // 从配置中获取此上下文的默认 TTL (例如，300秒)
                // 注意: config_.routing_table_default_ttl_seconds (如果添加了这个配置项)
                unsigned int default_ttl_seconds = 300;
                // if (config_.routing_table_default_ttl_seconds.has_value()) {
                //    default_ttl_seconds = *config_.routing_table_default_ttl_seconds;
                // }
                table = std::make_shared<routing::RoutingTable>(context_key, std::chrono::seconds(default_ttl_seconds));
                routing_tables_[context_key] = table;
                if (config_.logger) config_.logger->info("[RoutingMgr] 为上下文 '{}' 创建了新的路由表实例 (默认TTL: {}s)。", context_key, default_ttl_seconds);
            }
        }  // 解锁 routing_table_mutex_

        // 确定用于获取此上下文路由表的初始路由器
        // 优先级：1. 配置覆盖 specific_context_key 2. 配置覆盖 "default" 或 "" key 3. 从主URI解析
        bool initial_routers_found = false;
        if (config_.initial_router_addresses_override.count(context_key)) {
            initial_routers_for_this_context = config_.initial_router_addresses_override.at(context_key);
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了配置中覆盖的初始路由器。", context_key);
        }

        if (!initial_routers_found) {
            // 尝试通用的初始路由器配置 (例如，用户可能只配置了一组全局初始路由器)
            std::string generic_initial_router_key = "";  // 或者一个特殊的配置键
            if (config_.initial_router_addresses_override.count(generic_initial_router_key)) {
                initial_routers_for_this_context = config_.initial_router_addresses_override.at(generic_initial_router_key);
                if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
                if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了通用的初始路由器配置。", context_key);
            }
        }

        if (!initial_routers_found && !parsed_initial_uri_.hosts_with_ports.empty() && parsed_initial_uri_.is_routing_scheme) {
            for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                initial_routers_for_this_context.emplace_back(hp.first, hp.second);
            }
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了从主URI解析的初始路由器。", context_key);
        }

        if (!initial_routers_found) {
            if (config_.logger) config_.logger->error("[RoutingMgr] 无法确定用于刷新上下文 '{}' 的初始路由器。", context_key);
            // table->mark_as_stale(); // 确保它被标记为过时
            return nullptr;  // 无法刷新，返回空指针或当前的（可能是过时的）表
        }

        // 如果表已过期，则尝试刷新它
        // 使用一个更细粒度的锁或原子标志来避免在刷新时阻塞其他对此表的请求可能更好，但目前简化处理
        if (table->is_stale()) {
            if (config_.logger) config_.logger->info("[RoutingMgr] 路由表 '{}' 已过期或从未更新，尝试刷新。", context_key);

            // _fetch_and_update_routing_table 内部会连接到路由器并发送 ROUTE 消息
            boltprotocol::BoltError refresh_err = _fetch_and_update_routing_table(table, initial_routers_for_this_context, database_name, impersonated_user);

            if (refresh_err != boltprotocol::BoltError::SUCCESS) {
                if (config_.logger) config_.logger->error("[RoutingMgr] 刷新路由表 '{}' 失败，错误: {}", context_key, static_cast<int>(refresh_err));
                // 保留旧表（可能是空的或过期的），调用者需要处理
                // 或者，如果刷新失败意味着我们无法信任当前表，则返回nullptr
                return nullptr;  // 表示刷新失败
            }
            if (config_.logger) config_.logger->info("[RoutingMgr] 路由表 '{}' 刷新成功。", context_key);
        } else {
            if (config_.logger) config_.logger->trace("[RoutingMgr] 路由表 '{}' 仍然有效，无需刷新。", context_key);
        }
        return table;
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/routing/routing_table.h"

#include <algorithm>  // For std::remove

namespace neo4j_bolt_transport {
    namespace routing {

        RoutingTable::RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds)
            : database_context_key_(std::move(db_context_key)),
              last_updated_time_(std::chrono::steady_clock::time_point::min()),  // Stale by default
              ttl_(ttl_seconds) {
        }

        std::optional<ServerAddress> RoutingTable::get_server(ServerRole role) {
            std::lock_guard<std::mutex> lock(mutex_);
            if (is_stale()) {
                return std::nullopt;
            }

            std::vector<ServerAddress>* server_list = nullptr;
            std::atomic<std::size_t>* index_ptr = nullptr;

            switch (role) {
                case ServerRole::ROUTER:
                    server_list = &routers_;
                    index_ptr = &next_router_index_;
                    break;
                case ServerRole::READER:
                    server_list = &readers_;
                    index_ptr = &next_reader_index_;
                    break;
                case ServerRole::WRITER:
                    server_list = &writers_;
                    index_ptr = &next_writer_index_;
                    break;
            }

            if (!server_list || server_list->empty()) {
                return std::nullopt;
            }

            std::size_t current_index = index_ptr->fetch_add(1, std::memory_order_relaxed);
            return (*server_list)[current_index % server_list->size()];
        }

        boltprotocol::BoltError RoutingTable::update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds) {
            std::lock_guard<std::mutex> lock(mutex_);

            // It's crucial that ROUTE message provides absolute lists, not diffs.
            routers_ = new_routers;
            readers_ = new_readers;
            writers_ = new_writers;
            ttl_ = new_ttl_seconds;
            last_updated_time_ = std::chrono::steady_clock::now();

            next_reader_index_ = 0;
            next_writer_index_ = 0;
            next_router_index_ = 0;  // Reset router index as well

            if (routers_.empty() && (readers_.empty() || writers_.empty())) {
                // A routing table must have routers, or if it's a single-instance-like scenario
                // (no explicit routers), it must at least have readers and writers.
                // If all are empty after an update, it's problematic.
                mark_as_stale();                                         // Mark as stale to force re-fetch or error out
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;  // Or a more specific routing error
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        bool RoutingTable::is_stale() const {
            // No lock needed for reading const members or time_point if access is atomic enough,
            // but ttl_ could change. For safety, or if ttl_ wasn't const, use lock.
            // Here, last_updated_time_ is std::chrono, reads are usually atomic. ttl_ is const after construction until update.
            // For simplicity with mutex_:
            // std::lock_guard<std::mutex> lock(mutex_);
            if (last_updated_time_ == std::chrono::steady_clock::time_point::min()) return true;  // Never updated
            return std::chrono::steady_clock::now() > (last_updated_time_ + ttl_);
        }

        void RoutingTable::mark_as_stale() {
            std::lock_guard<std::mutex> lock(mutex_);
            last_updated_time_ = std::chrono::steady_clock::time_point::min();
        }

        const std::vector<ServerAddress>& RoutingTable::get_routers() const {
            std::lock_guard<std::mutex> lock(mutex_);
            return routers_;
        }

        void RoutingTable::forget_server(const ServerAddress& address) {
            std::lock_guard<std::mutex> lock(mutex_);
            auto remove_addr = [&](std::vector<ServerAddress>& vec) {
                vec.erase(std::remove(vec.begin(), vec.end(), address), vec.end());
            };
            remove_addr(routers_);
            remove_addr(readers_);
            remove_addr(writers_);

            // If forgetting a server makes a critical list empty, table might become stale faster
            if ((database_context_key_ != "system" && (readers_.empty() || writers_.empty())) || routers_.empty()) {
                // For simplicity, just mark stale. More complex logic could try other servers first.
                mark_as_stale();
            }
        }

    }  // namespace routing
}  // namespace neo4j_bolt_transport#include "boltprotocol/message_serialization.h"  // For ROUTE message
#include "boltprotocol/packstream_reader.h"      // For parsing ROUTE response
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 核心的路由表获取和更新逻辑
    boltprotocol::BoltError Neo4jBoltTransport::_fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update,
                                                                                const std::vector<routing::ServerAddress>& routers_to_try,
                                                                                const std::string& database_name_hint,                       // 数据库名称，用于ROUTE消息的参数
                                                                                const std::optional<std::string>& impersonated_user_hint) {  // 模拟用户，用于ROUTE消息

        if (routers_to_try.empty()) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: 没有提供路由器地址。");
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }
        if (!table_to_update) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: table_to_update 为空。");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        boltprotocol::RouteMessageParams route_params;
        // Bolt 4.3-4.4: route_params.routing_table_context (通常为空map)
        // Bolt 5.0+:  route_params.routing_table_context (可包含db, imp_user等)
        // 这里的 routing_table_context 是发送给服务器的，服务器用它来帮助确定它应该返回哪些地址（例如，在NAT后面）
        // 它通常是空的，或者包含客户端连接到此路由器的信息。
        // Neo4j Java驱动通常发送空map作为ROUTE请求的第一个参数（routing_context）。
        route_params.routing_table_context = {};  // 通常为空
        route_params.bookmarks = {};              // 通常在获取路由表时不传递书签

        // 确定ROUTE消息的格式版本
        boltprotocol::versions::Version version_for_route_message = boltprotocol::versions::V5_0;  // 默认使用较新版本
        if (!config_.preferred_bolt_versions.empty()) {
            // 使用驱动配置的最高优先级的 Bolt 版本来序列化 ROUTE 消息
            // 假设连接到的路由器能够理解这个版本
            version_for_route_message = config_.preferred_bolt_versions.front();
        }

        if (version_for_route_message >= boltprotocol::versions::Version(4, 4)) {  // Bolt 4.4+
            route_params.extra_for_v44_plus = std::map<std::string, boltprotocol::Value>();
            if (!database_name_hint.empty()) {
                (*route_params.extra_for_v44_plus)["db"] = database_name_hint;
            }
            // impersonated_user_hint 仅在 Bolt 5.1+ 的 ROUTE 消息中被正式支持于 extra map
            if (impersonated_user_hint.has_value() && !impersonated_user_hint->empty() && version_for_route_message >= boltprotocol::versions::Version(5, 1)) {
                (*route_params.extra_for_v44_plus)["imp_user"] = *impersonated_user_hint;
            }
        } else if (version_for_route_message == boltprotocol::versions::Version(4, 3)) {  // Bolt 4.3
            if (!database_name_hint.empty()) {
                route_params.db_name_for_v43 = database_name_hint;
            }
        } else {
            if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 消息格式不支持 Bolt 版本 {}.{}。", (int)version_for_route_message.major, (int)version_for_route_message.minor);
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
        }

        std::vector<uint8_t> route_payload;
        boltprotocol::PackStreamWriter writer(route_payload);
        boltprotocol::BoltError err = boltprotocol::serialize_route_message(route_params, writer, version_for_route_message);
        if (err != boltprotocol::BoltError::SUCCESS) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] 序列化 ROUTE 消息失败: {}", static_cast<int>(err));
            table_to_update->mark_as_stale();
            return err;
        }

        boltprotocol::SuccessMessageParams success_meta;
        boltprotocol::FailureMessageParams failure_meta;

        for (const auto& router_address_orig : routers_to_try) {
            if (closing_.load(std::memory_order_acquire)) return boltprotocol::BoltError::UNKNOWN_ERROR;  // 驱动正在关闭

            routing::ServerAddress router_address = router_address_orig;
            if (config_.server_address_resolver) {  // 应用地址解析器
                router_address = config_.server_address_resolver(router_address_orig);
            }

            if (config_.logger) config_.logger->debug("[RoutingFetcher] 尝试从路由器 {} (原始: {}) 获取路由表, 目标数据库: '{}'", router_address.to_string(), router_address_orig.to_string(), database_name_hint);

            // 为 HELLO 消息准备路由上下文，这应该是客户端连接到此特定路由器时所使用的地址。
            std::map<std::string, boltprotocol::Value> hello_routing_ctx;
            hello_routing_ctx["address"] = router_address.to_string();  // 发送解析后的地址

            internal::BoltConnectionConfig conn_conf = _create_physical_connection_config(router_address, hello_routing_ctx);
            auto temp_conn_logger = config_.get_or_create_logger("RouteConn");  // 单独的logger实例
            auto temp_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(conn_conf), io_context_, temp_conn_logger);

            if (temp_conn->establish() == boltprotocol::BoltError::SUCCESS) {
                // 检查协商的 Bolt 版本是否与序列化 ROUTE 消息时使用的版本兼容
                if (temp_conn->get_bolt_version() < boltprotocol::versions::Version(4, 3)) {
                    if (config_.logger) config_.logger->warn("[RoutingFetcher] 路由器 {} 使用的 Bolt 版本过低 ({}.{})，不支持现代 ROUTE 消息。", router_address.to_string(), (int)temp_conn->get_bolt_version().major, (int)temp_conn->get_bolt_version().minor);
                    temp_conn->terminate(true);
                    continue;  // 尝试下一个路由器
                }
                // 如果版本不匹配到需要重新序列化的程度，这里会更复杂。
                // 简单假设：如果连接成功，则尝试发送已序列化的ROUTE消息。

                boltprotocol::BoltError route_send_err = temp_conn->send_request_receive_summary(route_payload, success_meta, failure_meta);
                temp_conn->terminate(true);  // 关闭临时连接

                if (route_send_err == boltprotocol::BoltError::SUCCESS && temp_conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                    auto rt_it = success_meta.metadata.find("rt");
                    if (rt_it != success_meta.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second)) {
                        const auto& rt_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second);
                        if (rt_map_ptr) {
                            const auto& rt_data = rt_map_ptr->pairs;
                            long long ttl_val_ll = 0;
                            std::vector<routing::ServerAddress> new_routers, new_readers, new_writers;

                            auto ttl_data_it = rt_data.find("ttl");
                            if (ttl_data_it != rt_data.end() && std::holds_alternative<int64_t>(ttl_data_it->second)) {
                                ttl_val_ll = std::get<int64_t>(ttl_data_it->second);
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中缺少 'ttl' 字段或类型不正确。");
                                // 可以设置一个默认值或标记错误
                            }
                            std::chrono::seconds ttl_val = std::chrono::seconds(ttl_val_ll > 0 ? ttl_val_ll : 300);  // 默认300s

                            auto servers_data_it = rt_data.find("servers");
                            if (servers_data_it != rt_data.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second)) {
                                const auto& servers_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second);
                                if (servers_list_ptr) {
                                    for (const auto& server_item_val : servers_list_ptr->elements) {
                                        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val)) {
                                            const auto& server_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val);
                                            if (server_map_ptr) {
                                                std::string role_str;
                                                std::vector<std::string> addresses_str_list;

                                                auto role_it = server_map_ptr->pairs.find("role");
                                                if (role_it != server_map_ptr->pairs.end() && std::holds_alternative<std::string>(role_it->second)) {
                                                    role_str = std::get<std::string>(role_it->second);
                                                }

                                                auto addrs_it = server_map_ptr->pairs.find("addresses");
                                                if (addrs_it != server_map_ptr->pairs.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second)) {
                                                    const auto& addrs_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second);
                                                    if (addrs_list_ptr) {
                                                        for (const auto& addr_val : addrs_list_ptr->elements) {
                                                            if (std::holds_alternative<std::string>(addr_val)) {
                                                                addresses_str_list.push_back(std::get<std::string>(addr_val));
                                                            }
                                                        }
                                                    }
                                                }

                                                auto parse_host_port = [&](const std::string& addr_str) -> std::optional<routing::ServerAddress> {
                                                    // 移除可能的方案前缀 (bolt://, neo4j:// etc.)
                                                    std::string clean_addr_str = addr_str;
                                                    size_t scheme_end = clean_addr_str.find("://");
                                                    if (scheme_end != std::string::npos) {
                                                        clean_addr_str = clean_addr_str.substr(scheme_end + 3);
                                                    }

                                                    size_t colon_pos = clean_addr_str.rfind(':');
                                                    if (colon_pos == std::string::npos || colon_pos == 0 || colon_pos == clean_addr_str.length() - 1) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher] 地址 '{}' 格式无效 (缺少端口或格式错误)", addr_str);
                                                        return std::nullopt;
                                                    }
                                                    try {
                                                        std::string host_part = clean_addr_str.substr(0, colon_pos);
                                                        // 移除 IPv6 地址的方括号
                                                        if (host_part.length() > 2 && host_part.front() == '[' && host_part.back() == ']') {
                                                            host_part = host_part.substr(1, host_part.length() - 2);
                                                        }
                                                        if (host_part.empty()) {
                                                            if (config_.logger) config_.logger->warn("[RoutingFetcher] 地址 '{}' 解析后主机部分为空", addr_str);
                                                            return std::nullopt;
                                                        }

                                                        uint16_t port = static_cast<uint16_t>(std::stoul(clean_addr_str.substr(colon_pos + 1)));
                                                        return routing::ServerAddress{host_part, port};
                                                    } catch (const std::exception& e) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher] 解析地址 '{}' 端口失败: {}", addr_str, e.what());
                                                        return std::nullopt;
                                                    }
                                                };

                                                std::vector<routing::ServerAddress>* target_list_ptr = nullptr;
                                                if (role_str == "ROUTE")
                                                    target_list_ptr = &new_routers;
                                                else if (role_str == "READ")
                                                    target_list_ptr = &new_readers;
                                                else if (role_str == "WRITE")
                                                    target_list_ptr = &new_writers;

                                                if (target_list_ptr) {
                                                    for (const auto& addr_str : addresses_str_list) {
                                                        if (auto sa_opt = parse_host_port(addr_str)) {
                                                            target_list_ptr->push_back(*sa_opt);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中 'servers' 字段丢失或类型不正确。");
                                }
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中缺少 'rt' 字段或类型不正确。");
                                // 服务器可能返回了错误，但 send_request_receive_summary 认为协议级别是成功的
                                // 这种情况下，temp_conn->get_last_error_code() 可能不是 SUCCESS
                                if (temp_conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 消息的服务器响应指示错误: {}", temp_conn->get_last_error_message());
                                    // 标记为失败并尝试下一个路由器
                                } else {
                                    // 这是一个真正的协议格式问题
                                    table_to_update->mark_as_stale();
                                    return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
                                }
                            }
                            // 成功解析并获得了新的服务器列表
                            boltprotocol::BoltError update_err = table_to_update->update(new_routers, new_readers, new_writers, ttl_val);
                            if (update_err == boltprotocol::BoltError::SUCCESS) {
                                if (config_.logger) {
                                    config_.logger->info(
                                        "[RoutingFetcher] 路由表 '{}' 已成功从 {} 更新。Routers: {}, Readers: {}, Writers: {}, TTL: {}s", table_to_update->get_database_context_key(), router_address.to_string(), new_routers.size(), new_readers.size(), new_writers.size(), ttl_val.count());
                                }
                            } else {
                                if (config_.logger) config_.logger->error("[RoutingFetcher] 更新路由表对象失败，尽管从服务器获取了数据。");
                            }
                            return update_err;  // 返回更新结果
                        }  // success_meta.metadata.find("rt")
                    }  // temp_conn->get_last_error_code() == SUCCESS
                }  // route_send_err == SUCCESS

                // 如果 route_send_err != SUCCESS 或 temp_conn->get_last_error_code() != SUCCESS
                if (config_.logger) {
                    config_.logger->warn(
                        "[RoutingFetcher] 向路由器 {} 发送 ROUTE 消息失败。内部错误: {}, 服务器错误: {} (消息: {})", router_address.to_string(), error::bolt_error_to_string(route_send_err), error::bolt_error_to_string(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
                }
                // 不需要特别处理，循环会尝试下一个路由器

            } else {  // temp_conn->establish() failed
                if (config_.logger) config_.logger->warn("[RoutingFetcher] 无法建立到路由器 {} (原始: {}) 的临时连接。错误: {}, 消息: {}", router_address.to_string(), router_address_orig.to_string(), static_cast<int>(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
            }
            // 如果到此路由器失败，则尝试下一个
        }

        if (config_.logger) config_.logger->error("[RoutingFetcher] 尝试了所有 {} 个路由器，但无法获取路由表 '{}'。", routers_to_try.size(), table_to_update->get_database_context_key());
        table_to_update->mark_as_stale();               // 标记为过时，因为刷新失败
        return boltprotocol::BoltError::NETWORK_ERROR;  // 或者更具体的 "Routing information unavailable"
    }

}  // namespace neo4j_bolt_transport#include <chrono>    // For std::chrono::milliseconds
#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "boltprotocol/message_serialization.h"  // For serialize_..._message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // <--- 添加这一行
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // --- Explicit Transaction Methods ---
    std::pair<boltprotocol::BoltError, std::string> SessionHandle::begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "begin_transaction");
        if (!conn) {
            return conn_check_result;
        }
        auto logger = conn->get_logger();  // conn is valid here

        if (in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to begin transaction while already in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot begin transaction; already in an explicit transaction."};
        }

        boltprotocol::BeginMessageParams params;
        params.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) {
            params.db = session_params_.database_name;
        }
        if (session_params_.impersonated_user.has_value()) {
            params.imp_user = session_params_.impersonated_user;
        }

        // Access mode (Bolt 5.0+)
        if (!(conn->get_bolt_version() < boltprotocol::versions::V5_0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                params.other_extra_fields["mode"] = std::string("r");
            }
        }

        if (tx_metadata.has_value()) {
            params.tx_metadata = *tx_metadata;
        }
        if (tx_timeout_opt.has_value()) {
            params.tx_timeout = static_cast<int64_t>(tx_timeout_opt.value().count());
        }

        std::vector<uint8_t> begin_payload_bytes;
        boltprotocol::PackStreamWriter writer(begin_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_begin_message(params, writer, conn->get_bolt_version());
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("BEGIN serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(begin_payload_bytes, success_meta_raw, failure_meta_raw);

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                in_explicit_transaction_ = true;
                current_transaction_query_id_.reset();
                if (logger) {
                    logger->info("[SessionTX {}] Transaction started. DB: '{}', Mode: '{}', Timeout: {}ms, Meta: {}",
                                 conn->get_id(),
                                 params.db.value_or("<default>"),
                                 (session_params_.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"),
                                 params.tx_timeout.has_value() ? std::to_string(params.tx_timeout.value()) : "N/A",
                                 params.tx_metadata.has_value() && !params.tx_metadata.value().empty() ? "Yes" : "No");
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string server_fail_msg = error::format_server_failure(failure_meta_raw);
                std::string msg = error::format_error_message("BEGIN failed on server", conn->get_last_error_code(), server_fail_msg);
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("BEGIN send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::commit_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "commit_transaction");
        if (!conn) return conn_check_result;
        auto logger = conn->get_logger();  // conn is valid here

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to commit transaction while not in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot commit: not in an explicit transaction."};
        }

        std::vector<uint8_t> commit_payload_bytes;
        boltprotocol::PackStreamWriter writer(commit_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_commit_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("COMMIT serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(commit_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                auto it_bookmark = success_meta_raw.metadata.find("bookmark");
                if (it_bookmark != success_meta_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                } else {
                    if (logger) logger->trace("[SessionTX {}] COMMIT successful but no bookmark returned (Bolt version: {}.{}).", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                    update_bookmarks({});
                }
                if (logger) {
                    logger->info("[SessionTX {}] Transaction committed. New bookmark: {}", conn->get_id(), current_bookmarks_.empty() ? "<none>" : current_bookmarks_[0]);
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("COMMIT failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("COMMIT send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::rollback_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "rollback_transaction (pre-check)");

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (conn)
            logger = conn->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)  // transport_manager_ is checked
            logger = transport_manager_->get_config().logger;

        if (!in_explicit_transaction_) {
            if (logger) logger->trace("[SessionTX {}] Rollback called when not in an explicit transaction. No-op.", (conn ? conn->get_id() : 0));
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        if (!conn) {
            std::string msg = "Rollback attempt with no valid connection while in TX: " + conn_check_result.second;
            if (logger) logger->warn("[SessionTX Rollback] {}", msg);
            _invalidate_session_due_to_connection_error(conn_check_result.first, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {conn_check_result.first, msg};
        }

        std::vector<uint8_t> rollback_payload_bytes;
        boltprotocol::PackStreamWriter writer(rollback_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_rollback_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("ROLLBACK serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(rollback_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                if (logger) {
                    logger->info("[SessionTX {}] Transaction rolled back.", conn->get_id());
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("ROLLBACK failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("ROLLBACK send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "neo4j_bolt_transport/config/session_parameters.h"          // For config::SessionParameters
#include "neo4j_bolt_transport/error/neo4j_error_util.h"             // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // For internal::BoltPhysicalConnection
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"               // For Neo4jBoltTransport access
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    SessionHandle::SessionHandle(Neo4jBoltTransport* transport_mgr, internal::BoltPhysicalConnection::PooledConnection conn_ptr, config::SessionParameters params_val)
        : transport_manager_(transport_mgr), connection_(std::move(conn_ptr)), session_params_(std::move(params_val)), current_bookmarks_(session_params_.initial_bookmarks) {  // 从会话参数初始化书签

        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // 安全访问 logger
            drv_logger = transport_manager_->get_config().logger;
        }

        if (!transport_manager_) {
            connection_is_valid_ = false;
            is_closed_ = true;
            if (drv_logger) drv_logger->error("[SessionLC] SessionHandle created without a valid transport manager.");
            // connection_ 此时为 nullptr，_release_connection_to_pool 不会做任何事
            return;
        }

        std::shared_ptr<spdlog::logger> conn_logger = nullptr;
        if (connection_ && connection_->get_logger()) {
            conn_logger = connection_->get_logger();
        } else if (drv_logger) {
            conn_logger = drv_logger;  // 后备
        }

        if (!connection_ || !connection_->is_ready_for_queries()) {
            boltprotocol::BoltError last_err = connection_ ? connection_->get_last_error_code() : boltprotocol::BoltError::NETWORK_ERROR;
            std::string last_err_msg = connection_ ? connection_->get_last_error_message() : "Connection pointer null or not ready at SessionHandle construction.";

            if (conn_logger) conn_logger->warn("[SessionLC {}] Connection not ready at SessionHandle construction. Error: {}, Msg: {}", connection_ ? connection_->get_id() : 0, static_cast<int>(last_err), last_err_msg);
            _invalidate_session_due_to_connection_error(last_err, "SessionHandle construction: " + last_err_msg);
            _release_connection_to_pool(false);  // 释放可能坏掉的连接
        } else {
            connection_->mark_as_used();
            if (conn_logger) conn_logger->debug("[SessionLC {}] SessionHandle constructed with ready connection.", connection_->get_id());
        }
    }

    SessionHandle::~SessionHandle() {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] SessionHandle destructing. Closed: {}, InTx: {}", (connection_ ? connection_->get_id() : 0), is_closed_, in_explicit_transaction_);
        close();  // 确保所有资源都被正确关闭和释放
    }

    SessionHandle::SessionHandle(SessionHandle&& other) noexcept
        : transport_manager_(other.transport_manager_),
          connection_(std::move(other.connection_)),
          session_params_(std::move(other.session_params_)),
          in_explicit_transaction_(other.in_explicit_transaction_),
          current_transaction_query_id_(other.current_transaction_query_id_),
          current_bookmarks_(std::move(other.current_bookmarks_)),
          is_closed_(other.is_closed_),
          connection_is_valid_(other.connection_is_valid_) {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->trace("[SessionLC {}] SessionHandle move constructed from old SessionHandle.", (connection_ ? connection_->get_id() : 0));

        other.transport_manager_ = nullptr;  // other 现在无效
        other.is_closed_ = true;
        other.connection_is_valid_ = false;
    }

    SessionHandle& SessionHandle::operator=(SessionHandle&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = nullptr;
            if (connection_ && connection_->get_logger())
                logger = connection_->get_logger();
            else if (transport_manager_ && transport_manager_->get_config().logger)
                logger = transport_manager_->get_config().logger;
            if (logger) logger->trace("[SessionLC {}] SessionHandle move assigning from other SessionHandle.", (connection_ ? connection_->get_id() : 0));

            close();  // 首先关闭当前会话

            transport_manager_ = other.transport_manager_;
            connection_ = std::move(other.connection_);
            session_params_ = std::move(other.session_params_);
            in_explicit_transaction_ = other.in_explicit_transaction_;
            current_transaction_query_id_ = other.current_transaction_query_id_;
            current_bookmarks_ = std::move(other.current_bookmarks_);
            is_closed_ = other.is_closed_;
            connection_is_valid_ = other.connection_is_valid_;

            other.transport_manager_ = nullptr;  // other 现在无效
            other.is_closed_ = true;
            other.connection_is_valid_ = false;
        }
        return *this;
    }

    void SessionHandle::_release_connection_to_pool(bool mark_healthy) {
        if (connection_ && transport_manager_) {
            std::shared_ptr<spdlog::logger> logger = connection_->get_logger();  // 优先使用连接的logger
            uint64_t conn_id = connection_->get_id();
            if (logger) logger->trace("[SessionLC conn_id={}] Releasing connection to pool. Healthy: {}", conn_id, mark_healthy && connection_is_valid_);
            transport_manager_->release_connection(std::move(connection_), mark_healthy && connection_is_valid_);
            // connection_ 现在为 nullptr
        }
        connection_is_valid_ = false;  // 释放后，会话不再拥有有效连接
    }

    void SessionHandle::close() {
        if (is_closed_) {
            return;
        }

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] Closing SessionHandle. InTx: {}", (connection_ ? connection_->get_id() : 0), in_explicit_transaction_);

        if (in_explicit_transaction_ && connection_is_valid_ && connection_ && connection_->is_ready_for_queries()) {
            if (logger) logger->info("[SessionLC {}] Rolling back active transaction during close.", connection_->get_id());
            rollback_transaction();  // 这会将 in_explicit_transaction_ 设为 false
        }
        _release_connection_to_pool(connection_is_valid_);  // 根据当前连接的有效性状态释放
        is_closed_ = true;
    }

    void SessionHandle::_invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message) {
        connection_is_valid_ = false;
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            logger->warn("[SessionLC {}] Session invalidated due to connection error. Code: {} ({}), Context: {}",
                         (connection_ ? connection_->get_id() : 0),
                         static_cast<int>(error),
                         error::bolt_error_to_string(error),  // 添加错误码的字符串表示
                         context_message);
        }
    }

    internal::BoltPhysicalConnection* SessionHandle::_get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed_) {
            out_err_pair = {boltprotocol::BoltError::INVALID_ARGUMENT, "Operation on closed session: " + operation_context};
            if (drv_logger) drv_logger->warn("[SessionOp] {}", out_err_pair.second);
            return nullptr;
        }
        if (!connection_is_valid_ || !connection_) {
            out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "No valid connection for operation: " + operation_context};
            std::shared_ptr<spdlog::logger> log_to_use = (connection_ && connection_->get_logger()) ? connection_->get_logger() : drv_logger;
            if (log_to_use) log_to_use->warn("[SessionOp conn_id={}] {}", (connection_ ? connection_->get_id() : 0), out_err_pair.second);
            return nullptr;
        }

        if (!connection_->is_ready_for_queries()) {
            out_err_pair = {connection_->get_last_error_code(), connection_->get_last_error_message()};
            if (out_err_pair.first == boltprotocol::BoltError::SUCCESS) {  // 如果 is_ready 为 false 但上次错误是 SUCCESS，则有问题
                out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "Connection reported not ready for queries despite no specific error."};
            }
            std::string context_msg_full = operation_context + " (connection not ready: " + out_err_pair.second + ")";
            _invalidate_session_due_to_connection_error(out_err_pair.first, context_msg_full);  // 传递更详细的上下文
            if (connection_->get_logger()) connection_->get_logger()->warn("[SessionOp conn_id={}] {}", connection_->get_id(), context_msg_full);
            return nullptr;
        }

        connection_->mark_as_used();
        out_err_pair = {boltprotocol::BoltError::SUCCESS, ""};
        return connection_.get();
    }

    const std::vector<std::string>& SessionHandle::get_last_bookmarks() const {
        return current_bookmarks_;
    }

    void SessionHandle::update_bookmarks(const std::vector<std::string>& new_bookmarks) {
        if (is_closed_) return;
        current_bookmarks_ = new_bookmarks;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            std::string bookmarks_str;
            if (new_bookmarks.empty()) {
                bookmarks_str = "<empty>";
            } else {
                for (size_t i = 0; i < new_bookmarks.size(); ++i) {
                    bookmarks_str += new_bookmarks[i] + (i == new_bookmarks.size() - 1 ? "" : ", ");
                }
            }
            logger->trace("[SessionLC {}] Bookmarks updated to: [{}]", (connection_ ? connection_->get_id() : 0), bookmarks_str);
        }
    }

}  // namespace neo4j_bolt_transport#include <utility>  // For std::move

#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionWork typedef
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        // Note: The mode_hint (AccessMode::READ) is passed to _execute_transaction_work_internal.
        // That internal function will temporarily set session_params_.default_access_mode
        // for the duration of the managed transaction.
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::READ, tx_metadata, tx_timeout);
    }

    TransactionWorkResult SessionHandle::execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::WRITE, tx_metadata, tx_timeout);
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <chrono>     // For std::chrono::milliseconds
#include <iostream>   // 调试用
#include <thread>     // For std::this_thread::sleep_for
#include <utility>    // For std::move

#include "neo4j_bolt_transport/config/transport_config.h"  // For retry config access
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"       // For transport_manager_ to get config
#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionContext definition
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::_execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // Check transport_manager_
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed()) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Session is closed, cannot execute transaction work.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Session is closed, cannot execute transaction work."};
        }
        if (in_explicit_transaction_) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Cannot start managed transaction; an explicit transaction is already active.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot start managed transaction; an explicit transaction is already active."};
        }

        uint32_t max_retry_time_ms = 30000;
        uint32_t current_delay_ms = 1000;
        uint32_t max_delay_ms = 60000;
        double multiplier = 2.0;

        if (transport_manager_) {
            const auto& driver_conf = transport_manager_->get_config();
            max_retry_time_ms = driver_conf.max_transaction_retry_time_ms;
            current_delay_ms = driver_conf.transaction_retry_delay_initial_ms > 0 ? driver_conf.transaction_retry_delay_initial_ms : 1000;
            max_delay_ms = driver_conf.transaction_retry_delay_max_ms > 0 ? driver_conf.transaction_retry_delay_max_ms : 60000;
            multiplier = driver_conf.transaction_retry_delay_multiplier > 1 ? static_cast<double>(driver_conf.transaction_retry_delay_multiplier) : 2.0;
        }

        auto overall_deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(max_retry_time_ms);
        TransactionWorkResult last_attempt_result = {boltprotocol::BoltError::UNKNOWN_ERROR, "Transaction work did not complete successfully within retry budget."};
        int attempt_count = 0;

        config::AccessMode original_session_access_mode = session_params_.default_access_mode;
        session_params_.default_access_mode = mode_hint;

        while (std::chrono::steady_clock::now() < overall_deadline) {
            attempt_count++;
            std::shared_ptr<spdlog::logger> current_op_logger = drv_logger;

            std::pair<boltprotocol::BoltError, std::string> conn_check_for_log;
            internal::BoltPhysicalConnection* temp_conn_for_log_check = _get_valid_connection_for_operation(conn_check_for_log, "managed_tx_log_setup");
            if (temp_conn_for_log_check && temp_conn_for_log_check->get_logger()) {
                current_op_logger = temp_conn_for_log_check->get_logger();
            }

            if (current_op_logger) {
                current_op_logger->debug("[SessionTX Managed][Attempt {}] Starting transaction work (Mode: {}).", attempt_count, (mode_hint == config::AccessMode::READ ? "READ" : "WRITE"));
            }

            std::pair<boltprotocol::BoltError, std::string> pre_begin_conn_check;
            if (!_get_valid_connection_for_operation(pre_begin_conn_check, "managed_tx_pre_begin")) {
                last_attempt_result = {pre_begin_conn_check.first, "Managed TX: Connection unavailable before BEGIN (Attempt " + std::to_string(attempt_count) + "): " + pre_begin_conn_check.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                bool is_retryable_failure = (pre_begin_conn_check.first == boltprotocol::BoltError::NETWORK_ERROR || pre_begin_conn_check.first == boltprotocol::BoltError::HANDSHAKE_FAILED);  // More specific retry conditions
                if (is_retryable_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection unavailability before BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    // If connection was invalidated, _release_connection_to_pool would have been called.
                    // Next iteration _get_valid_connection_for_operation will try to get a new one if pool manager is used.
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            auto begin_res = begin_transaction(tx_metadata, tx_timeout_opt);
            if (begin_res.first != boltprotocol::BoltError::SUCCESS) {
                bool is_retryable_begin_failure = (begin_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                last_attempt_result = {begin_res.first, "Managed TX: Failed to begin (Attempt " + std::to_string(attempt_count) + "): " + begin_res.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                if (is_retryable_begin_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            if (connection_ && connection_->get_logger()) current_op_logger = connection_->get_logger();

            TransactionContext tx_context(*this);
            TransactionWorkResult work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "User work lambda not called."};

            try {
                work_res = work(tx_context);
            } catch (const std::exception& e) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Exception from user transaction work: " + std::string(e.what())};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Exception in user work: {}", e.what());
            } catch (...) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Unknown exception from user transaction work."};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Unknown exception in user work.");
            }

            if (!connection_is_valid_) {
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Connection became invalid during user work. Last conn error code: {}", connection_ ? static_cast<int>(connection_->get_last_error_code()) : -1);
                work_res = {boltprotocol::BoltError::NETWORK_ERROR, "Connection lost during transaction work execution."};
                rollback_transaction();
                last_attempt_result = work_res;
                if (std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection loss in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                } else {
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            }

            if (work_res.first == boltprotocol::BoltError::SUCCESS) {
                auto commit_res = commit_transaction();
                if (commit_res.first == boltprotocol::BoltError::SUCCESS) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Transaction work committed successfully.");
                    session_params_.default_access_mode = original_session_access_mode;
                    return {boltprotocol::BoltError::SUCCESS, ""};
                } else {
                    last_attempt_result = {commit_res.first, "Managed TX: Commit failed (Attempt " + std::to_string(attempt_count) + "): " + commit_res.second};
                    if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);
                    bool is_commit_retryable = (commit_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                    // Potentially check for specific Neo4j error codes from commit_res.second if available
                    if (is_commit_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                        if (current_op_logger) current_op_logger->info("[SessionTX Managed] COMMIT failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                        std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                        current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                        continue;
                    }
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            } else {  // User lambda returned error
                auto rollback_res = rollback_transaction();
                if (rollback_res.first != boltprotocol::BoltError::SUCCESS && connection_is_valid_ && current_op_logger) {
                    current_op_logger->warn("[SessionTX Managed] Rollback failed after work error ('{}'): {}", work_res.second, rollback_res.second);
                }
                last_attempt_result = work_res;
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Work failed (Attempt {}): {}", attempt_count, work_res.second);
                bool is_work_error_retryable = (work_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                // Potentially check for specific Neo4j error codes for retry
                if (is_work_error_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Work failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }
        }

        if (drv_logger) {
            drv_logger->warn("[SessionTX Managed] Transaction work failed after all {} retries or timeout. Last error: {}", attempt_count, last_attempt_result.second);
        }
        session_params_.default_access_mode = original_session_access_mode;
        return last_attempt_result;
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"  // For serialize_run_message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // Required for transport_manager_ access
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> SessionHandle::run_query(const std::string& cypher,
                                                                                                                           const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                           const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        boltprotocol::SuccessMessageParams run_summary_raw;
        boltprotocol::FailureMessageParams run_failure_details_raw;
        std::pair<boltprotocol::BoltError, std::string> prepare_result = {boltprotocol::BoltError::SUCCESS, ""};
        std::optional<int64_t> qid_for_stream;
        bool server_can_have_more_records_after_run = false;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string current_server_address = "unknown_server:0";
        boltprotocol::versions::Version current_bolt_version(0, 0);
        bool current_utc_patch_active = false;

        std::pair<boltprotocol::BoltError, std::string> conn_check_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_pair, "run_query (initial check)");

        if (conn) {
            logger = conn->get_logger();
            current_server_address = conn->get_config().target_host + ":" + std::to_string(conn->get_config().target_port);
            current_bolt_version = conn->get_bolt_version();
            current_utc_patch_active = conn->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (!conn) {
            prepare_result = conn_check_pair;
            if (logger) logger->warn("[SessionExec] run_query: Connection unavailable. Error: {}, Msg: {}", static_cast<int>(prepare_result.first), prepare_result.second);
        } else {
            std::optional<std::map<std::string, boltprotocol::Value>> metadata_to_pass;
            std::optional<std::chrono::milliseconds> timeout_to_pass;

            if (tx_config_overrides.has_value()) {
                metadata_to_pass = tx_config_overrides->metadata;
                timeout_to_pass = tx_config_overrides->timeout;
            } else {  // Use defaults from TransportConfig if no overrides
                if (transport_manager_ && transport_manager_->get_config().explicit_transaction_timeout_default_ms > 0 && !is_in_transaction()) {
                    timeout_to_pass = std::chrono::milliseconds(transport_manager_->get_config().explicit_transaction_timeout_default_ms);
                }
            }

            if (is_in_transaction()) {
                if (metadata_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_metadata_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                if (timeout_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_timeout_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                // For explicit TX, RUN does not take metadata/timeout. Those are on BEGIN.
                prepare_result = _prepare_explicit_tx_run(cypher, parameters, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = current_transaction_query_id_;  // Set by _prepare_explicit_tx_run
                    server_can_have_more_records_after_run = true;
                }
            } else {  // Auto-commit
                prepare_result = _prepare_auto_commit_run(cypher, parameters, metadata_to_pass, timeout_to_pass, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = std::nullopt;
                    auto it_qid = run_summary_raw.metadata.find("qid");
                    if (it_qid != run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                        qid_for_stream = std::get<int64_t>(it_qid->second);
                    }
                    server_can_have_more_records_after_run = true;
                }
            }
        }

        std::shared_ptr<std::vector<std::string>> fields_ptr = std::make_shared<std::vector<std::string>>();
        auto it_fields = run_summary_raw.metadata.find("fields");
        if (it_fields != run_summary_raw.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
            if (list_ptr) {
                fields_ptr->reserve(list_ptr->elements.size());
                for (const auto& field_val : list_ptr->elements) {
                    if (std::holds_alternative<std::string>(field_val)) {
                        fields_ptr->push_back(std::get<std::string>(field_val));
                    }
                }
            }
        }

        if (logger && prepare_result.first == boltprotocol::BoltError::SUCCESS) {
            logger->debug("[SessionExec] run_query successful prep. Fields: {}. QID for stream: {}", fields_ptr->size(), qid_for_stream.has_value() ? std::to_string(qid_for_stream.value()) : "none");
        }

        auto result_stream = std::make_unique<BoltResultStream>(this,
                                                                qid_for_stream,
                                                                std::move(run_summary_raw),
                                                                fields_ptr,
                                                                std::vector<boltprotocol::RecordMessageParams>{},
                                                                server_can_have_more_records_after_run,
                                                                current_bolt_version,
                                                                current_utc_patch_active,
                                                                current_server_address,
                                                                session_params_.database_name,
                                                                prepare_result.first,
                                                                prepare_result.second,
                                                                (prepare_result.first != boltprotocol::BoltError::SUCCESS ? std::make_optional(run_failure_details_raw) : std::nullopt));

        return {std::move(prepare_result), std::move(result_stream)};
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> SessionHandle::run_query_and_consume(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                   const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string srv_addr_cache = "unknown_server:0";
        boltprotocol::versions::Version bolt_ver_cache(0, 0);
        bool utc_patch_cache = false;

        if (connection_) {
            if (connection_->get_logger()) logger = connection_->get_logger();
            srv_addr_cache = connection_->get_config().target_host + ":" + std::to_string(connection_->get_config().target_port);
            bolt_ver_cache = connection_->get_bolt_version();
            utc_patch_cache = connection_->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume starting for cypher: {:.30}...", cypher);

        auto [initial_err_pair, result_stream_ptr] = run_query(cypher, parameters, tx_config_overrides);  // Pass overrides

        if (initial_err_pair.first != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: run_query failed initially. Error: {}, Msg: {}", static_cast<int>(initial_err_pair.first), initial_err_pair.second);
            if (result_stream_ptr) {
                boltprotocol::SuccessMessageParams params_copy = result_stream_ptr->get_run_summary().raw_params();
                return {initial_err_pair, ResultSummary(std::move(params_copy), bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
            }
            return {initial_err_pair, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        if (!result_stream_ptr) {
            if (logger) logger->error("[SessionExec] run_query_and_consume: Internal error - run_query succeeded but returned null stream.");
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, "Null result stream post run_query."}, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        auto [consume_err_code, consume_err_msg, final_summary_typed] = result_stream_ptr->consume();

        if (consume_err_code != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: stream consume failed. Error: {}, Msg: {}", static_cast<int>(consume_err_code), consume_err_msg);
            return {{consume_err_code, std::move(consume_err_msg)}, std::move(final_summary_typed)};
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume successful.");

        if (!connection_is_valid_) {
            boltprotocol::BoltError conn_last_err = boltprotocol::BoltError::NETWORK_ERROR;
            std::string conn_last_msg = "Connection lost during operation.";
            if (connection_ && connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                conn_last_err = connection_->get_last_error_code();
                conn_last_msg = connection_->get_last_error_message();
                if (logger) logger->warn("[SessionExec] run_query_and_consume: Connection became invalid. Last conn error: {}", conn_last_msg);
            } else if (logger) {
                logger->warn("[SessionExec] run_query_and_consume: Connection became invalid (no specific error).");
            }
            return {{conn_last_err, conn_last_msg}, std::move(final_summary_typed)};
        }
        return {{boltprotocol::BoltError::SUCCESS, ""}, std::move(final_summary_typed)};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::run_query_without_result(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        auto [err_pair_outer, summary_typed] = run_query_and_consume(cypher, parameters, tx_config_overrides);  // Pass overrides
        return err_pair_outer;
    }
}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_auto_commit_run(const std::string& cypher,
                                                                                            const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,
                                                                                            const std::optional<std::chrono::milliseconds>& tx_timeout,
                                                                                            boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                            boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_auto_commit_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;
        run_p.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) run_p.db = session_params_.database_name;
        if (session_params_.impersonated_user.has_value()) run_p.imp_user = session_params_.impersonated_user;

        // Compare with a constructed Version object for Bolt 5.0
        if (conn->get_bolt_version() < boltprotocol::versions::Version(5, 0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                run_p.mode = "r";
            }
        }

        if (tx_metadata.has_value()) {
            run_p.tx_metadata = tx_metadata.value();
        }
        if (tx_timeout.has_value()) {
            run_p.tx_timeout = static_cast<int64_t>(tx_timeout.value().count());
        }

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_writer(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_writer, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger)
            logger->trace(
                "[SessionStream {}] Sending auto-commit RUN. Cypher: {:.30}, Timeout: {}ms, Meta: {}", conn->get_id(), cypher, run_p.tx_timeout.has_value() ? std::to_string(run_p.tx_timeout.value()) : "N/A", run_p.tx_metadata.has_value() && !run_p.tx_metadata.value().empty() ? "Yes" : "No");

        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }
        if (conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Auto-commit RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }

        if (logger) logger->trace("[SessionStream {}] Auto-commit RUN successful, got its summary.", conn->get_id());
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_explicit_tx_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionStream {}] _prepare_explicit_tx_run called when not in transaction.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot run query in explicit TX mode; not in transaction."};
        }

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_w(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_w, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending explicit TX RUN. Cypher: {:.30}", conn->get_id(), cypher);
        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            current_transaction_query_id_.reset();
            // Compare with a constructed Version object for Bolt 4.0
            if (!(conn->get_bolt_version() < boltprotocol::versions::Version(4, 0))) {  // If Bolt version is >= 4.0
                auto it_qid = out_run_summary_raw.metadata.find("qid");
                if (it_qid != out_run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                    current_transaction_query_id_ = std::get<int64_t>(it_qid->second);
                    if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful, qid: {}.", conn->get_id(), *current_transaction_query_id_);
                } else {
                    if (logger) logger->warn("[SessionStream {}] Missing qid in RUN SUCCESS for explicit transaction (Bolt version {}.{}). Subsequent PULL/DISCARD may need to be implicit.", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                }
            } else {
                if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful (Bolt < 4.0, no qid expected from RUN).", conn->get_id());
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Explicit TX RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_pull_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::PullMessageParams pull_p;
        pull_p.n = n;
        pull_p.qid = qid;

        std::vector<uint8_t> pull_payload_bytes;
        boltprotocol::PackStreamWriter writer(pull_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_pull_message(pull_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending PULL (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;

        auto record_processor = [&](boltprotocol::MessageTag /*tag*/, const std::vector<uint8_t>& rec_payload, internal::BoltPhysicalConnection& /*connection_ref*/) {
            boltprotocol::RecordMessageParams rec;
            boltprotocol::PackStreamReader r(rec_payload);
            if (boltprotocol::deserialize_record_message(r, rec) == boltprotocol::BoltError::SUCCESS) {
                out_records.push_back(std::move(rec));
                return boltprotocol::BoltError::SUCCESS;
            }
            if (logger) logger->error("[SessionStream {}] Failed to deserialize RECORD message during PULL.", conn->get_id());
            return boltprotocol::BoltError::DESERIALIZATION_ERROR;
        };

        err = conn->send_request_receive_stream(pull_payload_bytes, record_processor, out_pull_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL stream processing", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_pull_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_pull_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after PULL: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after PULL, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) {
                bool has_more = false;
                auto it_has_more = out_pull_summary_raw.metadata.find("has_more");
                if (it_has_more != out_pull_summary_raw.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more = std::get<bool>(it_has_more->second);
                }
                logger->trace("[SessionStream {}] PULL successful. Records received: {}. HasMore: {}", conn->get_id(), out_records.size(), has_more);
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("PULL server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_discard_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::DiscardMessageParams discard_p;
        discard_p.n = n;
        discard_p.qid = qid;

        std::vector<uint8_t> discard_payload_bytes;
        boltprotocol::PackStreamWriter writer(discard_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_discard_message(discard_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending DISCARD (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;
        err = conn->send_request_receive_summary(discard_payload_bytes, out_discard_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_discard_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_discard_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after DISCARD: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after DISCARD, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) logger->trace("[SessionStream {}] DISCARD successful.", conn->get_id());
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("DISCARD server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/uri/uri_parser.h"

#include <algorithm>  // For std::transform, std::remove_if
#include <cctype>     // For std::tolower, std::isspace
#include <stdexcept>  // For std::stoi, std::stoul exceptions

namespace neo4j_bolt_transport {
    namespace uri {

        // Basic URL decoding (handles %XY and +)
        static std::string url_decode_component(const std::string& encoded) {
            std::string decoded;
            decoded.reserve(encoded.length());
            for (size_t i = 0; i < encoded.length(); ++i) {
                if (encoded[i] == '%' && i + 2 < encoded.length()) {
                    try {
                        std::string hex = encoded.substr(i + 1, 2);
                        char c = static_cast<char>(std::stoi(hex, nullptr, 16));
                        decoded += c;
                        i += 2;
                    } catch (const std::invalid_argument&) {  // Not a hex number
                        decoded += '%';                       // Treat as literal '%'
                    } catch (const std::out_of_range&) {      // Hex value too large for char
                        decoded += '%';                       // Treat as literal '%'
                    }
                } else if (encoded[i] == '+') {
                    decoded += ' ';
                } else {
                    decoded += encoded[i];
                }
            }
            return decoded;
        }

        // Helper to trim leading/trailing whitespace
        static std::string trim_whitespace(const std::string& s) {
            auto first = std::find_if_not(s.begin(), s.end(), [](unsigned char c) {
                return std::isspace(c);
            });
            if (first == s.end()) return "";  // String is all whitespace
            auto last = std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {
                            return std::isspace(c);
                        }).base();
            return std::string(first, last);
        }

        boltprotocol::BoltError UriParser::parse(const std::string& uri_string, ParsedUri& out_parsed_uri) {
            out_parsed_uri = {};  // Reset
            out_parsed_uri.input_uri = uri_string;

            if (uri_string.empty()) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 1. Scheme
            size_t scheme_end_pos = uri_string.find("://");
            if (scheme_end_pos == std::string::npos || scheme_end_pos == 0) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            out_parsed_uri.scheme = uri_string.substr(0, scheme_end_pos);
            std::transform(out_parsed_uri.scheme.begin(), out_parsed_uri.scheme.end(), out_parsed_uri.scheme.begin(), [](unsigned char c) {
                return std::tolower(c);
            });

            std::string remaining_uri = uri_string.substr(scheme_end_pos + 3);
            if (remaining_uri.empty() || remaining_uri[0] == '/' || remaining_uri[0] == '?') {  // Authority must exist
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 2. Authority (and userinfo within it)
            size_t authority_terminator_pos = remaining_uri.find_first_of("/?");
            std::string authority_part_full = remaining_uri.substr(0, authority_terminator_pos);

            std::string path_and_query_part;
            if (authority_terminator_pos != std::string::npos) {
                path_and_query_part = remaining_uri.substr(authority_terminator_pos);
            }

            // Userinfo (username:password@)
            size_t userinfo_terminator_pos = authority_part_full.find('@');
            std::string host_port_list_str = authority_part_full;

            if (userinfo_terminator_pos != std::string::npos) {
                std::string userinfo_str = authority_part_full.substr(0, userinfo_terminator_pos);
                host_port_list_str = authority_part_full.substr(userinfo_terminator_pos + 1);
                if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host missing after @

                size_t password_delim_pos = userinfo_str.find(':');
                if (password_delim_pos != std::string::npos) {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str.substr(0, password_delim_pos));
                    out_parsed_uri.password_from_uri = url_decode_component(userinfo_str.substr(password_delim_pos + 1));
                } else {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str);
                }
            }
            if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host(s) part is mandatory

            // Parse host(s) and port(s)
            // Host part can be a comma-separated list for routing schemes
            size_t current_token_pos = 0;
            while (current_token_pos < host_port_list_str.length()) {
                size_t next_host_separator = host_port_list_str.find(',', current_token_pos);
                std::string current_host_port_token = trim_whitespace(host_port_list_str.substr(current_token_pos, next_host_separator - current_token_pos));
                if (current_host_port_token.empty()) {  // Handles cases like ",," or leading/trailing commas
                    if (next_host_separator == std::string::npos) break;
                    current_token_pos = next_host_separator + 1;
                    continue;
                }

                std::string current_host_str;
                uint16_t current_port_val = 0;  // Default based on scheme later if not specified here

                size_t port_separator_pos = current_host_port_token.rfind(':');
                size_t ipv6_bracket_end_pos = current_host_port_token.rfind(']');

                if (port_separator_pos != std::string::npos && (ipv6_bracket_end_pos == std::string::npos || port_separator_pos > ipv6_bracket_end_pos)) {
                    // Port is specified
                    current_host_str = trim_whitespace(current_host_port_token.substr(0, port_separator_pos));
                    std::string port_str = trim_whitespace(current_host_port_token.substr(port_separator_pos + 1));
                    if (port_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port num missing after ':'
                    try {
                        unsigned long p_val = std::stoul(port_str);
                        if (p_val == 0 || p_val > 65535) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Invalid port range
                        current_port_val = static_cast<uint16_t>(p_val);
                    } catch (const std::exception&) {                      // std::invalid_argument or std::out_of_range
                        return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port not a number or out of range
                    }
                } else {
                    // No port specified for this token
                    current_host_str = current_host_port_token;
                }

                // Remove IPv6 brackets if present
                if (current_host_str.length() >= 2 && current_host_str.front() == '[' && current_host_str.back() == ']') {
                    current_host_str = current_host_str.substr(1, current_host_str.length() - 2);
                }
                if (current_host_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host cannot be empty

                out_parsed_uri.hosts_with_ports.emplace_back(current_host_str, current_port_val);

                if (next_host_separator == std::string::npos) break;
                current_token_pos = next_host_separator + 1;
            }
            if (out_parsed_uri.hosts_with_ports.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // No valid host found

            // 3. Query Parameters (Path component is usually ignored or used for specific DB in some drivers, simplified here)
            if (!path_and_query_part.empty()) {
                size_t query_start_pos = path_and_query_part.find('?');
                if (query_start_pos != std::string::npos) {
                    std::string query_string = path_and_query_part.substr(query_start_pos + 1);
                    size_t current_param_pos = 0;
                    while (current_param_pos < query_string.length()) {
                        size_t next_amp_pos = query_string.find('&', current_param_pos);
                        std::string param_pair_str = query_string.substr(current_param_pos, next_amp_pos - current_param_pos);
                        size_t eq_pos = param_pair_str.find('=');
                        if (eq_pos != std::string::npos) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str.substr(0, eq_pos)));
                            std::string value = trim_whitespace(url_decode_component(param_pair_str.substr(eq_pos + 1)));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = value;
                        } else if (!param_pair_str.empty()) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = "";
                        }
                        if (next_amp_pos == std::string::npos) break;
                        current_param_pos = next_amp_pos + 1;
                    }
                }
            }

            // Apply scheme-specific logic and default ports
            uint16_t default_port_for_scheme = 0;

            if (out_parsed_uri.scheme == "bolt") {
                out_parsed_uri.tls_enabled_by_scheme = false;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "bolt+s") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "bolt+ssc") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = false;  // Routing table will dictate TLS for resolved servers
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+s") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+ssc") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else {
                return boltprotocol::BoltError::INVALID_ARGUMENT;  // Unknown scheme
            }

            // Apply default port if any host_with_port has port 0
            for (auto& host_port_pair : out_parsed_uri.hosts_with_ports) {
                if (host_port_pair.second == 0) {
                    if (default_port_for_scheme == 0) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Scheme needs explicit port
                    host_port_pair.second = default_port_for_scheme;
                }
            }

            out_parsed_uri.is_valid = true;
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace uri
}  // namespace neo4j_bolt_transport