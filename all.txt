This file contains the full license text of the included third party
libraries. For an overview of the licenses see the NOTICE.txt file.


------------------------------------------------------------------------------
Apache Software License, Version 2.0
  Neo4j Bolt Connection (Bolt Provider reference impl)
  Neo4j Bolt Connection (Pooled Source impl)
  Neo4j Bolt Connection (Provider SPI)
  Neo4j Bolt Connection (Routed Source impl)
  Netty/Buffer
  Netty/Codec/Base
  Netty/Common
  Netty/Handler
  Netty/Resolver
  Netty/TomcatNative [OpenSSL - Classes]
  Netty/Transport
  Netty/Transport/Native/Unix/Common
  Non-Blocking Reactive Foundation for the JVM
------------------------------------------------------------------------------

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



------------------------------------------------------------------------------
MIT No Attribution License
  reactive-streams
------------------------------------------------------------------------------

MIT No Attribution

Copyright <year> <copyright holders>

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.




Copyright (c) "Neo4j"
Neo4j Sweden AB [https://neo4j.com]

This file is part of Neo4j.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Full license texts are found in LICENSES.txt.


Third-party licenses
--------------------

Apache Software License, Version 2.0
  Neo4j Bolt Connection (Bolt Provider reference impl)
  Neo4j Bolt Connection (Pooled Source impl)
  Neo4j Bolt Connection (Provider SPI)
  Neo4j Bolt Connection (Routed Source impl)
  Netty/Buffer
  Netty/Codec/Base
  Netty/Common
  Netty/Handler
  Netty/Resolver
  Netty/TomcatNative [OpenSSL - Classes]
  Netty/Transport
  Netty/Transport/Native/Unix/Common
  Non-Blocking Reactive Foundation for the JVM

MIT No Attribution License
  reactive-streams

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.neo4j.driver</groupId>
    <artifactId>neo4j-java-driver-parent</artifactId>
    <version>6.0-SNAPSHOT</version>
  </parent>

  <groupId>org.neo4j.doc.driver</groupId>
  <artifactId>neo4j-java-driver-examples</artifactId>

  <packaging>jar</packaging>
  <name>Neo4j Java Driver Examples</name>
  <description>Examples of using the Neo4j graph database through Java</description>
  <url>https://github.com/neo4j/neo4j-java-driver</url>

  <properties>
    <rootDir>${project.basedir}/..</rootDir>
    <!-- Turned off because it moves/deletes example tags and needs investigation. -->
    <spotless.check.skip>true</spotless.check.skip>
    <spotless.apply.skip>true</spotless.apply.skip>
  </properties>

  <dependencies>
    <!-- Compile dependencies -->
    <dependency>
      <groupId>org.neo4j.driver</groupId>
      <artifactId>neo4j-java-driver</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-core</artifactId>
    </dependency>

    <!-- Test dependencies -->
    <dependency>
      <groupId>org.neo4j.driver</groupId>
      <artifactId>neo4j-java-driver</artifactId>
      <version>${project.version}</version>
      <type>test-jar</type>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.rauschig</groupId>
      <artifactId>jarchivelib</artifactId>
    </dependency>
    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>neo4j</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.bouncycastle</groupId>
      <artifactId>bcpkix-jdk18on</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-javadoc-plugin</artifactId>
        <executions>
          <execution>
            <id>attach-javadocs</id>
            <phase>none</phase>
          </execution>
          <execution>
            <id>aggregate</id>
            <phase>none</phase>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

  <scm>
    <connection>scm:git:git://github.com/neo4j/neo4j-java-driver.git</connection>
    <developerConnection>scm:git:git@github.com:neo4j/neo4j-java-driver.git</developerConnection>
    <url>https://github.com/neo4j/neo4j-java-driver</url>
  </scm>

</project>
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::custom-auth-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import java.util.Map;
// end::custom-auth-import[]

public class CustomAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::custom-auth[]
    public CustomAuthExample(
            String uri,
            String principal,
            String credentials,
            String realm,
            String scheme,
            Map<String, Object> parameters) {
        driver = GraphDatabase.driver(uri, AuthTokens.custom(principal, credentials, realm, scheme, parameters));
    }
    // end::custom-auth[]

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletionStage;

public class AsyncAutocommitTransactionExample extends BaseApplication {
    public AsyncAutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    @SuppressWarnings("CallToPrintStackTrace")
    // tag::async-autocommit-transaction[]
    public CompletionStage<List<String>> readProductTitles() {
        var query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
        var parameters = Map.<String, Object>of("id", 0);

        var session = driver.session(AsyncSession.class);

        return session.runAsync(query, parameters)
                .thenCompose(cursor -> cursor.listAsync(record -> record.get(0).asString()))
                .exceptionally(error -> {
                    // query execution failed, print error and fallback to empty list of titles
                    error.printStackTrace();
                    return Collections.emptyList();
                })
                .thenCompose(titles -> session.closeAsync().thenApply(ignore -> titles));
    }
    // end::async-autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.async.AsyncSession;

import java.util.List;
import java.util.concurrent.CompletionStage;

public class AsyncResultConsumeExample extends BaseApplication {
    public AsyncResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-result-consume[]
    public CompletionStage<List<String>> getPeople() {
        var query = new Query("MATCH (a:Person) RETURN a.name ORDER BY a.name");
        var session = driver.session(AsyncSession.class);
        return session.executeReadAsync(tx -> tx.runAsync(query)
                .thenCompose(cursor -> cursor.listAsync(record -> record.get(0).asString())));
    }
    // end::async-result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.async.AsyncTransactionContext;
import org.neo4j.driver.async.ResultCursor;
import org.neo4j.driver.summary.ResultSummary;
import org.neo4j.driver.summary.SummaryCounters;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static org.neo4j.driver.Values.parameters;

public class AsyncRunMultipleTransactionExample extends BaseApplication {
    public AsyncRunMultipleTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-multiple-tx[]
    public CompletionStage<Integer> addEmployees(final String companyName) {
        var session = driver.session(AsyncSession.class);
        return session.executeReadAsync(AsyncRunMultipleTransactionExample::matchPersonNodes)
                .thenCompose(personNames -> session.executeWriteAsync(tx -> createNodes(tx, companyName, personNames)));
    }

    private static CompletionStage<List<String>> matchPersonNodes(AsyncTransactionContext tx) {
        return tx.runAsync("MATCH (a:Person) RETURN a.name AS name")
                .thenCompose(cursor -> cursor.listAsync(record -> record.get("name").asString()));
    }

    private static CompletionStage<Integer> createNodes(AsyncTransactionContext tx, String companyName, List<String> personNames) {
        return personNames.stream()
                .map(personName -> createNode(tx, companyName, personName))
                .reduce(CompletableFuture.completedFuture(0), (stage1, stage2) -> stage1.thenCombine(stage2, Integer::sum));
    }

    private static CompletionStage<Integer> createNode(AsyncTransactionContext tx, String companyName, String personName) {
        return tx.runAsync("MATCH (emp:Person {name: $person_name}) MERGE (com:Company {name: $company_name}) MERGE (emp)-[:WORKS_FOR]->(com)",
                        parameters("person_name", personName, "company_name", companyName))
                .thenCompose(ResultCursor::consumeAsync)
                .thenApply(ResultSummary::counters)
                .thenApply(SummaryCounters::nodesCreated);
    }
    // end::async-multiple-tx[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.summary.ResultSummary;

import java.util.Collections;
import java.util.Map;
import java.util.concurrent.CompletionStage;

public class AsyncTransactionFunctionExample extends BaseApplication {
    public AsyncTransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::async-transaction-function[]
    public CompletionStage<ResultSummary> printAllProducts() {
        var query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
        Map<String, Object> parameters = Collections.singletonMap("id", 0);

        var session = driver.session(AsyncSession.class);

        return session.executeReadAsync(tx -> tx.runAsync(query, parameters)
                .thenCompose(cursor -> cursor.forEachAsync(record ->
                        // asynchronously print every record
                        System.out.println(record.get(0).asString()))));
    }
    // end::async-transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class AutocommitTransactionExample extends BaseApplication {
    public AutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::autocommit-transaction[]
    public void addPerson(String name) {
        try (var session = driver.session()) {
            session.run("CREATE (a:Person {name: $name})", parameters("name", name));
        }
    }
    // end::autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public abstract class BaseApplication implements AutoCloseable {
    protected final Driver driver;

    public BaseApplication(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::basic-auth-import[]

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::basic-auth-import[]

public class BasicAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::basic-auth[]
    public BasicAuthExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }
    // end::basic-auth[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import java.util.concurrent.TimeUnit;

public class ConfigConnectionPoolExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-connection-pool[]
    public ConfigConnectionPoolExample(String uri, String user, String password) {
        var config = Config.builder()
                .withMaxConnectionLifetime(30, TimeUnit.MINUTES)
                .withMaxConnectionPoolSize(50)
                .withConnectionAcquisitionTimeout(2, TimeUnit.MINUTES)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-connection-pool[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public boolean canConnect() {
        var result = driver.session().run("RETURN 1");
        return result.single().get(0).asInt() == 1;
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-connection-timeout-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import static java.util.concurrent.TimeUnit.SECONDS;
// end::config-connection-timeout-import[]

public class ConfigConnectionTimeoutExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-connection-timeout[]
    public ConfigConnectionTimeoutExample(String uri, String user, String password) {
        var config = Config.builder()
                .withConnectionTimeout(15, SECONDS)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-connection-timeout[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.AuthToken;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.net.ServerAddress;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class ConfigCustomResolverExample {
    @SuppressWarnings("unused")
    // tag::config-custom-resolver[]
    public void addExampleNode() {
        var addresses = Set.of(
                ServerAddress.of("a.example.com", 7676),
                ServerAddress.of("b.example.com", 8787),
                ServerAddress.of("c.example.com", 9898)
        );
        addNode("neo4j://x.example.com", AuthTokens.basic("neo4j", "some password"), addresses, UUID.randomUUID().toString());
    }

    public void addNode(String virtualUri, AuthToken authToken, Set<ServerAddress> addresses, String id) {
        var config = Config.builder()
                .withResolver(address -> addresses)
                .build();
        try (var driver = GraphDatabase.driver(virtualUri, authToken, config)) {
            driver.executableQuery("CREATE ({id: $id})")
                    .withParameters(Map.of("id", id))
                    .execute();
        }
    }
    // end::config-custom-resolver[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-max-retry-time-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import static java.util.concurrent.TimeUnit.SECONDS;
// end::config-max-retry-time-import[]

public class ConfigMaxRetryTimeExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-max-retry-time[]
    public ConfigMaxRetryTimeExample(String uri, String user, String password) {
        var config = Config.builder()
                .withMaxTransactionRetryTime(15, SECONDS)
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-max-retry-time[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-trust-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::config-trust-import[]

public class ConfigTrustExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-trust[]
    public ConfigTrustExample(String uri, String user, String password) {
        var config = Config.builder()
                .withTrustStrategy(Config.TrustStrategy.trustSystemCertificates())
                .build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-trust[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::config-unencrypted-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::config-unencrypted-import[]

public class ConfigUnencryptedExample implements AutoCloseable {
    private final Driver driver;

    // tag::config-unencrypted[]
    public ConfigUnencryptedExample(String uri, String user, String password) {
        var config = Config.builder().withoutEncryption().build();

        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password), config);
    }
    // end::config-unencrypted[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::database-selection-import[]

import org.neo4j.driver.AccessMode;
import org.neo4j.driver.SessionConfig;
// end::database-selection-import[]

public class DatabaseSelectionExample extends BaseApplication {
    public DatabaseSelectionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    public void useAnotherDatabaseExample() {
        // tag::database-selection[]
        try (var session = driver.session(SessionConfig.forDatabase("examples"))) {
            session.run("CREATE (a:Greeting {message: 'Hello, Example-Database'}) RETURN a").consume();
        }

        var sessionConfig = SessionConfig.builder()
                .withDatabase("examples")
                .withDefaultAccessMode(AccessMode.READ)
                .build();
        try (var session = driver.session(sessionConfig)) {
            var msg = session.run("MATCH (a:Greeting) RETURN a.message as msg")
                    .single()
                    .get("msg")
                    .asString();
            System.out.println(msg);
        }
        // end::database-selection[]
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::driver-lifecycle-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::driver-lifecycle-import[]

// tag::driver-lifecycle[]
public class DriverLifecycleExample implements AutoCloseable {
    private final Driver driver;

    public DriverLifecycleExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
// end::driver-lifecycle[]
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::hello-world-import[]

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.Query;

import static org.neo4j.driver.Values.parameters;
// end::hello-world-import[]

// tag::hello-world[]
public class HelloWorldExample implements AutoCloseable {
    private final Driver driver;

    public HelloWorldExample(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public void printGreeting(final String message) {
        try (var session = driver.session()) {
            var greeting = session.executeWrite(tx -> {
                var query = new Query("CREATE (a:Greeting) SET a.message = $message RETURN a.message + ', from node ' + id(a)", parameters("message", message));
                var result = tx.run(query);
                return result.single().get(0).asString();
            });
            System.out.println(greeting);
        }
    }

    public static void main(String... args) {
        try (var greeter = new HelloWorldExample("bolt://localhost:7687", "neo4j", "password")) {
            greeter.printGreeting("hello, world");
        }
    }
}
// end::hello-world[]

// tag::hello-world-output[]
// hello, world, from node 1234
// end::hello-world-output[]
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::kerberos-auth-import[]
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
// end::kerberos-auth-import[]

@SuppressWarnings("unused")
public class KerberosAuthExample implements AutoCloseable {
    private final Driver driver;

    // tag::kerberos-auth[]
    public KerberosAuthExample(String uri, String ticket) {
        driver = GraphDatabase.driver(uri, AuthTokens.kerberos(ticket));
    }
    // end::kerberos-auth[]

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::pass-bookmarks-import[]

import org.neo4j.driver.AccessMode;
import org.neo4j.driver.Bookmark;
import org.neo4j.driver.TransactionContext;

import java.util.ArrayList;
import java.util.List;

import static org.neo4j.driver.SessionConfig.builder;
import static org.neo4j.driver.Values.parameters;
// end::pass-bookmarks-import[]

public class PassBookmarkExample extends BaseApplication {

    public PassBookmarkExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::pass-bookmarks[]
    // Create a company node
    private void addCompany(TransactionContext tx, String name) {
        tx.run("CREATE (:Company {name: $name})", parameters("name", name));
    }

    // Create a person node
    private void addPerson(TransactionContext tx, String name) {
        tx.run("CREATE (:Person {name: $name})", parameters("name", name));
    }

    // Create an employment relationship to a pre-existing company node.
    // This relies on the person first having been created.
    private void employ(TransactionContext tx, String person, String company) {
        tx.run("MATCH (person:Person {name: $person_name}) MATCH (company:Company {name: $company_name}) CREATE (person)-[:WORKS_FOR]->(company)",
                parameters("person_name", person, "company_name", company));
    }

    // Create a friendship between two people.
    @SuppressWarnings("SameParameterValue")
    private void makeFriends(TransactionContext tx, String person1, String person2) {
        tx.run("MATCH (a:Person {name: $person_1}) MATCH (b:Person {name: $person_2}) MERGE (a)-[:KNOWS]->(b)",
                parameters("person_1", person1, "person_2", person2));
    }

    // Match and display all friendships.
    private void printFriends(TransactionContext tx) {
        var result = tx.run("MATCH (a)-[:KNOWS]->(b) RETURN a.name, b.name");
        while (result.hasNext()) {
            var record = result.next();
            System.out.printf("%s knows %s%n", record.get("a.name").asString(), record.get("b.name").toString());
        }
    }

    public void addEmployAndMakeFriends() {
        // To collect the session bookmarks
        List<Bookmark> savedBookmarks;

        // Create the first person and employment relationship.
        try (var session1 =
                driver.session(builder().withDefaultAccessMode(AccessMode.WRITE).build())) {
            session1.executeWriteWithoutResult(tx -> addCompany(tx, "Wayne Enterprises"));
            session1.executeWriteWithoutResult(tx -> addPerson(tx, "Alice"));
            session1.executeWriteWithoutResult(tx -> employ(tx, "Alice", "Wayne Enterprises"));

            savedBookmarks = new ArrayList<>(session1.lastBookmarks());
        }

        // Create the second person and employment relationship.
        try (var session2 =
                driver.session(builder().withDefaultAccessMode(AccessMode.WRITE).build())) {
            session2.executeWriteWithoutResult(tx -> addCompany(tx, "LexCorp"));
            session2.executeWriteWithoutResult(tx -> addPerson(tx, "Bob"));
            session2.executeWriteWithoutResult(tx -> employ(tx, "Bob", "LexCorp"));

            savedBookmarks.addAll(session2.lastBookmarks());
        }

        // Create a friendship between the two people created above.
        try (var session3 = driver.session(builder()
                .withDefaultAccessMode(AccessMode.WRITE)
                .withBookmarks(savedBookmarks)
                .build())) {
            session3.executeWriteWithoutResult(tx -> makeFriends(tx, "Alice", "Bob"));

            session3.executeWriteWithoutResult(this::printFriends);
        }
    }
    // end::pass-bookmarks[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

// tag::read-write-transaction-import[]

import org.neo4j.driver.TransactionContext;

import static org.neo4j.driver.Values.parameters;
// end::read-write-transaction-import[]

public class ReadWriteTransactionExample extends BaseApplication {
    public ReadWriteTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::read-write-transaction[]
    public long addPerson(final String name) {
        try (var session = driver.session()) {
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume());
            return session.executeRead(tx -> matchPersonNode(tx, name));
        }
    }

    private static long matchPersonNode(TransactionContext tx, String name) {
        var result = tx.run("MATCH (a:Person {name: $name}) RETURN id(a)", parameters("name", name));
        return result.single().get(0).asLong();
    }
    // end::read-write-transaction[]

}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import java.util.ArrayList;
import java.util.List;

public class ResultConsumeExample extends BaseApplication {
    public ResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::result-consume[]
    public List<String> getPeople() {
        try (var session = driver.session()) {
            return session.executeRead(tx -> {
                List<String> names = new ArrayList<>();
                var result = tx.run("MATCH (a:Person) RETURN a.name ORDER BY a.name");
                while (result.hasNext()) {
                    names.add(result.next().get(0).asString());
                }
                return names;
            });
        }
    }
    // end::result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class ResultRetainExample extends BaseApplication {
    public ResultRetainExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::result-retain[]
    @SuppressWarnings("UnusedReturnValue")
    public int addEmployees(final String companyName) {
        try (var session = driver.session()) {
            var persons = session.executeRead(tx -> tx.run("MATCH (a:Person) RETURN a.name AS name").list());
            return persons.stream().mapToInt(person -> session.executeWrite(tx -> {
                var result = tx.run(
                        "MATCH (emp:Person {name: $person_name}) " + "MERGE (com:Company {name: $company_name}) "
                                + "MERGE (emp)-[:WORKS_FOR]->(com)",
                        parameters("person_name", person.get("name").asString(), "company_name", companyName));
                result.consume();
                return 1;
            })).sum();
        }
    }
    // end::result-retain[]

}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveSession;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;

public class RxAutocommitTransactionExample extends BaseApplication {
    public RxAutocommitTransactionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-autocommit-transaction[]
    public Flux<String> readProductTitles() {
        var query = new Query("MATCH (p:Product) WHERE p.id = $id RETURN p.title", Collections.singletonMap("id", 0));
        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.run(query))
                        .flatMap(result -> flowPublisherToFlux(result.records()))
                        .map(record -> record.get(0).asString()),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-autocommit-transaction[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveSession;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;
import static reactor.adapter.JdkFlowAdapter.publisherToFlowPublisher;

public class RxResultConsumeExample extends BaseApplication {
    public RxResultConsumeExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-result-consume[]
    public Flux<String> getPeople() {
        var query = new Query("MATCH (a:Person) RETURN a.name ORDER BY a.name");
        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.executeRead(tx -> {
                    var flux = flowPublisherToFlux(tx.run(query))
                            .flatMap(result -> flowPublisherToFlux(result.records()))
                            .map(record -> record.get(0).asString());
                    return publisherToFlowPublisher(flux);
                })),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-result-consume[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.Query;
import org.neo4j.driver.reactive.ReactiveResult;
import org.neo4j.driver.reactive.ReactiveSession;
import org.neo4j.driver.summary.ResultSummary;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.concurrent.atomic.AtomicReference;

import static reactor.adapter.JdkFlowAdapter.flowPublisherToFlux;
import static reactor.adapter.JdkFlowAdapter.publisherToFlowPublisher;

public class RxTransactionFunctionExample extends BaseApplication {
    public RxTransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::rx-transaction-function[]
    public Flux<ResultSummary> printAllProducts() {
        var query = new Query("MATCH (p:Product) WHERE p.id = $id RETURN p.title", Collections.singletonMap("id", 0));

        return Flux.usingWhen(
                Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
                session -> flowPublisherToFlux(session.executeRead(tx -> {
                    var resultRef = new AtomicReference<ReactiveResult>();
                    var flux = flowPublisherToFlux(tx.run(query))
                            .doOnNext(resultRef::set)
                            .flatMap(result -> flowPublisherToFlux(result.records()))
                            .doOnNext(record -> System.out.println(record.get(0).asString()))
                            .then(Mono.defer(() -> Mono.from(flowPublisherToFlux(resultRef.get().consume()))));
                    return publisherToFlowPublisher(flux);
                })),
                session -> flowPublisherToFlux(session.close()));
    }
    // end::rx-transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import static org.neo4j.driver.Values.parameters;

public class TransactionFunctionExample extends BaseApplication {
    public TransactionFunctionExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-function[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume());
        }
    }
    // end::transaction-function[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.TransactionConfig;

import java.util.Map;

import static org.neo4j.driver.Values.parameters;
import static org.neo4j.driver.Values.value;

public class TransactionMetadataConfigExample extends BaseApplication {
    public TransactionMetadataConfigExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-metadata-config[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            var txConfig = TransactionConfig.builder()
                    .withMetadata(Map.of("applicationId", value("123")))
                    .build();
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)).consume(), txConfig);
        }
    }
    // end::transaction-metadata-config[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.neo4j.driver.TransactionConfig;

import java.time.Duration;

import static org.neo4j.driver.Values.parameters;

public class TransactionTimeoutConfigExample extends BaseApplication {
    public TransactionTimeoutConfigExample(String uri, String user, String password) {
        super(uri, user, password);
    }

    // tag::transaction-timeout-config[]
    public void addPerson(final String name) {
        try (var session = driver.session()) {
            var txConfig = TransactionConfig.builder()
                    .withTimeout(Duration.ofSeconds(5))
                    .build();
            session.executeWriteWithoutResult(tx -> tx.run("CREATE (a:Person {name: $name})", parameters("name", name)), txConfig);
        }
    }
    // end::transaction-timeout-config[]
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
import org.neo4j.driver.SessionConfig;
import org.neo4j.driver.Value;
import org.neo4j.driver.Values;
import org.neo4j.driver.internal.util.EnabledOnNeo4jWith;
import org.neo4j.driver.summary.QueryType;
import org.neo4j.driver.testutil.DatabaseExtension;
import org.neo4j.driver.testutil.ParallelizableIT;
import org.neo4j.driver.testutil.StdIOCapture;
import org.neo4j.driver.testutil.TestUtil;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static java.util.Arrays.asList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.neo4j.driver.Values.parameters;
import static org.neo4j.driver.internal.util.Neo4jEdition.ENTERPRISE;
import static org.neo4j.driver.internal.util.Neo4jFeature.BOLT_V4;
import static org.neo4j.driver.testutil.TestUtil.await;
import static org.neo4j.driver.testutil.TestUtil.createDatabase;
import static org.neo4j.driver.testutil.TestUtil.dropDatabase;

@ParallelizableIT
class ExamplesIT {
    static final String USER = "neo4j";

    @RegisterExtension
    static final DatabaseExtension neo4j = new DatabaseExtension();

    private String uri;

    @SuppressWarnings("resource")
    private int readInt(String database, final String query, final Value parameters) {
        SessionConfig sessionConfig;
        if (database == null) {
            sessionConfig = SessionConfig.defaultConfig();
        } else {
            sessionConfig = SessionConfig.forDatabase(database);
        }
        try (var session = neo4j.driver().session(sessionConfig)) {
            return session.executeRead(
                    tx -> tx.run(query, parameters).single().get(0).asInt());
        }
    }

    private int readInt(final String query, final Value parameters) {
        return readInt(null, query, parameters);
    }

    private int readInt(final String query) {
        return readInt(query, parameters());
    }

    @SuppressWarnings("resource")
    private void write(final String query, final Value parameters) {
        try (var session = neo4j.driver().session()) {
            session.executeWriteWithoutResult(tx -> tx.run(query, parameters).consume());
        }
    }

    private void write(String query) {
        write(query, parameters());
    }

    private int personCount(String name) {
        return readInt("MATCH (a:Person {name: $name}) RETURN count(a)", parameters("name", name));
    }

    private int companyCount(String name) {
        return readInt("MATCH (a:Company {name: $name}) RETURN count(a)", parameters("name", name));
    }

    @BeforeEach
    void setUp() {
        uri = neo4j.uri().toString();
        TestUtil.cleanDb(neo4j.driver());
    }

    @Test
    void testShouldRunAutocommitTransactionExample() {
        // Given
        try (var example =
                new AutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    @SuppressWarnings("resource")
    void testShouldRunAsyncAutocommitTransactionExample() {
        try (var example =
                new AsyncAutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run("UNWIND ['Tesseract', 'Orb', 'Eye of Agamotto'] AS item "
                        + "CREATE (:Product {id: 0, title: item})");
            }

            // read all 'Product' nodes
            var titles = await(example.readProductTitles());
            assertEquals(new HashSet<>(asList("Tesseract", "Orb", "Eye of Agamotto")), new HashSet<>(titles));
        }
    }

    @Test
    void testShouldAsyncRunResultConsumeExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new AsyncResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = await(example.getPeople());

            // Then
            assertEquals(asList("Alice", "Bob"), names);
        }
    }

    @Test
    void testShouldAsyncRunMultipleTransactionExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example =
                new AsyncRunMultipleTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            var nodesCreated = await(example.addEmployees("Acme"));

            // Then
            var employeeCount =
                    readInt("MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Acme' RETURN count(emp)");
            assertEquals(2, employeeCount);
            assertEquals(1, nodesCreated);
        }
    }

    @Test
    void testShouldRunConfigConnectionPoolExample() {
        // Given
        try (var example = new ConfigConnectionPoolExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunBasicAuthExample() {
        // Given
        try (var example = new BasicAuthExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunCustomAuthExample() {
        // Given
        try (var example = new CustomAuthExample(uri, USER, neo4j.adminPassword(), null, "basic", Map.of())) {
            // Then
            assertTrue(example.canConnect());
        }
    }

    @Test
    void testShouldRunConfigConnectionTimeoutExample() {
        // Given
        try (var example =
                new ConfigConnectionTimeoutExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigMaxRetryTimeExample() {
        // Given
        try (var example = new ConfigMaxRetryTimeExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigTrustExample() {
        // Given
        try (var example = new ConfigTrustExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunConfigUnencryptedExample() {
        // Given
        try (var example = new ConfigUnencryptedExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunDriverLifecycleExample() {
        // Given
        try (var example = new DriverLifecycleExample(uri, USER, neo4j.adminPassword())) {
            // Then
            assertNotNull(example);
        }
    }

    @Test
    void testShouldRunHelloWorld() {
        // Given
        try (var greeter = new HelloWorldExample(uri, USER, neo4j.adminPassword())) {
            // When
            var stdIO = StdIOCapture.capture();

            try (stdIO) {
                greeter.printGreeting("hello, world");
            }

            // Then
            assertEquals(1, stdIO.stdout().size());
            assertTrue(stdIO.stdout().get(0).contains("hello, world"));
        }
    }

    @Test
    void testShouldRunReadWriteTransactionExample() {
        // Given
        try (var example = new ReadWriteTransactionExample(uri, USER, neo4j.adminPassword())) {
            // When
            var nodeID = example.addPerson("Alice");

            // Then
            assertTrue(nodeID >= 0L);
        }
    }

    @Test
    void testShouldRunResultConsumeExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new ResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = example.getPeople();

            // Then
            assertEquals(List.of("Alice", "Bob"), names);
        }
    }

    @Test
    void testShouldRunResultRetainExample() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new ResultRetainExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addEmployees("Acme");

            // Then
            var employeeCount =
                    readInt("MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Acme' RETURN count(emp)");
            assertEquals(2, employeeCount);
        }
    }

    @Test
    void testShouldRunTransactionFunctionExample() {
        // Given
        try (var example = new TransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    void testShouldConfigureTransactionTimeoutExample() {
        // Given
        try (var example =
                new TransactionTimeoutConfigExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    void testShouldConfigureTransactionMetadataExample() {
        // Given
        try (var example =
                new TransactionMetadataConfigExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addPerson("Alice");

            // Then
            assertTrue(personCount("Alice") > 0);
        }
    }

    @Test
    @SuppressWarnings("resource")
    void testShouldRunAsyncTransactionFunctionExample() {
        try (var example =
                new AsyncTransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run(
                        "UNWIND ['Infinity Gauntlet', 'Mjlnir'] AS item " + "CREATE (:Product {id: 0, title: item})");
            }

            var stdIOCapture = StdIOCapture.capture();

            // print all 'Product' nodes to fake stdout
            try (stdIOCapture) {
                var summary = await(example.printAllProducts());
                assertEquals(QueryType.READ_ONLY, summary.queryType());
            }

            Set<String> capturedOutput = new HashSet<>(stdIOCapture.stdout());
            assertEquals(new HashSet<>(asList("Infinity Gauntlet", "Mjlnir")), capturedOutput);
        }
    }

    @Test
    void testPassBookmarksExample() {
        try (var example = new PassBookmarkExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.addEmployAndMakeFriends();

            // Then
            assertEquals(1, companyCount("Wayne Enterprises"));
            assertEquals(1, companyCount("LexCorp"));
            assertEquals(1, personCount("Alice"));
            assertEquals(1, personCount("Bob"));

            var employeeCountOfWayne = readInt(
                    "MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'Wayne Enterprises' RETURN count(emp)");
            assertEquals(1, employeeCountOfWayne);

            var employeeCountOfLexCorp = readInt(
                    "MATCH (emp:Person)-[WORKS_FOR]->(com:Company) WHERE com.name = 'LexCorp' RETURN count(emp)");
            assertEquals(1, employeeCountOfLexCorp);

            var friendCount =
                    readInt("MATCH (a:Person {name: 'Alice'})-[:KNOWS]->(b:Person {name: 'Bob'}) RETURN count(a)");
            assertEquals(1, friendCount);
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    @SuppressWarnings("resource")
    void testShouldRunRxAutocommitTransactionExample() {
        try (var example =
                new RxAutocommitTransactionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run("UNWIND ['Tesseract', 'Orb', 'Eye of Agamotto'] AS item "
                        + "CREATE (:Product {id: 0, title: item})");
            }

            // read all 'Product' nodes
            var titles = await(example.readProductTitles());
            assertEquals(new HashSet<>(asList("Tesseract", "Orb", "Eye of Agamotto")), new HashSet<>(titles));
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    @SuppressWarnings("resource")
    void testShouldRunRxTransactionFunctionExampleReactor() {
        try (var example =
                new RxTransactionFunctionExample(uri, USER, neo4j.adminPassword())) {
            // create some 'Product' nodes
            try (var session = neo4j.driver().session()) {
                session.run(
                        "UNWIND ['Infinity Gauntlet', 'Mjlnir'] AS item " + "CREATE (:Product {id: 0, title: item})");
            }

            var stdIOCapture = StdIOCapture.capture();

            // print all 'Product' nodes to fake stdout
            try (stdIOCapture) {
                final var summaryList = await(example.printAllProducts());
                assertEquals(1, summaryList.size());
                var summary = summaryList.get(0);
                assertEquals(QueryType.READ_ONLY, summary.queryType());
            }

            Set<String> capturedOutput = new HashSet<>(stdIOCapture.stdout());
            assertEquals(new HashSet<>(asList("Infinity Gauntlet", "Mjlnir")), capturedOutput);
        }
    }

    @Test
    @EnabledOnNeo4jWith(BOLT_V4)
    void testShouldRunRxResultConsumeExampleReactor() {
        // Given
        write("CREATE (a:Person {name: 'Alice'})");
        write("CREATE (a:Person {name: 'Bob'})");
        try (var example = new RxResultConsumeExample(uri, USER, neo4j.adminPassword())) {
            // When
            var names = await(example.getPeople());

            // Then
            assertEquals(List.of("Alice", "Bob"), names);
        }
    }

    @Test
    @EnabledOnNeo4jWith(value = BOLT_V4, edition = ENTERPRISE)
    void testUseAnotherDatabaseExample() {
        var driver = neo4j.driver();
        dropDatabase(driver, "examples");
        createDatabase(driver, "examples");

        try (var example = new DatabaseSelectionExample(uri, USER, neo4j.adminPassword())) {
            // When
            example.useAnotherDatabaseExample();

            // Then
            var greetingCount = readInt("examples", "MATCH (a:Greeting) RETURN count(a)", Values.parameters());
            assertEquals(1, greetingCount);
        }
    }
}
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.docs.driver;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.DisabledIfSystemProperty;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.internal.util.EnabledOnNeo4jWith;
import org.neo4j.driver.internal.util.Neo4jFeature;
import org.neo4j.driver.net.ServerAddress;
import org.testcontainers.containers.Neo4jContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.net.URI;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;

@Testcontainers(disabledWithoutDocker = true)
@DisabledIfSystemProperty(named = "skipDockerTests", matches = "^true$")
class RoutingExamplesIT {
    private static final String NEO4J_VERSION =
            Optional.ofNullable(System.getenv("NEO4J_VERSION")).orElse("4.4");

    @Container
    @SuppressWarnings("resource")
    private static final Neo4jContainer<?> NEO4J_CONTAINER = new Neo4jContainer<>(
                    String.format("neo4j:%s-enterprise", NEO4J_VERSION))
            .withEnv("NEO4J_ACCEPT_LICENSE_AGREEMENT", "yes")
            // in this testing deployment the server runs inside a container and its Bolt port is exposed to the test(s)
            // on a random port that might not match the port in the routing table
            // this setting leads to the server echoing back the routing context address supplied by the driver
            // the test(s) may define the routing context address via the URI
            .withNeo4jConfig("dbms.routing.default_router", "SERVER")
            .withAdminPassword(null);

    @Test
    @EnabledOnNeo4jWith(Neo4jFeature.SERVER_SIDE_ROUTING_ENABLED_BY_DEFAULT)
    void testShouldRunConfigCustomResolverExample() {
        // Given
        var boltUri = URI.create(NEO4J_CONTAINER.getBoltUrl());
        var id = UUID.randomUUID().toString();
        var example = new ConfigCustomResolverExample();
        var neo4j = String.format("neo4j://%s:%d", boltUri.getHost(), boltUri.getPort());

        // When
        example.addNode(neo4j, AuthTokens.none(), Set.of(ServerAddress.of(boltUri.getHost(), boltUri.getPort())), id);

        // Then
        try(var driver = GraphDatabase.driver(boltUri, AuthTokens.none())) {
            var num = driver.executableQuery("MATCH (n{id: $id}) RETURN count(n)")
                    .withParameters(Map.of("id", id))
                    .execute();
            assertEquals(1, num.records().get(0).get(0).asInt());
        }
    }
}
<configuration>
  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>target/test.log</file>
    <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="FILE"/>
  </root>
</configuration>
# CMakeLists.txt for BoltProtocol module

# Since this module is purely for protocol logic and data structures,
# it might not have complex dependencies beyond standard C++.
# If PackStream or other parts need external libs (e.g., for specific data types),
# they would be added here.

file(GLOB_RECURSE BOLT_PROTOCOL_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(BoltProtocol ${BOLT_PROTOCOL_SOURCES})

target_include_directories(BoltProtocol
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(BoltProtocol PUBLIC Boost::asio OpenSSL::SSL OpenSSL::Crypto)

# build example, no condition
add_subdirectory(Example)

# BoltProtocol itself likely doesn't link to socket libraries.
# It provides structures and serialization/deserialization logic.
# The Neo4jBoltDriver will link the socket library and use BoltProtocol.

# Example of how other modules would link against BoltProtocol:
# target_link_libraries(Neo4jBoltDriver PRIVATE BoltProtocol)# BoltProtocol 

 BoltProtocol C++ Neo4j Bolt  Neo4j C++  Bolt 

## 

*   ****:  Neo4j Bolt 
*   ****: 
*   ****:  C++
*   ****: 

## 



*   **PackStream **:
    *    Bolt  PackStream V1 Null, Boolean, Integer, Float, String, List, Map, Structure
    *    `boltprotocol::Value`  C++  PackStream 
*   **Bolt  (Handshake)**:
    *    Bolt 
    *    `boltprotocol::versions::Version` 
    *    `boltprotocol::perform_handshake` 
*   ** (Chunking)**:
    *    `boltprotocol::ChunkedWriter`  Bolt 
    *    `boltprotocol::ChunkedReader` 
*   **Bolt **:
    *   ****: `boltprotocol::MessageTag`  Bolt 
    *   ****:  Bolt  HELLO, RUN, SUCCESS  C++ `struct` ( `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`)  `std::string`, `int64_t`, `std::optional`, `std::vector`, `std::map<std::string, boltprotocol::Value>` 
    *   ****:  C++  Bolt  ( `boltprotocol::serialize_hello_message`)
    *   ****:  C++  ( `boltprotocol::deserialize_success_message`)
    *   ****:  ( `boltprotocol::deserialize_hello_message_request`)
*   ** PackStream **:
    *   Node, Relationship, PathDate, Time, DateTime, Point  C++ `struct` ( `boltprotocol::BoltNode`, `boltprotocol::BoltDate`)
    *    `boltprotocol::PackStreamStructure`  ( `boltprotocol::from_packstream`, `boltprotocol::to_packstream`)

## 

 BoltProtocol 

1.  ****:
    *   `#include "boltprotocol/message_defs.h"`: 
        *    (`Value`, `BoltMap`, `BoltList`, `PackStreamStructure`)
        *    (`BoltError`)
        *    (`versions::Version`) 
        *    (`MessageTag`)
        *    (`HelloMessageParams` )
        *    (`BoltNode`, `BoltDate`  `bolt_structure_types.h`)
    *   `#include "boltprotocol/message_serialization.h"`: 
    *   `#include "boltprotocol/handshake.h"`: 
    *   `#include "boltprotocol/chunking.h"`: 
    *   `#include "boltprotocol/bolt_structure_serialization.h"`:  PackStream  `BoltNode` `PackStreamStructure` 
2.  ****:  PackStreamBolt 
3.  ****: 

##  ()



*   **`Include/boltprotocol/`**: 
    *   `detail/`: 
    *   `message_defs.h`: 
    *    `.h` 
*   **`Source/`**:  `.cpp` 
    *    ( `packstream_reader_*.cpp`, `message_serialization_client_*.cpp`, `bolt_structure_*.cpp`)

 Bolt # BoltProtocol 

 Bolt 

## 1. PackStream

PackStream  Bolt  C++ 

### C++  PackStream 

 PackStream  `boltprotocol::Value`  `std::variant`C++ PackStream 

*   **`std::nullptr_t`**:
    *    PackStream `Null`
*   **`bool`**:
    *    PackStream `Boolean` (`true`  `false`)
*   **`int64_t`**:
    *    PackStream `Integer`  (TinyInt, Int8, Int16, Int32, Int64)
*   **`double`**:
    *    PackStream `Float` (64)
*   **`std::string`**:
    *    PackStream `String` (UTF-8 )
*   **`std::shared_ptr<boltprotocol::BoltList>`**:
    *    PackStream `List`
    *   `boltprotocol::BoltList` 
        *   `std::vector<boltprotocol::Value> elements;`
*   **`std::shared_ptr<boltprotocol::BoltMap>`**:
    *    PackStream `Map`
    *   `boltprotocol::BoltMap` 
        *   `std::map<std::string, boltprotocol::Value> pairs;`
*   **`std::shared_ptr<boltprotocol::PackStreamStructure>`**:
    *    PackStream `Structure` Bolt 
    *   `boltprotocol::PackStreamStructure` 
        *   `uint8_t tag;` NodeDate 
        *   `std::vector<boltprotocol::Value> fields;`

****:  `Value``BoltList``BoltMap`  `PackStreamStructure`  Bolt  (`XxxMessageParams`)  PackStream  `BoltNode` C++ `struct`/

## 2. Bolt 

Bolt -

*   ** (Request Message)**: 
*   ** (Response Message)**: 
    *    ** (Detail Message)**:  `RECORD` 
    *    ** (Summary Message)**:  `SUCCESS`  `FAILURE`

 Bolt  **PackStream Structure**

###  (`boltprotocol::MessageTag`)

`boltprotocol::MessageTag`  `enum class` Bolt  () `PackStreamStructure`  `tag` 

*   ****:
    *   `MessageTag::HELLO` (0x01): 
    *   `MessageTag::LOGON` (0x6A):  (Bolt 5.1+)
    *   `MessageTag::RUN` (0x10):  Cypher 
    *   `MessageTag::PULL` (0x3F):  `RUN` 
    *   `MessageTag::BEGIN` (0x11): 
    *   `MessageTag::COMMIT` (0x12): 
    *   `MessageTag::SUCCESS` (0x70): 
    *   `MessageTag::FAILURE` (0x7F): 
    *   `MessageTag::RECORD` (0x71): 
    *   `MessageTag::IGNORED` (0x7E): 
    *   ... ()

###  (`boltprotocol::*MessageParams`)

 C++  Bolt  `MessageParams`  `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`, `boltprotocol::SuccessMessageParams`

*    C++  `std::string`, `int64_t`, `std::vector`, `std::map`,  `std::optional` ()  `boltprotocol::Value` ()
*   **, `boltprotocol::RunMessageParams` **:
    *   `std::string cypher_query;`
    *   `std::map<std::string, boltprotocol::Value> parameters;`
    *   `std::optional<std::vector<std::string>> bookmarks;`
    *   `std::optional<std::string> db;`
    *   ... 
*   

## 3.  PackStream  ()

 Bolt PackStream  Neo4j 

 PackStream Structure  C++ `struct`

*   `boltprotocol::BoltNode` ( PackStream Structure tag `0x4E 'N'`)
*   `boltprotocol::BoltRelationship` (tag `0x52 'R'`)
*   `boltprotocol::BoltPath` (tag `0x50 'P'`)
*   `boltprotocol::BoltDate` (tag `0x44 'D'`)
*   `boltprotocol::BoltTime` (tag `0x54 'T'`)
*   `boltprotocol::BoltDateTime` (tag `0x49 'I'`  `0x46 'F'`)
*   ... 

 `PackStreamStructure` (`Value`  `std::shared_ptr<PackStreamStructure>`)  `06-structure-types-and-conversions.md`  Bolt 

## 

*   Bolt  **PackStream** 
*    C++  PackStream  `boltprotocol::Value` ( `std::variant`) `BoltList``BoltMap`  `PackStreamStructure`
*   **Bolt **  `MessageTag`  `PackStreamStructure`
*    **`XxxMessageParams`** 
*    ** C++ `struct`** ( `BoltNode`) `PackStreamStructure` 

 Bolt  `03-handshake-and-chunking.md` 

---

**`Base/Protocol/BoltProtocol/Document/03-handshake-and-chunking.md`**

```markdown
# Bolt 

 Bolt  BoltProtocol 

## 1. Bolt  (Handshake)

 Bolt  Bolt  Bolt 

###  (`boltprotocol::versions::Version`)

Bolt  `boltprotocol::versions::Version` 

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 
        uint8_t minor; // 

        //  Version(5, 4)  Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        //  (<, ==, !=)
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;

        // 4 (, 00 00 Maj Min)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 4
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    // :
    // extern const Version V5_4; // (5,4)
    // extern const Version V5_3; // (5,3)
    // ... 
} // namespace versions
} // namespace boltprotocol
```
 `boltprotocol::versions::V5_4`

### 

 `#include "boltprotocol/handshake.h"` 

*   **`std::vector<boltprotocol::versions::Version> boltprotocol::versions::get_default_proposed_versions();`**
    *   ****:  Bolt 
    *   ****:  `Version`  `std::vector`

*   **`boltprotocol::BoltError boltprotocol::perform_handshake(std::ostream& client_output_stream, std::istream& client_input_stream, const std::vector<boltprotocol::versions::Version>& proposed_versions, boltprotocol::versions::Version& out_negotiated_version);`**
    *   ****:  Bolt 
        1.   `proposed_versions` 
        2.   `client_output_stream` 20 `6060B017` 4
        3.   `client_input_stream` 4
        4.   `out_negotiated_version` 
    *   ****:
        *   `client_output_stream`:  `std::ostream&`
        *   `client_input_stream`:  `std::istream&`
        *   `proposed_versions`:  `const std::vector<boltprotocol::versions::Version>&` `get_default_proposed_versions()` 
        *   `out_negotiated_version`:  `boltprotocol::versions::Version&` 
    *   ****:
        *   `boltprotocol::BoltError::SUCCESS`: `out_negotiated_version` 
        *   `boltprotocol::BoltError::INVALID_ARGUMENT`:  `proposed_versions` 
        *   `boltprotocol::BoltError::NETWORK_ERROR`: 
        *   `boltprotocol::BoltError::HANDSHAKE_NO_COMMON_VERSION`:  (`00 00 00 00`)
        *   `boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION`:  Bolt 
        *   

### 

```cpp
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h" // For BoltError and versions::Version constants
#include <iostream>
#include <sstream>   // 
#include <vector>
#include <array>     // 

int main() {
    std::stringstream client_to_server_pipe; 
    std::stringstream server_to_client_pipe; 
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError err;

    // 1. 
    std::vector<boltprotocol::versions::Version> client_proposals = 
        boltprotocol::versions::get_default_proposed_versions();

    if (client_proposals.empty()) {
        std::cerr << "Client: No versions to propose." << std::endl;
        return 1;
    }
    std::cout << "Client: Proposing versions: ";
    for (const auto& v : client_proposals) {
        std::cout << (int)v.major << "." << (int)v.minor << " ";
    }
    std::cout << std::endl;

    // ---  ---
    //  ( Bolt 5.4)
    boltprotocol::versions::Version server_supported_choice = client_proposals[0]; 
    std::array<uint8_t, boltprotocol::HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_data = 
        server_supported_choice.to_handshake_bytes();
    
    //  "server_to_client_pipe"
    server_to_client_pipe.write(
        reinterpret_cast<const char*>(server_response_data.data()), 
        server_response_data.size()
    );
    // 
    server_to_client_pipe.seekg(0); 
    // ---  ---

    // 2. 
    std::cout << "Client: Performing handshake..." << std::endl;
    err = boltprotocol::perform_handshake(
        client_to_server_pipe,   // 
        server_to_client_pipe,   // 
        client_proposals,
        negotiated_version
    );

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "Client: Handshake successful!" << std::endl;
        std::cout << "Client: Negotiated Bolt Protocol Version: "
                  << static_cast<int>(negotiated_version.major) << "."
                  << static_cast<int>(negotiated_version.minor) << std::endl;
        //  negotiated_version
    } else {
        std::cerr << "Client: Handshake failed. Error code: " << static_cast<int>(err) << std::endl;
        // 
        return 1;
    }

    // client_to_server_pipe 20
    // server_to_client_pipe 4 perform_handshake 

    return 0;
}
```

## 2.  (Chunking)

 Bolt  HELLO 

### 

*   ****:  **2** 16 65,535  (0xFFFF)
*   ****:  Bolt **** `00 00`0
*   **NOOP Chunk (Bolt 4.1+)**:  (`00 00`)  NOOP (No Operation)  (keep-alive)

### 

 `#include "boltprotocol/chunking.h"` 

*   **`boltprotocol::ChunkedWriter`**:  PackStream  Bolt 
    *   ****: `ChunkedWriter(std::ostream& output_stream);`
        *   `output_stream`: 
    *   ****: `boltprotocol::BoltError write_message(const std::vector<uint8_t>& full_message_payload);`
        *   `full_message_payload`:  PackStream  Bolt 
        *    `full_message_payload` 2 `00 00` 
        *   ****: `BoltError::SUCCESS`  `BoltError::NETWORK_ERROR`

*   **`boltprotocol::ChunkedReader`**:  Bolt 
    *   ****: `ChunkedReader(std::istream& input_stream);`
        *   `input_stream`: 
    *   ****: `boltprotocol::BoltError read_message(std::vector<uint8_t>& out_reconstructed_payload);`
        *    +  (`00 00`)
        *    `out_reconstructed_payload` 
        *   ****: `BoltError::SUCCESS`  `BoltError::NETWORK_ERROR`, `BoltError::CHUNK_DECODING_ERROR`, `BoltError::MESSAGE_TOO_LARGE`
        *    `00 00` NOOP chunk NOOP chunk  `read_message` `out_reconstructed_payload` 

### 

1.  ****:  ( `serialize_hello_message`)  `std::vector<uint8_t>`  PackStream 
2.  ****:
    a.   `ChunkedWriter` 
    b.   `writer.write_message()`
    c.  
3.  ****:
    a.   `ChunkedReader` 
    b.   `std::vector<uint8_t>` 
    c.   `reader.read_message()`
    d.  
    e.   PackStream  Bolt  ( `deserialize_success_message`) 

** `01-introduction.md` **

 Bolt  `perform_handshake`, `ChunkedWriter`,  `ChunkedReader` 
``` `04-message-serialization.md` 

---

**`Base/Protocol/BoltProtocol/Document/04-message-serialization.md`**

```markdown
# Bolt 

 BoltProtocol  C++  Bolt  Bolt  PackStream V1  `03-handshake-and-chunking.md`

 `#include "boltprotocol/message_serialization.h"` 

## 



1.  ****:
    ```cpp
    #include "boltprotocol/message_defs.h"     //  XxxMessageParams , Value, versions::Version, MessageTag 
    #include "boltprotocol/message_serialization.h" //  serialize_xxx_message 
    #include "boltprotocol/packstream_writer.h"   //  PackStreamWriter 
    #include <vector>                           // 
    ```
2.  ****:
     `boltprotocol::XxxMessageParams`  `RUN`  `boltprotocol::RunMessageParams` `bolt_message_params.h` 
3.  ** `PackStreamWriter`**:
     `boltprotocol::PackStreamWriter`  `std::vector<uint8_t>`
    ```cpp
    std::vector<uint8_t> serialized_message_bytes;
    boltprotocol::PackStreamWriter writer(serialized_message_bytes);
    ```
4.  ****:
     `boltprotocol::serialize_xxx_message()`  `PackStreamWriter` 
    *   ****:  `HELLO`, `RUN`, `BEGIN`, `ROUTE` `extra`  Bolt  `const boltprotocol::versions::Version& target_bolt_version`  Bolt  `HELLO` 
5.  ****:
     `boltprotocol::BoltError` `boltprotocol::BoltError::SUCCESS``PackStreamWriter`  `has_error()`  `get_error()` 
6.  ****:
     `PackStreamWriter`  `std::vector<uint8_t>`PackStream  Bolt 
    ```cpp
    // ... ()
    // serialized_message_bytes  ChunkedWriter 
    ```

## 



---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)
*Bolt < 5.1*

*   ****: `boltprotocol::HelloMessageParams`
    *   `user_agent` (std::string): ****. 
    *   `auth_scheme` (std::optional<std::string>):  "basic", "none", "kerberos" Bolt < 5.1
    *   `auth_principal` (std::optional<std::string>):  "basic" 
    *   `auth_credentials` (std::optional<std::string>):  "basic" 
    *   `auth_scheme_specific_tokens` (std::optional<std::map<std::string, Value>>): 
    *   `routing_context` (std::optional<std::map<std::string, Value>>): Bolt 4.1+ `{"address": "initial.host:port"}`
    *   `patch_bolt` (std::optional<std::vector<std::string>>): Bolt 4.3-4.4 `{"utc"}`
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+
    *   `bolt_agent` (std::optional<BoltAgentInfo>): Bolt 5.3+ ****. /
        *   `BoltAgentInfo::product` (std::string): ****.  "MyCppDriver/1.0"
        *   `BoltAgentInfo::platform` (std::optional<std::string>):  "Linux x86_64"
        *   `BoltAgentInfo::language` (std::optional<std::string>):  "C++20"
        *   `BoltAgentInfo::language_details` (std::optional<std::string>):  "GCC 11.3"
    *   `other_extra_tokens` (std::map<std::string, Value>):  `extra` 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_hello_message(
        const boltprotocol::HelloMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& client_target_version
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)
* Bolt 5.1+ *

*   ****: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>): ****.  `"scheme"` (, String)  scheme 
        *    `"basic"` scheme: `"principal"` (String), `"credentials"` (String).
        *    `"bearer"` scheme: `"credentials"` (String,  token).
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_logon_message(
        const boltprotocol::LogonMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)
* Bolt 5.1+ *

*   ****: `boltprotocol::LogoffMessageParams` ( LOGOFF )
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_logoff_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
    **:  `LogoffMessageParams`  PackStream Structure

---

### 4. `RUN` (MessageTag::RUN - `0x10`)
* Cypher *

*   ****: `boltprotocol::RunMessageParams`
    *   `cypher_query` (std::string): ****.  Cypher 
    *   `parameters` (std::map<std::string, Value>): Cypher 
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+. 
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+. 
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+. 
    *   `mode` (std::optional<std::string>): Bolt 3+.  ("r" "w"  "w")
    *   `db` (std::optional<std::string>): Bolt 4.0+. 
    *   `imp_user` (std::optional<std::string>): Bolt 4.4+.  RUN
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>):  `extra` 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_run_message(
        const boltprotocol::RunMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```
*   ****: `target_bolt_version`  `extra`  `RUN`  `extra` 

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)
* (Bolt 3+)*

*   ****: `boltprotocol::BeginMessageParams`
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+.
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+.
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+.
    *   `mode` (std::optional<std::string>): Bolt 3+ ( "w" )
    *   `db` (std::optional<std::string>): Bolt 4.0+.
    *   `imp_user` (std::optional<std::string>): Bolt 4.0+.
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>):  `extra` 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_begin_message(
        const boltprotocol::BeginMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)
* `RUN`  Bolt 4.0  `PULL_ALL` *

*   ****: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>): ** ( Bolt 4.0+)**. `-1` 
    *   `qid` (std::optional<int64_t>): ** ( Bolt 4.0+  PULL)**. ID Bolt 4.0  `PULL_ALL` `-1`
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_pull_message(
        const boltprotocol::PullMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****:  Bolt 4.0+  PULL  `extra` map Bolt < 4.0  `PULL_ALL` PSS (tag PULL, 0 fields) Bolt 4.0+ 

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)
* `RUN`  Bolt 4.0  `DISCARD_ALL` *

*   ****: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>): ** ( Bolt 4.0+)**. `-1` 
    *   `qid` (std::optional<int64_t>): ** ( Bolt 4.0+  DISCARD)**. ID
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_discard_message(
        const boltprotocol::DiscardMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****:  PULL

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)
* (Bolt 3+)*

*   ****: `boltprotocol::CommitMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_commit_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****: COMMIT  PackStream Structure  PackStream Map `{}`

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)
* (Bolt 3+)*

*   ****: `boltprotocol::RollbackMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_rollback_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****:  COMMIT  map 

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)
* `READY`  `AUTHENTICATION` *

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_reset_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****: RESET  PackStream Structure 

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)
* (Bolt 3+)*

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_goodbye_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   ****: GOODBYE  PackStream Structure 

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)
* (Bolt 4.3+)*

*   ****: `boltprotocol::RouteMessageParams`
    *   `routing_table_context` (std::map<std::string, Value>):  ROUTE V2 map  `"db"`  `"imp_user"`
    *   `bookmarks` (std::vector<std::string>): 
    *   `db_name_for_v43` (std::optional<std::string>): ** Bolt 4.3** PackStream Structure 
    *   `extra_for_v44_plus` (std::optional<std::map<std::string, Value>>): ** Bolt 4.4+** PackStream Structure  map  `"db"` / `"imp_user"`
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_route_message(
        const boltprotocol::RouteMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& negotiated_bolt_version
    );
    ```
*   ****: `negotiated_bolt_version`  `db_name_for_v43`  `extra_for_v44_plus`

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)
* API  (Bolt 5.4+)*

*   ****: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>): ****.  `"api"` `Integer`  API 
*   ****:
    ```cpp
    boltprotocol::BoltError serialize_telemetry_message(
        const boltprotocol::TelemetryMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

##  HELLO 

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h" // For HelloMessageParams, Value, versions::Version etc.
#include "boltprotocol/packstream_writer.h"
#include <vector>
#include <iostream>

int main() {
    boltprotocol::HelloMessageParams hello_p;
    //  Bolt 5.3
    boltprotocol::versions::Version target_version(5, 3);

    hello_p.user_agent = "MyAwesomeCppApp/1.0";
    
    // Bolt 5.3+  bolt_agent
    boltprotocol::HelloMessageParams::BoltAgentInfo agent;
    agent.product = "MyDriver/0.1";
    agent.platform = "Linux x64";
    agent.language = "C++20";
    hello_p.bolt_agent = agent;

    // Bolt 5.3 HELLO  ( LOGON)
    // hello_p.auth_scheme = "basic"; 
    // hello_p.auth_principal = "user";
    // hello_p.auth_credentials = "pass";

    std::map<std::string, boltprotocol::Value> routing_ctx;
    routing_ctx["address"] = boltprotocol::Value(std::string("client.initial.host:7687"));
    hello_p.routing_context = routing_ctx; // For Bolt 4.1+

    std::vector<uint8_t> serialized_bytes;
    boltprotocol::PackStreamWriter writer(serialized_bytes);

    boltprotocol::BoltError err = boltprotocol::serialize_hello_message(hello_p, writer, target_version);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "HELLO message serialized. Size: " << serialized_bytes.size() << std::endl;
        // serialized_bytes  ChunkedWriter
    } else {
        std::cerr << "HELLO serialization failed: " << static_cast<int>(err) << std::endl;
    }

    return 0;
}

```

 Bolt  PackStream  Bolt 
``` `05-message-deserialization.md` 

---

**`Base/Protocol/BoltProtocol/Document/05-message-deserialization.md`**

```markdown
# Bolt 

 BoltProtocol  Bolt  `ChunkedReader`  PackStream  C++ 

 `#include "boltprotocol/message_serialization.h"` 

## 

 Bolt 

1.  ****:
    ```cpp
    #include "boltprotocol/message_defs.h"     //  XxxMessageParams , Value, versions::Version, MessageTag 
    #include "boltprotocol/message_serialization.h" //  deserialize_xxx_message 
    #include "boltprotocol/packstream_reader.h"   //  PackStreamReader 
    #include <vector>                           //  ChunkedReader 
    ```
2.  ****:
     `boltprotocol::ChunkedReader`  Bolt  `std::vector<uint8_t>`  `received_message_bytes`
3.  ** `PackStreamReader`**:
     `boltprotocol::PackStreamReader` 
    ```cpp
    // std::vector<uint8_t> received_message_bytes = ... (from ChunkedReader)
    boltprotocol::PackStreamReader reader(received_message_bytes);
    ```
4.  ****:
    *   ****:  `boltprotocol::deserialize_xxx_message()` ()  `boltprotocol::deserialize_xxx_message_request()` () 
    *   ****:
        a.   `boltprotocol::Value` `std::shared_ptr<boltprotocol::PackStreamStructure>`
        b.   `tag`  `boltprotocol::MessageTag`
        c.   `tag` 
        d.  ****: **** `received_message_bytes`  `PackStreamReader` `Value` `deserialize_message_structure_prelude` 
    *   ****:  `HELLO`, `RUN`, `BEGIN`, `ROUTE`  `BoltDateTime`  Bolt  (`const boltprotocol::versions::Version& negotiated_version`)

5.  ****:
     `boltprotocol::BoltError` `boltprotocol::BoltError::SUCCESS``PackStreamReader` 
6.  ****:
     `SuccessMessageParams& out_params`

## A. 



---

### 1. `SUCCESS` (MessageTag::SUCCESS - `0x70`)
**

*   ** ()**: `boltprotocol::SuccessMessageParams`
    *   `metadata` (std::map<std::string, Value>):  `SUCCESS`  Bolt 
        *   `"fields"` (List<String>):  `RUN` 
        *   `"qid"` (Integer):  `RUN`ID
        *   `"t_first"` (Integer):  ()
        *   `"server"` (String):  ( "Neo4j/5.10.0") `HELLO` 
        *   `"connection_id"` (String):  `HELLO` 
        *   `"bookmark"` (String):  `COMMIT` 
        *   `"has_more"` (Boolean):  `PULL`/`DISCARD`  (Bolt 4.0+)
        *   `"patch_bolt"` (List<String>):  `HELLO`  (Bolt 4.3-4.4)
        *   `"hints"` (Map):  `HELLO`  (Bolt 4.3+)
        *   ...  `type`, `db`, `plan`, `profile`, `stats` 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_success_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::SuccessMessageParams& out_params
    );
    ```

---

### 2. `FAILURE` (MessageTag::FAILURE - `0x7F`)
**

*   ** ()**: `boltprotocol::FailureMessageParams`
    *   `metadata` (std::map<std::string, Value>): 
        *   `"code"` (String): Neo4j  (Bolt < 5.7)
        *   `"message"` (String): 
        *   `"neo4j_code"` (String): Neo4j  (Bolt 5.7+)
        *   `"gql_status"` (String): GQL  (Bolt 5.7+)
        *   `"description"` (String): GQL  (Bolt 5.7+)
        *   `"diagnostic_record"` (Map):  (Bolt 5.7+)
        *   `"cause"` (Map):  (Bolt 5.7+)
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_failure_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::FailureMessageParams& out_params
    );
    ```

---

### 3. `RECORD` (MessageTag::RECORD - `0x71`)
**

*   ** ()**: `boltprotocol::RecordMessageParams`
    *   `fields` (std::vector<Value>):  `RUN`  `SUCCESS`  `"fields"` 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_record_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RecordMessageParams& out_params
    );
    ```

---

### 4. `IGNORED` (MessageTag::IGNORED - `0x7E`)
* `FAILED`  `INTERRUPTED` *

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_ignored_message(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   ****: IGNORED  PackStream Structure 01 map 

---

## B. 



---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)

*   ** ()**: `boltprotocol::HelloMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_hello_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::HelloMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version // 
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)

*   ** ()**: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>)
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_logon_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::LogonMessageParams& out_params
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_logoff_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```

---

### 4. `RUN` (MessageTag::RUN - `0x10`)

*   ** ()**: `boltprotocol::RunMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_run_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RunMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)

*   ** ()**: `boltprotocol::BeginMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_begin_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::BeginMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)

*   ** ()**: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_pull_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::PullMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   ****:  `server_negotiated_version`  Bolt < 4.0  `PULL_ALL` (0)  Bolt 4.0+  `PULL` (1 `extra` map )

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)

*   ** ()**: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_discard_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::DiscardMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   ****:  PULL

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_commit_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   ****:  PackStream Structure 1 map

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_rollback_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   ****:  COMMIT

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_reset_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   ****:  PackStream Structure 0

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)

*   ****: 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_goodbye_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   ****:  PackStream Structure 0

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)

*   ** ()**: `boltprotocol::RouteMessageParams` ()
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_route_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RouteMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   ****:  `server_negotiated_version`  `db_name` (Bolt 4.3)  `extra` map (Bolt 4.4+)

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)

*   ** ()**: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>):  `"api"` (Integer) 
*   ****:
    ```cpp
    boltprotocol::BoltError deserialize_telemetry_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::TelemetryMessageParams& out_params
    );
    ```

##  ( RECORD )

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include <vector>
#include <iostream>

//  received_record_bytes  ChunkedReader  RECORD 
// std::vector<uint8_t> received_record_bytes = ...; 

void process_record_message(const std::vector<uint8_t>& received_record_bytes) {
    boltprotocol::PackStreamReader reader(received_record_bytes);
    boltprotocol::RecordMessageParams record_data;
    boltprotocol::BoltError err = boltprotocol::deserialize_record_message(reader, record_data);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "RECORD message deserialized. Number of fields: " << record_data.fields.size() << std::endl;
        for (size_t i = 0; i < record_data.fields.size(); ++i) {
            const auto& fieldValue = record_data.fields[i];
            //  fieldValue  ( std::holds_alternative  std::get) 
            if (std::holds_alternative<std::string>(fieldValue)) {
                std::cout << "  Field " << i << " (String): " << std::get<std::string>(fieldValue) << std::endl;
            } else if (std::holds_alternative<int64_t>(fieldValue)) {
                std::cout << "  Field " << i << " (Integer): " << std::get<int64_t>(fieldValue) << std::endl;
            } // ...  ...
        }
    } else {
        std::cerr << "Failed to deserialize RECORD message, error: " << static_cast<int>(err) << std::endl;
    }
}
```
 Bolt 
``` `06-structure-types-and-conversions.md` 

---

**`Base/Protocol/BoltProtocol/Document/06-structure-types-and-conversions.md`**

```markdown
#  PackStream 

Bolt  PackStream `RECORD`  `RUN`  PackStream Structure 

 C++ BoltProtocol 

1.  ** C++ **:  PackStream Structure  C++ `struct`
2.  ****:  `boltprotocol::PackStreamStructure` ( `std::shared_ptr`  `boltprotocol::Value` )  C++ 

 `#include "boltprotocol/bolt_structure_types.h"` ( `boltprotocol/message_defs.h` )
 `#include "boltprotocol/bolt_structure_serialization.h"`

## 1.  C++ 

 C++  PackStream  Bolt  `element_id`  Bolt 5.0+ 

###  (Graph Primitives)

*   **`boltprotocol::BoltNode`** (PackStream Tag: `0x4E 'N'`)
    *   `int64_t id;`
    *   `std::vector<std::string> labels;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltRelationship`** (PackStream Tag: `0x52 'R'`)
    *   `int64_t id;`
    *   `int64_t start_node_id;`
    *   `int64_t end_node_id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> start_node_element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> end_node_element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltUnboundRelationship`** (PackStream Tag: `0x72 'r'`)
    *   * `BoltPath` *
    *   `int64_t id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltPath`** (PackStream Tag: `0x50 'P'`)
    *   `std::vector<BoltNode> nodes;`
    *   `std::vector<BoltUnboundRelationship> rels;`
    *   `std::vector<int64_t> indices;` ()

###  (Temporal Types)

*   **`boltprotocol::BoltDate`** (PackStream Tag: `0x44 'D'`)
    *   `int64_t days_since_epoch;` ( Unix )

*   **`boltprotocol::BoltTime`** (PackStream Tag: `0x54 'T'`)
    *   `int64_t nanoseconds_since_midnight;` ()
    *   `int32_t tz_offset_seconds;` ( UTC )

*   **`boltprotocol::BoltLocalTime`** (PackStream Tag: `0x74 't'`)
    *   `int64_t nanoseconds_since_midnight;` ()

*   **`boltprotocol::BoltDateTime`** (PackStream Tag: `0x49 'I'` () / `0x46 'F'` ())
    *   `int64_t seconds_epoch_utc;` ( Unix  UTC )
    *   `int32_t nanoseconds_of_second;` (, 0-999,999,999)
    *   `int32_t tz_offset_seconds;` ( UTC )

*   **`boltprotocol::BoltDateTimeZoneId`** (PackStream Tag: `0x69 'i'` () / `0x66 'f'` ())
    *   `int64_t seconds_epoch_utc;` ( Unix  UTC ****:  'f'  UTC TZDB )
    *   `int32_t nanoseconds_of_second;`
    *   `std::string tz_id;` ( "Europe/Paris")

*   **`boltprotocol::BoltLocalDateTime`** (PackStream Tag: `0x64 'd'`)
    *   `int64_t seconds_epoch_local;` ( Unix )
    *   `int32_t nanoseconds_of_second;`

*   **`boltprotocol::BoltDuration`** (PackStream Tag: `0x45 'E'`)
    *   `int64_t months;`
    *   `int64_t days;`
    *   `int64_t seconds;`
    *   `int32_t nanoseconds;` ()

###  (Spatial Types)

*   **`boltprotocol::BoltPoint2D`** (PackStream Tag: `0x58 'X'`)
    *   `uint32_t srid;` ()
    *   `double x;`
    *   `double y;`

*   **`boltprotocol::BoltPoint3D`** (PackStream Tag: `0x59 'Y'`)
    *   `uint32_t srid;`
    *   `double x;`
    *   `double y;`
    *   `double z;`

## 2. 

 `boltprotocol::PackStreamStructure`  C++ 

### A.  `PackStreamStructure`  (`from_packstream`)

 `RECORD` 

*   ****:
    ```cpp
    boltprotocol::BoltError from_packstream(
        const boltprotocol::PackStreamStructure& pss, 
        TypedStruct& out_struct, 
        /* : const boltprotocol::versions::Version& bolt_version () */
    );
    ```
    *   `pss`:  PackStream 
    *   `out_struct`: 
    *   `bolt_version`:  Bolt  `BoltNode`, `BoltRelationship`, `BoltDateTime`
    *   ****: `BoltError::SUCCESS`  `BoltError::INVALID_MESSAGE_FORMAT` 

*   ****:
    *   `from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDate& out_date);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);`
    *   ... ()

### B.  `PackStreamStructure` (`to_packstream`)

 Cypher 

*   ****:
    ```cpp
    boltprotocol::BoltError to_packstream(
        const TypedStruct& typed_struct, 
        /* : const boltprotocol::versions::Version& bolt_version, */
        /* : bool utc_patch_active_for_4_4, ( BoltDateTime/ZoneId  Bolt 4.4) */
        std::shared_ptr<PackStreamStructure>& out_pss_sptr 
    );
    ```
    *   `typed_struct`:  C++ 
    *   `bolt_version`, `utc_patch_active_for_4_4`:  Bolt  DateTime  DateTimeZoneId
    *   `out_pss_sptr`:  `std::shared_ptr<PackStreamStructure>` `shared_ptr`  `Value` 
    *   ****: `BoltError::SUCCESS` 

*   ****:
    *   `to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   ... ()

### C.  `Value`  (`value_to_typed_struct`)

 `boltprotocol::Value` `std::shared_ptr<PackStreamStructure>`

*   ****:
    ```cpp
    // /
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct, 
        const boltprotocol::versions::Version& bolt_version, 
        bool utc_patch_active_for_4_4 = false // false
    );

    //  ( BoltDate)
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct
    );
    ```
*   ****:
    1.   `value`  `std::shared_ptr<PackStreamStructure>`
    2.   `from_packstream` 
    3.   `from_packstream` 
*   ****:
    ```cpp
    //  record_field  RecordMessageParams::fields  Value
    // boltprotocol::Value record_field = ...;
    // boltprotocol::versions::Version current_bolt_version = ...;
    // bool is_utc_patch_active_for_4_4 = ...; // ()

    boltprotocol::BoltNode node;
    boltprotocol::BoltError err_node = boltprotocol::value_to_typed_struct(record_field, node, current_bolt_version);
    if (err_node == boltprotocol::BoltError::SUCCESS) {
        //  node
    }

    boltprotocol::BoltDate date_obj;
    boltprotocol::BoltError err_date = boltprotocol::value_to_typed_struct(record_field, date_obj); // Date
    if (err_date == boltprotocol::BoltError::SUCCESS) {
        //  date_obj
    }

    boltprotocol::BoltDateTime datetime_obj;
    // DateTime  bolt_version  4.4 utc_patch_active_for_4_4
    boltprotocol::BoltError err_dt = boltprotocol::value_to_typed_struct(record_field, datetime_obj, current_bolt_version, is_utc_patch_active_for_4_4);
    if (err_dt == boltprotocol::BoltError::SUCCESS) {
        //  datetime_obj (from_packstream for DateTime/ZoneId utc_patchto_packstream)
        // from_packstream
    }
    ```

## 

*   ****: `BoltNode`, `BoltRelationship`, `BoltUnboundRelationship`  `element_id`  Bolt 5.0  `bolt_version` 
*   **DateTime  DateTimeZoneId**:
    *   Bolt 5.0  (tag 'I'  'i')  (tag 'F'  'f')
    *   Bolt 4.4  `HELLO`  `"utc"` 
    *   `from_packstream`  PackStream Structure ****
    *   `to_packstream`  `bolt_version`  `utc_patch_active_for_4_4` (4.4) 
    *   ** `DateTimeZoneId` (tag 'f') **:  `seconds`  UTC  UTC  `tz_id`  (TZDB) TZDB `DateTimeZoneId` 

 Bolt 
```

---

**7. `Base/Protocol/BoltProtocol/Document/07-error-handling.md`** ()
**8. `Base/Protocol/BoltProtocol/Document/08-versioning.md`** ()

 `07-error-handling.md` 

---

**`Base/Protocol/BoltProtocol/Document/07-error-handling.md`**

```markdown
# BoltProtocol 

BoltProtocol  `boltprotocol::BoltError` 

## 1. `boltprotocol::BoltError` 

`BoltError`  `boltprotocol/bolt_errors_versions.h`  `boltprotocol/message_defs.h` 



*   **`BoltError::SUCCESS` ( 0)**:
    *   

*   ****:
    *   `BoltError::UNKNOWN_ERROR`: 
    *   `BoltError::INVALID_ARGUMENT`: 
    *   `BoltError::OUT_OF_MEMORY`: 

*   **/**:
    *   `BoltError::SERIALIZATION_ERROR`:  C++  PackStream 
    *   `BoltError::DESERIALIZATION_ERROR`:  PackStream  C++ 
    *   `BoltError::INVALID_MESSAGE_FORMAT`:  PackStream Structure 
    *   `BoltError::RECURSION_DEPTH_EXCEEDED`:  PackStream  List, Map, Structure
    *   `BoltError::MESSAGE_TOO_LARGE`: 

*   ****:
    *   `BoltError::NETWORK_ERROR`: / I/O 

*   ** (Handshake) **:
    *   `BoltError::HANDSHAKE_FAILED`: 
    *   `BoltError::HANDSHAKE_NO_COMMON_VERSION`:  Bolt 
    *   `BoltError::HANDSHAKE_MAGIC_MISMATCH`:  Bolt 
    *   `BoltError::UNSUPPORTED_PROTOCOL_VERSION`: 

*   ** (Chunking) **:
    *   `BoltError::CHUNK_TOO_LARGE`:  (65535 )
    *   `BoltError::CHUNK_ENCODING_ERROR`: 
    *   `BoltError::CHUNK_DECODING_ERROR`: 

## 2. 

 `BoltError` ****

****:
```cpp
#include "boltprotocol/message_defs.h" // For BoltError
#include <iostream>

//  some_bolt_operation 
// boltprotocol::BoltError result = some_bolt_operation(args...);

// if (result != boltprotocol::BoltError::SUCCESS) {
//     std::cerr << "Bolt operation failed with error code: " 
//               << static_cast<int>(result) << std::endl;
//     //  result 
//     // 
// } else {
//     // 
// }
```

## 3. `PackStreamReader`  `PackStreamWriter` 

`PackStreamReader`  `PackStreamWriter`  `ChunkedReader`  `ChunkedWriter`/



*   **`bool has_error() const;`**:
    *    `true` `false`
*   **`boltprotocol::BoltError get_error() const;`**:
    *    `BoltError`  `has_error()`  `false` `BoltError::SUCCESS`

****:
```cpp
#include "boltprotocol/packstream_writer.h"
#include "boltprotocol/message_defs.h" // For Value, BoltError
#include <vector>
#include <string>
#include <iostream>

// std::vector<uint8_t> buffer;
// boltprotocol::PackStreamWriter writer(buffer);
// boltprotocol::Value val1(std::string("test"));
// boltprotocol::Value val2(12345LL);

// writer.write(val1); // 
// writer.write(val2); // 

// // 
// if (writer.has_error()) {
//     boltprotocol::BoltError final_error = writer.get_error();
//     std::cerr << "PackStreamWriter encountered an error during operations: " 
//               << static_cast<int>(final_error) << std::endl;
// } else {
//     std::cout << "All PackStream writes successful." << std::endl;
// }
```
 `write`  `read` 

## 4.  C++ 

BoltProtocol ** C++ ** `BoltError` 

 C++  `std::vector`, `std::string`, `std::map`  `std::bad_alloc`

*   ****:  `std::bad_alloc` `BoltError` `BoltError::OUT_OF_MEMORY`
*   ****: 

 `BoltError`  C++ 

## 5.  ()



*   ****:  `BoltError::NETWORK_ERROR` 
*   ****: / `BoltError::INVALID_MESSAGE_FORMAT`, `BoltError::DESERIALIZATION_ERROR` Bolt /
    1.  
    2.   Bolt 
    3.  
    4.  

## 

*   ****:  BoltProtocol 
*   ****:  `BoltError` 
*   ****:  `has_error()`  `get_error()` 
*   ****: 

 `BoltError` 
``` `08-versioning.md` 

---

**`Base/Protocol/BoltProtocol/Document/08-versioning.md`**

```markdown
# Bolt 

Bolt BoltProtocol 

## 1.  (`boltprotocol::versions::Version`)

Bolt  `boltprotocol::versions::Version`  `boltprotocol/bolt_errors_versions.h`  `boltprotocol/message_defs.h` 

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 
        uint8_t minor; // 

        //  ( 0.0 )
        Version(); 

        //  Version(5, 4)  Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        // 
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;
        bool operator!=(const Version& other) const;
        // >=, >, <=  <  == 

        // 4 ( 00 00 Major Minor)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 4
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    //  Bolt 
    extern const Version V5_4; // (5,4)
    extern const Version V5_3; // (5,3)
    extern const Version V5_2; // (5,2)
    extern const Version V5_1; // (5,1)
    extern const Version V5_0; // (5,0)
    extern const Version V4_4; // (4,4)
    // ... 

    // 
    extern const std::vector<Version>& get_default_proposed_versions();

} // namespace versions
} // namespace boltprotocol
```

 `boltprotocol::versions::V5_4` `Version` 

## 2. 

**** Bolt  API  `03-handshake-and-chunking.md` 

 `boltprotocol::perform_handshake()`
1.   (`std::vector<boltprotocol::versions::Version>`)
2.  
3.  
4.   `boltprotocol::versions::Version& out_negotiated_version` 

 `out_negotiated_version` ****

## 3. 

Bolt  Bolt 



*   ****:
    *   **`HELLO` **:
        *   Bolt 5.1 scheme, principal, credentials HELLO  `extra` map 
        *   Bolt 5.1  `LOGON` 
        *   Bolt 4.1+`extra` map  `routing` 
        *   Bolt 4.3-4.4`extra` map  `patch_bolt`  ( `"utc"`)
        *   Bolt 5.2+`extra` map  `notifications_minimum_severity`  `notifications_disabled_categories`
        *   Bolt 5.3+`extra` map **** `bolt_agent` 
    *   **`RUN`  `BEGIN` **:  `extra` map  `db`, `imp_user`, `tx_timeout`, `mode`, `bookmarks`, `notifications_...` Bolt 
    *   **`PULL`  `DISCARD` **:
        *   Bolt 4.0  `PULL_ALL`  `DISCARD_ALL` PackStream Structure 
        *   Bolt 4.0  `PULL`  `DISCARD` PackStream Structure  `extra` map  map  `n`  `qid` 
    *   **`ROUTE` **:
        *   Bolt 4.3PackStream Structure  `db` (String  Null)
        *   Bolt 4.4 PackStream Structure  `extra` Map ( `db`, `imp_user`)
    *   **`LOGON`, `LOGOFF`, `TELEMETRY`**:  Bolt 

*   **PackStream **:
    *   `BoltNode`, `BoltRelationship`, `BoltUnboundRelationship`  `element_id`  Bolt 5.0 
    *   `BoltDateTime`  `BoltDateTimeZoneId` Bolt 5.0  ( 'I', 'i') ( 'F', 'f')Bolt 4.4  `"utc"` patch 

*   ****:
    *    `ROUTE`  `rt`  `db`  Bolt 4.4 
    *    `SUCCESS`  `FAILURE`  `metadata`  `FAILURE`  `gql_status`  Bolt 5.7+ 

## 4.  BoltProtocol 

 API  `boltprotocol::versions::Version` 

*   ****:
    *   `serialize_hello_message(params, writer, client_target_version)`: `client_target_version`  HELLO 
    *   `serialize_run_message(params, writer, negotiated_version)`
    *   `serialize_begin_message(params, writer, negotiated_version)`
    *   `serialize_route_message(params, writer, negotiated_version)`
    *    `negotiated_version` 

*   ****:
    *   `deserialize_hello_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_run_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_begin_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_pull_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_discard_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_route_message_request(reader, out_params, server_negotiated_version)`
    *    `server_negotiated_version` 

*   ** PackStream **:
    *   `from_packstream(pss, out_node, bolt_version)`
    *   `to_packstream(node, bolt_version, out_pss)`
    *   `to_packstream(datetime, bolt_version, utc_patch_active_for_4_4, out_pss)`
    *    `utc_patch_active_for_4_4`  DateTime/DateTimeZoneId /

## 5. 

 BoltProtocol 

1.  ****:  `perform_handshake`
2.  ****:  `perform_handshake`  `negotiated_version`
3.  ****:  `negotiated_version`
4.  ****:  `HELLO`  `SUCCESS`  `metadata`  `patch_bolt`  "utc" patch  `hints`/`configuration_hints` ROUTE V2  `RouteMessageParams`  `routing_table_context` `to_packstream`  `utc_patch_active_for_4_4` 

## 

Bolt  API  Bolt 
```#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "client_example_session.h"  // For ClientSession struct
#include "client_example_utils.h"    // For print_bolt_error_details_client if main directly reports an error

// Include new transaction step headers
#include "boltprotocol/message_defs.h"  // For BoltError, Value
#include "client_example_tx_begin.h"
#include "client_example_tx_commit.h"
#include "client_example_tx_pull.h"
#include "client_example_tx_run.h"

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Client Example (No-Exception, Refactored TX)" << std::endl;
    std::cout << "-----------------------------------------------------------" << std::endl;

    ClientSession session;  // Manages streams, negotiated_version, last_error

    // --- 0. Perform Handshake ---
    std::cout << "\n--- Performing Handshake ---" << std::endl;
    if (session.perform_handshake_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- 1. Client Sends HELLO Message ---
    std::cout << "\n--- Client Sending HELLO ---" << std::endl;
    if (session.send_hello_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- Transaction Block ---
    std::cout << "\n--- Starting Transaction Block ---" << std::endl;
    if (ClientTransaction::begin_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }

    int64_t query_id = -1;
    std::string test_query = "CREATE (a:Person {name: 'Alice'}) RETURN id(a)";
    std::map<std::string, Value> test_params;

    // std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl; // Moved into function
    if (ClientTransaction::run_query_in_transaction(session, test_query, test_params, query_id) != BoltError::SUCCESS) {
        // Consider ROLLBACK here
        session.send_goodbye_sequence();
        return 1;
    }

    if (query_id != -1) {
        std::vector<RecordMessageParams> records;
        // std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << query_id << " ---" << std::endl; // Moved
        if (ClientTransaction::pull_all_results_in_transaction(session, query_id, records) != BoltError::SUCCESS) {
            session.send_goodbye_sequence();
            return 1;
        }
        std::cout << "Client: PULL sequence successful. Received " << records.size() << " records." << std::endl;
        for (const auto& record_param : records) {
            std::cout << "  Record: ";
            for (const auto& field_value : record_param.fields) {
                if (std::holds_alternative<int64_t>(field_value)) {
                    std::cout << std::get<int64_t>(field_value) << " ";
                } else if (std::holds_alternative<std::string>(field_value)) {
                    std::cout << "\"" << std::get<std::string>(field_value) << "\" ";
                } else {
                    std::cout << "[type_idx:" << field_value.index() << "] ";
                }
            }
            std::cout << std::endl;
        }
    } else {
        std::cout << "Client: No valid qid from RUN, or qid indicates no results to pull. Skipping PULL." << std::endl;
    }

    // std::cout << "\n--- Client Sending COMMIT ---" << std::endl; // Moved
    if (ClientTransaction::commit_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }
    std::cout << "--- Transaction Block Finished ---" << std::endl;

    // --- 5. Client Sends GOODBYE ---
    std::cout << "\n--- Client Sending GOODBYE ---" << std::endl;
    if (session.send_goodbye_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    std::cout << "\nClient example finished successfully." << std::endl;
    return 0;
}// Base/Protocol/BoltProtocol/Example/client_example_session.cpp
#include "client_example_session.h"

#include <array>  // For std::array in manual handshake simulation

#include "boltprotocol/bolt_errors_versions.h"
#include "boltprotocol/message_defs.h"

// Anonymous namespace for implementation details or helpers local to this file
namespace {

    boltprotocol::BoltError prepare_hello_message_bytes(const boltprotocol::versions::Version& target_version, std::vector<uint8_t>& out_bytes) {
        using namespace boltprotocol;
        using versions::V5_1;
        using versions::V5_3;

        out_bytes.clear();
        PackStreamWriter ps_writer(out_bytes);

        HelloMessageParams hello_params;
        bool prep_ok = true;
        try {
            hello_params.user_agent = DEFAULT_USER_AGENT_FORMAT_STRING + " (Bolt " + std::to_string(target_version.major) + "." + std::to_string(target_version.minor) + ")";

            if (target_version < V5_1) {
                hello_params.auth_scheme = "basic";
                hello_params.auth_principal = "neo4j";
                hello_params.auth_credentials = "password";
            }

            if (target_version == V5_3 || !(target_version < V5_3)) {  // Equivalent to target_version >= V5_3
                HelloMessageParams::BoltAgentInfo agent_info;
                agent_info.product = "MyExampleClientLib/0.1";
                agent_info.platform = "Cpp/LinuxGeneric";
                hello_params.bolt_agent = agent_info;
            }

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc HELLO params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc HELLO params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep HELLO params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return BoltError::UNKNOWN_ERROR;

        BoltError err = serialize_hello_message(hello_params, ps_writer, target_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing HELLO", err, nullptr, &ps_writer);
        }
        return err;
    }

}  // anonymous namespace

boltprotocol::BoltError ClientSession::perform_handshake_sequence() {
    using namespace boltprotocol;
    client_to_server_stream.clear();  // Clear flags
    client_to_server_stream.str("");  // Clear content
    server_to_client_stream.clear();  // Clear flags
    server_to_client_stream.str("");  // Clear content

    std::vector<versions::Version> proposed_versions = versions::get_default_proposed_versions();
    if (proposed_versions.empty()) {
        print_bolt_error_details_client("perform_handshake_sequence: proposed_versions empty", BoltError::INVALID_ARGUMENT);
        last_error = BoltError::INVALID_ARGUMENT;
        return last_error;
    }

    // Simulate server choosing the first proposed version
    versions::Version server_chosen_version_sim = proposed_versions[0];
    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_b = server_chosen_version_sim.to_handshake_bytes();
    server_to_client_stream.write(reinterpret_cast<const char*>(server_response_b.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    server_to_client_stream.seekg(0);  // Rewind for client to read

    // For std::stringstream, we need to pass them directly to a perform_handshake
    // that is overloaded or templated to accept std::istream and std::ostream.
    // The current template `perform_handshake(SyncReadWriteStream& stream, ...)`
    // will not work directly with two separate std::stringstream.
    // The previous attempt to call it with two std::stringstream instances was due to a
    // misunderstanding of the template after it was changed from (ostream, istream, ...) form.

    // Since client_example uses std::stringstream, and perform_handshake is now
    // templated for a single SyncReadWriteStream (which std::stringstream does not model
    // in the way Boost.ASIO sockets do, e.g. no write_some/read_some for asio::write/read free functions),
    // we must manually implement the handshake byte exchange for the example.
    // OR, we could create a simple wrapper for std::stringstream that *does* satisfy
    // SyncReadWriteStream, but that's more involved for just an example.

    std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes_content;
    last_error = build_handshake_request(proposed_versions, handshake_request_bytes_content);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Building handshake request for example", last_error);
        return last_error;
    }

    client_to_server_stream.write(reinterpret_cast<const char*>(handshake_request_bytes_content.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
    if (client_to_server_stream.fail()) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Writing handshake to client_to_server_stream", last_error);
        return last_error;
    }
    client_to_server_stream.flush();  // Ensure it's "sent"

    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes_read;
    server_to_client_stream.read(reinterpret_cast<char*>(server_response_bytes_read.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    if (server_to_client_stream.fail() || static_cast<size_t>(server_to_client_stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Reading handshake response from server_to_client_stream", last_error);
        return last_error;
    }

    last_error = parse_handshake_response(server_response_bytes_read, negotiated_version);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Example: Parsing handshake response", last_error);
        return last_error;
    }

    std::cout << "Client: Handshake successful! Negotiated version: " << static_cast<int>(negotiated_version.major) << "." << static_cast<int>(negotiated_version.minor) << std::endl;
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_hello_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    last_error = prepare_hello_message_bytes(negotiated_version, raw_message_bytes_storage);
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = simulate_server_simple_success_response(server_to_client_stream, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("HELLO resp empty", BoltError::DESERIALIZATION_ERROR);
        last_error = BoltError::DESERIALIZATION_ERROR;
        return last_error;
    }
    SuccessMessageParams hello_success_params;
    {
        PackStreamReader hello_response_reader(raw_response_bytes_storage);
        last_error = deserialize_success_message(hello_response_reader, hello_success_params);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser HELLO SUCCESS", last_error, &hello_response_reader);
            return last_error;
        }
    }
    std::cout << "Client: HELLO SUCCESS deserialized." << std::endl;
    auto it_conn_id = hello_success_params.metadata.find("connection_id");
    if (it_conn_id != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_conn_id->second))) {
            std::cout << "Client: Received connection_id: " << *str_val << std::endl;
        }
    }
    auto it_server_agent = hello_success_params.metadata.find("server");
    if (it_server_agent != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_server_agent->second))) {
            std::cout << "Client: Server agent: " << *str_val << std::endl;
        }
    }
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_goodbye_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        last_error = serialize_goodbye_message(ps_writer);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing GOODBYE", last_error, nullptr, &ps_writer);
            return last_error;
        }
    }
    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "GOODBYE", false);
    if (last_error != BoltError::SUCCESS) {
        return last_error;
    }
    std::cout << "Client: GOODBYE sent." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_SESSION_H
#define CLIENT_EXAMPLE_SESSION_H

#include <array>  // For handshake
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For helpers

struct ClientSession {
    std::stringstream client_to_server_stream;
    std::stringstream server_to_client_stream;
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError last_error = boltprotocol::BoltError::SUCCESS;

    ClientSession() = default;

    boltprotocol::BoltError perform_handshake_sequence();
    boltprotocol::BoltError send_hello_sequence();
    boltprotocol::BoltError send_goodbye_sequence();
};

#endif  // CLIENT_EXAMPLE_SESSION_H#include "client_example_tx_begin.h"

#include "boltprotocol/message_serialization.h"  // For serialize_begin_message
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For simulate_server_simple_success_response, send_and_receive_raw_message_client

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending BEGIN ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            BeginMessageParams begin_params;
            // Populate begin_params with specific fields if needed, e.g., based on session.negotiated_version
            // begin_params.tx_timeout = 5000; // Example
            session.last_error = serialize_begin_message(begin_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing BEGIN", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("BEGIN resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams begin_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, begin_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser BEGIN SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: BEGIN SUCCESS deserialized." << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_BEGIN_H
#define CLIENT_EXAMPLE_TX_BEGIN_H

#include "boltprotocol/message_defs.h"  // For BoltError
#include "client_example_session.h"     // For ClientSession

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_BEGIN_H#include "client_example_tx_commit.h"

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending COMMIT ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            session.last_error = serialize_commit_message(ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing COMMIT", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("COMMIT resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams commit_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, commit_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser COMMIT SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: COMMIT SUCCESS deserialized." << std::endl;
        // Check for bookmark from commit_success_params.metadata if needed
        auto it_bookmark = commit_success_params.metadata.find("bookmark");
        if (it_bookmark != commit_success_params.metadata.end()) {
            if (const auto* str_val = std::get_if<std::string>(&(it_bookmark->second))) {
                std::cout << "Client: Received bookmark from COMMIT: " << *str_val << std::endl;
            }
        }
        return BoltError::SUCCESS;
    }

    // Implement rollback_transaction here if needed in the future
    /*
    boltprotocol::BoltError rollback_transaction(ClientSession& session) {
        // ... similar to commit_transaction but sends ROLLBACK and expects SUCCESS
        return BoltError::SUCCESS;
    }
    */

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_COMMIT_H
#define CLIENT_EXAMPLE_TX_COMMIT_H

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session);
    // boltprotocol::BoltError rollback_transaction(ClientSession& session); // For future

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_COMMIT_H#include "client_example_tx_pull.h"

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server sending a RECORD message
    boltprotocol::BoltError simulate_server_record_response(std::stringstream& server_pipe, const std::vector<boltprotocol::Value>& record_fields) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            RecordMessageParams rec_p;
            try {
                rec_p.fields = record_fields;  // Copy
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            PackStreamStructure pss_rec_obj;
            pss_rec_obj.tag = static_cast<uint8_t>(MessageTag::RECORD);
            std::shared_ptr<BoltList> list_sptr;
            try {
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(rec_p.fields);
                pss_rec_obj.fields.emplace_back(Value(list_sptr));
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            std::shared_ptr<PackStreamStructure> pss_rec_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_rec_obj));
            if (!pss_rec_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_rec_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RECORD", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RECORD", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RECORD response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_pull_message_bytes;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_records.clear();

        std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << qid << " ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_pull_message_bytes);
            PullMessageParams pull_params;
            pull_params.n = -1;  // PULL ALL
            if (qid != -1) {     // qid is mandatory for PULL in explicit transaction
                pull_params.qid = qid;
            } else {
                // This is an issue if qid is expected.
                print_bolt_error_details_client("PULL: qid is -1, which is invalid for explicit TX PULL", BoltError::INVALID_ARGUMENT);
                session.last_error = BoltError::INVALID_ARGUMENT;
                return session.last_error;
            }

            session.last_error = serialize_pull_message(pull_params, ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing PULL", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        bool first_pull_interaction = true;
        bool has_more_server_says = true;

        while (has_more_server_says) {
            // --- Simulate Server Response for PULL ---
            // This simulation sends one record, then a SUCCESS summary.
            // A real server might send many records before a SUCCESS with has_more:true,
            // or end with has_more:false.
            if (first_pull_interaction) {
                // Simulate server sending one RECORD
                std::vector<Value> record_data;
                try {
                    record_data.emplace_back(Value(static_cast<int64_t>(12345)));
                }  // Dummy ID
                catch (...) {
                    session.last_error = BoltError::OUT_OF_MEMORY;
                    return session.last_error;
                }
                session.last_error = simulate_server_record_response(session.server_to_client_stream, record_data);
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            } else {
                // After the first (and only in this sim) record, server sends SUCCESS summary
                // Simulate has_more:false to end the loop.
                // In a real scenario, server might send SUCCESS with has_more:true if there are more batches.
                session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "PULL summary (final)", qid);
                // To make it more realistic, the success response should include "has_more":false
                // We'd need to modify simulate_server_simple_success_response or use a more specific one.
                // For now, our client loop will break when it gets a SUCCESS.
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            }

            // --- Client Sends PULL (first time) and Receives Response ---
            std::vector<uint8_t> message_to_send_this_iteration;
            if (first_pull_interaction) {
                message_to_send_this_iteration = raw_pull_message_bytes;
            }

            session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, message_to_send_this_iteration, raw_response_bytes_storage, first_pull_interaction ? "PULL (for RECORD)" : "PULL (for summary)");
            if (session.last_error != BoltError::SUCCESS) return session.last_error;
            first_pull_interaction = false;

            if (raw_response_bytes_storage.empty()) {
                print_bolt_error_details_client("PULL response empty", BoltError::DESERIALIZATION_ERROR);
                session.last_error = BoltError::DESERIALIZATION_ERROR;
                return session.last_error;
            }

            // --- Client Deserializes Response ---
            Value peek_value;
            PackStreamStructure received_pss;  // To store the actual structure
            {
                PackStreamReader peek_reader(raw_response_bytes_storage);
                // We need to get the actual PSS, not just the shared_ptr from Value for tag checking.
                BoltError temp_err = deserialize_message_structure_prelude(peek_reader, MessageTag::HELLO, 0, 1, received_pss);  // Tag doesn't matter for just getting fields
                if (peek_reader.has_error() && temp_err == BoltError::SUCCESS) temp_err = peek_reader.get_error();               // ensure err state is from reader if prelude was ok

                if (temp_err != BoltError::SUCCESS && temp_err != BoltError::INVALID_MESSAGE_FORMAT) {  // Allow tag mismatch
                    print_bolt_error_details_client("Peeking PULL response structure", temp_err, &peek_reader);
                    session.last_error = temp_err;
                    return session.last_error;
                }
                // If it was INVALID_MESSAGE_FORMAT due to tag, that's fine, we check tag below.
                // If it was another error (e.g. not a PSS at all), that's a problem.
                if (!peek_reader.has_error() && received_pss.fields.empty() && received_pss.tag == 0) {  // deserialize_message_structure_prelude failed to get a PSS
                    print_bolt_error_details_client("Peeking PULL response: not a valid PSS", BoltError::DESERIALIZATION_ERROR, &peek_reader);
                    session.last_error = BoltError::DESERIALIZATION_ERROR;
                    return session.last_error;
                }
            }

            if (static_cast<MessageTag>(received_pss.tag) == MessageTag::RECORD) {
                RecordMessageParams rec_params;
                PackStreamReader record_reader(raw_response_bytes_storage);
                session.last_error = deserialize_record_message(record_reader, rec_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing RECORD from PULL", session.last_error, &record_reader);
                    return session.last_error;
                }
                out_records.push_back(std::move(rec_params));
                std::cout << "Client: RECORD deserialized from PULL." << std::endl;
                // Check for "has_more" in record metadata if present (uncommon, usually in SUCCESS)
                // For this simulation, we assume has_more_server_says is true until SUCCESS says otherwise
            } else if (static_cast<MessageTag>(received_pss.tag) == MessageTag::SUCCESS) {
                SuccessMessageParams summary_params;
                PackStreamReader summary_reader(raw_response_bytes_storage);
                session.last_error = deserialize_success_message(summary_reader, summary_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing SUCCESS summary from PULL", session.last_error, &summary_reader);
                    return session.last_error;
                }
                std::cout << "Client: PULL summary SUCCESS deserialized." << std::endl;

                // Check for "has_more" in the SUCCESS metadata
                auto it_has_more = summary_params.metadata.find("has_more");
                if (it_has_more != summary_params.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more_server_says = std::get<bool>(it_has_more->second);
                    std::cout << "Client: PULL summary has_more=" << (has_more_server_says ? "true" : "false") << std::endl;
                } else {
                    has_more_server_says = false;  // If not present, assume no more (Bolt 3 behavior)
                    std::cout << "Client: PULL summary 'has_more' not found or not bool, assuming false." << std::endl;
                }
            } else {
                print_bolt_error_details_client("PULL response unexpected PSS tag: " + std::to_string(received_pss.tag), BoltError::INVALID_MESSAGE_FORMAT);
                session.last_error = BoltError::INVALID_MESSAGE_FORMAT;
                return session.last_error;
            }
        }
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_PULL_H
#define CLIENT_EXAMPLE_TX_PULL_H

#include <vector>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_PULL_H#include "client_example_tx_run.h"

#include "boltprotocol/chunking.h"  // For ChunkedWriter if server sim uses it directly
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server RUN response (SUCCESS with fields and qid)
    // This could also live in client_example_utils.cpp if it's more general
    boltprotocol::BoltError simulate_server_run_response_fields(std::stringstream& server_pipe, const std::vector<std::string>& field_names, int64_t qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            SuccessMessageParams fields_s_p;
            bool prep_ok = true;
            try {
                auto fields_list_sptr = std::make_shared<BoltList>();
                for (const auto& field_name : field_names) {
                    fields_list_sptr->elements.emplace_back(Value(field_name));
                }
                fields_s_p.metadata.emplace("fields", Value(fields_list_sptr));
                if (qid != -1) {
                    fields_s_p.metadata.emplace("qid", Value(qid));
                }
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields alloc", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc Sim Srv: RUN SUCCESS fields: " << e.what() << std::endl;
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields stdexc", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                return BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return BoltError::UNKNOWN_ERROR;

            PackStreamStructure pss_obj;
            pss_obj.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            std::shared_ptr<BoltMap> meta_map_sptr;
            try {
                meta_map_sptr = std::make_shared<BoltMap>();
                meta_map_sptr->pairs = std::move(fields_s_p.metadata);
                pss_obj.fields.emplace_back(Value(meta_map_sptr));
            } catch (...) {
                return BoltError::UNKNOWN_ERROR; /* Simplified error */
            }

            std::shared_ptr<PackStreamStructure> pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj));
            if (!pss_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RUN SUCCESS fields", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        // Prime server_pipe with the response
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RUN SUCCESS fields", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RUN SUCCESS (fields, qid=" << qid << ") response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params, int64_t& out_qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_qid = -1;

        std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            RunMessageParams run_params;
            bool prep_ok = true;
            try {
                run_params.cypher_query = query;
                run_params.parameters = params;
                // Example of setting specific extra fields for RUN
                // run_params.db = "mydb"; // If appropriate for the version
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("alloc RUN_IN_TX params", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                session.last_error = BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc RUN_IN_TX params: " << e.what() << std::endl;
                print_bolt_error_details_client("prep RUN_IN_TX params", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                session.last_error = BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return session.last_error;

            session.last_error = serialize_run_message(run_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing RUN_IN_TX", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        int64_t simulated_qid = 2;                              // Server would generate this
        std::vector<std::string> simulated_fields = {"id(a)"};  // Match "CREATE (a:Person {name: 'Alice'}) RETURN id(a)"
        session.last_error = simulate_server_run_response_fields(session.server_to_client_stream, simulated_fields, simulated_qid);
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "RUN_IN_TX");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("RUN_IN_TX resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams run_in_tx_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, run_in_tx_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser RUN_IN_TX SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }

        auto it_qid = run_in_tx_success_params.metadata.find("qid");
        if (it_qid != run_in_tx_success_params.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
            out_qid = std::get<int64_t>(it_qid->second);
        } else {
            std::cout << "Client: Warning - qid not found or not int64 in RUN SUCCESS metadata for TX." << std::endl;
            // For auto-commit RUN, qid might not be present if no results are expected or version is old.
            // For explicit TX RUN, qid is usually expected.
        }
        std::cout << "Client: RUN_IN_TX SUCCESS (fields) deserialized. qid: " << out_qid << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_RUN_H
#define CLIENT_EXAMPLE_TX_RUN_H

#include <map>
#include <string>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params,
                                                     int64_t& out_qid);  // Output parameter for query ID

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_RUN_H#include "client_example_utils.h"

// Helper to print BoltError and associated reader/writer errors
void print_bolt_error_details_client(const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer, boltprotocol::ChunkedReader* chunk_reader, boltprotocol::ChunkedWriter* chunk_writer) {
    std::cerr << "Error (Client) " << context << ": " << static_cast<int>(err_code);
    if (reader && reader->has_error() && reader->get_error() != err_code) {
        std::cerr << " (PackStreamReader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err_code) {
        std::cerr << " (PackStreamWriter specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    if (chunk_reader && chunk_reader->has_error() && chunk_reader->get_error() != err_code) {
        std::cerr << " (ChunkedReader specific error: " << static_cast<int>(chunk_reader->get_error()) << ")";
    }
    if (chunk_writer && chunk_writer->has_error() && chunk_writer->get_error() != err_code) {
        std::cerr << " (ChunkedWriter specific error: " << static_cast<int>(chunk_writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

// Helper function to print a byte vector
void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}

// Simulate sending a raw message (PackStream bytes) via ChunkedWriter
// and receiving a raw response (PackStream bytes) via ChunkedReader.
boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response) {
    using namespace boltprotocol;
    BoltError err;

    // --- Client Sends Message ---
    std::cout << "Client: Preparing to send " << message_description_for_log << "..." << std::endl;
    print_bytes_client("Client: Raw " + message_description_for_log + " to send: ", raw_message_to_send);

    // Clear client_to_server_pipe for this message (caller responsibility to manage overall pipe lifetime)
    // For this helper, we assume it's okay to clear before writing.
    if (!raw_message_to_send.empty()) {  // Only clear if we are actually sending something
        client_to_server_pipe.clear();
        client_to_server_pipe.str("");
    }

    if (!raw_message_to_send.empty()) {  // Only write if there's a message
        ChunkedWriter chunk_writer(client_to_server_pipe);
        err = chunk_writer.write_message(raw_message_to_send);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("ChunkedWriter writing " + message_description_for_log, err, nullptr, nullptr, nullptr, &chunk_writer);
            return err;
        }
        std::cout << "Client: " << message_description_for_log << " written to client_to_server_pipe (chunked)." << std::endl;
    } else if (expect_response) {  // If sending nothing but expecting response (e.g. implicit PULL after RUN)
        std::cout << "Client: Sending no explicit message, but expecting response for " << message_description_for_log << "." << std::endl;
    } else {  // Sending nothing, expecting nothing
        std::cout << "Client: No message to send and no response expected for " << message_description_for_log << "." << std::endl;
    }

    // --- Client Receiving Response (if expected) ---
    if (!expect_response) {
        std::cout << "Client: No response expected for " << message_description_for_log << "." << std::endl;
        // Even if no response expected, server_pipe might have old data; clear it.
        server_to_client_pipe.clear();
        server_to_client_pipe.str("");
        return BoltError::SUCCESS;
    }

    std::cout << "Client: Waiting for server response to " << message_description_for_log << "..." << std::endl;
    // Check if the server pipe is empty *before* trying to read.
    // Need to peek to see if there's content, as str() doesn't reflect read position.
    server_to_client_pipe.peek();  // This updates EOF state if at end
    if (server_to_client_pipe.str().empty() && server_to_client_pipe.eof()) {
        std::cout << "Client: Server_to_client_pipe is empty and at EOF. No response to read for " << message_description_for_log << "." << std::endl;
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log + " (pipe was empty)", BoltError::NETWORK_ERROR);
        return BoltError::NETWORK_ERROR;
    }

    out_raw_response_received.clear();
    ChunkedReader chunk_reader(server_to_client_pipe);
    err = chunk_reader.read_message(out_raw_response_received);

    if (err != BoltError::SUCCESS) {
        // If read_message fails, it might be due to an empty pipe that wasn't caught above, or actual error.
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log, err, nullptr, nullptr, &chunk_reader);
        return err;
    }
    print_bytes_client("Client: Raw response received for " + message_description_for_log + ": ", out_raw_response_received);

    // Clear the server_to_client_pipe after successful read, ready for next simulated server response.
    server_to_client_pipe.clear();
    server_to_client_pipe.str("");

    return BoltError::SUCCESS;
}

// Helper to simulate server sending a simple SUCCESS {} response
boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid) {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_server_response_bytes;
    BoltError err;
    {
        PackStreamWriter ps_writer(raw_server_response_bytes);
        SuccessMessageParams success_p;
        bool prep_ok = true;
        try {
            if (qid != -1) {
                success_p.metadata.emplace("qid", Value(qid));
            }
            // Add other common success fields if needed for simulation
            // success_p.metadata.emplace("type", Value(std::string("r"))); // For query summary
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        PackStreamStructure success_pss;
        success_pss.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
        std::shared_ptr<BoltMap> meta_map_sptr;
        try {
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_p.metadata);  // Move if success_p not used after
            success_pss.fields.emplace_back(Value(meta_map_sptr));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS PSS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(success_pss));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS sptr: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr null", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        err = ps_writer.write(Value(std::move(pss_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing " + context_log + " SUCCESS", err, nullptr, &ps_writer);
            return err;
        }
    }
    // "Server" puts its response into the server_pipe
    server_pipe.clear();
    server_pipe.str("");  // Clear for this specific response
    {
        ChunkedWriter server_chunk_writer(server_pipe);
        err = server_chunk_writer.write_message(raw_server_response_bytes);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunk writing " + context_log + " SUCCESS", err, nullptr, nullptr, nullptr, &server_chunk_writer);
            return err;
        }
    }
    std::cout << "Server (Simulated): Sent " << context_log << " SUCCESS response." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_UTILS_H
#define CLIENT_EXAMPLE_UTILS_H

#include <cstdint>    // For uint8_t
#include <exception>  // For std::bad_alloc, std::exception
#include <iomanip>    // For std::setw, std::setfill
#include <iostream>
#include <map>     // For std::map
#include <memory>  // For std::shared_ptr, std::make_shared
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"  // Needed for PackStreamReader in print_bolt_error_details_client
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_client(
    const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr, boltprotocol::ChunkedReader* chunk_reader = nullptr, boltprotocol::ChunkedWriter* chunk_writer = nullptr);

void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes);

boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response = true);

boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid = -1);

#endif  // CLIENT_EXAMPLE_UTILS_H# CMakeLists.txt for BoltProtocol module examples

add_executable(client_example
    client_example_main.cpp
    client_example_utils.h
    client_example_utils.cpp
    client_example_session.h
    client_example_session.cpp
    # client_example_transaction.h # This header is now split
    # client_example_transaction.cpp # This source is now split
    client_example_tx_begin.h
    client_example_tx_begin.cpp
    client_example_tx_run.h
    client_example_tx_run.cpp
    client_example_tx_pull.h
    client_example_tx_pull.cpp
    client_example_tx_commit.h
    client_example_tx_commit.cpp
)
target_link_libraries(client_example PUBLIC BoltProtocol)

add_executable(server_example
    server_example_main.cpp
    server_example_utils.h
    server_example_utils.cpp
    server_example_handlers.h
    server_example_handlers.cpp
)
target_link_libraries(server_example PUBLIC BoltProtocol)#include "server_example_handlers.h"

#include <exception>
#include <optional>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version from bolt_errors_versions.h

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version) {
        using namespace boltprotocol;
        std::cout << "  Server processing HELLO message from: " << parsed_hello_params.user_agent << std::endl;
        if (parsed_hello_params.bolt_agent.has_value()) {
            std::cout << "    Bolt Agent Product: " << parsed_hello_params.bolt_agent.value().product << std::endl;
        }
        if (parsed_hello_params.auth_scheme.has_value()) {
            std::cout << "    Auth Scheme: " << parsed_hello_params.auth_scheme.value() << std::endl;
        }

        SuccessMessageParams success_for_hello_params;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;
        bool server_resp_ok = true;

        try {
            success_for_hello_params.metadata.emplace("connection_id", Value(std::string("server-conn-xyz")));
            success_for_hello_params.metadata.emplace("server", Value(std::string("MyExampleBoltServer/0.1 (Bolt ") + std::to_string(server_negotiated_version.major) + "." + std::to_string(server_negotiated_version.minor) + ")"));

            if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
                if (parsed_hello_params.patch_bolt.has_value()) {
                    for (const auto& patch : parsed_hello_params.patch_bolt.value()) {
                        if (patch == "utc") {
                            auto agreed_patches_list = std::make_shared<BoltList>();
                            agreed_patches_list->elements.emplace_back(Value(std::string("utc")));
                            success_for_hello_params.metadata.emplace("patch_bolt", Value(agreed_patches_list));
                            std::cout << "    Server agreed to 'utc' patch." << std::endl;
                            break;
                        }
                    }
                }
            }

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_for_hello_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));
            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("server HELLO SUCCESS resp (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            server_resp_ok = false;
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server HELLO SUCCESS resp: " << e_std.what() << std::endl;
            print_bolt_error_details_server("server HELLO SUCCESS resp (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            server_resp_ok = false;
            return BoltError::UNKNOWN_ERROR;
        }

        if (!server_resp_ok || !pss_to_write_sptr) {
            if (server_resp_ok && !pss_to_write_sptr) {
                print_bolt_error_details_server("server HELLO SUCCESS resp (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
            }
            return response_writer.get_error();
        }

        BoltError err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server serializing SUCCESS for HELLO", err, nullptr, &response_writer);
        }
        return err;
    }

    // handle_run_message now receives fully parsed RunMessageParams.
    // It no longer needs to deserialize from a raw PackStreamStructure itself.
    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Already parsed
                                               boltprotocol::PackStreamWriter& response_writer) {
        using namespace boltprotocol;
        std::cout << "  Server processing RUN query: '" << run_params.cypher_query << "'" << std::endl;

        // Access typed optional fields
        if (run_params.db.has_value()) {
            std::cout << "    For database: " << run_params.db.value() << std::endl;
        }
        if (run_params.tx_timeout.has_value()) {
            std::cout << "    With tx_timeout: " << run_params.tx_timeout.value() << "ms" << std::endl;
        }

        // Access cypher parameters
        auto limit_it = run_params.parameters.find("limit");
        if (limit_it != run_params.parameters.end()) {
            if (const auto* limit_val_ptr = std::get_if<int64_t>(&(limit_it->second))) {
                std::cout << "    With limit parameter: " << *limit_val_ptr << std::endl;
            }
        }
        // Access other_extra_fields if needed
        if (!run_params.other_extra_fields.empty()) {
            std::cout << "    With other extra fields:" << std::endl;
            for (const auto& pair : run_params.other_extra_fields) {
                std::cout << "      " << pair.first << ": (type " << pair.second.index() << ")" << std::endl;
            }
        }

        BoltError err = BoltError::SUCCESS;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<BoltList> list_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;

        // 1. Send SUCCESS for RUN (contains field names)
        try {
            SuccessMessageParams run_success_params;
            list_sptr = std::make_shared<BoltList>();
            list_sptr->elements.emplace_back(Value(std::string("name")));
            run_success_params.metadata.emplace("fields", Value(list_sptr));
            // Optionally add qid for explicit transactions, or t_first for auto-commit
            // run_success_params.metadata.emplace("t_first", Value(static_cast<int64_t>(10))); // Example

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();

            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(run_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing RUN SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing RUN SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing RUN SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing RUN SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS for RUN", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS for RUN (with fields)." << std::endl;

        // 2. Send RECORD messages (dummy data)
        for (int i = 0; i < 2; ++i) {
            try {
                RecordMessageParams record_params;
                record_params.fields.emplace_back(Value(std::string("Node " + std::to_string(i))));

                pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::RECORD);
                pss_obj_on_stack.fields.clear();
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(record_params.fields);
                pss_obj_on_stack.fields.emplace_back(Value(list_sptr));

                pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

            } catch (const std::bad_alloc&) {
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e_std) {
                std::cerr << "Std exception server preparing RECORD " << std::to_string(i) << ": " << e_std.what() << std::endl;
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
                response_writer.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }

            if (!pss_to_write_sptr) {
                print_bolt_error_details_server("preparing RECORD (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            }
            err = response_writer.write(Value(std::move(pss_to_write_sptr)));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_server("serializing RECORD " + std::to_string(i), err, nullptr, &response_writer);
                return err;
            }
            std::cout << "  Server sent RECORD " << i << "." << std::endl;
        }
        // 3. Send final SUCCESS (summary)
        try {
            SuccessMessageParams summary_success_params;
            summary_success_params.metadata.emplace("type", Value(std::string("r")));
            // For auto-commit that's now finished:
            // summary_success_params.metadata.emplace("bookmark", Value(std::string("neo4j:bookmark:v1:tx42")));
            // summary_success_params.metadata.emplace("has_more", Value(false)); // If Bolt 4.0+

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(summary_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing summary SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing summary SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing summary SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing summary SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS summary", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS summary." << std::endl;
        return BoltError::SUCCESS;
    }

    // This helper is no longer strictly needed if server_example_main.cpp directly uses
    // deserialize_run_message_request. If it were kept, it would need significant rework
    // to populate the new RunMessageParams structure correctly from a raw PackStreamStructure.
    // For now, let's comment it out as its functionality is superseded.
    /*
    boltprotocol::BoltError deserialize_run_params_from_struct(
        const boltprotocol::PackStreamStructure& run_struct,
        boltprotocol::RunMessageParams& out_params) {
        // ... This would need to parse run_struct.fields and populate the new
        //     std::optional members of out_params and other_extra_fields ...
        print_bolt_error_details_server("deserialize_run_params_from_struct is deprecated", boltprotocol::BoltError::UNKNOWN_ERROR);
        return boltprotocol::BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace ServerHandlers#ifndef SERVER_EXAMPLE_HANDLERS_H
#define SERVER_EXAMPLE_HANDLERS_H

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_utils.h"

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version);

    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Now receives fully parsed params
                                               boltprotocol::PackStreamWriter& response_writer
                                               // const boltprotocol::versions::Version& server_negotiated_version // Optional: if needed
    );

    // Removed deserialize_run_params_from_struct as its functionality is now
    // part of deserialize_run_message_request from the core library.

}  // namespace ServerHandlers

#endif  // SERVER_EXAMPLE_HANDLERS_H#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/bolt_errors_versions.h"  // For direct use of versions::V5_X
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_handlers.h"
#include "server_example_utils.h"

// Helper to simulate client sending a HELLO message
boltprotocol::BoltError simulate_client_hello(const boltprotocol::versions::Version& client_simulated_target_version, std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_hello_writer(out_raw_bytes);

    HelloMessageParams client_hello_params;
    bool client_prep_ok = true;
    try {
        client_hello_params.user_agent = "MyExampleCppClient/1.0 (Simulated)";

        if (client_simulated_target_version < versions::V5_1) {
            client_hello_params.auth_scheme = "basic";
            client_hello_params.auth_principal = "neo4j";
            client_hello_params.auth_credentials = "password";
        }
        if (!(client_simulated_target_version < versions::V5_3)) {  // client_simulated_target_version >= V5_3
            HelloMessageParams::BoltAgentInfo agent_info;
            agent_info.product = "SimulatedClientDriver/0.5";
            client_hello_params.bolt_agent = agent_info;
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim HELLO (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim HELLO: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim HELLO (std::exception)", BoltError::UNKNOWN_ERROR);
        client_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_prep_ok) return BoltError::UNKNOWN_ERROR;

    BoltError err = serialize_hello_message(client_hello_params, client_hello_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing HELLO", err, nullptr, &client_hello_writer);
    }
    return err;
}

// Helper to simulate client sending a RUN message
boltprotocol::BoltError simulate_client_run(const boltprotocol::versions::Version& client_simulated_target_version,  // Added version
                                            std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_run_writer(out_raw_bytes);
    RunMessageParams client_run_params;
    bool client_run_prep_ok = true;
    try {
        client_run_params.cypher_query = "MATCH (n) RETURN n.name AS name LIMIT $limit";
        client_run_params.parameters.emplace("limit", Value(static_cast<int64_t>(5)));
        // Example: Populate some typed extra fields if simulating a client that sends them
        if (client_simulated_target_version.major >= 4) {
            client_run_params.db = "system";
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim RUN (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_run_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim RUN: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim RUN (std::exception)", BoltError::UNKNOWN_ERROR);
        client_run_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_run_prep_ok) return BoltError::UNKNOWN_ERROR;

    // Pass the target version for RUN serialization
    BoltError err = serialize_run_message(client_run_params, client_run_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing RUN", err, nullptr, &client_run_writer);
    }
    return err;
}

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Server Example (Refactored, No-Exception Mode)" << std::endl;
    std::cout << "------------------------------------------------------------" << std::endl;

    std::vector<uint8_t> server_receive_buffer_storage;
    std::vector<uint8_t> server_send_buffer_storage;
    BoltError err = BoltError::SUCCESS;

    versions::Version server_assumed_negotiated_version = versions::V5_3;  // Example version server operates as

    std::cout << "\nServer expecting HELLO message (simulating client targeting v" << static_cast<int>(server_assumed_negotiated_version.major) << "." << static_cast<int>(server_assumed_negotiated_version.minor) << ") ..." << std::endl;

    err = simulate_client_hello(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for HELLO (raw): ", server_receive_buffer_storage);

    HelloMessageParams actual_hello_params;
    {
        PackStreamReader hello_reader(server_receive_buffer_storage);
        err = deserialize_hello_message_request(hello_reader, actual_hello_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing HELLO request", err, &hello_reader);
            return 1;
        }
    }
    std::cout << "Server: HELLO message structure received and parsed." << std::endl;
    std::cout << "  User Agent from HELLO: " << actual_hello_params.user_agent << std::endl;
    if (actual_hello_params.bolt_agent.has_value()) {
        std::cout << "  Bolt Agent Product: " << actual_hello_params.bolt_agent.value().product << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter success_hello_writer(server_send_buffer_storage);
        err = ServerHandlers::handle_hello_message(actual_hello_params, success_hello_writer, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending SUCCESS (for HELLO) (raw): ", server_send_buffer_storage);

    // === Stage 2: Client sends RUN, Server processes and responds ===
    std::cout << "\nServer expecting RUN message..." << std::endl;
    // Client also simulates RUN targeting the assumed negotiated version
    err = simulate_client_run(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for RUN (raw): ", server_receive_buffer_storage);

    RunMessageParams actual_run_params;
    {
        PackStreamReader run_reader(server_receive_buffer_storage);
        // Server deserializes RUN based on the version it negotiated
        err = deserialize_run_message_request(run_reader, actual_run_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing RUN request", err, &run_reader);
            return 1;
        }
    }
    std::cout << "Server: RUN message structure received and parsed." << std::endl;
    if (actual_run_params.db.has_value()) {
        std::cout << "  RUN request for database: " << actual_run_params.db.value() << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter run_response_writer(server_send_buffer_storage);
        // Pass the negotiated version to the handler if it needs to make version-specific decisions
        // For now, handle_run_message doesn't use it, but good practice.
        err = ServerHandlers::handle_run_message(actual_run_params, run_response_writer /*, server_assumed_negotiated_version */);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending full response stream for RUN (raw): ", server_send_buffer_storage);

    std::cout << "\nServer example finished." << std::endl;
    return 0;
}#include "server_example_utils.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer) {
    std::cerr << "Error (Server) " << context << ": " << static_cast<int>(err);
    if (reader && reader->has_error() && reader->get_error() != err) {
        std::cerr << " (Reader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err) {
        std::cerr << " (Writer specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}#ifndef SERVER_EXAMPLE_UTILS_H
#define SERVER_EXAMPLE_UTILS_H

#include <cstdint>  // For uint8_t
#include <iomanip>  // For std::setw, std::setfill
#include <iostream>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr);

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes);

#endif  // SERVER_EXAMPLE_UTILS_H#ifndef BOLTPROTOCOL_CORE_TYPES_H
#define BOLTPROTOCOL_CORE_TYPES_H

#include <cstdint>  // For uintXX_t types
#include <map>
#include <memory>  // For std::shared_ptr
#include <string>
#include <variant>  // For std::variant
#include <vector>

// Forward declarations within this file if mutually dependent, or include necessary headers
// For now, PackStreamStructure, BoltList, BoltMap are defined before Value uses them with shared_ptr.

namespace boltprotocol {

    // Forward declarations for Value variant members
    struct BoltList;
    struct BoltMap;
    struct PackStreamStructure;

    // Core PackStream Value type
    using Value = std::variant<std::nullptr_t, bool, int64_t, double, std::string, std::shared_ptr<BoltList>, std::shared_ptr<BoltMap>, std::shared_ptr<PackStreamStructure> >;

    // Definition for BoltList
    struct BoltList {
        std::vector<Value> elements;
        bool operator==(const BoltList& other) const {
            // Simple comparison, might need deep comparison for shared_ptr<Value> elements if Value itself can be complex.
            // Current Value::operator== handles shared_ptr comparison correctly.
            return elements == other.elements;
        }
    };

    // Definition for BoltMap
    struct BoltMap {
        std::map<std::string, Value> pairs;
        bool operator==(const BoltMap& other) const {
            return pairs == other.pairs;
        }
    };

    // Definition for PackStreamStructure
    struct PackStreamStructure {
        uint8_t tag = 0;
        std::vector<Value> fields;
        bool operator==(const PackStreamStructure& other) const {
            return tag == other.tag && fields == other.fields;
        }
    };

    // Global operator== for Value, needs full definitions of BoltList, BoltMap, PackStreamStructure
    // This declaration should ideally be where Value is fully defined or usable.
    // If moved to a .cpp, it needs to be declared here.
    // Keeping it here for header-only convenience if types are simple enough.
    // bool operator==(const Value& lhs, const Value& rhs); // Definition will be in message_defs.cpp (or a new core_types.cpp)

    // Global Constants
    constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;
    // extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING; // Declaration here, definition in a .cpp file
    constexpr uint16_t MAX_CHUNK_PAYLOAD_SIZE = 65535;
    constexpr uint16_t CHUNK_HEADER_SIZE = 2;

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CORE_TYPES_H#ifndef BOLTPROTOCOL_ERRORS_VERSIONS_H
#define BOLTPROTOCOL_ERRORS_VERSIONS_H

#include <array>
#include <cstdint>
#include <string>  // For Version::to_string ()
#include <vector>

namespace boltprotocol {

    enum class BoltError {
        SUCCESS = 0,
        UNKNOWN_ERROR,
        INVALID_ARGUMENT,
        SERIALIZATION_ERROR,
        DESERIALIZATION_ERROR,
        INVALID_MESSAGE_FORMAT,
        UNSUPPORTED_PROTOCOL_VERSION,
        NETWORK_ERROR,
        HANDSHAKE_FAILED,
        HANDSHAKE_NO_COMMON_VERSION,
        HANDSHAKE_MAGIC_MISMATCH,
        CHUNK_TOO_LARGE,
        CHUNK_ENCODING_ERROR,
        CHUNK_DECODING_ERROR,
        OUT_OF_MEMORY,
        RECURSION_DEPTH_EXCEEDED,
        MESSAGE_TOO_LARGE
    };

    namespace versions {
        struct Version {
            uint8_t major = 0;
            uint8_t minor = 0;

            Version() = default;
            constexpr Version(uint8_t maj, uint8_t min) : major(maj), minor(min) {
            }

            // 
            bool operator<(const Version& other) const;
            bool operator==(const Version& other) const;

            // 
            bool operator!=(const Version& other) const;
            bool operator>(const Version& other) const;
            bool operator<=(const Version& other) const;
            bool operator>=(const Version& other) const;

            std::string to_string() const;  // 

            std::array<uint8_t, 4> to_handshake_bytes() const;
            static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
        };

        // 
        extern const Version V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3;  //  V4_3 
        // extern const Version V4_2, V4_1, V4_0, V3_0;

        // 
        extern const std::vector<Version>& get_default_proposed_versions();
    }  // namespace versions

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_ERRORS_VERSIONS_H#ifndef BOLTPROTOCOL_MESSAGE_PARAMS_H
#define BOLTPROTOCOL_MESSAGE_PARAMS_H

#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Message Parameter Structures ---

    struct HelloMessageParams {
        std::string user_agent;
        std::optional<std::string> auth_scheme;
        std::optional<std::string> auth_principal;
        std::optional<std::string> auth_credentials;
        std::optional<std::map<std::string, Value>> auth_scheme_specific_tokens;  // For complex schemes like custom
        std::optional<std::map<std::string, Value>> routing_context;
        std::optional<std::vector<std::string>> patch_bolt;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        struct BoltAgentInfo {
            std::string product;
            std::optional<std::string> platform;
            std::optional<std::string> language;
            std::optional<std::string> language_details;
        };
        std::optional<BoltAgentInfo> bolt_agent;
        std::map<std::string, Value> other_extra_tokens;  // For any other non-standard tokens
    };

    struct RunMessageParams {
        std::string cypher_query;
        std::map<std::string, Value> parameters;
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the implicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the implicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt < 5.0)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct DiscardMessageParams {
        std::optional<int64_t> n;    // Number of records to discard (-1 for all)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct PullMessageParams {
        std::optional<int64_t> n;    // Number of records to pull (-1 for all remaining in current batch context)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct BeginMessageParams {
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the explicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the explicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt 5.0+)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct CommitMessageParams { /* PSS field is an empty map {} */
    };
    struct RollbackMessageParams { /* PSS field is an empty map {} */
    };

    struct RouteMessageParams {
        std::map<std::string, Value> routing_table_context;
        std::vector<std::string> bookmarks;
        std::optional<std::string> db_name_for_v43;  // Bolt 4.3: db (String or null)
        // Bolt 4.4+: extra map (can contain "db" and/or "imp_user")
        // Bolt 5.1+: extra map can also contain "notifications_min_severity", "notifications_disabled_categories"
        std::optional<std::map<std::string, Value>> extra_for_v44_plus;
    };

    struct TelemetryMessageParams {
        std::map<std::string, Value> metadata;  // api (int)
    };
    struct LogonMessageParams {
        std::map<std::string, Value> auth_tokens;
    };
    struct LogoffMessageParams { /* No fields */
    };

    struct SuccessMessageParams {
        std::map<std::string, Value> metadata;
    };
    struct RecordMessageParams {
        std::vector<Value> fields;
    };
    struct FailureMessageParams {
        std::map<std::string, Value> metadata;  // code (String), message (String)
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_PARAMS_H#ifndef BOLTPROTOCOL_MESSAGE_TAGS_H
#define BOLTPROTOCOL_MESSAGE_TAGS_H

#include <cstdint>

namespace boltprotocol {

    enum class MessageTag : uint8_t {
        HELLO = 0x01,
        RUN = 0x10,
        DISCARD = 0x2F,
        PULL = 0x3F,
        BEGIN = 0x11,
        COMMIT = 0x12,
        ROLLBACK = 0x13,
        RESET = 0x0F,
        GOODBYE = 0x02,
        ROUTE = 0x66,
        TELEMETRY = 0x54,
        LOGON = 0x6A,
        LOGOFF = 0x6B,
        SUCCESS = 0x70,
        RECORD = 0x71,
        IGNORED = 0x7E,
        FAILURE = 0x7F,
        // INIT = 0x01, // Same as HELLO tag
        // ACK_FAILURE = 0x0E // Bolt v1/v2 only
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_TAGS_H#ifndef BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H
#define BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_structure_types.h"

namespace boltprotocol {

    // --- Conversion from PackStreamStructure to Typed Struct ---

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    // For from_packstream, utc_patch_active might not be strictly needed if we rely on the tag ('I' vs 'F') primarily.
    // However, for to_packstream, it's crucial for Bolt 4.4.
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);

    // --- Conversion from Typed Struct to PackStreamStructure ---

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);               // <--- MODIFIED
    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);  // <--- MODIFIED
    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss);

    // Convenience template to extract from Value
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct, const versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Dispatch to the correct from_packstream overload based on T
        if constexpr (std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId> || std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath>) {
            // These types' from_packstream take bolt_version.
            // For DateTime/DateTimeZoneId, utc_patch_active is not directly used by from_packstream (tag driven).
            return from_packstream(*pss_sptr, out_typed_struct, bolt_version);
        } else {
            // For types like BoltDate, BoltTime, etc., that don't need bolt_version for from_packstream.
            return from_packstream(*pss_sptr, out_typed_struct);
        }
    }
    // Keep the overload for types not needing version or patch info for deserialization (tag-driven)
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // This simple overload is suitable for types whose from_packstream does not need a version.
        // For version-dependent types, the other overload must be used.
        return from_packstream(*pss_sptr, out_typed_struct);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H#ifndef BOLTPROTOCOL_STRUCTURE_TYPES_H
#define BOLTPROTOCOL_STRUCTURE_TYPES_H

#include <cstdint>
#include <map>
#include <memory>  // For std::shared_ptr in Path
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"  // For Value, BoltMap, BoltList, PackStreamStructure
// bolt_errors_versions.h might be needed if version checks are done during construction/conversion
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Graph Primitives ---

    // Tag: 0x4E ('N')
    struct BoltNode {
        int64_t id;                               // Field 0: id (Integer)
        std::vector<std::string> labels;          // Field 1: labels (List<String>)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        // Default constructor
        BoltNode() : id(0) {
        }

        bool operator==(const BoltNode& other) const {
            return id == other.id && labels == other.labels && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x52 ('R')
    struct BoltRelationship {
        int64_t id;                                        // Field 0: id (Integer)
        int64_t start_node_id;                             // Field 1: startNodeId (Integer)
        int64_t end_node_id;                               // Field 2: endNodeId (Integer)
        std::string type;                                  // Field 3: type (String)
        std::map<std::string, Value> properties;           // Field 4: properties (Map)
        std::optional<std::string> element_id;             // Field 5: element_id (String, Bolt 5.0+)
        std::optional<std::string> start_node_element_id;  // Field 6: start_node_element_id (String, Bolt 5.0+)
        std::optional<std::string> end_node_element_id;    // Field 7: end_node_element_id (String, Bolt 5.0+)

        BoltRelationship() : id(0), start_node_id(0), end_node_id(0) {
        }

        bool operator==(const BoltRelationship& other) const {
            return id == other.id && start_node_id == other.start_node_id && end_node_id == other.end_node_id && type == other.type && properties == other.properties && element_id == other.element_id && start_node_element_id == other.start_node_element_id &&
                   end_node_element_id == other.end_node_element_id;
        }
    };

    // Tag: 0x72 ('r') - Unbound Relationship (used within Path)
    struct BoltUnboundRelationship {
        int64_t id;                               // Field 0: id (Integer)
        std::string type;                         // Field 1: type (String)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        BoltUnboundRelationship() : id(0) {
        }

        bool operator==(const BoltUnboundRelationship& other) const {
            return id == other.id && type == other.type && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x50 ('P')
    struct BoltPath {
        std::vector<BoltNode> nodes;                // Field 0: nodes (List<Node>)
        std::vector<BoltUnboundRelationship> rels;  // Field 1: rels (List<UnboundRelationship>)
        std::vector<int64_t> indices;               // Field 2: indices (List<Integer>)
        // Note: For Path, nodes and rels are lists of *actual* BoltNode/BoltUnboundRelationship objects,
        // not shared_ptr<PackStreamStructure>. The conversion logic will handle this.

        bool operator==(const BoltPath& other) const {
            return nodes == other.nodes && rels == other.rels && indices == other.indices;
        }
    };

    // --- Temporal Types ---

    // Tag: 0x44 ('D') - Date
    struct BoltDate {
        int64_t days_since_epoch;  // days since Unix epoch (1970-01-01)

        BoltDate(int64_t days = 0) : days_since_epoch(days) {
        }
        bool operator==(const BoltDate& other) const {
            return days_since_epoch == other.days_since_epoch;
        }
    };

    // Tag: 0x54 ('T') - Time (with offset)
    struct BoltTime {
        int64_t nanoseconds_since_midnight;  // nanoseconds since midnight for the given offset
        int32_t tz_offset_seconds;           // offset in seconds from UTC

        BoltTime(int64_t nanos = 0, int32_t offset = 0) : nanoseconds_since_midnight(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x74 ('t') - LocalTime
    struct BoltLocalTime {
        int64_t nanoseconds_since_midnight;

        BoltLocalTime(int64_t nanos = 0) : nanoseconds_since_midnight(nanos) {
        }
        bool operator==(const BoltLocalTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight;
        }
    };

    // Tag: 0x49 ('I') - DateTime (with offset, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTime (tag 0x46 'F')
    struct BoltDateTime {
        int64_t seconds_epoch_utc;      // seconds since Unix epoch (UTC)
        int32_t nanoseconds_of_second;  // nanoseconds within the second (0 to 999,999,999)
        int32_t tz_offset_seconds;      // offset in seconds from UTC for the original instant

        BoltDateTime(int64_t secs = 0, int32_t nanos = 0, int32_t offset = 0) : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltDateTime& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x69 ('i') - DateTimeZoneId (with named zone, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTimeZoneId (tag 0x66 'f')
    struct BoltDateTimeZoneId {
        int64_t seconds_epoch_utc;
        int32_t nanoseconds_of_second;
        std::string tz_id;  // Timezone ID string (e.g., "Europe/Paris")

        BoltDateTimeZoneId(int64_t secs = 0, int32_t nanos = 0, std::string id = "") : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_id(std::move(id)) {
        }
        bool operator==(const BoltDateTimeZoneId& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_id == other.tz_id;
        }
    };

    // Tag: 0x64 ('d') - LocalDateTime
    struct BoltLocalDateTime {
        int64_t seconds_epoch_local;  // seconds since Unix epoch, interpreted as local datetime
        int32_t nanoseconds_of_second;

        BoltLocalDateTime(int64_t secs = 0, int32_t nanos = 0) : seconds_epoch_local(secs), nanoseconds_of_second(nanos) {
        }
        bool operator==(const BoltLocalDateTime& other) const {
            return seconds_epoch_local == other.seconds_epoch_local && nanoseconds_of_second == other.nanoseconds_of_second;
        }
    };

    // Tag: 0x45 ('E') - Duration
    struct BoltDuration {
        int64_t months;
        int64_t days;
        int64_t seconds;
        int32_t nanoseconds;  // nanoseconds adjustment for seconds component

        BoltDuration(int64_t m = 0, int64_t d = 0, int64_t s = 0, int32_t ns = 0) : months(m), days(d), seconds(s), nanoseconds(ns) {
        }
        bool operator==(const BoltDuration& other) const {
            return months == other.months && days == other.days && seconds == other.seconds && nanoseconds == other.nanoseconds;
        }
    };

    // --- Spatial Types ---

    // Tag: 0x58 ('X') - Point2D
    struct BoltPoint2D {
        uint32_t srid;  // Spatial Reference System Identifier
        double x;
        double y;

        BoltPoint2D(uint32_t id = 0, double px = 0.0, double py = 0.0) : srid(id), x(px), y(py) {
        }
        bool operator==(const BoltPoint2D& other) const {
            return srid == other.srid && x == other.x && y == other.y;
        }
    };

    // Tag: 0x59 ('Y') - Point3D
    struct BoltPoint3D {
        uint32_t srid;
        double x;
        double y;
        double z;

        BoltPoint3D(uint32_t id = 0, double px = 0.0, double py = 0.0, double pz = 0.0) : srid(id), x(px), y(py), z(pz) {
        }
        bool operator==(const BoltPoint3D& other) const {
            return srid == other.srid && x == other.x && y == other.y && z == other.z;
        }
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_TYPES_H#ifndef BOLTPROTOCOL_CHUNKING_H
#define BOLTPROTOCOL_CHUNKING_H

#include <cstdint>
#include <functional>  // For std::function
#include <iosfwd>      // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE

namespace boltprotocol {

    /**
     * @brief ChunkedWriter  Bolt 
     */
    class ChunkedWriter {
      public:
        explicit ChunkedWriter(std::ostream& stream);

        // 
        ChunkedWriter(const ChunkedWriter&) = delete;
        ChunkedWriter& operator=(const ChunkedWriter&) = delete;
        ChunkedWriter(ChunkedWriter&&) = delete;
        ChunkedWriter& operator=(ChunkedWriter&&) = delete;

        /**
         * @brief 
         *        
         * @param message_data  Bolt 
         * @return BoltError::SUCCESS 
         *         BoltError::NETWORK_ERROR 
         *         BoltError::SERIALIZATION_ERROR 
         */
        BoltError write_message(const std::vector<uint8_t>& message_data);

        /**
         * @brief 
         */
        BoltError get_error() const {
            return last_error_;
        }

        /**
         * @brief 
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError write_chunk(const uint8_t* data, uint16_t size);
        BoltError write_chunk_header(uint16_t chunk_payload_size);
        BoltError write_end_of_message_marker();  // Writes a zero-size chunk

        void set_error(BoltError err);

        std::ostream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
    };

    /**
     * @brief ChunkedReader  Bolt 
     */
    class ChunkedReader {
      public:
        explicit ChunkedReader(std::istream& stream);

        // 
        ChunkedReader(const ChunkedReader&) = delete;
        ChunkedReader& operator=(const ChunkedReader&) = delete;
        ChunkedReader(ChunkedReader&&) = delete;
        ChunkedReader& operator=(ChunkedReader&&) = delete;

        /**
         * @brief  Bolt 
         *        
         * @param out_message_data 
         *                         
         * @return BoltError::SUCCESS 
         *         BoltError::NETWORK_ERROR 
         *         BoltError::DESERIALIZATION_ERROR 
         *         BoltError::CHUNK_TOO_LARGE  MAX_CHUNK_PAYLOAD_SIZE.
         */
        BoltError read_message(std::vector<uint8_t>& out_message_data);

        /**
         * @brief 
         */
        BoltError get_error() const {
            return last_error_;
        }
        /**
         * @brief 
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError read_chunk_header(uint16_t& out_chunk_payload_size);
        BoltError read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to);

        void set_error(BoltError err);

        std::istream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
        // 
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CHUNKING_H#ifndef BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H
#define BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H

#include <map>
#include <memory>  // For std::shared_ptr
#include <optional>
#include <string>
#include <variant>  // For std::holds_alternative, std::get
#include <vector>

#include "boltprotocol/bolt_core_types.h"       // For Value, BoltList, BoltMap, PackStreamStructure
#include "boltprotocol/bolt_errors_versions.h"  // For versions::Version, BoltError
#include "boltprotocol/bolt_structure_types.h"  // For forward declaring BoltNode etc. if needed, or full defs for recursion

// Forward declare from_packstream for recursive calls in get_typed_list_field
namespace boltprotocol {
    // We need to forward declare all from_packstream overloads that might be called recursively
    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);
}  // namespace boltprotocol

namespace boltprotocol {
    namespace detail {

        template <typename T>
        inline std::optional<T> get_typed_field(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<T>(field_value)) {
                    try {
                        return std::get<T>(field_value);
                    } catch (const std::bad_variant_access&) { /* Defensive */
                    }
                }
            }
            return std::nullopt;
        }

        // Specialization for shared_ptr<BoltMap> to return the inner map directly
        template <>
        inline std::optional<std::map<std::string, Value>> get_typed_field<std::map<std::string, Value>>(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltMap>>(field_value)) {
                    const auto& map_sptr = std::get<std::shared_ptr<BoltMap>>(field_value);
                    if (map_sptr) {
                        try {
                            return map_sptr->pairs;
                        } catch (...) { /* map copy failed */
                        }
                    }
                }
            }
            return std::nullopt;
        }

        template <typename T>  // T is the target strong type, e.g., BoltNode
        inline std::optional<std::vector<T>> get_typed_list_field(const std::vector<Value>& fields, size_t index, const versions::Version* bolt_version_for_nested = nullptr) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltList>>(field_value)) {
                    const auto& list_sptr = std::get<std::shared_ptr<BoltList>>(field_value);
                    if (list_sptr) {
                        std::vector<T> result;
                        result.reserve(list_sptr->elements.size());
                        bool conversion_ok = true;
                        for (const auto& list_element_value : list_sptr->elements) {
                            if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(list_element_value)) {
                                const auto& element_pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(list_element_value);
                                if (element_pss_sptr) {
                                    T typed_element;
                                    BoltError err = BoltError::UNKNOWN_ERROR;  // Initialize to an error state

                                    // Dispatch based on type T for version parameter
                                    if constexpr (std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath> || std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId>) {
                                        if (!bolt_version_for_nested) {  // Version is required for these types
                                            conversion_ok = false;
                                            break;
                                        }
                                        err = from_packstream(*element_pss_sptr, typed_element, *bolt_version_for_nested);
                                    } else {  // For types like BoltDate, BoltTime, etc., that don't need version for from_packstream
                                        err = from_packstream(*element_pss_sptr, typed_element);
                                    }

                                    if (err == BoltError::SUCCESS) {
                                        try {
                                            result.push_back(std::move(typed_element));
                                        } catch (...) {
                                            conversion_ok = false;
                                            break;
                                        }
                                    } else {
                                        conversion_ok = false;
                                        break;
                                    }
                                } else {
                                    conversion_ok = false;
                                    break;
                                }  // Null PSS in list
                            } else {
                                conversion_ok = false;
                                break;
                            }  // Element not a PSS
                        }
                        if (conversion_ok) return result;
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H#ifndef BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H
#define BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H

#include <algorithm>  // For std::reverse
#include <bit>        // For std::endian (C++20 and later)
#include <cstdint>
#include <type_traits>  // For std::is_integral_v, std::is_enum_v

namespace boltprotocol {
    namespace detail {

        // Helper to swap bytes of an integer type T
        template <typename T>
        inline T swap_bytes_helper(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "swap_bytes_helper requires an integral or enum type.");
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
            auto* bytes = reinterpret_cast<unsigned char*>(&value);
            std::reverse(bytes, bytes + sizeof(T));
            return value;
        }

        // --- Host to Big Endian (Network Order) ---
        inline uint16_t host_to_be(uint16_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {  // std::endian::big (or other, assuming network order is what we want if not little)
                return val;
            }
        }

        inline uint32_t host_to_be(uint32_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        inline uint64_t host_to_be(uint64_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        // --- Big Endian (Network Order) to Host ---
        inline uint16_t be_to_host(uint16_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint32_t be_to_host(uint32_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint64_t be_to_host(uint64_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H#ifndef BOLTPROTOCOL_HANDSHAKE_H
#define BOLTPROTOCOL_HANDSHAKE_H

#include <array>
#include <boost/asio/basic_socket_iostream.hpp>  // For boost::asio::basic_socket_iostream
#include <boost/asio/ip/tcp.hpp>                 // For boost::asio::ip::tcp
#include <boost/asio/read.hpp>
#include <boost/asio/ssl/stream.hpp>  // For boost::asio::ssl::stream
#include <boost/asio/write.hpp>
#include <boost/system/error_code.hpp>
#include <cstdint>
#include <cstring>  // For std::memcpy
#include <istream>  // For std::istream characteristics if needed
#include <ostream>  // For std::ostream characteristics if needed
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"

namespace boltprotocol {

    constexpr size_t HANDSHAKE_NUM_PROPOSED_VERSIONS = 4;
    constexpr size_t HANDSHAKE_VERSION_SIZE_BYTES = 4;
    constexpr size_t HANDSHAKE_REQUEST_SIZE_BYTES = sizeof(BOLT_MAGIC_PREAMBLE) + (HANDSHAKE_NUM_PROPOSED_VERSIONS * HANDSHAKE_VERSION_SIZE_BYTES);
    constexpr size_t HANDSHAKE_RESPONSE_SIZE_BYTES = HANDSHAKE_VERSION_SIZE_BYTES;

    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes);
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response, versions::Version& out_negotiated_version);

    template <typename StreamType>
    BoltError perform_handshake(StreamType& stream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version) {
        std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes;
        BoltError build_err = build_handshake_request(proposed_versions, handshake_request_bytes);
        if (build_err != BoltError::SUCCESS) {
            return build_err;
        }

        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes;
        boost::system::error_code ec;

        //  if constexpr  StreamType  IO 
        if constexpr (std::is_base_of_v<std::basic_iostream<char>, StreamType> &&
                      //  basic_socket_iostream  std::iostream  Boost 
                      (std::is_same_v<StreamType, boost::asio::ip::tcp::iostream> || std::is_same_v<StreamType, boost::asio::basic_socket_iostream<boost::asio::ip::tcp>>)) {
            //  boost::asio::ip::tcp::iostream  basic_socket_iostream
            //  iostream 
            stream.write(reinterpret_cast<const char*>(handshake_request_bytes.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
            if (stream.fail()) return BoltError::NETWORK_ERROR;
            stream.flush();
            if (stream.fail()) return BoltError::NETWORK_ERROR;

            stream.read(reinterpret_cast<char*>(server_response_bytes.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
            if (stream.fail() || static_cast<size_t>(stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
                return BoltError::NETWORK_ERROR;
            }
        } else {
            //  Boost.ASIO  ssl::stream  ip::tcp::socket
            //  boost::asio::write  boost::asio::read 
            boost::asio::write(stream, boost::asio::buffer(handshake_request_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }

            boost::asio::read(stream, boost::asio::buffer(server_response_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }
        }

        return parse_handshake_response(server_response_bytes, out_negotiated_version);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_HANDSHAKE_H#ifndef BOLTPROTOCOL_MESSAGE_DEFS_H
#define BOLTPROTOCOL_MESSAGE_DEFS_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_message_params.h"
#include "bolt_message_tags.h"
#include "bolt_structure_types.h"  // <--- ADDED: For BoltNode, BoltDate etc.
// bolt_structure_serialization.h is for functions, not direct types needed by message_params generally

namespace boltprotocol {
    extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING;
    bool operator==(const Value& lhs, const Value& rhs);
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_DEFS_H#ifndef BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H
#define BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    // --- Client Message Serialization (Client -> Server) ---
    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version);
    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_goodbye_message(PackStreamWriter& writer);
    BoltError serialize_reset_message(PackStreamWriter& writer);
    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_commit_message(PackStreamWriter& writer);
    BoltError serialize_rollback_message(PackStreamWriter& writer);
    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version);
    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logoff_message(PackStreamWriter& writer);

    // --- Server Message Deserialization (Server -> Client) ---
    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params);
    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params);
    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params);
    BoltError deserialize_ignored_message(PackStreamReader& reader);

    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents);

    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count);

    // --- Server-Side Deserialization of Client Requests ---
    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params);
    BoltError deserialize_logoff_message_request(PackStreamReader& reader);
    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version);

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version);        // <--- MODIFIED
    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- MODIFIED
    BoltError deserialize_commit_message_request(PackStreamReader& reader);
    BoltError deserialize_rollback_message_request(PackStreamReader& reader);
    BoltError deserialize_reset_message_request(PackStreamReader& reader);
    BoltError deserialize_goodbye_message_request(PackStreamReader& reader);
    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- ADDED
    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params);                                              // <--- ADDED

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H

#include <cstdint>

namespace boltprotocol {

    // PackStream Marker Bytes
    constexpr uint8_t MARKER_NULL = 0xC0;
    constexpr uint8_t MARKER_FALSE = 0xC2;
    constexpr uint8_t MARKER_TRUE = 0xC3;
    constexpr uint8_t MARKER_FLOAT64 = 0xC1;

    // Integer markers
    // Tiny Int: -16 to 127 directly encoded in the marker byte
    // INT_8:  0xC8 <int8>
    // INT_16: 0xC9 <int16>
    // INT_32: 0xCA <int32>
    // INT_64: 0xCB <int64>
    constexpr uint8_t MARKER_INT_8 = 0xC8;
    constexpr uint8_t MARKER_INT_16 = 0xC9;
    constexpr uint8_t MARKER_INT_32 = 0xCA;
    constexpr uint8_t MARKER_INT_64 = 0xCB;

    // String markers
    // TINY_STRING: 0x80..0x8F (length 0-15)
    // STRING_8:    0xD0 <len_uint8> <utf8_bytes>
    // STRING_16:   0xD1 <len_uint16> <utf8_bytes>
    // STRING_32:   0xD2 <len_uint32> <utf8_bytes>
    constexpr uint8_t MARKER_TINY_STRING_BASE = 0x80;  // Base for 0x80 | len
    constexpr uint8_t MARKER_STRING_8 = 0xD0;
    constexpr uint8_t MARKER_STRING_16 = 0xD1;
    constexpr uint8_t MARKER_STRING_32 = 0xD2;

    // List markers
    // TINY_LIST:   0x90..0x9F (size 0-15)
    // LIST_8:      0xD4 <size_uint8>
    // LIST_16:     0xD5 <size_uint16>
    // LIST_32:     0xD6 <size_uint32>
    constexpr uint8_t MARKER_TINY_LIST_BASE = 0x90;  // Base for 0x90 | size
    constexpr uint8_t MARKER_LIST_8 = 0xD4;
    constexpr uint8_t MARKER_LIST_16 = 0xD5;
    constexpr uint8_t MARKER_LIST_32 = 0xD6;

    // Map markers
    // TINY_MAP:    0xA0..0xAF (size 0-15)
    // MAP_8:       0xD8 <size_uint8>
    // MAP_16:      0xD9 <size_uint16>
    // MAP_32:      0xDA <size_uint32>
    constexpr uint8_t MARKER_TINY_MAP_BASE = 0xA0;  // Base for 0xA0 | size
    constexpr uint8_t MARKER_MAP_8 = 0xD8;
    constexpr uint8_t MARKER_MAP_16 = 0xD9;
    constexpr uint8_t MARKER_MAP_32 = 0xDA;

    // Structure markers
    // TINY_STRUCT: 0xB0..0xBF (size 0-15) <tag_uint8>
    // STRUCT_8:    0xDC <size_uint8> <tag_uint8>
    // STRUCT_16:   0xDD <size_uint16> <tag_uint8>
    constexpr uint8_t MARKER_TINY_STRUCT_BASE = 0xB0;  // Base for 0xB0 | size
    constexpr uint8_t MARKER_STRUCT_8 = 0xDC;
    constexpr uint8_t MARKER_STRUCT_16 = 0xDD;

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamReader {
      public:
        explicit PackStreamReader(const std::vector<uint8_t>& buffer);
        explicit PackStreamReader(std::istream& stream);

        // /
        PackStreamReader(const PackStreamReader&) = delete;
        PackStreamReader& operator=(const PackStreamReader&) = delete;
        PackStreamReader(PackStreamReader&&) = delete;
        PackStreamReader& operator=(PackStreamReader&&) = delete;

        /**
         * @brief Reads a single PackStream Value from the input.
         * @param out_value Output parameter where the read Value will be stored if successful.
         *                  Its content is undefined if an error occurs.
         * @return BoltError::SUCCESS on successful read.
         *         BoltError::DESERIALIZATION_ERROR for format errors, unexpected EOF, etc.
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if reader not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails.
         */
        BoltError read(Value& out_value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

        /**
         * @brief Checks if the end of the underlying buffer or stream has been reached.
         *        Also returns true if an error has occurred, as further reading is not possible.
         * @return True if EOF or error, false otherwise.
         */
        bool eof() const;

      private:
        // IO,  error_state_
        BoltError peek_byte(uint8_t& out_byte);
        BoltError consume_byte(uint8_t& out_byte);
        BoltError consume_bytes(void* dest, size_t size);

        template <typename T>
        BoltError consume_network_int(T& out_val) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "consume_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;  // 

            //  out_val 
            out_val = T{};
            BoltError err;

            if constexpr (sizeof(T) == 1) {
                uint8_t byte_val;
                err = consume_byte(byte_val);
                if (err != BoltError::SUCCESS) return err;
                out_val = static_cast<T>(byte_val);
                return BoltError::SUCCESS;
            } else {
                typename std::conditional<sizeof(T) == 2, uint16_t, typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type>::type raw_be_val = 0;

                err = consume_bytes(&raw_be_val, sizeof(raw_be_val));
                if (err != BoltError::SUCCESS) return err;

                if constexpr (sizeof(T) == 2) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint16_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 4) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint32_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 8) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint64_t>(raw_be_val)));
                } else {
                    static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for consume_network_int.");
                    set_error(BoltError::INVALID_ARGUMENT);  //  static_assert 
                    return BoltError::INVALID_ARGUMENT;
                }
                return BoltError::SUCCESS;
            }
        }

      public:
        void set_error(BoltError error);

      private:
        //  ( BoltError  out_value )
        BoltError read_null_value(Value& out_value);
        BoltError read_boolean_value(bool bool_val_from_marker, Value& out_value);
        BoltError read_float64_value(Value& out_value);
        BoltError read_integer_value(uint8_t marker, Value& out_value);
        BoltError read_string_value(uint8_t marker, Value& out_value);
        BoltError read_string_data_into(std::string& out_string, uint32_t size);
        BoltError read_list_value(uint8_t marker, Value& out_value);
        BoltError read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size);
        BoltError read_map_value(uint8_t marker, Value& out_value);
        BoltError read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size);
        BoltError read_struct_value(uint8_t marker, Value& out_value);
        BoltError read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size);

        const std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::istream* stream_ptr_ = nullptr;
        size_t buffer_pos_ = 0;
        BoltError error_state_ = BoltError::SUCCESS;

        // 
        // ( read_list/map/struct_elements_into )
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamWriter {
      public:
        explicit PackStreamWriter(std::vector<uint8_t>& buffer);
        explicit PackStreamWriter(std::ostream& stream);

        // 
        PackStreamWriter(const PackStreamWriter&) = delete;
        PackStreamWriter& operator=(const PackStreamWriter&) = delete;
        PackStreamWriter(PackStreamWriter&&) = delete;
        PackStreamWriter& operator=(PackStreamWriter&&) = delete;

        /**
         * @brief Writes a single PackStream Value to the output.
         * @param value The Value to serialize and write.
         * @return BoltError::SUCCESS on successful write.
         *         BoltError::SERIALIZATION_ERROR for logical errors (e.g., string too long).
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if writer not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails (e.g. vector resize).
         */
        BoltError write(const Value& value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

      private:
        // IO,  error_state_
        BoltError append_byte(uint8_t byte);
        BoltError append_bytes(const void* data, size_t size);

        template <typename T>
        BoltError append_network_int(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "append_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;

            BoltError err;
            if constexpr (sizeof(T) == 1) {
                err = append_byte(static_cast<uint8_t>(value));
            } else if constexpr (sizeof(T) == 2) {
                uint16_t be_val = detail::host_to_be(static_cast<uint16_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 4) {
                uint32_t be_val = detail::host_to_be(static_cast<uint32_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 8) {
                uint64_t be_val = detail::host_to_be(static_cast<uint64_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else {
                static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for append_network_int.");
                set_error(BoltError::INVALID_ARGUMENT);  //  static_assert 
                return BoltError::INVALID_ARGUMENT;
            }
            return err;  //  append_byte  append_bytes 
        }

      public:
        void set_error(BoltError error);

      private:
        //  ( BoltError)
        BoltError write_null_internal();
        BoltError write_boolean_internal(bool bool_value);
        BoltError write_integer_internal(int64_t int_value);
        BoltError write_float_internal(double float_value);
        BoltError write_string_header_internal(uint32_t size);
        BoltError write_string_data_internal(const std::string& value_str);  //  const ref
        BoltError serialize_string_internal(const std::string& str_value);
        BoltError write_list_header_internal(uint32_t size);
        BoltError serialize_list_internal(const BoltList& list_data);  //  const ref
        BoltError write_map_header_internal(uint32_t size);
        BoltError serialize_map_internal(const BoltMap& map_data);  //  const ref
        BoltError write_struct_header_internal(uint8_t tag, uint32_t size);
        BoltError serialize_structure_internal(const PackStreamStructure& struct_data);  //  const ref

        std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::ostream* stream_ptr_ = nullptr;
        BoltError error_state_ = BoltError::SUCCESS;

        // 
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  //  Reader 
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {  // Anonymous namespace for internal linkage helper functions

        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                return std::get<std::string>(it->second);
            }
            return std::nullopt;
        }

        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            result.push_back(std::get<std::string>(element));
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }

        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    return inner_map_sptr->pairs;
                }
            }
            return std::nullopt;
        }
        // Note: get_optional_int64_from_map was defined in the previous full listing of this file
        // but it's not actually used by HELLO, LOGON, or LOGOFF deserialization.
        // If other functions in this file needed it, it would go here too.

    }  // anonymous namespace

    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version) {
        // ... (implementation remains the same, uses helpers from anonymous namespace) ...
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure hello_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::HELLO, 1, 1, hello_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (hello_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(hello_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(hello_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs = extra_map_sptr->pairs;
        // using namespace detail_server_request_deserialization; // No longer needed due to anonymous namespace

        auto ua_it = extra_map_pairs.find("user_agent");
        if (ua_it != extra_map_pairs.end() && std::holds_alternative<std::string>(ua_it->second)) {
            try {
                out_params.user_agent = std::get<std::string>(ua_it->second);
            } catch (...) {
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        bool expect_auth_in_hello = (server_negotiated_version < versions::V5_1);
        if (expect_auth_in_hello) {
            out_params.auth_scheme = get_optional_string_from_map(*extra_map_sptr, "scheme");
            out_params.auth_principal = get_optional_string_from_map(*extra_map_sptr, "principal");
            out_params.auth_credentials = get_optional_string_from_map(*extra_map_sptr, "credentials");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 1)) {
            out_params.routing_context = get_optional_map_from_map(*extra_map_sptr, "routing");
        }
        if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
            out_params.patch_bolt = get_optional_list_string_from_map(*extra_map_sptr, "patch_bolt");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        bool bolt_agent_expected = (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 3));
        auto bolt_agent_map_val_it = extra_map_pairs.find("bolt_agent");
        if (bolt_agent_map_val_it != extra_map_pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second)) {
            auto agent_map_sptr = std::get<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second);
            if (agent_map_sptr) {
                HelloMessageParams::BoltAgentInfo agent_info;
                auto product_val = get_optional_string_from_map(*agent_map_sptr, "product");
                if (!product_val.has_value() || product_val.value().empty()) {
                    if (bolt_agent_expected) {
                        reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                        return BoltError::INVALID_MESSAGE_FORMAT;
                    }
                } else {
                    agent_info.product = product_val.value();
                }
                agent_info.platform = get_optional_string_from_map(*agent_map_sptr, "platform");
                agent_info.language = get_optional_string_from_map(*agent_map_sptr, "language");
                agent_info.language_details = get_optional_string_from_map(*agent_map_sptr, "language_details");
                if (!agent_info.product.empty()) {
                    out_params.bolt_agent = agent_info;
                } else if (bolt_agent_expected) {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            } else if (bolt_agent_expected) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else if (bolt_agent_expected) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        for (const auto& pair : extra_map_pairs) {
            if (pair.first != "user_agent" && pair.first != "scheme" && pair.first != "principal" && pair.first != "credentials" && pair.first != "routing" && pair.first != "patch_bolt" && pair.first != "notifications_minimum_severity" && pair.first != "notifications_disabled_categories" &&
                pair.first != "bolt_agent") {
                try {
                    out_params.other_extra_tokens.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        out_params.auth_tokens.clear();

        PackStreamStructure logon_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGON, 1, 1, logon_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (logon_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(logon_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(logon_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!auth_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.auth_tokens = std::move(auth_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logoff_message_request(PackStreamReader& reader) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        PackStreamStructure logoff_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGOFF, 0, 0, logoff_struct_contents);
        return err;
    }

}  // namespace boltprotocol// Base/Protocol/BoltProtocol/Source/bolt_errors_versions.cpp
//  Source/message_defs.cpp 

#include "boltprotocol/bolt_errors_versions.h"  //  Version 

#include <algorithm>  // For std::min (if needed, though not in current Version funcs)
#include <cstring>    // For std::memcpy in from_handshake_bytes (original version had it)
#include <stdexcept>  // For std::to_string in Version::to_string()
#include <string>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"  //  to_handshake_bytes  from_handshake_bytes

namespace boltprotocol {
    namespace versions {

        // --- Definitions for Version struct methods ---
        bool Version::operator<(const Version& other) const {
            if (major != other.major) {
                return major < other.major;
            }
            return minor < other.minor;
        }

        bool Version::operator==(const Version& other) const {
            return major == other.major && minor == other.minor;
        }

        bool Version::operator!=(const Version& other) const {
            return !(*this == other);
        }

        bool Version::operator>(const Version& other) const {
            return other < *this;
        }

        bool Version::operator<=(const Version& other) const {
            return !(*this > other);
        }

        bool Version::operator>=(const Version& other) const {
            return !(*this < other);
        }

        std::string Version::to_string() const {
            return std::to_string(static_cast<int>(major)) + "." + std::to_string(static_cast<int>(minor));
        }

        std::array<uint8_t, 4> Version::to_handshake_bytes() const {
            // Per Bolt spec for handshake version slots (e.g., Bolt 4.0+):
            // Versions are 32-bit unsigned integers, big-endian.
            // Example: 5.4 is 0x00000504.
            // Your previous provided code for handshake.cpp used a similar construction:
            // uint32_t version_int32_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));
            // uint32_t version_be = detail::host_to_be(version_int32_for_handshake);
            // std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            // However, the example handshake code `server_response_b = server_chosen_version_sim.to_handshake_bytes();`
            // and `Version::to_handshake_bytes()` in `message_defs.cpp` (from previous full listing) used `{0, 0, minor, major}`.
            // The spec for *server response* says: "the response will contain that version encoded as a single 32-bit integer."
            // The client *proposal slots* also take 32-bit big-endian integers.
            // Let's assume the intent for Version::to_handshake_bytes is to produce the 4-byte representation of THIS version
            // as it would appear in a handshake slot or response.
            // The common interpretation is [0,0,Major,Minor] if thinking about it byte-wise to form 0x0000MMNN (big-endian)
            // or if using your earlier message_defs.cpp code: {0,0,minor,major} which means MM=minor, NN=major.
            // Let's stick to the [0,0,Major,Minor] that maps to a simple u32.
            std::array<uint8_t, 4> bytes = {0, 0, 0, 0};
            uint32_t version_val = (static_cast<uint32_t>(major) << 8) | static_cast<uint32_t>(minor);
            uint32_t version_val_be = detail::host_to_be(version_val);
            std::memcpy(bytes.data(), &version_val_be, sizeof(uint32_t));
            return bytes;  // This will be [0,0,major,minor] if major/minor are single bytes and host is little-endian
                           // or [major,minor,0,0] if host is big-endian and we want 0xMMNN0000.
                           // Re-evaluating: The spec example "00 00 00 01" means version 1.0 (major=1, minor=0).
                           // So the 32-bit int is 0x0000MMNN where MM=major, NN=minor.
                           // Therefore, this implementation is correct if `version_val` is structured as Major in MSB of the relevant part.
                           // `(static_cast<uint32_t>(major) << 8) | static_cast<uint32_t>(minor)` results in 0x0000MMNN.
                           // `detail::host_to_be` correctly converts this to big-endian.
        }

        BoltError Version::from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version) {
            // Server responds with a single 32-bit big-endian version.
            uint32_t version_val_be;
            std::memcpy(&version_val_be, bytes.data(), sizeof(uint32_t));
            uint32_t version_val_host = detail::be_to_host(version_val_be);

            // Expecting 0x0000MMNN format where MM is major, NN is minor.
            if ((version_val_host >> 16) != 0) {  // Top two bytes should be zero for modern single versions
                // This could be a range proposal format if we were parsing client proposals,
                // but server response is a single version.
                // If not 0.0.X.Y, it's an unsupported format for a single version response.
                out_version = Version(0, 0);  // Reset
                return BoltError::UNSUPPORTED_PROTOCOL_VERSION;
            }

            out_version.major = static_cast<uint8_t>((version_val_host >> 8) & 0xFF);
            out_version.minor = static_cast<uint8_t>(version_val_host & 0xFF);

            // Check for 0.0 specifically, which means "no common version" if all bytes were zero.
            if (out_version.major == 0 && out_version.minor == 0) {
                bool all_zero = true;
                for (uint8_t b : bytes)
                    if (b != 0) all_zero = false;
                if (all_zero) {
                    // The handshake.cpp `parse_handshake_response` already checks this and returns HANDSHAKE_NO_COMMON_VERSION.
                    // So, here, parsing 0.0.0.0 as Version(0,0) is fine.
                }
            }
            return BoltError::SUCCESS;
        }

        // --- Definitions for extern version constants ---
        const Version V5_4(5, 4);
        const Version V5_3(5, 3);
        const Version V5_2(5, 2);
        const Version V5_1(5, 1);
        const Version V5_0(5, 0);
        const Version V4_4(4, 4);
        const Version V4_3(4, 3);
        // Add other versions if they were declared, e.g.:
        // const Version V4_2(4,2);
        // const Version V4_1(4,1);
        // const Version V4_0(4,0);
        // const Version V3_0(3,0);

        // --- Definition for get_default_proposed_versions ---
        const std::vector<Version>& get_default_proposed_versions() {
            static const std::vector<Version> DEFAULT_PROPOSED_VERSIONS_LIST = {
                V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3  // Add others if defined and desired
            };
            return DEFAULT_PROPOSED_VERSIONS_LIST;
        }

    }  // namespace versions
}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field etc.

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version) {
        if (pss.tag != 0x4E) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto labels_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);  // Uses specialization

        if (!id_opt.has_value() || !labels_list_sptr_opt.has_value() || !props_map_opt.has_value()) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& labels_list_sptr = labels_list_sptr_opt.value();
        if (!labels_list_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_node.id = id_opt.value();

        out_node.labels.clear();
        out_node.labels.reserve(labels_list_sptr->elements.size());
        for (const auto& label_val : labels_list_sptr->elements) {
            if (std::holds_alternative<std::string>(label_val)) {
                try {
                    out_node.labels.push_back(std::get<std::string>(label_val));
                } catch (...) {
                    return BoltError::OUT_OF_MEMORY;
                }  // Or UNKNOWN_ERROR
            } else {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        try {
            out_node.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_node.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
            // If field 3 is present but not string, get_typed_field returns nullopt, element_id remains nullopt.
            // If it's present and is PackNull, it should also result in nullopt.
            // This needs to be handled carefully if PackNull should clear the optional vs. type mismatch.
            // Current get_typed_field will return nullopt if type is not string.
            if (pss.fields[3].index() != 0 && !out_node.element_id.has_value() && pss.fields[3].index() != detail::get_typed_field<std::string>(pss.fields, 3).has_value()) {
                // This condition means: field 3 is not PackNull, AND we didn't get a string, AND it wasn't because it was a string.
                // This is a bit complex, usually indicates a type mismatch that wasn't caught by holds_alternative if Value was more complex.
                // For string, if it's not string, get_typed_field returns nullopt.
            }
        } else {
            out_node.element_id = std::nullopt;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x4E;  // 'N'

            out_pss_sptr->fields.emplace_back(Value(node.id));

            auto labels_list_sptr = std::make_shared<BoltList>();
            labels_list_sptr->elements.reserve(node.labels.size());
            for (const auto& label : node.labels) {
                labels_list_sptr->elements.emplace_back(Value(label));
            }
            out_pss_sptr->fields.emplace_back(Value(labels_list_sptr));

            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = node.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                if (node.element_id.has_value()) {
                    out_pss_sptr->fields.emplace_back(Value(node.element_id.value()));
                } else {
                    out_pss_sptr->fields.emplace_back(nullptr);
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version) {
        if (pss.tag != 0x50) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nodes_vec_opt = detail::get_typed_list_field<BoltNode>(pss.fields, 0, &bolt_version);
        if (!nodes_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.nodes = std::move(nodes_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto rels_vec_opt = detail::get_typed_list_field<BoltUnboundRelationship>(pss.fields, 1, &bolt_version);
        if (!rels_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.rels = std::move(rels_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto indices_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 2);
        if (!indices_list_sptr_opt || !indices_list_sptr_opt.value()) return BoltError::INVALID_MESSAGE_FORMAT;

        const auto& indices_list_sptr = indices_list_sptr_opt.value();
        out_path.indices.clear();
        try {
            out_path.indices.reserve(indices_list_sptr->elements.size());
            for (const auto& idx_val : indices_list_sptr->elements) {
                if (std::holds_alternative<int64_t>(idx_val)) {
                    out_path.indices.push_back(std::get<int64_t>(idx_val));
                } else {
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::UNKNOWN_ERROR;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x50;

            auto nodes_list_sptr = std::make_shared<BoltList>();
            nodes_list_sptr->elements.reserve(path.nodes.size());
            for (const auto& node : path.nodes) {
                std::shared_ptr<PackStreamStructure> node_pss_sptr;
                BoltError err = to_packstream(node, bolt_version, node_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                nodes_list_sptr->elements.emplace_back(Value(node_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(nodes_list_sptr));

            auto rels_list_sptr = std::make_shared<BoltList>();
            rels_list_sptr->elements.reserve(path.rels.size());
            for (const auto& rel : path.rels) {
                std::shared_ptr<PackStreamStructure> rel_pss_sptr;
                BoltError err = to_packstream(rel, bolt_version, rel_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                rels_list_sptr->elements.emplace_back(Value(rel_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(rels_list_sptr));

            auto indices_list_sptr = std::make_shared<BoltList>();
            indices_list_sptr->elements.reserve(path.indices.size());
            for (const auto& idx : path.indices) {
                indices_list_sptr->elements.emplace_back(Value(idx));
            }
            out_pss_sptr->fields.emplace_back(Value(indices_list_sptr));

        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x52) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 5;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 8 : 5;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto start_id_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto end_id_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 3);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 4);

        if (!id_opt || !start_id_opt || !end_id_opt || !type_opt || !props_map_opt) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_rel.id = id_opt.value();
        out_rel.start_node_id = start_id_opt.value();
        out_rel.end_node_id = end_id_opt.value();
        out_rel.type = type_opt.value();
        try {
            out_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 8) {
            out_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 5);
            out_rel.start_node_element_id = detail::get_typed_field<std::string>(pss.fields, 6);
            out_rel.end_node_element_id = detail::get_typed_field<std::string>(pss.fields, 7);
        } else {
            out_rel.element_id = std::nullopt;
            out_rel.start_node_element_id = std::nullopt;
            out_rel.end_node_element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x52;
            out_pss_sptr->fields.emplace_back(Value(rel.id));
            out_pss_sptr->fields.emplace_back(Value(rel.start_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.end_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(rel.element_id.has_value() ? Value(rel.element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.start_node_element_id.has_value() ? Value(rel.start_node_element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.end_node_element_id.has_value() ? Value(rel.end_node_element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x72) return BoltError::INVALID_MESSAGE_FORMAT;
        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;
        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) return BoltError::INVALID_MESSAGE_FORMAT;

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);

        if (!id_opt || !type_opt || !props_map_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_unbound_rel.id = id_opt.value();
        out_unbound_rel.type = type_opt.value();
        try {
            out_unbound_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_unbound_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
        } else {
            out_unbound_rel.element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x72;
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.id));
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = unbound_rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));
            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(unbound_rel.element_id.has_value() ? Value(unbound_rel.element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point) {
        if (pss.tag != 0x58) return BoltError::INVALID_MESSAGE_FORMAT;  // 'X'
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);

        if (!srid_opt || !x_opt || !y_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x58;  // 'X'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point) {
        if (pss.tag != 0x59) return BoltError::INVALID_MESSAGE_FORMAT;  // 'Y'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);
        auto z_opt = detail::get_typed_field<double>(pss.fields, 3);

        if (!srid_opt || !x_opt || !y_opt || !z_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        out_point.z = z_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x59;  // 'Y'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
            out_pss_sptr->fields.emplace_back(Value(point.z));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date) {
        if (pss.tag != 0x44) return BoltError::INVALID_MESSAGE_FORMAT;  // 'D'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!days_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_date.days_since_epoch = days_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x44;  // 'D'
            out_pss_sptr->fields.emplace_back(Value(date.days_since_epoch));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <iostream>
#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    // DateTime (Modern 'I' - 0x49 and Legacy 'F' - 0x46)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version) {
        // bolt_version is available if subtle distinctions are needed, but tag is primary.
        if (pss.tag == 0x49) {  // Modern DateTime 'I'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.seconds_epoch_utc = secs_opt.value();
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x46) {  // Legacy DateTime 'F'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            out_datetime.seconds_epoch_utc = secs_adjusted_by_offset_opt.value() - out_datetime.tz_offset_seconds;
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            return BoltError::SUCCESS;
        }

        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);

        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x49;  // 'I'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            } else {                       // Use Legacy DateTime 'F'
                out_pss_sptr->tag = 0x46;  // 'F'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc + datetime.tz_offset_seconds));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // DateTimeZoneId (Modern 'i' - 0x69 and Legacy 'f' - 0x66)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version) {
        // bolt_version might be used for subtle interpretation differences if any beyond tag.
        if (pss.tag == 0x69) {  // Modern 'i'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x66) {  // Legacy 'f'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_adjusted_by_offset_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            // Caller should be aware that for legacy 'f', seconds_epoch_utc is not pure UTC.
            return BoltError::SUCCESS;
        }
        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x69;  // 'i'
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            } else {                       // Use Legacy DateTimeZoneId 'f'
                out_pss_sptr->tag = 0x66;  // 'f'
                // As discussed, serializing to legacy 'f' from UTC seconds + tz_id without a TZDB is problematic.
                // The stored datetime_zoneid.seconds_epoch_utc is assumed to be pure UTC.
                // To produce the correct legacy 'seconds' field, we'd need to add the offset for tz_id at that instant.
                // Lacking TZDB, we will return an error or serialize potentially incorrect data.
                // For now, return error to highlight the issue.
                // A user wanting to serialize to legacy 'f' must provide a `seconds_epoch_utc` value
                // that is ALREADY `actual_utc_seconds + offset_for_tz_id_at_that_instant`.
                // std::cerr << "Error: Cannot accurately serialize BoltDateTimeZoneId to legacy format (0x66) "
                //           << "without timezone database information or pre-adjusted seconds value." << std::endl;
                // return BoltError::SERIALIZATION_ERROR;
                // OR, proceed with caution:
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));  // This is UTC, not adjusted!
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // LocalDateTime ('d' - 0x64)
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime) {
        if (pss.tag != 0x64) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;
        auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        if (!secs_opt.has_value() || !nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;
        out_local_datetime.seconds_epoch_local = secs_opt.value();
        out_local_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x64;
            out_pss_sptr->fields.emplace_back(Value(local_datetime.seconds_epoch_local));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(local_datetime.nanoseconds_of_second)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration) {
        if (pss.tag != 0x45) return BoltError::INVALID_MESSAGE_FORMAT;  // 'E'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto months_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto seconds_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 3);

        if (!months_opt || !days_opt || !seconds_opt || !nanos_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_duration.months = months_opt.value();
        out_duration.days = days_opt.value();
        out_duration.seconds = seconds_opt.value();
        out_duration.nanoseconds = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x45;  // 'E'
            out_pss_sptr->fields.emplace_back(Value(duration.months));
            out_pss_sptr->fields.emplace_back(Value(duration.days));
            out_pss_sptr->fields.emplace_back(Value(duration.seconds));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(duration.nanoseconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time) {
        if (pss.tag != 0x54) return BoltError::INVALID_MESSAGE_FORMAT;  // 'T'
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 1);  // Spec: Integer

        if (!nanos_opt.has_value() || !offset_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_time.nanoseconds_since_midnight = nanos_opt.value();
        // tz_offset_seconds is int32_t in BoltTime struct. Check for overflow if necessary,
        // though unlikely for timezone offsets.
        out_time.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x54;  // 'T'
            out_pss_sptr->fields.emplace_back(Value(time.nanoseconds_since_midnight));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(time.tz_offset_seconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time) {
        if (pss.tag != 0x74) return BoltError::INVALID_MESSAGE_FORMAT;  // 't'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_local_time.nanoseconds_since_midnight = nanos_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x74;  // 't'
            out_pss_sptr->fields.emplace_back(Value(local_time.nanoseconds_since_midnight));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/chunking.h"

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy (though not strictly needed if only writing from vector)
#include <exception>  // For std::bad_alloc
#include <iostream>   // For stream operations (std::ostream, std::istream)
#include <vector>     // For std::vector manipulations

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host

namespace boltprotocol {

    // --- ChunkedWriter Implementation ---

    ChunkedWriter::ChunkedWriter(std::ostream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {                        // Initial check of stream state
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if stream is already bad
        }
    }

    void ChunkedWriter::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to write the 2-byte chunk header
    BoltError ChunkedWriter::write_chunk_header(uint16_t chunk_payload_size) {
        if (has_error()) return last_error_;  // Don't proceed if already in error state

        uint16_t size_be = detail::host_to_be(chunk_payload_size);
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.write(reinterpret_cast<const char*>(&size_be), sizeof(size_be));
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return BoltError::NETWORK_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write a data chunk (header + payload)
    BoltError ChunkedWriter::write_chunk(const uint8_t* data, uint16_t size) {
        // This function is internal. `write_message` ensures size <= MAX_CHUNK_PAYLOAD_SIZE.
        // `has_error()` check is done by caller or at the start of `write_message`.

        BoltError err = write_chunk_header(size);
        if (err != BoltError::SUCCESS) {
            // error already set by write_chunk_header
            return err;
        }

        if (size > 0) {             // Only write payload if size is non-zero
            if (data == nullptr) {  // Should not happen if size > 0
                set_error(BoltError::INVALID_ARGUMENT);
                return last_error_;
            }
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return last_error_;
            }
            stream_.write(reinterpret_cast<const char*>(data), size);
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return BoltError::NETWORK_ERROR;
            }
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write the end-of-message marker (a chunk with size 0)
    BoltError ChunkedWriter::write_end_of_message_marker() {
        return write_chunk_header(0);  // This writes a 2-byte header with 0x0000
    }

    // Public method to write a full message, chunked.
    BoltError ChunkedWriter::write_message(const std::vector<uint8_t>& message_data) {
        if (has_error()) return last_error_;  // Check if writer is already in an error state
        last_error_ = BoltError::SUCCESS;     // Reset error for this new operation

        const uint8_t* data_ptr = message_data.data();
        size_t total_message_size = message_data.size();
        size_t remaining_size = total_message_size;

        if (stream_.fail()) {  // Check stream before starting writes for this message
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        // Handle empty message payload: send a single EOM marker if message_data is empty.
        // Bolt messages are typically not empty (even GOODBYE has a PSS structure).
        // If message_data is empty, it means the PSS serialization resulted in zero bytes.
        // This case is unusual. A common interpretation would be to send *no* data chunks,
        // followed by the EOM marker.
        if (total_message_size == 0) {
            BoltError eom_err = write_end_of_message_marker();
            if (eom_err == BoltError::SUCCESS) {
                stream_.flush();  // Attempt to flush
                if (stream_.fail()) {
                    set_error(BoltError::NETWORK_ERROR);
                    return last_error_;
                }
            }
            return eom_err;  // Return error from writing EOM or SUCCESS
        }

        // Write data chunks
        while (remaining_size > 0) {
            uint16_t current_chunk_payload_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(MAX_CHUNK_PAYLOAD_SIZE)));

            BoltError chunk_write_err = write_chunk(data_ptr, current_chunk_payload_size);
            if (chunk_write_err != BoltError::SUCCESS) {
                // Error (and last_error_) already set by write_chunk or write_chunk_header
                return last_error_;
            }

            data_ptr += current_chunk_payload_size;
            remaining_size -= current_chunk_payload_size;
        }

        // After all data chunks are written, write the end-of-message marker
        BoltError eom_err = write_end_of_message_marker();
        if (eom_err != BoltError::SUCCESS) {
            return last_error_;  // Error already set
        }

        // Attempt to flush the stream to ensure all data is sent
        stream_.flush();
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        return BoltError::SUCCESS;
    }

    // --- ChunkedReader Implementation ---

    ChunkedReader::ChunkedReader(std::istream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void ChunkedReader::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to read the 2-byte chunk header
    BoltError ChunkedReader::read_chunk_header(uint16_t& out_chunk_payload_size) {
        out_chunk_payload_size = 0;  // Initialize output
        if (has_error()) return last_error_;

        uint16_t size_be;  // To store big-endian size from stream

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(&size_be), sizeof(size_be));

        if (stream_.fail()) {                     // Check failbit (which is set on EOF by read if not enough bytes)
            set_error(BoltError::NETWORK_ERROR);  // Could be EOF if connection closed cleanly mid-message
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != sizeof(size_be)) {
            // This case should ideally be caught by stream.fail() if not enough bytes were read.
            // But as a safeguard:
            set_error(BoltError::NETWORK_ERROR);  // Incomplete read for header
            return last_error_;
        }

        out_chunk_payload_size = detail::be_to_host(size_be);

        // As per spec, MAX_CHUNK_PAYLOAD_SIZE is 65535 (0xFFFF).
        // The chunk_payload_size read from header can be this max value.
        // There's no separate check for > MAX_CHUNK_PAYLOAD_SIZE here, as uint16_t naturally holds up to this.
        // A CHUNK_TOO_LARGE error would be if a spec defined a lower practical limit, but Bolt uses full uint16_t range.

        return BoltError::SUCCESS;
    }

    // Private helper to read the payload of a chunk
    BoltError ChunkedReader::read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to) {
        if (has_error()) return last_error_;
        if (payload_size == 0) return BoltError::SUCCESS;  // Nothing to read

        size_t current_buffer_capacity = buffer_to_append_to.capacity();
        size_t current_buffer_size = buffer_to_append_to.size();
        size_t required_capacity = current_buffer_size + payload_size;

        // Grow buffer if needed. This is where std::bad_alloc can occur.
        if (required_capacity > current_buffer_capacity) {
            try {
                // Reserve to avoid multiple small reallocations if reading many small chunks.
                // A growth factor could be used (e.g., 1.5x or 2x) for efficiency.
                // For simplicity here, just reserve what's immediately needed for this chunk.
                buffer_to_append_to.reserve(required_capacity);
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return last_error_;
            } catch (const std::length_error&) {          // If required_capacity is too large for vector
                set_error(BoltError::MESSAGE_TOO_LARGE);  // Or OUT_OF_MEMORY if more appropriate
                return last_error_;
            } catch (const std::exception&) {
                set_error(BoltError::UNKNOWN_ERROR);
                return last_error_;
            }
        }

        // Resize to exact size needed for appending, then read directly into new space.
        // This is less efficient than reading into a temporary buffer and then appending,
        // but simpler for now. A more optimized version might use a fixed-size read buffer.
        // We need to append, so we must first store current_buffer_size, then resize, then read.
        try {
            buffer_to_append_to.resize(required_capacity);  // Resize to make space
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return last_error_;
        } catch (const std::length_error&) {
            set_error(BoltError::MESSAGE_TOO_LARGE);
            return last_error_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return last_error_;
        }

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(buffer_to_append_to.data() + current_buffer_size), payload_size);

        if (stream_.fail()) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize on partial read/failure
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != payload_size) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize
            set_error(BoltError::NETWORK_ERROR);              // Incomplete read for payload
            return last_error_;
        }
        return BoltError::SUCCESS;
    }

    // Public method to read a full message, de-chunked.
    BoltError ChunkedReader::read_message(std::vector<uint8_t>& out_message_data) {
        if (has_error()) return last_error_;
        last_error_ = BoltError::SUCCESS;  // Reset error for this new operation

        out_message_data.clear();  // Ensure output vector starts empty for this message
        // Optionally, reserve a typical message size if known, e.g., out_message_data.reserve(4096);
        // This needs a try-catch for bad_alloc if done.

        uint16_t current_chunk_payload_size;
        BoltError err;

        while (true) {  // Loop to read chunks until EOM
            err = read_chunk_header(current_chunk_payload_size);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_header
                return last_error_;
            }

            if (current_chunk_payload_size == 0) {  // End-of-message marker (0x0000 chunk size)
                break;                              // Successfully read all chunks for this message
            }

            // Optional: Check against a max total message size to prevent OOM from malicious server
            // Example: constexpr size_t MAX_ALLOWED_TOTAL_MESSAGE_SIZE = 16 * 1024 * 1024; // 16MB
            // if (out_message_data.size() + current_chunk_payload_size > MAX_ALLOWED_TOTAL_MESSAGE_SIZE) {
            //    set_error(BoltError::MESSAGE_TOO_LARGE);
            //    out_message_data.clear();
            //    return last_error_;
            // }

            err = read_chunk_payload(current_chunk_payload_size, out_message_data);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_payload
                return last_error_;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/handshake.h"  // 

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
// <iostream> is not directly needed here anymore for perform_handshake

#include "boltprotocol/detail/byte_order_utils.h"  // For detail::host_to_be

namespace boltprotocol {

    // build_handshake_request: Constructs the 20-byte handshake request.
    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes) {
        if (proposed_versions.empty()) {
            return BoltError::INVALID_ARGUMENT;
        }

        // 1. Magic Preamble (4 bytes, Big Endian)
        uint32_t preamble_be = detail::host_to_be(BOLT_MAGIC_PREAMBLE);  // BOLT_MAGIC_PREAMBLE from message_defs.h
        std::memcpy(out_handshake_bytes.data(), &preamble_be, sizeof(preamble_be));
        size_t current_offset = sizeof(preamble_be);

        // 2. Proposed Versions (4 versions, each 4 bytes, Big Endian)
        size_t num_versions_to_write = std::min(proposed_versions.size(), HANDSHAKE_NUM_PROPOSED_VERSIONS);

        for (size_t i = 0; i < num_versions_to_write; ++i) {
            // Version::to_handshake_bytes() already returns the 4 bytes in the correct format (00 00 Maj Min)
            // and handles endianness *if* it were encoding a multi-byte representation of major/minor itself.
            // However, the Bolt spec for handshake versions is simpler: the 4-byte int is 0.0.Major.Minor.
            // So we construct this 32-bit int and then convert to big endian.
            uint32_t version_int32_for_handshake = 0;  // Example: For 5.4, this would be 0x00000504
            version_int32_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));

            uint32_t version_be = detail::host_to_be(version_int32_for_handshake);
            std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
        }

        // Fill remaining version slots with "No Version" (all zeros)
        if (num_versions_to_write < HANDSHAKE_NUM_PROPOSED_VERSIONS) {
            uint32_t no_version_int_be = detail::host_to_be(static_cast<uint32_t>(0));  // 0x00000000
            for (size_t i = num_versions_to_write; i < HANDSHAKE_NUM_PROPOSED_VERSIONS; ++i) {
                std::memcpy(out_handshake_bytes.data() + current_offset, &no_version_int_be, HANDSHAKE_VERSION_SIZE_BYTES);
                current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
            }
        }
        return BoltError::SUCCESS;
    }

    // parse_handshake_response: Parses the 4-byte server response.
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response_bytes, versions::Version& out_negotiated_version) {
        // Version::from_handshake_bytes directly uses the byte array.
        BoltError err = versions::Version::from_handshake_bytes(server_response_bytes, out_negotiated_version);

        if (err != BoltError::SUCCESS) {
            return err;  // Could be UNSUPPORTED_PROTOCOL_VERSION if format is unexpected by from_handshake_bytes
        }

        // Specific check for "No common version" which is represented by all zeros.
        // Version::from_handshake_bytes might return 0.0 as a valid version for all zeros.
        if (out_negotiated_version.major == 0 && out_negotiated_version.minor == 0) {
            // Check if all bytes in server_response_bytes are actually zero
            bool all_zero = true;
            for (uint8_t byte : server_response_bytes) {
                if (byte != 0) {
                    all_zero = false;
                    break;
                }
            }
            if (all_zero) {
                return BoltError::HANDSHAKE_NO_COMMON_VERSION;
            }
            // If it parsed as 0.0 but bytes weren't all zero, it's an odd case,
            // but Version::from_handshake_bytes should ideally handle invalid formats.
            // For now, if it parses to 0.0 and wasn't all zeros, treat as success with 0.0 (unlikely scenario).
        }
        return BoltError::SUCCESS;
    }

    // The definition of perform_handshake (template function) is now in handshake_impl.hpp

}  // namespace boltprotocol// Base/Protocol/BoltProtocol/Source/message_defs.cpp
#include "boltprotocol/message_defs.h"  //  Value, BoltList, BoltMap, PackStreamStructure 

#include <string>
#include <variant>  // For std::visit

namespace boltprotocol {

    //  DEFAULT_USER_AGENT_FORMAT_STRING
    const std::string DEFAULT_USER_AGENT_FORMAT_STRING = "BoltProtocolCppLib/0.2";  // 

    //  Value::operator==
    //  BoltList, BoltMap, PackStreamStructure  operator== 
    // BoltList::operator==  BoltMap::operator==  bolt_core_types.h 
    // PackStreamStructure::operator==  bolt_core_types.h 
    bool operator==(const Value& lhs, const Value& rhs) {
        if (lhs.index() != rhs.index()) {
            return false;
        }

        //  std::visit  variant 
        return std::visit(
            [](const auto& l_val, const auto& r_val) -> bool {
                //  if constexpr  shared_ptr
                using T1 = std::decay_t<decltype(l_val)>;
                using T2 = std::decay_t<decltype(r_val)>;

                if constexpr (std::is_same_v<T1, T2>) {
                    //  shared_ptr 
                    if constexpr (std::is_same_v<T1, std::shared_ptr<BoltList>>) {
                        if (l_val && r_val) return *l_val == *r_val;  // 
                        return !l_val && !r_val;                      // 
                    } else if constexpr (std::is_same_v<T1, std::shared_ptr<BoltMap>>) {
                        if (l_val && r_val) return *l_val == *r_val;
                        return !l_val && !r_val;
                    } else if constexpr (std::is_same_v<T1, std::shared_ptr<PackStreamStructure>>) {
                        if (l_val && r_val) return *l_val == *r_val;
                        return !l_val && !r_val;
                    } else {
                        //  shared_ptr  (nullptr_t, bool, int64_t, double, std::string)
                        // 
                        return l_val == r_val;
                    }
                } else {
                    // Variant  index 
                    return false;
                }
            },
            lhs,
            rhs);
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure run_struct_obj;
        run_struct_obj.tag = static_cast<uint8_t>(MessageTag::RUN);

        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            // Field 1: Cypher query (string)
            run_struct_obj.fields.emplace_back(Value(params.cypher_query));

            // Field 2: Parameters map (cypher parameters)
            // It's okay if params.parameters is empty, it will serialize as an empty map.
            auto cypher_params_map_sptr = std::make_shared<BoltMap>();
            cypher_params_map_sptr->pairs = params.parameters;
            run_struct_obj.fields.emplace_back(Value(cypher_params_map_sptr));

            // Field 3: Extra metadata map
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
            }

            if (target_bolt_version.major > 4 || (target_bolt_version.major == 4 && target_bolt_version.minor >= 4)) {  // imp_user for RUN introduced in Bolt 4.4
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            run_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(run_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_pull_message and serialize_discard_message remain unchanged
    // ... (serialize_pull_message implementation) ...
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure pull_struct_obj;
        pull_struct_obj.tag = static_cast<uint8_t>(MessageTag::PULL);
        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            pull_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pull_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_discard_message implementation) ...
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure discard_struct_obj;
        discard_struct_obj.tag = static_cast<uint8_t>(MessageTag::DISCARD);
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            discard_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(discard_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version) {
        if (writer.has_error()) return writer.get_error();

        if (negotiated_bolt_version < versions::Version(4, 3)) {
            writer.set_error(BoltError::SERIALIZATION_ERROR);
            return writer.get_error();
        }

        PackStreamStructure route_struct_obj;
        route_struct_obj.tag = static_cast<uint8_t>(MessageTag::ROUTE);

        std::shared_ptr<BoltMap> routing_table_context_map_sptr;
        std::shared_ptr<BoltList> bookmarks_list_sptr;

        try {
            routing_table_context_map_sptr = std::make_shared<BoltMap>();
            routing_table_context_map_sptr->pairs = params.routing_table_context;
            route_struct_obj.fields.emplace_back(Value(routing_table_context_map_sptr));

            bookmarks_list_sptr = std::make_shared<BoltList>();
            for (const auto& bookmark_str : params.bookmarks) {
                bookmarks_list_sptr->elements.emplace_back(Value(bookmark_str));
            }
            route_struct_obj.fields.emplace_back(Value(bookmarks_list_sptr));

            if (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor == 3) {  // Bolt 4.3
                if (params.db_name_for_v43.has_value()) {
                    route_struct_obj.fields.emplace_back(Value(params.db_name_for_v43.value()));
                } else {
                    route_struct_obj.fields.emplace_back(nullptr);
                }
            } else if (negotiated_bolt_version.major > 4 || (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor >= 4)) {  // Bolt 4.4+
                std::shared_ptr<BoltMap> extra_map_sptr = std::make_shared<BoltMap>();                                                     // Always create the map
                if (params.extra_for_v44_plus.has_value()) {
                    extra_map_sptr->pairs = params.extra_for_v44_plus.value();
                }
                // The 'extra' dictionary field is always present for Bolt 4.4+, even if empty.
                route_struct_obj.fields.emplace_back(Value(extra_map_sptr));
            }
            // No other cases, as we checked for version < 4.3 at the beginning.

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(route_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            metadata_map_sptr->pairs = params.metadata;
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_hello_obj;
        pss_hello_obj.tag = static_cast<uint8_t>(MessageTag::HELLO);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& pairs = extra_map_sptr->pairs;

            pairs.emplace("user_agent", Value(params.user_agent));

            bool use_auth_in_hello = (client_target_version < versions::V5_1);  // Qualified comparison

            if (use_auth_in_hello) {
                if (params.auth_scheme.has_value()) pairs.emplace("scheme", Value(params.auth_scheme.value()));
                if (params.auth_principal.has_value()) pairs.emplace("principal", Value(params.auth_principal.value()));
                if (params.auth_credentials.has_value()) pairs.emplace("credentials", Value(params.auth_credentials.value()));
                if (params.auth_scheme_specific_tokens.has_value()) {
                    for (const auto& token_pair : params.auth_scheme_specific_tokens.value()) {
                        pairs.emplace(token_pair.first, token_pair.second);
                    }
                }
            }

            if (client_target_version.major > 4 || (client_target_version.major == 4 && client_target_version.minor >= 1)) {
                if (params.routing_context.has_value()) {
                    auto routing_map_val_sptr = std::make_shared<BoltMap>();
                    routing_map_val_sptr->pairs = params.routing_context.value();
                    pairs.emplace("routing", Value(routing_map_val_sptr));
                }
            }

            if (client_target_version.major == 4 && (client_target_version.minor == 3 || client_target_version.minor == 4)) {
                if (params.patch_bolt.has_value() && !params.patch_bolt.value().empty()) {
                    auto patch_list_sptr = std::make_shared<BoltList>();
                    for (const auto& patch_str : params.patch_bolt.value()) {
                        patch_list_sptr->elements.emplace_back(Value(patch_str));
                    }
                    pairs.emplace("patch_bolt", Value(patch_list_sptr));
                }
            }

            if (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 2)) {
                if (params.notifications_min_severity.has_value()) {
                    pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat_str : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat_str));
                    }
                    pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            bool bolt_agent_mandatory = (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 3));
            if (bolt_agent_mandatory) {
                if (!params.bolt_agent.has_value() || params.bolt_agent.value().product.empty()) {
                    writer.set_error(BoltError::SERIALIZATION_ERROR);
                    return BoltError::SERIALIZATION_ERROR;
                }
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            } else if (params.bolt_agent.has_value()) {
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));  // Product is mandatory in BoltAgentInfo itself
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            }

            for (const auto& token_pair : params.other_extra_tokens) {
                pairs.emplace(token_pair.first, token_pair.second);
            }
            pss_hello_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_hello_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_goodbye_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::GOODBYE);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_reset_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::RESET);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_logon_obj;
        pss_logon_obj.tag = static_cast<uint8_t>(MessageTag::LOGON);

        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::make_shared<BoltMap>();
            // The auth_tokens map in LogonMessageParams directly becomes the PSS field.
            auth_map_sptr->pairs = params.auth_tokens;

            pss_logon_obj.fields.emplace_back(Value(auth_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_logon_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logoff_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::LOGOFF);
            // LOGOFF PSS has no fields.
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <map>
#include <memory>  // For std::make_shared, std::shared_ptr
#include <vector>  // For PackStreamStructure fields

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For the function declaration
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;                                // Create on stack
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);  // Tag 0x54

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            // Copy the metadata from params. Telemetry typically has specific keys like "api".
            // The caller is responsible for ensuring params.metadata is correctly populated.
            metadata_map_sptr->pairs = params.metadata;

            // The TELEMETRY message PackStreamStructure has one field: the metadata map.
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Catch other potential exceptions from map copy or emplace_back
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // Consider logging e_std.what() for debugging if needed
            return BoltError::UNKNOWN_ERROR;
        }

        // Now, convert the stack-based PSS object to a shared_ptr to pass to writer.write()
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Other exceptions from make_shared or PSS move ctor
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {                                 // Should typically be caught by bad_alloc if make_shared fails
            writer.set_error(BoltError::OUT_OF_MEMORY);  // Or UNKNOWN_ERROR if make_shared could return null without exception
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure begin_struct_obj;
        begin_struct_obj.tag = static_cast<uint8_t>(MessageTag::BEGIN);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            // BEGIN shares many 'extra' fields with RUN's auto-commit extras
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {  // Defaults to "w" if not sent, but can be explicit
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db and imp_user for BEGIN introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            begin_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(begin_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_commit_message and serialize_rollback_message remain unchanged
    // ... (serialize_commit_message implementation) ...
    BoltError serialize_commit_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::COMMIT);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_rollback_message implementation) ...
    BoltError serialize_rollback_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::ROLLBACK);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get
#include <vector>     // For PackStreamStructure::fields

#include "boltprotocol/message_defs.h"           // For message structs, Value, MessageTag, BoltError
#include "boltprotocol/message_serialization.h"  // 
#include "boltprotocol/packstream_reader.h"      // For PackStreamReader

namespace boltprotocol {

    // Helper to deserialize a structure from a reader and validate its basic properties
    // This function was originally in message_serialization_server.cpp
    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents) {
        if (reader.has_error()) return reader.get_error();

        Value raw_value;
        BoltError err = reader.read(raw_value);
        if (err != BoltError::SUCCESS) {
            // reader.read() should have set its internal error state.
            return err;
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(raw_value)) {
            try {
                struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(raw_value));
            } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            } catch (const std::exception&) {  // Other potential issues with std::get or Value move
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (!struct_sptr) {  // Null shared_ptr received in Value
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Move the contents from the object pointed to by shared_ptr into out_structure_contents.
        try {
            out_structure_contents = std::move(*struct_sptr);  // PackStreamStructure move assignment
        } catch (const std::bad_alloc&) {                      // If vector/map move assignment allocates and fails
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (static_cast<MessageTag>(out_structure_contents.tag) != expected_tag) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Tag mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (out_structure_contents.fields.size() < expected_fields_min || out_structure_contents.fields.size() > expected_fields_max) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Field count mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        return BoltError::SUCCESS;
    }

    // peek_message_structure_header remains problematic and likely unused as discussed.
    // If it were to be implemented and was general, it could go here.
    // For now, it's commented out or returns an error in message_serialization.h
    /*
    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count) {
        // ... implementation ...
        return BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::bad_variant_access
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get (though not strictly used for get if field is optional)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        // IGNORED message PSS has 0 or 1 field. If 1, it's a map (usually for future use or diagnostics).
        // The spec typically shows IGNORED {}, meaning 0 fields in its PSS, or IGNORED {<metadata_map>}.
        // A PSS with 0 fields is valid. A PSS with 1 field (the map) is also valid.
        // So, expected_fields_min = 0, expected_fields_max = 1.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // If there is a field, it must be a map.
        // Client usually doesn't need to parse this map, so we just validate its presence and type if it exists.
        if (!ignored_struct_contents.fields.empty()) {  // Field is present
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            // We don't need to extract the map's content for IGNORED typically.
            // std::shared_ptr<BoltMap> metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0]);
            // if (!metadata_map_sptr) { /* This would be an error if the field is present but map pointer is null */ }
        }
        // If fields is empty, it's a valid IGNORED {} message, nothing more to do.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_reset_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RESET message PSS (Bolt 1+) has 0 fields.
        PackStreamStructure reset_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RESET, 0, 0, reset_struct_contents);
        // No fields to parse further from reset_struct_contents.fields.
        return err;
    }

    BoltError deserialize_goodbye_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // GOODBYE message PSS (Bolt 3+) has 0 fields.
        PackStreamStructure goodbye_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::GOODBYE, 0, 0, goodbye_struct_contents);
        // No fields to parse further.
        return err;
    }

    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure telemetry_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::TELEMETRY, 1, 1, telemetry_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (telemetry_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(telemetry_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(telemetry_struct_contents.fields[0]));
        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        auto api_val_it = out_params.metadata.find("api");
        if (api_val_it == out_params.metadata.end() || !std::holds_alternative<int64_t>(api_val_it->second)) {
            // Specification: "unless it sends an invalid value for the api field, which results in a FAILURE response."
            // This deserializer can flag it, actual FAILURE is up to server logic.
            // For now, successful deserialization of the structure, content validation is next step.
            // reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Or a specific "TELEMETRY_INVALID_API_FIELD"
            // return reader.get_error();
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure run_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RUN, 3, 3, run_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (run_struct_contents.fields.size() < 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        if (!std::holds_alternative<std::string>(run_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.cypher_query = std::get<std::string>(std::move(run_struct_contents.fields[0]));
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto params_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[1]));
        if (!params_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.parameters = std::move(params_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[2])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[2]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;

        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && pair.first == "db") ||
                                   ((server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) && pair.first == "imp_user") ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory for map */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure pull_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ PULL has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 1, 1, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (pull_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(pull_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(pull_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ PULL
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT; // Be strict or allow for now?
            }
        } else {  // Bolt < 4.0 (PULL_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 0, 0, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            // For PULL_ALL, n is implicitly -1 (all), qid is implicitly -1 (last query)
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure discard_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ DISCARD has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 1, 1, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (discard_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(discard_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(discard_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ DISCARD
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else {  // Bolt < 4.0 (DISCARD_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 0, 0, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};  // Clear params

        // ROUTE message introduced in 4.3. PSS has 3 fields.
        if (server_negotiated_version < versions::Version(4, 3)) {
            reader.set_error(BoltError::UNSUPPORTED_PROTOCOL_VERSION);  // Or INVALID_MESSAGE_FORMAT
            return reader.get_error();
        }

        PackStreamStructure route_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROUTE, 3, 3, route_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (route_struct_contents.fields.size() != 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Field 0: routing_context (Map)
        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto route_context_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[0]));
        if (!route_context_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.routing_table_context = std::move(route_context_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 1: bookmarks (List<String>)
        if (!std::holds_alternative<std::shared_ptr<BoltList>>(route_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto bookmarks_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(route_struct_contents.fields[1]));
        if (!bookmarks_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        out_params.bookmarks.clear();
        try {
            out_params.bookmarks.reserve(bookmarks_list_sptr->elements.size());
            for (const auto& bm_val : bookmarks_list_sptr->elements) {
                if (std::holds_alternative<std::string>(bm_val)) {
                    out_params.bookmarks.push_back(std::get<std::string>(bm_val));
                } else {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;  // Bookmark not a string
                }
            }
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 2: Varies by version (db string for 4.3, extra map for 4.4+)
        if (server_negotiated_version.major == 4 && server_negotiated_version.minor == 3) {  // Bolt 4.3
            if (std::holds_alternative<std::string>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::get<std::string>(std::move(route_struct_contents.fields[2]));
            } else if (std::holds_alternative<std::nullptr_t>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::nullopt;
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Expected string or null
            }
        } else if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {  // Bolt 4.4+
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[2])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[2]));
            if (extra_map_sptr) {  // Map can be empty, but shared_ptr should be non-null
                out_params.extra_for_v44_plus = std::move(extra_map_sptr->pairs);
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Extra map field was null
            }
        }
        // For Bolt 5.0+, the PSS structure is like 4.4 (3 fields, 3rd is extra map).
        // The semantic meaning of routing_table_context and extra_for_v44_plus for ROUTE V2 is handled
        // by how the client populates RouteMessageParams and how server interprets them.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For deserialize_message_structure_prelude
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure begin_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::BEGIN, 1, 1, begin_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (begin_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(begin_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(begin_struct_contents.fields[0]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;
        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && (pair.first == "db" || pair.first == "imp_user")) ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_commit_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // CommitMessageParams is empty struct, no out_params needed.

        PackStreamStructure commit_struct_contents;
        // COMMIT PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::COMMIT, 1, 1, commit_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // Validate the field is indeed a map (preferably empty).
        if (commit_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map field was a null shared_ptr
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Specification: "Fields: No fields." but the PackStream structure for COMMIT is `COMMIT {}`
        // This means the PSS has one field, which is an empty map.
        // We can optionally check if map_sptr->pairs is empty for stricter validation.
        // if (!map_sptr->pairs.empty()) {
        //     reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Expected empty map
        //     return BoltError::INVALID_MESSAGE_FORMAT;
        // }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_rollback_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RollbackMessageParams is empty.

        PackStreamStructure rollback_struct_contents;
        // ROLLBACK PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROLLBACK, 1, 1, rollback_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }
        // Validate the field.
        if (rollback_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // The map should be empty.
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>
#include <vector>

#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_optional_list_string_from_map if used
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure success_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::SUCCESS, 1, 1, success_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (success_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(success_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(success_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Example of how an upper layer (e.g., ClientSession) might use this:
        // After calling deserialize_success_message for a HELLO response:
        // if (auto patch_list_val = boltprotocol::detail::get_optional_list_string_from_map(boltprotocol::BoltMap{out_params.metadata}, "patch_bolt")) {
        //    session.agreed_patches = patch_list_val.value();
        //    for(const auto& patch : session.agreed_patches) {
        //        if (patch == "utc") session.utc_patch_active_for_4_4 = true;
        //    }
        // }
        // This logic belongs in the consuming code, not the generic deserializer.

        return BoltError::SUCCESS;
    }

    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure failure_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::FAILURE, 1, 1, failure_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (failure_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(failure_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(failure_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.fields.clear();

        PackStreamStructure record_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RECORD, 1, 1, record_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (record_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltList>>(record_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltList> fields_list_sptr;
        try {
            fields_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(record_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!fields_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.fields = std::move(fields_list_sptr->elements);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (!ignored_struct_contents.fields.empty()) {
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_reader.h"  // 

#include <cstring>    // For memcpy in consume_bytes (if used for non-trivial types, though here it's for raw bytes)
#include <exception>  // For std::bad_alloc (relevant for Value assignment in read() if target type allocates)
#include <iostream>   // For std::istream operations
// byte_order_utils.h is included via packstream_reader.h

namespace boltprotocol {

    // --- PackStreamReader Constructor and Basic IO ---

    PackStreamReader::PackStreamReader(const std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // No body needed if all initialization is in member initializer list
    }

    PackStreamReader::PackStreamReader(std::istream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {   // Basic stream validity check
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if appropriate
        }
    }

    void PackStreamReader::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    bool PackStreamReader::eof() const {
        if (has_error()) return true;  // If already in error, considered EOF for reading purposes
        if (buffer_ptr_) {
            return buffer_pos_ >= buffer_ptr_->size();
        }
        if (stream_ptr_) {
            // stream.eof() is only true after an attempt to read past EOF.
            // stream.peek() == EOF is a more reliable way to check without consuming.
            return stream_ptr_->peek() == EOF;
        }
        return true;  // No valid source
    }

    BoltError PackStreamReader::peek_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check stream state before peeking
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->peek();  // peek() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {  // badbit indicates a serious I/O error
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // eofbit, or (eofbit and failbit if formatting error also occurred)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_++];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->get();  // get() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_bytes(void* dest, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to read
        if (dest == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            if (buffer_pos_ + size <= buffer_ptr_->size()) {
                // Using reinterpret_cast for buffer_ptr_->data() is okay as it's uint8_t
                std::memcpy(dest, buffer_ptr_->data() + buffer_pos_, size);
                buffer_pos_ += size;
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // Buffer read out of bounds
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->read(static_cast<char*>(dest), static_cast<std::streamsize>(size));

            // Check if the read was successful and complete
            if (static_cast<size_t>(stream_ptr_->gcount()) != size) {
                // failbit will be set if gcount() < size and not EOF, or badbit is set.
                // eofbit will be set if EOF was reached during the read.
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // Could be failbit (less data than requested) or eofbit (hit EOF)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // Not enough data or other stream error
                }
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    // --- PackStreamReader Main Read Logic ---

    BoltError PackStreamReader::read(Value& out_value) {
        // Reset output value to a known state (nullptr for variant is a good default)
        try {
            out_value = nullptr;
        } catch (const std::bad_alloc&) {  // Should not happen for nullptr_t assignment
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        if (has_error()) return error_state_;
        if (eof()) {                                      // Check before attempting to consume any byte
            set_error(BoltError::DESERIALIZATION_ERROR);  // Attempt to read past EOF
            return error_state_;
        }

        uint8_t marker;
        BoltError err = consume_byte(marker);
        if (err != BoltError::SUCCESS) return err;  // error_state_ already set by consume_byte

        // Handle Tiny Positive Int (0 to 127) and Tiny Negative Int (-16 to -1) directly
        // These are outside the typical marker switch for performance and clarity.
        if (marker <= 0x7F) {  // Tiny Positive Int (0 to 127)
            try {
                out_value = static_cast<int64_t>(marker);
            } catch (const std::bad_alloc&) {  // Value variant assignment might allocate.
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        if (marker >= 0xF0) {  // Tiny Negative Int (-16 to -1)
            try {
                out_value = static_cast<int64_t>(static_cast<int8_t>(marker));
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }

        // Dispatch to type-specific handlers based on marker
        // These handlers are now in separate .cpp files but are still part of PackStreamReader class.
        switch (marker) {
            case MARKER_NULL:
                return read_null_value(out_value);
            case MARKER_FALSE:
                return read_boolean_value(false, out_value);
            case MARKER_TRUE:
                return read_boolean_value(true, out_value);
            case MARKER_FLOAT64:
                return read_float64_value(out_value);

            case MARKER_INT_8:
            case MARKER_INT_16:
            case MARKER_INT_32:
            case MARKER_INT_64:
                return read_integer_value(marker, out_value);

            // Ranged cases for C++20 and later (as per project requirement)
            case MARKER_TINY_STRING_BASE ...(MARKER_TINY_STRING_BASE + 0x0F):  // 0x80 to 0x8F
            case MARKER_STRING_8:
            case MARKER_STRING_16:
            case MARKER_STRING_32:
                return read_string_value(marker, out_value);

            case MARKER_TINY_LIST_BASE ...(MARKER_TINY_LIST_BASE + 0x0F):  // 0x90 to 0x9F
            case MARKER_LIST_8:
            case MARKER_LIST_16:
            case MARKER_LIST_32:
                return read_list_value(marker, out_value);

            case MARKER_TINY_MAP_BASE ...(MARKER_TINY_MAP_BASE + 0x0F):  // 0xA0 to 0xAF
            case MARKER_MAP_8:
            case MARKER_MAP_16:
            case MARKER_MAP_32:
                return read_map_value(marker, out_value);

            case MARKER_TINY_STRUCT_BASE ...(MARKER_TINY_STRUCT_BASE + 0x0F):  // 0xB0 to 0xBF
            case MARKER_STRUCT_8:
            case MARKER_STRUCT_16:
                return read_struct_value(marker, out_value);

            default:
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Unknown marker
                return error_state_;
        }
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error, std::bad_variant_access
#include <map>
#include <memory>  // For std::shared_ptr, std::make_shared
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read List elements into a pre-allocated BoltList shared_ptr
    BoltError PackStreamReader::read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!list_sptr) {  // Should be allocated by caller (read_list_value)
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = BoltError::SUCCESS;
        try {
            list_sptr->elements.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large for vector
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value element;
            err = this->read(element);  // Recursive call to PackStreamReader::read for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call
                return error_state_;
            }
            try {
                list_sptr->elements.push_back(std::move(element));  // Value move ctor/vector push_back
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other potential exceptions from push_back or Value move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_list_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_LIST_BASE) {  // Tiny List (0x90 to 0x9F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_LIST_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltList> list_sptr;
        try {
            list_sptr = std::make_shared<BoltList>();  // Potential std::bad_alloc
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other errors from make_shared construction
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        // No need to check if (!list_sptr) because make_shared throws on failure.

        err = read_list_elements_into(list_sptr, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set
            return error_state_;
        }

        try {
            out_value = std::move(list_sptr);  // Move shared_ptr into variant
        } catch (const std::bad_alloc&) {      // Variant assignment can allocate.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // Helper to read Map key-value pairs into a pre-allocated BoltMap shared_ptr
    BoltError PackStreamReader::read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!map_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        for (uint32_t i = 0; i < size; ++i) {
            Value key_as_value;
            err = this->read(key_as_value);  // Read map key
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            std::string key_str;
            if (std::holds_alternative<std::string>(key_as_value)) {
                try {
                    // std::get for rvalue variant returns rvalue ref or throws if type mismatch / bad state
                    key_str = std::get<std::string>(std::move(key_as_value));
                } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                    current_recursion_depth_--;
                    set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return error_state_;
                } catch (const std::bad_alloc&) {  // string move assignment/ctor
                    current_recursion_depth_--;
                    set_error(BoltError::OUT_OF_MEMORY);
                    return error_state_;
                } catch (const std::exception&) {
                    current_recursion_depth_--;
                    set_error(BoltError::UNKNOWN_ERROR);
                    return error_state_;
                }
            } else {
                current_recursion_depth_--;
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map key must be a string
                return error_state_;
            }

            Value map_value_element;
            err = this->read(map_value_element);  // Read map value
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            try {
                // map::emplace can throw (e.g. bad_alloc for node, or if Value copy/move throws)
                map_sptr->pairs.emplace(std::move(key_str), std::move(map_value_element));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other exceptions from emplace or Value's move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_map_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_MAP_BASE) {  // Tiny Map (0xA0 to 0xAF)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_MAP_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltMap> map_sptr;
        try {
            map_sptr = std::make_shared<BoltMap>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_map_pairs_into(map_sptr, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(map_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less likely here, more in complex types)
#include <limits>     // For std::numeric_limits (though not strictly needed for existing integer logic)

#include "boltprotocol/message_defs.h"       // For Value, BoltError
#include "boltprotocol/packstream_reader.h"  // For PackStreamReader class declaration and constants
// byte_order_utils.h is included via packstream_reader.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamReader::read_null_value(Value& out_value) {
        if (has_error()) return error_state_;
        out_value = nullptr;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_boolean_value(bool bool_val_from_marker, Value& out_value) {
        if (has_error()) return error_state_;
        out_value = bool_val_from_marker;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_float64_value(Value& out_value) {
        if (has_error()) return error_state_;
        uint64_t temp_int;
        BoltError err = consume_network_int(temp_int);  // consume_network_int handles byte swapping
        if (err != BoltError::SUCCESS) return err;

        double val;
        // Ensure that double is 64-bit and has the same endianness concerns as uint64_t
        // The value read into temp_int is already in host byte order.
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&val, &temp_int, sizeof(double));

        try {
            out_value = val;
        } catch (const std::bad_alloc&) {  // Value variant assignment might allocate if it's a complex type, though not for double. Defensive.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_integer_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        BoltError err;
        int64_t final_val = 0;

        switch (marker) {
            case MARKER_INT_8:
                {
                    int8_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_16:
                {
                    int16_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_32:
                {
                    int32_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_64:
                {
                    int64_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = val;
                    break;
                }
            default:
                // This case should ideally not be reached if dispatch in `read()` is correct
                set_error(BoltError::INVALID_ARGUMENT);
                return error_state_;
        }

        try {
            out_value = final_val;
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <string>
#include <vector>  // Though not directly used, good for context

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read string data of a given size into an std::string
    // This was originally in packstream_reader_types.cpp
    BoltError PackStreamReader::read_string_data_into(std::string& out_string, uint32_t size) {
        if (has_error()) return error_state_;
        out_string.clear();

        if (size == 0) {
            return BoltError::SUCCESS;
        }
        try {
            out_string.resize(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {              // String too long for std::string to handle
            set_error(BoltError::DESERIALIZATION_ERROR);  // Or MESSAGE_TOO_LARGE
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        // consume_bytes will set error_state_ on failure (e.g., not enough bytes)
        return consume_bytes(out_string.data(), size);
    }

    BoltError PackStreamReader::read_string_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRING_BASE) {  // Tiny String (0x80 to 0x8F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_STRING_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;  // Already uint32_t
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);  // Marker not a string marker
                    return error_state_;
            }
        }

        std::string s_val;
        err = read_string_data_into(s_val, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ is already set by read_string_data_into or consume_bytes
            return error_state_;
        }

        try {
            out_value = std::move(s_val);  // std::string move constructor into variant
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other potential exceptions from variant assignment
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <memory>     // For std::shared_ptr, std::make_shared
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read Structure fields into a pre-allocated PackStreamStructure shared_ptr
    BoltError PackStreamReader::read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        if (!struct_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        struct_sptr->tag = tag;  // Set the tag

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        try {
            struct_sptr->fields.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value field_val;
            err = this->read(field_val);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }
            try {
                struct_sptr->fields.push_back(std::move(field_val));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_struct_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        uint8_t tag = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRUCT_BASE) {  // Tiny Struct (0xB0 to 0xBF)
            size = marker & 0x0F;
            err = consume_byte(tag);  // Read the tag byte following the marker
            if (err != BoltError::SUCCESS) return err;
        } else {
            switch (marker) {
                case MARKER_STRUCT_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                case MARKER_STRUCT_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        try {
            struct_sptr = std::make_shared<PackStreamStructure>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_struct_fields_into(struct_sptr, tag, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(struct_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_writer.h"  // 

#include <cstring>    // For memcpy (used in append_network_int indirectly via detail::host_to_be)
#include <exception>  // For std::bad_alloc (relevant for vector buffer operations)
#include <iostream>   // For std::ostream operations
#include <variant>    // For std::visit
// byte_order_utils.h is included via packstream_writer.h

namespace boltprotocol {

    // --- PackStreamWriter Constructor and Low-Level IO ---

    PackStreamWriter::PackStreamWriter(std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // Initialization in member initializer list
    }

    PackStreamWriter::PackStreamWriter(std::ostream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void PackStreamWriter::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    BoltError PackStreamWriter::append_byte(uint8_t byte) {
        if (has_error()) return error_state_;

        if (buffer_ptr_) {
            try {
                buffer_ptr_->push_back(byte);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other possible exceptions from vector
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->put(static_cast<char>(byte));
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);  // Error after writing
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::append_bytes(const void* data, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to append
        if (data == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            const auto* byte_data = static_cast<const uint8_t*>(data);
            try {
                // Insert range [first, last)
                buffer_ptr_->insert(buffer_ptr_->end(), byte_data, byte_data + size);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other vector exceptions
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->write(static_cast<const char*>(data), static_cast<std::streamsize>(size));
            if (stream_ptr_->fail()) {  // Error after writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // --- PackStreamWriter Main Dispatch Logic ---

    BoltError PackStreamWriter::write(const Value& value) {
        if (has_error()) return error_state_;  // Already in error

        // Visitor lambda to dispatch to internal type-specific writers
        auto visitor = [&](const auto& arg) -> BoltError {
            // std::decay_t to handle const& from variant's get/visit
            using T = std::decay_t<decltype(arg)>;

            if constexpr (std::is_same_v<T, std::nullptr_t>) {
                return write_null_internal();
            } else if constexpr (std::is_same_v<T, bool>) {
                return write_boolean_internal(arg);
            } else if constexpr (std::is_same_v<T, int64_t>) {
                return write_integer_internal(arg);
            } else if constexpr (std::is_same_v<T, double>) {
                return write_float_internal(arg);
            } else if constexpr (std::is_same_v<T, std::string>) {
                return serialize_string_internal(arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltList>>) {
                if (!arg) {  // Handle null shared_ptr as PackStream NULL
                    return write_null_internal();
                }
                return serialize_list_internal(*arg);  // Dereference shared_ptr
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltMap>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_map_internal(*arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<PackStreamStructure>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_structure_internal(*arg);
            } else {
                // This static_assert will fail at compile time if Value has an unhandled type.
                // static_assert(false, "Unhandled type in PackStreamWriter::write visitor");
                // For runtime, in case a type slips through somehow (shouldn't with variant):
                set_error(BoltError::SERIALIZATION_ERROR);  // Unknown type to serialize
                return error_state_;
            }
        };

        return std::visit(visitor, value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits
#include <map>
#include <memory>  // For std::shared_ptr (used in Value variant)
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_list_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny List
            err = append_byte(MARKER_TINY_LIST_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_LIST_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_LIST_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // LIST_32
            err = append_byte(MARKER_LIST_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_list_internal(const BoltList& list_data) {
        if (has_error()) return error_state_;
        const auto& list_elements = list_data.elements;

        if (list_elements.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // List too large for PackStream size encoding
            return error_state_;
        }
        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_list_header_internal(static_cast<uint32_t>(list_elements.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;  // Error already set
        }

        for (const auto& item : list_elements) {
            err = this->write(item);  // Recursive call to PackStreamWriter::write for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call to write()
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::write_map_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Map
            err = append_byte(MARKER_TINY_MAP_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_MAP_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_MAP_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // MAP_32
            err = append_byte(MARKER_MAP_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_map_internal(const BoltMap& map_data) {
        if (has_error()) return error_state_;
        const auto& map_pairs = map_data.pairs;

        if (map_pairs.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // Map too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_map_header_internal(static_cast<uint32_t>(map_pairs.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& pair : map_pairs) {
            // Write key (must be string for PackStream maps)
            err = serialize_string_internal(pair.first);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by serialize_string_internal
            }
            // Write value (recursive call)
            err = this->write(pair.second);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by recursive write()
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less direct here)
#include <limits>     // For std::numeric_limits

#include "boltprotocol/message_defs.h"       // For BoltError (though packstream_writer.h includes it)
#include "boltprotocol/packstream_writer.h"  // For PackStreamWriter class declaration and constants
// byte_order_utils.h is included via packstream_writer.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamWriter::write_null_internal() {
        if (has_error()) return error_state_;
        return append_byte(MARKER_NULL);
    }

    BoltError PackStreamWriter::write_boolean_internal(bool bool_value) {
        if (has_error()) return error_state_;
        return append_byte(bool_value ? MARKER_TRUE : MARKER_FALSE);
    }

    BoltError PackStreamWriter::write_integer_internal(int64_t int_value) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;  // Initialize err

        if (int_value >= -16 && int_value <= 127) {  // Tiny Int
            err = append_byte(static_cast<uint8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int8_t>::min() && int_value <= std::numeric_limits<int8_t>::max()) {
            err = append_byte(MARKER_INT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int16_t>::min() && int_value <= std::numeric_limits<int16_t>::max()) {
            err = append_byte(MARKER_INT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int16_t>(int_value));
        } else if (int_value >= std::numeric_limits<int32_t>::min() && int_value <= std::numeric_limits<int32_t>::max()) {
            err = append_byte(MARKER_INT_32);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int32_t>(int_value));
        } else {  // INT_64
            err = append_byte(MARKER_INT_64);
            if (err == BoltError::SUCCESS) err = append_network_int(int_value);
        }
        return err;  // Return the result of the last append operation
    }

    BoltError PackStreamWriter::write_float_internal(double float_value) {
        if (has_error()) return error_state_;
        BoltError err = append_byte(MARKER_FLOAT64);
        if (err != BoltError::SUCCESS) return err;  // If appending marker failed

        uint64_t temp_int;  // To hold byte representation of double
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&temp_int, &float_value, sizeof(double));

        // append_network_int will handle host-to-be conversion for temp_int
        return append_network_int(temp_int);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc (from vector operations if buffer_ptr_)
#include <limits>     // For std::numeric_limits
#include <string>
#include <vector>  // For buffer_ptr_ if used (though append_bytes handles it)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_string_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny String (0x80 to 0x8F)
            err = append_byte(MARKER_TINY_STRING_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_STRING_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_STRING_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // STRING_32 (uint32_t max is handled by PackStream spec)
            err = append_byte(MARKER_STRING_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);  // size is already uint32_t
        }
        return err;
    }

    BoltError PackStreamWriter::write_string_data_internal(const std::string& value_str) {
        if (has_error()) return error_state_;
        if (value_str.empty()) {
            return BoltError::SUCCESS;  // Nothing to append for an empty string's data
        }
        // append_bytes handles potential errors (like OUT_OF_MEMORY if writing to vector buffer)
        return append_bytes(value_str.data(), value_str.length());
    }

    BoltError PackStreamWriter::serialize_string_internal(const std::string& str_value) {
        if (has_error()) return error_state_;

        // PackStream strings are limited to 2^32 - 1 bytes (UINT32_MAX).
        // std::string::length() returns size_t.
        if (str_value.length() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // String too long for PackStream
            return error_state_;
        }
        uint32_t len = static_cast<uint32_t>(str_value.length());

        BoltError err = write_string_header_internal(len);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set by write_string_header_internal or its callees
            return error_state_;
        }
        // Only write data if length > 0 (handled by write_string_data_internal)
        return write_string_data_internal(str_value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits (for STRUCT_16 max size)
#include <memory>     // For std::shared_ptr (used in Value variant)
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_struct_header_internal(uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Struct (0xB0 to 0xBF)
            err = append_byte(MARKER_TINY_STRUCT_BASE | static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint8_t>::max()) {  // Struct 8
            err = append_byte(MARKER_STRUCT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint16_t>::max()) {  // Struct 16
            err = append_byte(MARKER_STRUCT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else {
            // PackStream v1 (which Bolt uses) does not define STRUCT_32.
            // Maximum number of fields for a structure is 65535 (0xFFFF).
            set_error(BoltError::SERIALIZATION_ERROR);  // Structure too large for PackStream v1 encoding
            return error_state_;
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_structure_internal(const PackStreamStructure& struct_data) {
        if (has_error()) return error_state_;

        // Max fields for a PackStream structure (STRUCT_16 limit)
        if (struct_data.fields.size() > std::numeric_limits<uint16_t>::max()) {  // 65535
            set_error(BoltError::SERIALIZATION_ERROR);                           // Structure too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_struct_header_internal(struct_data.tag, static_cast<uint32_t>(struct_data.fields.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& field : struct_data.fields) {
            err = this->write(field);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocolBolt Protocol handshake specification

All Bolt connections begin with a handshake to negotiate which version of the messaging protocol to use. Following a successful negotiation, the agreed messaging protocol then takes ownership of the connection for the remainder of its lifetime. The handshake itself is not versioned.

Bolt is a client-server protocol designed primarily for executing queries against a database server. Communication occurs through request-response exchanges, in much the same way as HTTP. Unlike HTTP, however, Bolt connections are stateful.

Bolt Protocol message specification

The message specification describes the message exchanges that take place on a connection following a successful Bolt handshake. For details of establishing a connection and performing a handshake, see Bolt Protocol handshake specification.

The Bolt protocol communicates with specific versioned messages.
Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.

For more information, see the corresponding version of the Bolt Protocol server state specification.
Server signals

Jump ahead means that the signal is immediately available before any messages are processed in the message queue.
Server signal 	Jump ahead 	Description

<INTERRUPT>


X

an interrupt signal

<DISCONNECT>


a disconnect signal
Protocol errors

If a server or client receives a message type that is unexpected, according to the transitions described in this document, it must treat that as a protocol error. Protocol errors are fatal and should immediately transition the server state to DEFUNCT, closing any open connections.
Session

Each connection to the server creates a new session that lives until that connection is closed. Each session is isolated and the server keeps track of the current state, based on the requests and responses exchanged within that session. A session ends when the socket for that connection is closed. Typically, this will be closed by the client.
Message exchange

Messages are exchanged in a request-response pattern between client and server. Each request consists of exactly one message and each response consists of zero or more detail messages followed by exactly one summary message. The presence or absence of detail messages in a response is directly related to the type of request message that has been sent. In other words, some request message types elicit a response that may contain detail messages, others do not.

Messages may also be pipelined. In other words, clients may send multiple requests eagerly without first waiting for responses. When a failure occurs in this scenario, servers must ignore all subsequent requests until the client has explicitly acknowledged receipt of the failure. This prevents inadvertent execution of queries that may not be valid. More details of this process can be found in the sections below.
Serialization

Messages and their contents are serialized into network streams using PackStream Specification Version 1. Each message is represented as a PackStream structure that contains a fixed number of fields. The message type is denoted by the PackStream structure tag byte and each message is defined in the Bolt protocol. Serialization is specified with PackStream Version 1.
Chunking

A layer of chunking is also applied to message transmissions as a way to more predictably manage packets of data. The chunking process allows the message to be broken into one or more pieces, each of an arbitrary size, and for those pieces to be transmitted within separate chunks. Each chunk consists of a two-byte header, detailing the chunk size in bytes followed by the chunk data itself. Chunk headers are 16-bit unsigned integers, meaning that the maximum theoretical chunk size permitted is 65,535 bytes.

Each encoded message must be terminated with a chunk of zero size, i.e.

00 00

This is used to signal message boundaries to a receiving parties, allowing blocks of data to be fully received without requiring that the message is parsed immediately. This also allows for unknown message types to be received and handled without breaking the messaging chain.

The Bolt protocol encodes each message using a chunked transfer encoding.

Each message is transferred as one or more chunks of data.

Each chunk starts with a two-byte header, an unsigned big-endian 16-bit integer, representing the size of the chunk not including the header.

A message can be divided across multiple chunks, allowing client and server alike to transfer large messages without having to determine the length of the entire message in advance.

Chunking applies on each message individually.

One chunk cannot contain more than one message.

Each message ends with two bytes with the value 00 00, these are not counted towards the chunk size (you may consider them as individual chunks of size 0).

With version 4.1+, the NOOP chunk (empty chunk) is used to send an empty chunk and the purpose is to be able to support a keep alive behaviour on the connection.


Examples of how Bolt chunks messages
Example of a message in one chunk

Message data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

results in the following chunk:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00

with the chunk header 00 10 and the end marker 00 00.
Example of a message split in two chunks

Message data containing 20 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 02 03 04

results in chunk 1 and chunk 2:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00 04 01 02 03 04 00 00

with the chunk 1 header 00 01 and no end marker for chunk 1, still message data. Chunk 2 has a header 00 04 and an end marker 00 00.
Example with two messages

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

are both encoded with chunking:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Example with two messages with a NOOP in between

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

The two messages encoded with chunking and a NOOP(empty chunk) in between:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Pipelining

The client may send multiple requests eagerly without first waiting for responses.
Transaction

A transaction is the concept of atomic units of work.

The concept of Transaction is when the server is in the READY state and the transaction is opened with the request message RUN and the response of a summary message SUCCESS. The Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL.

Version 3 of the Bolt Protocol introduces the concept of Auto-commit Transaction and Explicit Transaction. Auto-commit Transaction is the server in the READY state and the transition to the STREAMING state. The transaction is opened with the request message RUN and the response of a summary message SUCCESS.

The Auto-commit Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL. Thus, the Auto-commit Transaction can only contain one RUN request message.

In version 4 of the Bolt Protocol, the DISCARD_ALL and PULL_ALL messages are renamed to DISCARD and PULL and new fields are introduced.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: RUN ...      // Open a new Auto-commit Transaction
S: SUCCESS ...  // Server is in STREAMING state

C: PULL ...
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in STREAMING state

C: PULL
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in READY state and this implies that the Auto-commit Transaction is closed.

In version 1, HELLO is called INIT and Auto-commit Transaction is just Transaction. The field has_more=true/false is introduced in version 4. See also the corresponding version of the Bolt Protocol server state specification.

The Explicit Transaction is introduced in version 3 of Bolt and is a more generic transaction that can contain several RUN request messages. The concept of Explicit Transaction is when the server is in the READY state and the transaction is opened with the request message BEGIN and the response of a summary message SUCCESS (thus transition into the TX_READY server state).

The Explicit Transaction is successfully closed with the request message COMMIT and the response of a summary message SUCCESS. The result stream (detail messages) must be fully consumed or discarded by a client before the server can transition to the TX_READY state and thus be able to close the transaction with a COMMIT request message. It can be gracefully discarded and set to the initial server state of READY with the request message ROLLBACK.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: BEGIN ...    // Open a new Explicit Transaction
S: SUCCESS ...  // Server is in TX_READY state

C: RUN ...
S: SUCCESS {"qid": 123, ...} // Server is in TX_STREAMING state, one stream is open

C: RUN ...
S: SUCCESS {"qid": 456, ...} // Server is in TX_STREAMING state, two streams are open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in TX_STREAMING state, two streams are still open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is still in TX_STREAMING state, one stream is still open

C: PULL {"qid": 456, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in TX_READY state, all streams have been fully consumed

C: COMMIT   // Close the Explicit Transaction
S: SUCCESS  // Server is in READY state

In version 3, PULL is called PULL_ALL. Additionally, there are no fields, e.g qid=123 and has_more=true/false available in version 3 of the Bolt Protocol.

More examples of message exchanges can be found in AppendixMessage exchange examples.
Messages

There are three different kinds of messages:

Request message - the client sends a message.

Summary message - the server always responds with one summary message if the connection is still open.

Detail message - the server always responds with zero or more detail messages before sending a summary message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Message 	Signature 	Type of message 	Fields 	Description

HELLO

01

Request

extra::Dictionary(user_agent::String, routing::Dictionary(address::String), notifications_minimum_severity::String, notifications_disabled_categories::List<String>, bolt_agent::Dictionary(product::String, platform::String, language::String, language_details::String))

initialize connection (replaces INIT of v1 & v2)(routing::Dictionary(address::String) added in v4.1) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)(bolt_agent::Dictionary added in v5.3)

LOGON

6A

Request

scheme::String, 

authenticates the user you send with the message

LOGOFF

6B

Request

logs off current user, becomes ready for another LOGON message

TELEMETRY

54

Request

api::Integer

transmit usage telemetry (added in v5.4)

GOODBYE

02

Request

close the connection, triggers a <DISCONNECT> signal

ACK_FAILURE (only v1 and v2)

0E

Request

acknowledge a failure response (deprecated, use RESET instead with v3+)

RESET

0F

Request

reset the connection, triggers an <INTERRUPT> signal

RUN

10

Request

query::String, parameters::Dictionary, extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db:String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

execute a query (extra::Dictionary added in v3)(db:String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

DISCARD

2F

Request

extra::Dictionary(n::Integer, qid::Integer)

discard records (replaces DISCARD_ALL of v1, v2 & v3)(fields added in v4.0)

PULL

3F

Request

extra::Dictionary(n::Integer, qid::Integer)

fetch records (replaces PULL_ALL of v1, v2 & v3)(fields added in v4.0)

BEGIN

11

Request

extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db::String, imp_user::String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

begin a new transaction (added in v3)(db::String, imp_user::String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

COMMIT

12

Request

commit a transaction (added in v3)

ROLLBACK

13

Request

rollback a transaction (added in v3)

ROUTE

66

Request

routing::Dictionary(address::String), bookmarks::List<String>, extra::Dictionary(db::String, imp_user::String)

fetch the current routing table (added in v4.3)

SUCCESS

70

Summary

metadata::Dictionary

request succeeded

IGNORED

7E

Summary

request was ignored

FAILURE

7F

Summary

metadata::Dictionary

request failed

RECORD

71

Detail

data::List

data values
Request message HELLO

Introduced in bolt 3

The HELLO message request the connection to be authorized for use with the remote database and replaces the INIT request message of version 1 and 2. See below for more information on INIT.

The server must be in the CONNECTED state to be able to process a HELLO message. For any other states, receipt of an HELLO request must be considered a protocol violation and lead to connection closure.

Clients should send HELLO message to the server immediately after connection and process the corresponding response before using that connection in any other way.

Clients wishing to retry initialization should establish a new connection.

In version 4.1, routing::Dictionary(address::String) was added to indicate an indicator if the server should carry out routing, according to the given routing context.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

In version 5.3, bolt_agent::Dictionary was added to indicate the underlying driver and its version as opposed to the application using the driver in `user_agent.

On versions earlier than 5.1, the authentication token described on the LOGON message should be sent as part of the HELLO message instead.
routing values 	Description

{"routing": null} or {}

the server should not carry out routing

{"routing": {}}

the server should carry out routing

{"routing": {"address": "x.example.com:9001", "region": "example", }}

the server should carry out routing according to the given routing context

Signature: 01
Fields:

extra::Dictionary(
scheme::String,
...
user_agent::String,
patch_bolt::List<String>,
routing::Dictionary(address::String),
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>,
bolt_agent::Dictionary(
product::String,
platform::String,
language::String,
language_details::String
)
)

scheme is the authentication scheme, alongside any additional entries (...) specific to the chosen scheme. Predefined schemes are: "none", "basic", "bearer", "kerberos" (depending on the servers capabilities). See LOGON message for more information. Removed after bolt 5.0

The user_agent should conform to "Name/Version" for example "Example/4.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information). Drivers should allow application code to set this value as it is meant to identify the application using the driver.

patch_bolt lets the driver request a patch to the protocol from the server. The patch must not be applied until the server acknowledges it in the SUCCESS response. Default: []. Introduced in bolt 4.3 Removed after bolt 4.4

    "utc" is currently the only supported patch. If successfully negotiated, server and driver will use DateTime and DateTimeZoneId as defined in Bolt version 5.0.

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string. Setting routing to null indicates that the server should not carry out any routing. Default: null. Introduced in bolt 4.1

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes  Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes  Server notification grouping and filtering for available categories. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

bolt_agent::Dictionary, as opposed to user_agent, is meant to identify the driver rather than the application using it. Drivers should not allow applications to change this value. When populating the fields, drivers should be careful not to include anything that could be used to identify a single machine or user. This field is mandatory. Introduced in bolt 5.3

    product::String should conform to "Name/Version" and identify the driver for example "neo4j-fortran-alice-doe/42.69.0". This field is mandatory.

    platform::String should describe the platform the driver is running on for example "Linux 5.15.0-58-generic; x86_64". Send null (or omit) if no platform information is available. Default: null.

    language::String should conform to "Name/Version" and describe the language the driver/application is written in for example "Fortran/77". Send null (or omit) if no language information is available. Default: null.

    language_details::String can contain further information about the language the driver/application is written in for example compiler, runtime, or interpreter and respective versions. Send null (or omit) if no language details are available. Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

HELLO {extra}

Example 1

HELLO {"user_agent": "Example/4.1.0", "routing": {"address": "x.example.com:9001"}, "bolt_agent": {"product": "neo4j-fortran-alice-doe/42.69.0", "platform": "Linux 5.15.0-58-generic; x86_64", "language": "Fortran/77", "language_details": "gfortran 9.3.0"}}

Example 2

HELLO {"user_agent": "Example/4.2.0", "patch_bolt": ["utc"], "routing": {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"}, "notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata:

server::String (server agent string, example "Neo4j/4.1.0")

connection_id::String (unique identifier of the bolt connection used on the server side, example: "bolt-61")

patch_bolt::List<String> only if the client requested patches in the patch_bolt field of the request. The server will include the subset of requested patches (with the exact same string the client requests) if it supports it. From that point onward, the server-client communication must only use the patched protocol. Introduced in bolt 4.3 Removed after bolt 4.4

hints::Dictionary (set of optional configuration hints to be considered by the driver) Introduced in bolt 4.3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The hints dictionary may contain a set of optional configuration hints which may be interpreted or ignored by drivers at their own discretion in order to augment operations where applicable. A full listing of the available hints may be found in AppendixConnection hints. Hints remain valid throughout the lifetime of a given connection and cannot be changed. As such, newly established connections may observe different hints and/or hint values as the server configuration is adjusted.
Example

SUCCESS {"server": "Neo4j/4.0.0", "hints": {"connection.recv_timeout_seconds": 120}}

Example 2

SUCCESS {"server": "Neo4j/4.4.0", "patch_bolt": ["utc"], "hints": {"connection.recv_timeout_seconds": 120}}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages. Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1+

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message INIT

Introduced in bolt 1 Removed after bolt 2

The INIT message is a request for the connection to be authorized for use with the remote database.

The request message INIT is only valid in version 1 and 2 and is replaced by the request message HELLO in version 3+.

The INIT message uses the structure signature 01 and passes two fields: user agent (String) and auth_token (Dictionary).

The server must be in the CONNECTED state to be able to process an INIT request. For any other states, receipt of an INIT request must be considered a protocol violation and lead to connection closure.

Clients should send INIT requests to the network immediately after connection and process the corresponding response before using that connection in any other way.

A receiving server may choose to register or otherwise log the user agent but may also ignore it if preferred.

The auth token should be used by the server to determine whether the client is permitted to exchange further messages. If this authentication fails, the server must respond with a FAILURE message and immediately close the connection. Clients wishing to retry initialization should establish a new connection.

Signature: 01
Fields:

user_agent::String,
auth_token::Dictionary(
scheme::String,
principal::String,
credentials::String,
)

The user_agent should conform to "Name/Version" for example "Example/1.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information).

The scheme is the authentication scheme. Predefined schemes are "none" and "basic". If no scheme is provided, it defaults to "none".

The auth_token must contain either just the entry {"scheme" : "none"} or the keys scheme, principal and credentials.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid Summary Messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

INIT "user_agent" {auth_token}

Example 1

INIT "Example/1.0.0" {"scheme": "none"}

Example 2

INIT "Example/1.0.0" {"scheme": "basic", "principal": "neo4j", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata.

server::String (server agent string, example "Neo4j/3.4.0")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"server": "Neo4j/3.4.0"}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages.

Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message LOGON

Introduced in bolt 5.1

A LOGON message carries an authentication request.

This message is new in version 5.1. In previous versions, authentication was part of the HELLO message.

Signature: 6A
Fields:

auth::Dictionary(
scheme::String,
...
)

The scheme is the authentication scheme. Predefined schemes are none, basic, bearer and kerberos (depending on the servers capabilities).

Further entries in the message are passed to the implementation of the chosen authentication scheme. Their names, types, and defaults depend on that choice.

    The scheme basic requires a username principal::String and a password credentials::String.

    The scheme bearer merely requires a token credentials::String.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

If authentication fails, the server responds with a FAILURE message and immediately closes the connection.
Examples
Synopsis

LOGON {auth}

Example 1

LOGON {"scheme": "basic", "principal": "user", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client has been successfully authenticated.

The following fields are defined for inclusion in the SUCCESS metadata.

advertised_address::String? - the configured advertised address of the database server. Introduced in bolt 5.8

credentials_expired::Boolean - the sent credentials are expired, the user must update them. If this field is not present, it should be considered to be false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v5.8+

SUCCESS {"advertised_address": "graphz.example.com:7687"}

Example v5.1+

SUCCESS {}

Request message LOGOFF

Introduced in bolt 5.1

A LOGOFF message logs off the currently authenticated user. The connection is then ready for another LOGON message.

This message is new in version 5.1. No equivalent exists in previous versions.

Signature: 6B

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

LOGOFF

Example

LOGOFF

Server response SUCCESS

If a LOGOFF message request has been successfully received, the server should respond with a SUCCESS message and enter the AUTHENTICATION state.
Example

SUCCESS {}

Server response FAILURE

If LOGOFF message is received while the server is not in the READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to LOGOFF should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by a session in the FAILED state."}

Example v5.1+

FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by session in the READY state", "gql_status": "08N06", "description": "error: connection exception - protocol error. General network protocol error.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}, "cause": {"message": "08N10: Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "gql_status": "08N10", "description": "error: connection exception - invalid server state. Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Request message TELEMETRY

Introduced in bolt 5.4

The TELEMETRY message contains an integer representing which driver API was used.

The telemetry information is stored on the servers metrics system. The client receives a SUCCESS response, unless it sends an invalid value for the api field, which results in a FAILURE response.

Clients should offer the user the option to disable sending telemetry. Further, the server might opt out of receiving telemetry from the client by sending the corresponding configuration hint in the SUCCESS message of the HELLO message. See AppendixConnection hints for more information. If the client ignores the hint, the server must still accept the TELEMETRY message.

The message may only be sent in the READY state.

Signature: 54
Fields:

api::Integer

Valid values for api and the corresponding API associations are:

0Managed transaction

1Explicit transaction

2Implicit transaction

3Driver-level execute_query()
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

TELEMETRY api

Example 1

TELEMETRY 0

Server response SUCCESS

If a TELEMETRY message request is successfully received, the server responds with a SUCCESS and remains in its current state.
Example

SUCCESS {}

Server response FAILURE

If a TELEMETRY message contains a value that is not a valid api value or is sent in the wrong state, the server responds with a FAILURE message and enters the FAILED state.
Example 1 v5.7+

C: TELEMETRY 2
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state.", "gql_status": "50N42", "description": "error: general processing exception - unexpected error. Unexpected error has occurred. See debug log for details."}

Example 1 v5.4+

C: TELEMETRY 2
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state."}

Example 2 v5.7+

C: TELEMETRY "oh no!"
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING", "gql_status": "22G03", "description": "error: data exception - invalid value type", "cause": {"message": "22N01: Expected the value 128 to be of type INT, but was of type STRING.", "gql_status": "22N01", "description": "error: data exception - invalid type. Expected the value 128 to be of type INT, but was of type STRING.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Example 2 v5.4+

C: TELEMETRY "oh no!"
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING"}

Example 3 v5.7+

C: TELEMETRY 9001
S: FAILURE {"neo4j_code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "gql_status": "50N00", "description": "error: general processing exception - internal error. Internal exception raised DecoderException: org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "cause": {"message": "50N09: The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "gql_status": "50N09", "description": "error: general processing exception - invalid server state transition. The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "diagnostic_record": {"_classification": "DATABASE_ERROR"}}}

Example 3 v5.4+

C: TELEMETRY 9001
S: FAILURE {"code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001"}

Request message GOODBYE

Introduced in bolt 3

The GOODBYE message notifies the server that the connection is terminating gracefully. On receipt of this message, the server should immediately shut down the socket on its side without sending a response.

A client may shut down the socket at any time after sending the GOODBYE message. This message interrupts the server current work if there is any.

Signature: 02

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

No summary messages should be returned.
Examples
Synopsis

GOODBYE

Example

GOODBYE

Request message ACK_FAILURE

Introduced in bolt 1 Removed after bolt 2

The request message ACK_FAILURE signals to the server that the client has acknowledged a previous failure and should return to a READY state.

The request message ACK_FAILURE is only valid in version 1 and 2 and the request message RESET should be used in its place in version 3+.

Signature: 0E

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a FAILED state to be able to successfully process an ACK_FAILURE request. For any other states, receipt of an ACK_FAILURE request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

ACK_FAILURE

Example

ACK_FAILURE

Server response SUCCESS

If an ACK_FAILURE request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.

The server may attach metadata to the SUCCESS message.
Example

SUCCESS {}

Server response message FAILURE

If an ACK_FAILURE request is received while not in the FAILED state, the server should respond with a FAILURE message and immediately close the connection.

The server may attach metadata to the message to provide more detail on the nature of the failure.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RESET

Introduced in bolt 1

The RESET message requests that the connection should be set back to its initial RESET state, as if a HELLO (INIT in v1 and v2) (and a LOGON in v5.1+) had just successfully completed. The RESET message is unique in that, on arrival at the server, it jumps ahead in the message queue, stopping any unit of work that happens to be executing. All the queued messages originally in front of the RESET message will then be IGNORED until the RESET position is reached. Then from this point, the server state is reset to a state that is ready for a new session.

In version 1 and 2, the RESET message splits into two separate signals. First, an <INTERRUPT> signal jumps ahead in the message queue, stopping any unit of work that happens to be executing, and putting the state machine into an INTERRUPTED state. Second, the RESET queues along with all other incoming messages and is used to put the state machine back to READY when its turn for processing arrives. This essentially means that the INTERRUPTED state exists only transitionally between the arrival of a RESET in the message queue and the later processing of that RESET in its proper position. The INTERRUPTED state is therefore the only state to automatically resolve without any further input from the client and whose entry does not generate a response message.

Signature: 0F

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

RESET

Example

RESET

Server response SUCCESS

If a RESET message request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example

SUCCESS {}

Server response FAILURE

If RESET message is received before the server enters a READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to RESET should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1-v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RUN

Introduced in bolt 1

The RUN message requests that a Cypher query is executed with a set of parameters and additional extra data.

In version 3+, this message can both be used in an Explicit Transaction or an Auto-commit Transaction. The transaction type is implied by the message sequence:

Explicit Transaction: RUN while inside a transaction context started with BEGIN first.

Auto-commit Transaction: RUN without having started an explicit transaction with BEGIN first.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 10
Fields:

query::String,
parameters::Dictionary,
extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The query can be any Cypher query (including a procedure call).

The parameters is a dictionary of parameters to be used in the query string.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

An Explicit Transaction (BEGIN+RUN) does not carry any data in the extra field.

For Auto-commit Transaction (RUN) the extra field carries:

extra contains additional options. Introduced in bolt 3

    The bookmarks is a list of strings containing some kind of bookmark identification, e.g., ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

    The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

    The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

    The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Default: "w".

    The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

    The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

    The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes  Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

    The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes  Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a READY or READY_TX (v3+) state to be able to successfully process a RUN request. If the server is in a FAILED or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a RUN request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

RUN "query" {parameters} {extra}

Example 1

RUN "RETURN $x AS x" {"x": 1} {"bookmarks": [], "tx_timeout": 123, "tx_metadata": {"log": "example_message"}, "mode": "r"}

Example 2

RUN "RETURN $x AS x" {"x": 1} {}

Example 3

RUN "CALL dbms.procedures()" {} {}

Example 3

RUN "RETURN 42" {} {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages.

The following fields are defined for inclusion in the SUCCESS metadata.

fields::List<String>, the fields of the return result. e.g. [name, age, ]

t_first::Integer, the time, specified in ms, which the first record in the result stream is available after.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Implicit Transaction (RUN):

db::String? - resolved users home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Explicit Transaction (BEGIN+RUN):

qid::Integer specifies the server assigned statement ID to reference the server side result-set with commencing BEGIN`RUN`PULL and BEGIN`RUN`DISCARD messages. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.0+

SUCCESS {"fields": ["x"], "t_first": 123, "qid": 7000}

Example v3+

SUCCESS {"fields": ["x"], "t_first": 123}

For v1 and v2, if a RUN request has been successfully received and is considered valid by the server, the server should respond with a SUCCESS message and enter the STREAMING state. The server may attach metadata to the message to provide header detail for the results that follow. Clients should not consider a SUCCESS response to indicate completion of the execution of that query, merely acceptance of it. The following fields are defined for inclusion in the metadata:

`fields` (e.g. ["name", "age"])

`result_available_after` (e.g. 123)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v1 and v2

SUCCESS {"fields": ["x"], "result_available_after": 123}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message DISCARD

Introduced in bolt 1

The DISCARD message requests that the remainder of the result stream should be thrown away.

In v1, v2 and v3, this message is called DISCARD_ALL, has no fields and issues a request to discard the outstanding result and return to a READY state. A receiving server should not abort the request but continue to process it without streaming any detail messages back to the client.

Signature: 2F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to throw away. n=-1 will throw away all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

DISCARD {extra}

Example 1

DISCARD {"n": -1, "qid": -1}

Example 2

DISCARD {"n": 1000}

Example 3 v1, v2 or v3

DISCARD_ALL

In version 1 and 2, the server must be in a STREAMING or STREAMING_TX (v3+) state to be able to successfully process a DISCARD request. If the server is in a FAILED state or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a DISCARD request will be considered a protocol violation and will lead to connection closure.
Server response SUCCESS

has_more::Boolean, true if there are no more records to stream. If this field is not present, it should be considered to default to false. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::Stringthe bookmark after committing this transaction (Autocommit Transaction only).

db::Stringthe database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary>a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Introduced in bolt 3 Removed after bolt 5.4

statuses::List<Dictionary>a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionaryplan result. Introduced in bolt 3

profile::Dictionaryprofile result. Introduced in bolt 3

result_consumed_after::Integersame as t_last. Removed after bolt 2

result_available_after::Integersame as t_first. Removed after bolt 2

stats::Dictionarycounter information, such as db-hits etc. Introduced in bolt 3

t_last::Integerthe time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integerthe time (in ms) after which the DBMS was ready to stream the first record in the result. Introduced in bolt 3

type::Stringthe type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example 1 v4+

SUCCESS {"has_more": true}

Example 2 v4+

SUCCESS {"bookmark": "example-bookmark:1", "db": "example_database"}

Example v3

SUCCESS {"bookmark": "example-bookmark:1"}

In version 1 and 2, if a DISCARD_ALL request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example v1 and v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Request message PULL

The PULL message requests data from the remainder of the result stream.

In v1, v2, and v3, this message is called PULL_ALL and has no fields. In v1 and v2, this message issues a request to stream the outstanding result back to the client, before returning to a READY state. Result detail consists of zero or more detail messages being sent before the summary message. This version of the protocol defines one such detail message, namely RECORD (described below).

Signature: 3F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to fetch. n=-1 will fetch all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

Zero or more RECORD.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

PULL {extra}

Synopsis v1 - v3

PULL_ALL

Example 1

PULL {"n": -1, "qid": -1}

Example 2

PULL {"n": 1000}

Example v1 - v3

PULL_ALL

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

has_more::Boolean, true if there are more records to stream. If this field is not present it should be considered to default to false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::Stringthe bookmark after committing this transaction (Autocommit Transaction only).

db::Stringthe database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary>a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Removed after bolt 5.4

statuses::List<Dictionary>a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionaryplan result. Introduced in bolt 3

profile::Dictionaryprofile result. Introduced in bolt 3

result_consumed_after::Integersame as t_last. Removed after bolt 2

result_available_after::Integersame as t_first. Removed after bolt 2

stats::Dictionarycounter information, such as db-hits etc. Introduced in bolt 3

t_last::Integerthe time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integerthe time (in ms) after which the first record in the result stream is available. Introduced in bolt 3

type::Stringthe type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v3+

SUCCESS {"bookmark": "example-bookmark:1", "t_last": 123}

Example v1 - v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Server response IGNORED

For v1 and v2, a server that receives a PULL_ALL request while in FAILED state or INTERRUPTED state, should respond with an IGNORED message and discard the request without processing it. No state change should occur.
Example

IGNORED

Server response FAILURE

For v1 and v2, a PULL_ALL message request cannot be processed successfully, the server should respond with a FAILURE message and enter the FAILED state. The server may attach metadata to the message to provide more detail on the nature of the failure.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Server response RECORD (in v1 and v2)

Zero or more RECORD messages may be returned in response to a PULL_ALL prior to the trailing summary message. Each record carries with it a list of values which form the data content of the record. The order of the values within the list should be meaningful to the client, perhaps based on a requested ordering for that result, but no guarantees should be made around the order of records within the result. A record should only be considered valid if followed by a SUCCESS summary message. Until this summary has been received, the records validity should be considered tentative.
Example

RECORD [1, 2, 3]

Request massage BEGIN

Introduced in bolt 1

The BEGIN message request the creation of a new Explicit Transaction. This message should then be followed by a RUN message. The Explicit Transaction is closed with either the COMMIT message or ROLLBACK message.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 11
Fields:

extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Defaults to write access if no mode is sent. Default: "w".

The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see the Status Codes  Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes  Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

BEGIN {extra}

Example 1

BEGIN {"tx_timeout": 123, "mode": "r", "db": "example_database", "tx_metadata": {"log": "example_log_data"}, "imp_user" : "bob"}

Example 2

BEGIN {"db": "example_database", "tx_metadata": {"log": "example_log_data"}, "bookmarks": ["example-bookmark:1", "example-bookmark2"]}

Example 3

BEGIN {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

db::String? - resolved users home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {}

Example with Home Database Resolution

SUCCESS {"db": "my_home_db"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message COMMIT

The COMMIT message request that the Explicit Transaction is done.

The COMMIT message does not exist in v1 and v2.

Signature: 12

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

COMMIT

Example

COMMIT

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was completed:

bookmark::String, the bookmark after committing this transaction.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"bookmark": "example-bookmark:1"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROLLBACK

The ROLLBACK message requests that the Explicit Transaction rolls back.

The ROLLBACK message does not exist in v1 and v2.

Signature: 13

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROLLBACK

Example

ROLLBACK

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was rolled back.
Example

SUCCESS

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROUTE

Introduced in bolt 4.3

The ROUTE instructs the server to return the current routing table. In previous versions there was no explicit message for this and a procedure had to be invoked using Cypher through the RUN and PULL messages.

This message can only be sent after successful authentication and outside of transactions.

Signature: 66
Fields:

routing::Dictionary,
bookmarks::List<String>,
db::String,
extra::Dictionary(
db::String,
imp_user::String,
)

Note that in v4.4, the db parameter is migrated into a dedicated dictionary named extra that also includes the imp_user and thus, in v4.3 the fields are:

routing::Dictionary,
bookmarks::List<String>,
db::String

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string.

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"].

The db specifies the database name for multi-database to select where the transaction takes place. null denotes the server-side configured default database. Removed after bolt 4.3

extra contains additional options. Introduced in bolt 4.4

    db as above. Default: null.

    The imp_user specifies the impersonated user for the purposes of resolving their home database. null denotes no impersonation (execution takes place as the current user). Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROUTE {routing} [bookmarks] {extra}

Example v4.4+

ROUTE {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"} ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"] {"db": "example_database", "imp_user": "bob"}

Example v4.3

ROUTE {"address": "x.example.com:7687"} [] null

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. The following fields are defined for inclusion in the SUCCESS metadata:

rt::Dictionary(ttl::Integer, db::String, servers::List<Dictionary(addresses::List<String>, role::String)>), the current routing table.

    ttl::Integer specifies for how many seconds this routing table should be considered valid.

    db::String identifies the database for which this routing table applies. Introduced in bolt 4.4

    servers have three elements of the type Dictionary(addresses::List<String>, role::String), where role is one of "ROUTE", "READ", "WRITE" for exactly one entry each.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.4+

SUCCESS {
"rt": {"ttl": 1000,
"db": "foo",
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Example v4.3

SUCCESS {
"rt": {"ttl": 1000,
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Server message IGNORED
Example

IGNORED

Server message FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v4.3 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Summary message SUCCESS

The SUCCESS message indicates that the corresponding request has succeeded as intended. It may contain metadata relating to the outcome. Metadata keys are described in the section of this document relating to the message that began the exchange.

Signature: 70
Fields:

metadata::Dictionary

Examples
Synopsis

SUCCESS {metadata}

Example

SUCCESS {"example": "see specific message for server response metadata"}

Summary message IGNORED

The IGNORED message indicates that the corresponding request has not been carried out.

Signature: 7E

Fields: No fields.
Examples
Synopsis

IGNORED

Example

IGNORED

Summary message FAILURE

Signature: 7F
Fields:

metadata::Dictionary

The following fields are defined in the metadata:

message::String - the human readable description of the failure.

code::String - the neo4j code identifying the failure. Removed after bolt 5.6

neo4j_code::String - the neo4j code identifying the failure. Introduced in bolt 5.7

gql_status::String - the GQL status which identifies the error. This should be used in favor of neo4j_code. See more about GQL-status notification object. Introduced in bolt 5.7

description::String - describes the failure represented by gql_status. Introduced in bolt 5.7

diagnostic_record::Dictionary - contains fields for helping diagnosing the status. Omitted when content is default. Introduced in bolt 5.7

    OPERATION::String - GQL standard field. Default: ""

    OPERATION_CODE::String - GQL standard field. Default: "0"

    CURRENT_SCHEMA::String - GQL standard field. Default: "/"

    _classification::String? - classifies the failure.

cause:Dictionary(message::String, gql_status::String, description::String, diagnostic_record::Dictionary, cause::Dictionary?)? - the inner cause of the error. This fields provides more specific details and context about the failure. Introduced in bolt 5.7

The diagnostic_record field can contain extra and undocumented entries. This information can be important for diagnosing failures.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

FAILURE {metadata}

Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Detail message RECORD

A RECORD message carries a sequence of values corresponding to a single entry in a result.

Signature: 71

These messages are currently only ever received in response to a PULL (PULL_ALL in v1, v2, and v3) message and will always be followed by a summary message.
Examples
Synopsis

RECORD [data]

Example 1

RECORD ["1", "2", "3"]

Example 2

RECORD [{"point": [1, 2]}, "example_data", 123]

Summary of changes per version

The sections below list the changes of messages compared to the previous version. Please also check for changes in Structure Semantics.
Version 5.8

Introduce connection hint ssr.enabled

Introduce advertised_address as response metadata of LOGON

SUCCESS message of begin transaction messages (BEGIN or RUN) contains resolved home database as db.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.7

FAILURE message was changed to have gql_status, description, diagnostic_record and cause. code was renamed to neo4j_code.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.6

SUCCESS messages that contain a notifications field were changed to have a field statuses instead.

    SUCCESS on PULL

    SUCCESS on DISCARD
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.5

Unsupported (and undocumented ) protocol version

Version 5.5 was only ever released in some drivers, but has a flawed design. No Neo4j server will negotiate this protocol version.
Version 5.4

A new message TELEMETRY is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.3

A new field bolt_agent is added to the HELLO messages extra dictionary.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.2

HELLO, BEGIN and RUN messages now accept notifications options notifications_minimum_severity and notifications_disabled_categories.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.1

HELLO message no longer accepts authentication.

LOGON message has been added and accepts authentication.

LOGOFF message has been added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5

No changes from version 4.4
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.4

The db parameter within the ROUTE message is migrated into a dedicated dictionary named extra.

An imp_user parameter is added to the meta fields within ROUTE, RUN and BEGIN messages respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.3

NOOP chunks may now be transmitted in all connection states when a connection remains in idle for extended periods of time while the server is busy processing a request.

An additional hints dictionary is added to the metadata property of the SUCCESS structure transmitted in response to the HELLO command in order to provide optional configuration hints to drivers.

A new message ROUTE to query the routing table is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

The HELLO message, defines the sub-field routing::Dictionary(address::String) to indicate if server side routing should be performed and can include routing context data.

Support for NOOP chunk (empty chunk). Both server and client should support this.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.0

DISCARD_ALL message renamed to DISCARD and introduced new fields.

PULL_ALL message renamed to PULL and introduced new fields.

The BEGIN message now have a field db::String to specify a database name.

The RUN message now have a field db::String to specify a database name.

Explicit Transaction (BEGIN+RUN) can now get a server response with a SUCCESS and metadata key qid (query identification).

The DISCARD message can now discard an arbitrary number of records. New fields n and qid.

The DISCARD message can now get a server response with a SUCCESS and metadata key has_more.

The PULL message can now fetch an arbitrary number of records. New fields n and qid.

The PULL message can now get a server response with a SUCCESS and metadata key has_more.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 3

The INIT request message is replaced with HELLO message.

The ACK_FAILURE request message is removed. Use RESET message instead.

Added extra::Dictionary field to RUN message.

Added extra::Dictionary field to BEGIN message.

New HELLO request message.

New GOODBYE request message.

New BEGIN request message.

New COMMIT request message.

New ROLLBACK request message.

New RESET request message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

Byte values are represented using hexadecimal notation unless otherwise specified.
Endianness

Bolt requires that all values that can vary by endianness should be transmitted using network byte order, also known as big-endian byte order. This means that the most significant part of the value is written to the network or memory space first and the least significant part is written last.
Connection and disconnection

Bolt communication is intended to take place over a TCP connection. The default port is TCP 7687 but any port can be used.

There is no formal shutdown procedure for a Bolt connection. Either peer may close the connection at TCP level at any time. Both client and server should be prepared for that to occur and should handle it appropriately.
Handshake

Immediately following a successful connection, the client MUST initiate a handshake. This handshake is a fixed exchange used to determine the version of messaging protocol that follows.
Bolt identification

The first part of the handshake is used to identify to the server that this is a Bolt connection. It should be sent by a client immediately following the establishment of a successful connection and does not require a server response.

The identification consists of the following four bytes:

C: 60 60 B0 17

Version negotiation

After identification, a small client-server exchange occurs to determine which version of the messaging protocol to use. In this, the client submits exactly four protocol versions, each encoded as a big-endian 32-bit unsigned integer for a total of 128 bits. Protocol version zero can be used as a placeholder if fewer than four versions are required in the exchange. Should a match be found for a version supported by the server, the response will contain that version encoded as a single 32-bit integer. If no match is found, a zero value is returned followed by immediate closure of the connection by the server.

Within this exchange, a zero value (four zero bytes) always represents no protocol version. For the client, this can be used as a filler if fewer than four protocol versions are known. For the server, this indicates no version match has been found.

A server should assume that the versions contained within a clients request have been sent in order of preference. Therefore, if a match occurs for more than one version, the first match should be selected.
Example where the client is aware of the Bolt protocol version 1 and the server responds with version 1.

C: 60 60 B0 17
C: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 01

Example where the client is aware of the Bolt protocol versions 1 and 2, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol versions 1, 2 and 3, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 02 00 00 00 01 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol version 3 but the server responds with no version, the server do not support communication with the client.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 00

Bolt version 4.3

With Bolt version 4.3, the version scheme supports ranges of minor versions. The first 8 bits are reserved. The next 8 bits represent the number of consecutive minor versions below the specified minor (next 8 bits) and major (next 8 bits) version that are supported.

The range cannot span multiple major versions.
Example with versions 4.3 plus two previous minor versions, 4.2 and 4.1

00 02 03 04

Example where the client is aware of five Bolt versions; 3, 4.0, 4.1, 4.2 and 4.3, and the server responds with 4.1

C: 60 60 B0 17
C: 00 03 03 04 00 00 01 04 00 00 00 04 00 00 00 03
S: 00 00 01 04

The client has to specify all versions prior to 4.3 explicitly since servers that only support those protocol versions might not support ranges. The example makes use of the fact that Bolt 4.1 and 4.2 are equivalent and only offer 4.3, 4.2, 4.0, and 3, but specify a range (4.3-4.0), in case the server supports ranges.
Bolt version 4.0

With Bolt version 4.0 the version scheme supports major and minor versioning number. The first 16 bits are reserved. 8 bits represents the minor version. 8 bits represents the major version.
Example with version 4.1

00 00 01 04

Example where the client is aware of three Bolt versions; 3, 4.0 and 4.1, and the server responds with 4.1.

C: 60 60 B0 17
C: 00 00 01 04 00 00 00 04 00 00 00 03 00 00 00 00
S: 00 00 01 04

Structure Semantics

While PackStream defines what a Structure looks like, it does not define what it means. The semantics of Structures are bound to the Bolt Protocol version.

The table below lists the PackStream specified structures and their code and tag byte across all currently existing Bolt Protocol versions.
Structures
Structure name 	Code 	tag byte

Node

N

4E

Relationship

R

52

UnboundRelationship

r

72

Path

P

50

Date

D

44

Time

T

54

LocalTime

t

74

DateTime

I

49

DateTimeZoneId

i

69

LocalDateTime

d

64

Duration

E

45

Point2D

X

58

Point3D

Y

59

Legacy Structures

Legacy DateTime

F

46

Legacy DateTimeZoneId

f

66
Node

A snapshot of a node within a graph database.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 4E

Number of fields: 4 (3 before version 5.0)

Node::Structure(
id::Integer,
labels::List<String>,
properties::Dictionary,
element_id::String,
)

Example of a node structure

Node(
id = 3,
labels = ["Example", "Node"],
properties = {"name": "example"},
element_id = "abc123",
)

B4 4E
...

Relationship

A snapshot of a relationship within a graph database.

The fields element_id, start_node_element_id, and end_node_element_id were added with version 5.0 and do not exist in earlier versions.

tag byte: 52

Number of fields: 8 (5 before version 5.0)

Relationship::Structure(
id::Integer,
startNodeId::Integer,
endNodeId::Integer,
type::String,
properties::Dictionary,
element_id::String,
start_node_element_id::String,
end_node_element_id::String,
)

Example of a relationship structure

Relationship(
id = 11,
startNodeId = 2,
endNodeId = 3,
type = "KNOWS",
properties = {"name": "example"},
element_id = "abc123",
start_node_element_id = "def456",
end_node_element_id = "ghi789",
)

B8 52
...

UnboundRelationship

A relationship without start or end node ID. It is used internally for Path serialization.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 72

Number of fields: 4 (3 before version 5.0)

UnboundRelationship::Structure(
id::Integer,
type::String,
properties::Dictionary,
element_id::String,
)

Example of unbound relationship structure

UnboundRelationship(
id = 17,
type = "KNOWS",
properties = {"name": "example"},
element_id = "foo"
)

B4 72
...

Path

An alternating sequence of nodes and relationships.

tag byte: 50

Number of fields: 3

Path::Structure(
nodes::List<Node>,
rels::List<UnboundRelationship>,
indices::List<Integer>,
)

Where the nodes field contains a list of nodes and the rels field is a list of unbound relationships. The indices are a list of integers describing how to construct the path from nodes and rels. The first node in nodes is always the first node in the path and is not referenced in indices. indices always has an even number of entries. The 1st, 3rd,  entry in indices refers to an entry in rels (1-indexed), for example, a 3 would refer to the 3rd element of rels. The number can also be negative which should be treated like the positive equivalent, except for denoting the relationship in the inverse direction. The number is never 0. The 2nd, 4th,  entry in indices refers to an entry in nodes (0-indexed), for example, a 3 would refer to the 4th element of nodes. The number is always  0.
Example (simplified notation for <Node> and <UnboundRelationship>)

Path::Structure(
nodes: [Node::Structure(42, ...), Node::Structure(69, ...), Node::Structure(1, ...)],
rels: [UnboundRelationship::Structure(1000, ...), UnboundRelationship::Structure(1001, ...)],
indices: [1, 1, 1, 0, -2, 2],

This represents the path (42)-[1000](69)-[1000](42)[1001]-(1), where (n) denotes a node with id n and [n] a relationship with id n ( or  denotes the direction of each relationship).
Date

A date without a time-zone in the ISO-8601 calendar system, e.g. 2007-12-03.

tag byte: 44

Number of fields: 1

Date::Structure(
days::Integer,
)

Where the days are days since Unix epoch. 0 for example represents 1970-01-01 while 1 represents 1970-01-02.
Time

An instant capturing the time of day, and the timezone, but not the date.

tag byte: 54

Number of fields: 2

Time::Structure(
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight (this time is not UTC) and the tz_offset_seconds are an offset in seconds from UTC.
LocalTime

An instant capturing the time of day, but neither the date nor the time zone.

tag byte: 74

Number of fields: 1

LocalTime::Structure(
nanoseconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight.
DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure is new in version 5.0. It replaces Legacy DateTime and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 49

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_offset_seconds specifies the offset in seconds from UTC.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+01:00 can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00.000000042+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure is new in version 5.0. It replaces Legacy DateTimeZoneId and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 69

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_id specifies the timezone name as understood by the timezone database.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+0100[Europe/Paris] can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3_600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone specified by tz_id, giving 1970-01-01T02:15:00.000000042+0100[Europe/Paris]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

LocalDateTime

An instant capturing the date and the time but not the time zone.

tag byte: 64

Number of fields: 2

LocalDateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
)

Where the seconds are seconds since the Unix epoch.
Duration

A temporal amount. This captures the difference in time between two instants. It only captures the amount of time between two instants, it does not capture a start time and end time. A unit capturing the start time and end time would be a Time Interval and is out of scope for this proposal.

A duration can be negative.

tag byte: 45

Number of fields: 4

Duration::Structure(
months::Integer,
days::Integer,
seconds::Integer,
nanoseconds::Integer,
)

Point2D

A representation of a single location in 2-dimensional space.

tag byte: 58

Number of fields: 3

Point2D::Structure(
srid::Integer,
x::Float,
y::Float,
)

Where the srid is a Spatial Reference System Identifier.
Point3D

A representation of a single location in 3-dimensional space.

tag byte: 59

Number of fields: 4

Point3D::Structure(
srid::Integer,
x::Float,
y::Float,
z::Float,
)

Where the srid is a Spatial Reference System Identifier.
Legacy Structures
Legacy DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure got removed in version 5.0 in favor of DateTime.

tag byte: 46

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The tz_offset_seconds specifies the offset in seconds from UTC.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the above offset.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+01:00 (and 42 nanoseconds) can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

remove the offset from the seconds field, which gives here 8100

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp, giving 1970-01-01T01:15:00Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Legacy DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure got removed in version 5.0 in favor of DateTimeZoneId.

tag byte: 66

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The tz_id specifies the timezone name as understood by the timezone database.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the offset derived from the named timezone and specified the point in time.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+0100[Europe/Paris] (and 42 nanoseconds) can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the resolved offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens as follows:

instantiate the idiomatic equivalent of DateTime assuming the seconds denote a Unix timestamp, giving 1970-01-01T02:15:00Z.

set the timezone of the resulting instance, without changing the date/time components, giving 1970-01-01T02:15:00+0100[Europe/Paris] (this may lead to ambiguities, refer to the Known Limitations section below for more information).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Time Shifts

Note: these issues have been resolved with the introduction of DateTimeZoneId in version 5.0.

Not all instances of DateTimeZoneId map to a single valid point in time.

During time shifts like going from 2AM to 3AM in a given day and timezone, 2:30AM e.g. does not happen.

Similarly, when going from 3AM to 2AM in a given day and timezone, 2:30AM happens twice.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In the first case, a DateTimeZoneId specifying a time between 2AM and 3AM does not correspond to any actual points in time for that timezone and is invalid.

In the second case, all points in the time between 2AM and 3AM exist twice, but with a different offset. Therefore, the timezone name is not sufficient to resolve the ambiguity, the timezone offset is also needed. Since DateTimeZoneId does not include the timezone offset, the resolution of these particular datetimes is undefined behavior.
Summary of changes per version

The sections below list the changes of structure semantics in versions where they changed. Please also check for changes in Bolt Messages.
Version 5.0

The element_id field was added to Node.

The fields element_id, start_node_element_id, and end_node_element_id were added to Relationship.

The element_id field was added to UnboundRelationship.

Replaced Legacy DateTime and Legacy DateTimeZoneId with DateTime and DateTimeZoneId respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime.

This state is used to determine what actions may be undertaken by the client. Each server state specification corresponds to a message specification with the same version.

For a summary of all available server state transitions in each version of the Bolt Protocol, see the Appendix pages.
Server states

Each connection maintained by a Bolt server will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.
State 	Logic state 	Description

DISCONNECTED

X

no socket connection

DEFUNCT

X

the socket connection is permanently closed

NEGOTIATION

protocol handshake is completed successfully; ready to accept a HELLO message

AUTHENTICATION

HELLO or LOGOFF message accepted; ready to accept a LOGON message

READY

ready to accept a RUN message

STREAMING

Auto-commit Transaction, a result is available for streaming from the server

TX_READY

Explicit Transaction, ready to accept a RUN message

TX_STREAMING

Explicit Transaction, a result is available for streaming from the server

FAILED

a connection is in a temporarily unusable state

INTERRUPTED

the server got an <INTERRUPT> signal
Server state DISCONNECTED

No socket connection has yet been established. This is the initial state and exists only in a logical sense prior to the socket being opened.
Transitions from DISCONNECTED

Bolt handshake completed successfully to NEGOTIATION

Bolt handshake did not complete successfully to DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state NEGOTIATION

After a new protocol connection has been established and handshake has been completed successfully, the server enters the NEGOTIATION state. The connection has not yet been authenticated and permits only one transition, through successful initialization using the HELLO message, into the AUTHENTICATION state.
Transitions from NEGOTIATION

<DISCONNECT> to DEFUNCT

HELLO to AUTHENTICATION or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state AUTHENTICATION

Connection has been established and metadata has been sent back from the HELLO message or a LOGOFF message was received whilst in ready state. Ready to accept a LOGON message with authentication information.
Transitions from NEGOTIATION

LOGON to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Transitions from READY

LOGOFF to AUTHENTICATION
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state DEFUNCT

This is not strictly a connection state, but is instead a logical state that exists after a connection has been closed. When DEFUNCT, a connection is permanently not usable. This may arise due to a graceful shutdown or can occur after an unrecoverable error or protocol violation. Clients and servers should clear up any resources associated with a connection on entering this state, including closing any open sockets. This is a terminal state on which no further transitions may be carried out. The <DISCONNECT> signal will set the connection in the DEFUNCT server state.
Server state READY

The READY state can handle the request messages RUN and BEGIN and receive a query.
Transitions from READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to STREAMING or FAILED

BEGIN to TX_READY or FAILED (v3+)

LOGOFF to AUTHENTICATION (v5.1+)

TELEMETRY to READY (v5.4+)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state STREAMING

When STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can re-enter the READY state and allow any further queries to be executed.
Transitions from STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL to READY, FAILED, or STREAMING

DISCARD to READY, FAILED, or STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1, v2 and v3, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL_ALL to READY or FAILED

DISCARD_ALL to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 1. Request message DISCARD state transitions State 	New state 	Response

STREAMING

READY

SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

FAILURE {}

STREAMING

STREAMING

SUCCESS {"has_more": true}
Table 2. Request message PULL state transitions State 	New state 	Response

STREAMING

READY

[RECORD ] SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

[RECORD ] FAILURE {}

STREAMING

STREAMING

[RECORD ] SUCCESS {"has_more": true}
Table 3. Request message DISCARD_ALL state transitions in v1, v2, and v3 only State 	New state 	Response

STREAMING

READY

`SUCCESS {}

STREAMING

FAILED

FAILURE {}
Table 4. Request message PULL_ALL state transitions in v1. v2 and v3 only State 	New state 	Response

STREAMING

READY

[RECORD ] SUCCESS {}

STREAMING

FAILED

[RECORD ] FAILURE {}
Server state TX_READY
Transitions from TX_READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

COMMIT to READY or FAILED

ROLLBACK to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 5. Request message RUN state transitions State 	New state 	Response

TX_READY

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_READY

FAILED

FAILURE{}

The TX_READY server state does not exist in v1 or v2.
Server state TX_STREAMING

When TX_STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can transition to the TX_READY state.
Transitions from TX_STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

PULL to TX_READY, FAILED or TX_STREAMING

DISCARD to TX_READY, FAILED or TX_STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 6. Request message RUN state transitions State 	New state 	Response

TX_STREAMING

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_STREAMING

FAILED

FAILURE{}
Table 7. Request message DISCARD state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

FAILURE {}

TX_STREAMING

TX_STREAMING

SUCCESS {"has_more": true}
Table 8. Request messages PULL state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

[RECORD ] SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

[RECORD ] FAILURE {}

TX_STREAMING

TX_STREAMING

[RECORD ] SUCCESS {"has_more": true}

The TX_STREAMING server state does not exist in v1 or v2.
Server state FAILED

When FAILED, a connection is in a temporarily unusable state. This is generally as the result of encountering a recoverable error. This mode ensures that only one failure can exist at a time, preventing cascading issues from batches of work.
Transitions from FAILED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to FAILED

PULL to FAILED

DISCARD to FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, in a FAILED state, no more work will be processed until the failure has been acknowledged by ACK_FAILURE or until the connection has been RESET.

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

ACK_FAILURE to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state INTERRUPTED

This state occurs between the server receiving the jump-ahead <INTERRUPT> and the queued RESET message, (the RESET message triggers an <INTERRUPT>). Most incoming messages are ignored when the server are in an INTERRUPTED state, with the exception of the RESET that allows transition back to READY. The <INTERRUPT> signal will set the connection in the INTERRUPTED server state.
Transitions from INTERRUPTED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD to INTERRUPTED

PULL to INTERRUPTED

BEGIN to INTERRUPTED

COMMIT to INTERRUPTED

ROLLBACK to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD_ALL to INTERRUPTED

PULL_ALL to INTERRUPTED

ACK_FAILURE to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Summary of changes per version

The sections below list the changes compared to the previous version.
Version 5.2

No changes compared to version 5.1.
Version 5.1

CONNECTED state has been renamed to NEGOTIATION but still accepts the HELLO message.

HELLO message no longer accepts authentication and transitions to the AUTHENTICATION state from NEGOTIATION.

LOGON message has been added. It can only be received in the AUTHENTICATION state and transitions to the READY state.

LOGOFF message has be added. It can only be received in the READY state and transitions to the AUTHENTICATION state.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.0

No changes compared to version 4.4.
Version 4.4

No changes compared to version 4.3.
Version 4.3

The ROUTE message was added. It can only be received in the READY state and causes no transition.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

No changes compared to version 4.0.
Version 4.0

Compared to version 3 the RUN, PULL and DISCARD now can re-enter STREAMING or TX_STREAMING. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 4.0.
Version 3

Compared to version 2 there are new server states:

TX_READY

TX_STREAMING These states are introduced to handle the concept of Explicit Transaction. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 3.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

boltfile(GLOB_RECURSE NEO4J_BOLT_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(Neo4jBoltTransport ${NEO4J_BOLT_TRANSPORT_SOURCE})

target_include_directories(Neo4jBoltTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(Neo4jBoltTransport PUBLIC Boost::asio Boost::system)
target_link_libraries(Neo4jBoltTransport PUBLIC Protocol)
target_compile_definitions(Neo4jBoltTransport PUBLIC SPDLOG_USE_STD_FORMAT)
target_link_libraries(Neo4jBoltTransport
    PUBLIC
    spdlog::spdlog_header_only
)#ifndef NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H
#define NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H

#include <map>
#include <memory>  // For std::shared_ptr for field_names
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/bolt_structure_types.h"
#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {

    class BoltRecord {
      public:
        // Constructor takes rvalue refs to move data if possible.
        // field_names_ptr is shared because multiple records from the same result stream share it.
        BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> field_names_ptr);

        BoltRecord(const BoltRecord&) = delete;  // Typically records are not copied once created
        BoltRecord& operator=(const BoltRecord&) = delete;
        BoltRecord(BoltRecord&&) noexcept = default;
        BoltRecord& operator=(BoltRecord&&) noexcept = default;

        // Access by index
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(size_t index) const;

        // Access by name
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(const std::string& field_name) const;

        // Typed access by index
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(size_t index) const;

        // Typed access by name
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(const std::string& field_name) const;

        // Typed access for Bolt Structures (Node, Relationship, etc.)
        // These require the Bolt version for correct deserialization of version-dependent fields.
        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(size_t index,
                                                                                  const boltprotocol::versions::Version& bolt_version,
                                                                                  bool utc_patch_active_for_4_4 = false  // Relevant for DateTime types in Bolt 4.4
        ) const;

        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) const;

        size_t field_count() const noexcept {
            return fields_.size();
        }
        const std::vector<std::string>& field_names() const;  // Returns empty if no names available

      private:
        std::vector<boltprotocol::Value> fields_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_;  // Pointer to shared field names
        // Optional: Cache field name to index map for faster named lookups if records are long-lived
        // mutable std::optional<std::map<std::string, size_t>> field_name_to_index_cache_;
        // const std::map<std::string, size_t>& get_field_name_map() const;
    };

    // --- Template Implementations for BoltRecord ---
    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(size_t index) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T{}};
        }
        if (std::holds_alternative<T>(value_result.second)) {
            try {
                return {boltprotocol::BoltError::SUCCESS, std::get<T>(value_result.second)};
            } catch (const std::bad_variant_access&) {                         // Should not happen if holds_alternative is true
                return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
            }
        }
        // Special case for int64_t, allow conversion from other integral types if safe (e.g. int32_t -> int64_t)
        // This requires more complex logic or a dedicated conversion utility.
        // For now, strict type match.
        return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
    }

    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // No field names available
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // Field name not found
        }
        return get_as<T>(static_cast<size_t>(index));
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(size_t index, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T_BoltStructure{}};
        }

        T_BoltStructure typed_struct;
        boltprotocol::BoltError conversion_err;

        // Use the value_to_typed_struct that takes version and patch info
        if constexpr (std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTime> || std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTimeZoneId> || std::is_same_v<T_BoltStructure, boltprotocol::BoltNode> || std::is_same_v<T_BoltStructure, boltprotocol::BoltRelationship> ||
                      std::is_same_v<T_BoltStructure, boltprotocol::BoltUnboundRelationship> || std::is_same_v<T_BoltStructure, boltprotocol::BoltPath>) {
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct, bolt_version, utc_patch_active_for_4_4);
        } else {  // For types like BoltDate, BoltTime that don't need version for deserialization
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct);
        }

        if (conversion_err != boltprotocol::BoltError::SUCCESS) {
            return {conversion_err, T_BoltStructure{}};
        }
        return {boltprotocol::BoltError::SUCCESS, typed_struct};
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        return get_bolt_structure_as<T_BoltStructure>(static_cast<size_t>(index), bolt_version, utc_patch_active_for_4_4);
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H

#include <map>
#include <optional>
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For boltprotocol::Value

namespace neo4j_bolt_transport {
    namespace config {

        struct NoAuth {};

        struct BasicAuth {
            std::string username;
            std::string password;
            std::optional<std::string> realm;
        };

        struct KerberosAuth {
            std::string base64_ticket;
        };

        struct CustomAuth {
            std::string principal;
            std::string credentials;
            std::optional<std::string> realm;
            std::string scheme;  // The custom scheme name, e.g., "custom_sso"
            std::optional<std::map<std::string, boltprotocol::Value>> parameters;
        };

        struct BearerAuth {
            std::string token;  // The bearer token
        };

        // Variant to hold different authentication types
        using AuthTokenVariant = std::variant<NoAuth, BasicAuth, KerberosAuth, BearerAuth, CustomAuth>;

        // Factory class for creating AuthTokenVariant instances easily
        class AuthTokens {
          public:
            AuthTokens() = delete;  // Static factory methods only

            static AuthTokenVariant none();
            static AuthTokenVariant basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm = std::nullopt);
            static AuthTokenVariant kerberos(const std::string& base64_ticket);
            static AuthTokenVariant bearer(const std::string& token);
            static AuthTokenVariant custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters = std::nullopt);
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {
    namespace config {

        enum class AccessMode { READ, WRITE };

        struct SessionParameters {
            std::optional<std::string> database_name;
            AccessMode default_access_mode = AccessMode::WRITE;
            std::vector<std::string> initial_bookmarks;
            std::optional<std::string> impersonated_user;

            // Default number of records to fetch in each PULL message.
            // -1 typically means "fetch all remaining".
            // Drivers often have a default like 1000.
            int64_t default_fetch_size = 1000;

            SessionParameters() = default;

            static SessionParameters for_database(const std::string& db_name) {
                SessionParameters p;
                p.database_name = db_name;
                return p;
            }

            SessionParameters& with_database(const std::string& db_name) {
                database_name = db_name;
                return *this;
            }
            SessionParameters& with_default_access_mode(AccessMode mode) {
                default_access_mode = mode;
                return *this;
            }
            SessionParameters& with_bookmarks(const std::vector<std::string>& new_bookmarks) {
                initial_bookmarks = new_bookmarks;
                return *this;
            }
            SessionParameters& with_impersonated_user(const std::string& user) {
                impersonated_user = user;
                return *this;
            }
            SessionParameters& with_fetch_size(int64_t size) {
                default_fetch_size = size;
                return *this;
            }
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H

#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <set>  // For set of ServerAddress
#include <string>
#include <vector>

#include "auth_token.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/routing/server_address.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    namespace uri {
        struct ParsedUri;
    }

    namespace config {

        struct TransportConfig {
            std::string uri_string;
            AuthTokenVariant auth_token = AuthTokens::none();
            std::string user_agent_override;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info;

            enum class EncryptionStrategy { NEGOTIATE_FROM_URI_SCHEME, FORCE_PLAINTEXT, FORCE_ENCRYPTED_SYSTEM_CERTS, FORCE_ENCRYPTED_TRUST_ALL_CERTS, FORCE_ENCRYPTED_CUSTOM_CERTS };
            EncryptionStrategy encryption_strategy = EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            std::size_t max_connection_pool_size = 100;
            uint32_t connection_acquisition_timeout_ms = 60000;  // Timeout for acquiring a connection from the pool
            uint32_t max_connection_lifetime_ms = 3600000;       // Max lifetime of a pooled connection
            uint32_t idle_timeout_ms = 600000;                   // Max idle time for a pooled connection
            uint32_t idle_time_before_health_check_ms = 30000;   // Idle time after which a health check (ping) is performed before reuse

            // Socket level timeouts
            uint32_t tcp_connect_timeout_ms = 5000;  // Timeout for establishing the TCP connection
            uint32_t socket_read_timeout_ms = 0;     // Timeout for socket read operations (0 = system default/infinite)
            uint32_t socket_write_timeout_ms = 0;    // Timeout for socket write operations (0 = system default/infinite)
            bool tcp_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;

            // Bolt protocol level timeouts
            uint32_t hello_timeout_ms = 15000;   // Timeout for HELLO message exchange
            uint32_t goodbye_timeout_ms = 5000;  // Timeout for GOODBYE message exchange (if sent)

            // Transaction related configurations
            uint32_t max_transaction_retry_time_ms = 30000;  // Max total time for retrying a managed transaction
            uint32_t transaction_retry_delay_initial_ms = 1000;
            uint32_t transaction_retry_delay_multiplier = 2;
            uint32_t transaction_retry_delay_max_ms = 60000;
            uint32_t explicit_transaction_timeout_default_ms = 0;  // Default timeout for explicit transactions if not specified per-transaction (0 = server default)

            // --- Routing ---
            bool client_side_routing_enabled = true;
            uint32_t routing_table_refresh_ttl_margin_ms = 5000;
            uint32_t routing_max_retry_attempts = 3;
            std::function<routing::ServerAddress(const routing::ServerAddress&)> server_address_resolver;
            std::map<std::string, std::vector<routing::ServerAddress>> initial_router_addresses_override;

            // --- Bolt Protocol ---
            std::vector<boltprotocol::versions::Version> preferred_bolt_versions;

            // --- Logging ---
            std::shared_ptr<spdlog::logger> logger;
            spdlog::level::level_enum log_level = spdlog::level::info;

            TransportConfig(const std::string& uri_str = "bolt://localhost:7687");
            TransportConfig();

            boltprotocol::BoltError apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri);
            void prepare_agent_strings(const std::string& default_transport_name_version = "Neo4jBoltTransportCpp/0.6.0");  // Version bump

            std::shared_ptr<spdlog::logger> get_or_create_logger(const std::string& logger_name = "Neo4jBoltTransport");
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H
#define NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H

#include <optional>
#include <string>

#include "boltprotocol/message_defs.h"  // For BoltError and FailureMessageParams

namespace neo4j_bolt_transport {
    namespace error {

        // Creates a detailed error message string from FailureMessageParams
        inline std::string format_server_failure(const boltprotocol::FailureMessageParams& failure_params) {
            std::string server_code = "Unknown.Error";
            std::string server_message = "An error occurred on the server.";

            auto extract_string_from_value = [](const boltprotocol::Value& val) -> std::optional<std::string> {
                if (std::holds_alternative<std::string>(val)) {
                    return std::get<std::string>(val);
                }
                return std::nullopt;
            };

            auto it_code = failure_params.metadata.find("neo4j_code");  // Bolt 5.7+
            if (it_code == failure_params.metadata.end() || !extract_string_from_value(it_code->second).has_value()) {
                it_code = failure_params.metadata.find("code");  // Legacy
            }
            if (it_code != failure_params.metadata.end()) {
                if (auto code_opt = extract_string_from_value(it_code->second)) {
                    server_code = *code_opt;
                }
            }

            auto it_msg = failure_params.metadata.find("message");
            if (it_msg != failure_params.metadata.end()) {
                if (auto msg_opt = extract_string_from_value(it_msg->second)) {
                    server_message = *msg_opt;
                }
            }

            return "[" + server_code + "] " + server_message;
        }

        // Converts BoltError enum to a human-readable string (basic version)
        inline std::string bolt_error_to_string(boltprotocol::BoltError err_code) {
            switch (err_code) {
                case boltprotocol::BoltError::SUCCESS:
                    return "SUCCESS";
                case boltprotocol::BoltError::UNKNOWN_ERROR:
                    return "UNKNOWN_ERROR";
                case boltprotocol::BoltError::INVALID_ARGUMENT:
                    return "INVALID_ARGUMENT";
                case boltprotocol::BoltError::SERIALIZATION_ERROR:
                    return "SERIALIZATION_ERROR";
                case boltprotocol::BoltError::DESERIALIZATION_ERROR:
                    return "DESERIALIZATION_ERROR";
                case boltprotocol::BoltError::INVALID_MESSAGE_FORMAT:
                    return "INVALID_MESSAGE_FORMAT";
                case boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION:
                    return "UNSUPPORTED_PROTOCOL_VERSION";
                case boltprotocol::BoltError::NETWORK_ERROR:
                    return "NETWORK_ERROR";
                case boltprotocol::BoltError::HANDSHAKE_FAILED:
                    return "HANDSHAKE_FAILED";
                // ... add all other BoltError codes ...
                default:
                    return "UNRECOGNIZED_BOLT_ERROR (" + std::to_string(static_cast<int>(err_code)) + ")";
            }
        }

        // Combines a BoltError with a context message and potentially a server failure message
        inline std::string format_error_message(const std::string& context, boltprotocol::BoltError err_code, const std::optional<std::string>& server_failure_detail = std::nullopt) {
            std::string msg = context + ": " + bolt_error_to_string(err_code) + " (code " + std::to_string(static_cast<int>(err_code)) + ")";
            if (server_failure_detail && !server_failure_detail->empty()) {
                msg += "; Server detail: " + *server_failure_detail;
            }
            return msg;
        }

    }  // namespace error
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H

#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <memory>  // For std::weak_ptr
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version

namespace neo4j_bolt_transport {
    namespace internal {

        // Represents an established, active asynchronous stream and its parameters.
        // Ownership of the stream object is held by this context.
        struct ActiveAsyncStreamContext {
            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> stream;

            boltprotocol::versions::Version negotiated_bolt_version;
            std::string server_agent_string;
            std::string server_connection_id;
            bool utc_patch_active = false;
            bool encryption_was_used = false;

            ActiveAsyncStreamContext(std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> s, boltprotocol::versions::Version bv, std::string sa, std::string cid, bool utc, bool enc_used)
                : stream(std::move(s)), negotiated_bolt_version(bv), server_agent_string(std::move(sa)), server_connection_id(std::move(cid)), utc_patch_active(utc), encryption_was_used(enc_used) {
            }

            explicit ActiveAsyncStreamContext(boost::asio::io_context& ioc) : stream(boost::asio::ip::tcp::socket(ioc)) {
            }
            ActiveAsyncStreamContext() = delete;

            ActiveAsyncStreamContext(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext& operator=(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext(ActiveAsyncStreamContext&&) = default;
            ActiveAsyncStreamContext& operator=(ActiveAsyncStreamContext&&) = default;

            boost::asio::any_io_executor get_executor() {
                return std::visit(
                    [](auto& s) {
                        return s.get_executor();
                    },
                    stream);
            }
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H// Include/neo4j_bolt_transport/internal/async_utils_decl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/buffer.hpp>  // For buffer concepts
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <chrono>
#include <string>
#include <utility>

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Timeout wrapper for read operations
            template <typename Stream, typename MutableBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_read_with_timeout(IAsyncContextCallbacks* callbacks,
                                                                                                            Stream& stream,
                                                                                                            MutableBufferSequence buffers,  // Must be mutable
                                                                                                            std::chrono::milliseconds timeout_duration,
                                                                                                            const std::string& operation_name);

            // Timeout wrapper for write operations
            template <typename Stream, typename ConstBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_write_with_timeout(IAsyncContextCallbacks* callbacks,
                                                                                                             Stream& stream,
                                                                                                             ConstBufferSequence buffers,  // Can be const
                                                                                                             std::chrono::milliseconds timeout_duration,
                                                                                                             const std::string& operation_name);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#include "async_utils_impl.h"

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H

#include <spdlog/spdlog.h>

#include <boost/asio/as_tuple.hpp>
#include <boost/asio/buffer.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>
#include <tuple>
#include <type_traits>  // For std::invoke_result_t

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Internal helper for timed I/O operations that return awaitable<tuple<ec, size_t>>
            template <typename Stream, typename IoOperation>
            boost::asio::awaitable<std::tuple<boost::system::error_code, std::size_t>> perform_timed_io(IAsyncContextCallbacks* callbacks,
                                                                                                        Stream& stream,
                                                                                                        std::chrono::milliseconds timeout_duration,
                                                                                                        const std::string& operation_name_for_log,
                                                                                                        IoOperation io_op  // Lambda returning awaitable<tuple<ec, size_t>>
            ) {
                std::shared_ptr<spdlog::logger> logger = nullptr;
                if (callbacks) {
                    logger = callbacks->get_logger();
                }

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtilTimed {}] Op on closed stream (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::not_connected, 0);  // Or appropriate error
                }

                if (timeout_duration.count() <= 0) {  // No timeout
                    try {
                        co_return co_await io_op();
                    } catch (const boost::system::system_error& e_sys) {
                        if (logger) logger->error("[AsyncUtilTimed {}] Exception (no timeout, obj id {}): {}", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0, e_sys.what());
                        co_return std::make_tuple(e_sys.code(), 0);
                    }
                }

                boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
                timer.expires_after(timeout_duration);

                std::optional<std::tuple<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        std::tuple<boost::system::error_code, std::size_t> temp_io_res;
                        try {
                            temp_io_res = co_await io_op();
                        } catch (const boost::system::system_error& e_sys) {
                            std::get<0>(temp_io_res) = e_sys.code();
                            std::get<1>(temp_io_res) = 0;
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = temp_io_res;
                            timer.cancel();
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec_val;
                        std::tie(timer_ec_val) = co_await timer.async_wait(boost::asio::as_tuple(boost::asio::use_awaitable));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {timer_ec_val};
                            if (timer_ec_val != boost::asio::error::operation_aborted) {
                                stream.lowest_layer().cancel();
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(co_await boost::asio::this_coro::executor, boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    co_return io_result_opt.value();
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    if (logger) logger->warn("[AsyncUtilTimed {}] Op timed out (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::timed_out, 0);
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        if (logger) logger->error("[AsyncUtilTimed {}] Logic error: Timer aborted, no I/O (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                        co_return std::make_tuple(boost::asio::error::fault, 0);
                    }
                    // This should be caught by the first if (io_result_opt.has_value())
                    if (logger) logger->error("[AsyncUtilTimed {}] Logic error: Timer aborted, but io_result_opt is somehow still empty (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::fault, 0);
                } else {
                    if (logger) logger->error("[AsyncUtilTimed {}] Unexpected fallthrough (obj id {}).", operation_name_for_log, callbacks ? callbacks->get_id_for_logging() : 0);
                    co_return std::make_tuple(boost::asio::error::fault, 0);
                }
            }

            template <typename Stream, typename MutableBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_read_with_timeout(IAsyncContextCallbacks* callbacks, Stream& stream, MutableBufferSequence buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name) {
                static_assert(boost::asio::is_mutable_buffer_sequence<MutableBufferSequence>::value, "async_read_with_timeout requires a MutableBufferSequence.");

                auto completion_token = boost::asio::as_tuple(boost::asio::use_awaitable);
                auto io_op_lambda = [&]() {  // Lambda for the actual read operation
                    return boost::asio::async_read(stream, buffers, completion_token);
                };

                auto [ec, bytes_transferred] = co_await perform_timed_io(callbacks, stream, timeout_duration, operation_name, io_op_lambda);

                if (ec) {
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::invalid_argument)
                        mapped_error = boltprotocol::BoltError::INVALID_ARGUMENT;
                    else if (ec == boost::asio::error::not_connected)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::fault)
                        mapped_error = boltprotocol::BoltError::UNKNOWN_ERROR;

                    if (callbacks) {  // callbacks might be null if initial check failed
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{mapped_error, 0};
                    }
                }
                co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

            template <typename Stream, typename ConstBufferSequence>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_write_with_timeout(IAsyncContextCallbacks* callbacks, Stream& stream, ConstBufferSequence buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name) {
                static_assert(boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value, "async_write_with_timeout requires a ConstBufferSequence.");

                auto completion_token = boost::asio::as_tuple(boost::asio::use_awaitable);
                auto io_op_lambda = [&]() {  // Lambda for the actual write operation
                    return boost::asio::async_write(stream, buffers, completion_token);
                };

                auto [ec, bytes_transferred] = co_await perform_timed_io(callbacks, stream, timeout_duration, operation_name, io_op_lambda);

                if (ec) {
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::invalid_argument)
                        mapped_error = boltprotocol::BoltError::INVALID_ARGUMENT;
                    else if (ec == boost::asio::error::not_connected)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::fault)
                        mapped_error = boltprotocol::BoltError::UNKNOWN_ERROR;

                    if (callbacks) {
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{mapped_error, 0};
                    }
                }
                co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"                     // For Value, Version
#include "neo4j_bolt_transport/config/transport_config.h"  // For AuthTokenVariant, EncryptionStrategy

namespace neo4j_bolt_transport {
    namespace internal {

        struct BoltConnectionConfig {
            std::string target_host;
            uint16_t target_port;

            config::AuthTokenVariant auth_token;
            std::string user_agent_for_hello;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info_for_hello;

            bool encryption_enabled = false;
            config::TransportConfig::EncryptionStrategy resolved_encryption_strategy = config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            uint32_t tcp_connect_timeout_ms = 5000;
            uint32_t socket_read_timeout_ms = 0;   // Added
            uint32_t socket_write_timeout_ms = 0;  // Added
            bool socket_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;
            uint32_t bolt_handshake_timeout_ms = 10000;
            uint32_t hello_timeout_ms = 15000;   // Added
            uint32_t goodbye_timeout_ms = 5000;  // Added

            std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_context;
            std::optional<std::vector<boltprotocol::versions::Version>> preferred_bolt_versions;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H

#include <atomic>
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl/context.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "bolt_connection_config.h"
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "neo4j_bolt_transport/internal/async_types.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    class SessionHandle;

    namespace internal {

        class BoltPhysicalConnection : public std::enable_shared_from_this<BoltPhysicalConnection>, public IAsyncContextCallbacks {
          public:
            using PooledConnection = std::unique_ptr<BoltPhysicalConnection>;
            enum class InternalState {
                FRESH,
                TCP_CONNECTING,
                ASYNC_TCP_CONNECTING,
                TCP_CONNECTED,
                SSL_CONTEXT_SETUP,
                SSL_HANDSHAKING,
                ASYNC_SSL_HANDSHAKING,
                SSL_HANDSHAKEN,
                BOLT_HANDSHAKING,
                ASYNC_BOLT_HANDSHAKING,
                BOLT_HANDSHAKEN,
                ASYNC_BOLT_HANDSHAKEN,
                HELLO_AUTH_SENT,
                ASYNC_HELLO_AUTH_SENT,
                READY,
                ASYNC_READY,
                STREAMING,
                ASYNC_STREAMING,
                AWAITING_SUMMARY,
                ASYNC_AWAITING_SUMMARY,
                FAILED_SERVER_REPORTED,
                DEFUNCT
            };

            BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr);
            ~BoltPhysicalConnection() override;

            BoltPhysicalConnection(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection& operator=(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept;
            BoltPhysicalConnection& operator=(BoltPhysicalConnection&& other) noexcept;

            // --- Synchronous API ---
            boltprotocol::BoltError establish();
            boltprotocol::BoltError terminate(bool send_goodbye = true);
            boltprotocol::BoltError ping(std::chrono::milliseconds timeout);
            bool is_ready_for_queries() const;
            bool is_defunct() const;
            boltprotocol::BoltError get_last_error_code() const {
                return last_error_code_;
            }
            std::string get_last_error_message() const {
                return last_error_message_;
            }
            uint64_t get_id() const {
                return id_;
            }
            const boltprotocol::versions::Version& get_bolt_version() const {
                return negotiated_bolt_version_;
            }
            bool is_utc_patch_active() const {
                return utc_patch_active_;
            }
            const std::string& get_server_agent() const {
                return server_agent_string_;
            }
            const std::string& get_connection_id() const {
                return server_assigned_conn_id_;
            }
            const BoltConnectionConfig& get_config() const {
                return conn_config_;
            }
            boost::asio::io_context& get_io_context() {
                return io_context_ref_;
            }
            std::chrono::steady_clock::time_point get_creation_timestamp() const {
                return creation_timestamp_;
            }
            std::chrono::steady_clock::time_point get_last_used_timestamp() const {
                return last_used_timestamp_.load(std::memory_order_relaxed);
            }
            void mark_as_used();
            bool is_encrypted() const;

            using MessageHandler = std::function<boltprotocol::BoltError(boltprotocol::MessageTag tag, const std::vector<uint8_t>& payload, BoltPhysicalConnection& connection)>;
            boltprotocol::BoltError send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError perform_reset();
            boltprotocol::BoltError perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success);
            boltprotocol::BoltError perform_logoff(boltprotocol::SuccessMessageParams& out_success);

            // --- Asynchronous API ---
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> establish_async();
            boost::asio::awaitable<boltprotocol::BoltError> terminate_async(bool send_goodbye = true);
            boost::asio::awaitable<boltprotocol::BoltError> ping_async(std::chrono::milliseconds timeout);

            // --- IAsyncContextCallbacks implementation ---
            std::shared_ptr<spdlog::logger> get_logger() const override {
                return logger_;
            }
            uint64_t get_id_for_logging() const override {
                return id_;
            }
            void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) override;
            boltprotocol::BoltError get_last_error_code_from_async() const override {
                return last_error_code_;
            }

            void _mark_as_defunct_internal(boltprotocol::BoltError reason, const std::string& message = "");

          private:
            friend class neo4j_bolt_transport::SessionHandle;

            boltprotocol::BoltError _stage_tcp_connect();
            boltprotocol::BoltError _stage_ssl_context_setup();
            boltprotocol::BoltError _stage_ssl_handshake();
            boltprotocol::BoltError _stage_bolt_handshake();
            boltprotocol::BoltError _stage_send_hello_and_initial_auth();

            boost::asio::awaitable<boltprotocol::BoltError> _stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout);
            // ---  ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket>& stream,  //  stream<tcp::socket>&
                                                                                       std::chrono::milliseconds timeout);
            // ---  ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_send_hello_and_initial_auth_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);

            void _prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const;
            boltprotocol::BoltError _execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> _execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                        std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> perform_logon_async(boltprotocol::LogonMessageParams logon_params,
                                                                                                                               std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> perform_logoff_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);

            boltprotocol::BoltError _write_to_active_sync_stream(const uint8_t* data, size_t size);
            boltprotocol::BoltError _read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read);

            boost::asio::awaitable<boltprotocol::BoltError> _write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read);

            boltprotocol::BoltError _send_chunked_payload_sync(const std::vector<uint8_t>& payload);
            boltprotocol::BoltError _receive_chunked_payload_sync(std::vector<uint8_t>& out_payload);

            boost::asio::awaitable<boltprotocol::BoltError> _send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, std::vector<uint8_t> payload);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref);

            boltprotocol::BoltError _peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const;

            void _reset_resources_and_state(bool called_from_destructor = false);
            void _update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta);
            void _update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta);
            boltprotocol::BoltError _classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta);
            std::string _get_current_state_as_string() const;

            uint64_t id_;
            BoltConnectionConfig conn_config_;
            boost::asio::io_context& io_context_ref_;
            std::shared_ptr<spdlog::logger> logger_;

            std::unique_ptr<boost::asio::ip::tcp::socket> owned_socket_for_sync_plain_;
            std::unique_ptr<boost::asio::ip::tcp::iostream> plain_iostream_wrapper_;
            std::unique_ptr<boost::asio::ssl::context> ssl_context_sync_;
            std::unique_ptr<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ssl_stream_sync_;

            std::atomic<InternalState> current_state_;
            boltprotocol::versions::Version negotiated_bolt_version_;
            std::string server_agent_string_;
            std::string server_assigned_conn_id_;
            bool utc_patch_active_ = false;

            std::chrono::steady_clock::time_point creation_timestamp_;
            std::atomic<std::chrono::steady_clock::time_point> last_used_timestamp_;

            boltprotocol::BoltError last_error_code_ = boltprotocol::BoltError::SUCCESS;
            std::string last_error_message_;

            static std::atomic<uint64_t> next_connection_id_counter_;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H

#include <cstdint>  // For uint64_t
#include <memory>
#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "spdlog/fwd.h"                         // Forward declaration for spdlog::logger

namespace neo4j_bolt_transport {
    namespace internal {

        class IAsyncContextCallbacks {
          public:
            virtual ~IAsyncContextCallbacks() = default;

            virtual std::shared_ptr<spdlog::logger> get_logger() const = 0;
            virtual uint64_t get_id_for_logging() const = 0;
            virtual void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) = 0;
            virtual boltprotocol::BoltError get_last_error_code_from_async() const = 0;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H

#include <atomic>
#include <boost/asio/executor_work_guard.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/asio/steady_timer.hpp>  // For eviction_timer_
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include "config/transport_config.h"
#include "internal/bolt_physical_connection.h"
#include "routing/routing_table.h"
#include "routing/server_address.h"
#include "session_handle.h"
#include "uri/parsed_uri.h"

//  Boost.Asio include
// #include <boost/asio/co_spawn.hpp>
// #include <boost/asio/detached.hpp>
// #include <boost/asio/awaitable.hpp>

namespace neo4j_bolt_transport {

    namespace config {
        struct SessionParameters;
    }
    class AsyncSessionHandle;  // 

    class Neo4jBoltTransport {
      public:
        explicit Neo4jBoltTransport(config::TransportConfig config);
        ~Neo4jBoltTransport();

        Neo4jBoltTransport(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport& operator=(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport(Neo4jBoltTransport&&) = delete;
        Neo4jBoltTransport& operator=(Neo4jBoltTransport&&) = delete;

        // --- Synchronous API ---
        boltprotocol::BoltError verify_connectivity();
        std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> acquire_session(const config::SessionParameters& params);
        void close();

        const config::TransportConfig& get_config() const {
            return config_;
        }
        boost::asio::io_context& get_io_context() {
            return io_context_;
        }

        void release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy = true);

        // --- Asynchronous API () ---
        //  boost::asio::awaitable<...>
        // AsyncSessionHandle
        //  AsyncSessionHandle 
        // boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
        // acquire_async_session(const config::SessionParameters& params);

      private:
        // ---  ---
        std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> _acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        // boost::asio::awaitable<std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection>>
        // _acquire_async_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        std::pair<boltprotocol::BoltError, routing::ServerAddress> _get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint);
        std::shared_ptr<routing::RoutingTable> _get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user);
        boltprotocol::BoltError _fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update, const std::vector<routing::ServerAddress>& initial_routers_for_context, const std::string& database_name_hint, const std::optional<std::string>& impersonated_user_hint);
        void _handle_routing_failure(const routing::ServerAddress& failed_address, const std::string& database_context_key);

        void _evict_stale_connections_task();
        internal::BoltConnectionConfig _create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const;

        // 
        static std::string _make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user);

        config::TransportConfig config_;
        uri::ParsedUri parsed_initial_uri_;

        boost::asio::io_context io_context_;
        std::unique_ptr<std::thread> io_thread_;
        bool own_io_thread_ = false;
        std::unique_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> work_guard_;

        std::deque<internal::BoltPhysicalConnection::PooledConnection> idle_connections_;
        std::size_t total_connections_currently_pooled_ = 0;
        std::size_t total_connections_ever_created_ = 0;
        std::mutex pool_mutex_;
        std::condition_variable pool_condition_;
        std::atomic<bool> closing_{false};

        std::string finalized_user_agent_;
        boltprotocol::HelloMessageParams::BoltAgentInfo finalized_bolt_agent_info_;

        std::map<std::string, std::shared_ptr<routing::RoutingTable>> routing_tables_;
        std::mutex routing_table_mutex_;

        std::unique_ptr<boost::asio::steady_timer> eviction_timer_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H

#include <functional>  // For std::function
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For Value, SuccessMessageParams, FailureMessageParams
// BoltRecord and BoltResultStream are needed for the 'run' method's return type
#include "bolt_record.h"
#include "result_stream.h"

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // TransactionContext is passed to user-provided transaction functions (lambdas).
    // It provides methods to execute queries within the scope of the managed transaction.
    class TransactionContext {
      public:
        // Constructor taking a non-owning pointer to the SessionHandle that manages this transaction.
        // The SessionHandle must outlive the TransactionContext.
        explicit TransactionContext(SessionHandle& session);
        virtual ~TransactionContext() = default;  // Good practice for base classes if inherited

        // Executes a query within the current transaction.
        // Returns a pair: { {Error, ErrorMsg}, ResultStreamUniquePtr }.
        // The ResultStream unique_ptr is null if an error occurred before streaming could start.
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters = {}  // Default empty parameters
        );

        // Executes a query and consumes its result, returning only the summary.
        // Useful for DML statements (CREATE, MERGE, DELETE, SET).
        // Returns {Error, ErrorMsg}. out_summary and out_failure are populated.
        std::pair<boltprotocol::BoltError, std::string> run_consume(const std::string& cypher,
                                                                    const std::map<std::string, boltprotocol::Value>& parameters,  // No default for params here
                                                                    boltprotocol::SuccessMessageParams& out_summary,
                                                                    boltprotocol::FailureMessageParams& out_failure);

        // Note: A full-fledged TransactionContext in official drivers often mirrors
        // many methods of the Session object (like run, commit, rollback, close).
        // However, for the managed transaction function pattern, the Session handles
        // commit/rollback/close based on the lambda's outcome.
        // If we want the lambda to have more control, these methods could be added here,
        // and they would signal the Session to perform the action.
        // For now, we keep it to query execution.

        // boltprotocol::BoltError commit(); // Example: Signals the managing Session to commit
        // boltprotocol::BoltError rollback(); // Example: Signals the managing Session to rollback
        // bool is_open() const; // Example: Checks if the underlying transaction is still active

      private:
        SessionHandle& owner_session_;  // Non-owning reference to the session managing the transaction
    };

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return a TransactionWorkResult indicating success or application-level failure.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H

#include <functional>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

namespace neo4j_bolt_transport {

    // Forward declare TransactionContext (defined in neo4j_transaction_context.h)
    class TransactionContext;

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return SUCCESS if work is done, or an error code + message if app logic fails.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

    // REMOVED conflicting TransactionContext class definition from here.
    // The primary definition is in neo4j_transaction_context.h

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H
#define NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H

#include <deque>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "bolt_record.h"
#include "boltprotocol/message_defs.h"
#include "result_summary.h"  // <--- NEW

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    class BoltResultStream {
      public:
        // Constructor now takes initial raw summary and connection info for typed summary
        BoltResultStream(SessionHandle* session,
                         std::optional<int64_t> query_id_for_streaming,
                         boltprotocol::SuccessMessageParams run_summary_params,  // Raw params from RUN
                         std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                         std::vector<boltprotocol::RecordMessageParams> initial_records,
                         bool server_might_have_more,
                         const boltprotocol::versions::Version& bolt_version,          // For ResultSummary
                         bool utc_patch_active,                                        // For ResultSummary
                         const std::string& server_address_for_summary,                // For ResultSummary
                         const std::optional<std::string>& database_name_for_summary,  // For ResultSummary
                         boltprotocol::BoltError initial_error = boltprotocol::BoltError::SUCCESS,
                         const std::string& initial_error_message = "",
                         const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details = std::nullopt);

        ~BoltResultStream();

        BoltResultStream(const BoltResultStream&) = delete;
        BoltResultStream& operator=(const BoltResultStream&) = delete;
        BoltResultStream(BoltResultStream&& other) noexcept;
        BoltResultStream& operator=(BoltResultStream&& other) noexcept;

        std::pair<boltprotocol::BoltError, std::string> has_next(bool& out_has_next);
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> next();
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> single();  // <--- NEW

        std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> list_all();
        std::tuple<boltprotocol::BoltError, std::string, ResultSummary> consume();  // <--- MODIFIED to return typed ResultSummary

        const ResultSummary& get_run_summary() const {
            return run_summary_typed_;
        }  // <--- MODIFIED
        const ResultSummary& get_final_summary() const {
            return final_summary_typed_;
        }  // <--- MODIFIED (after full consumption/discard)

        bool is_fully_consumed_or_failed() const;
        bool has_failed() const;
        boltprotocol::BoltError get_failure_reason() const;
        const std::string& get_failure_message() const;
        const boltprotocol::FailureMessageParams& get_failure_details() const;  // For raw server failure
        const std::vector<std::string>& field_names() const;

      private:
        friend class SessionHandle;
        friend class TransactionContext;

        std::pair<boltprotocol::BoltError, std::string> _fetch_more_records(int64_t n);
        std::pair<boltprotocol::BoltError, std::string> _discard_all_remaining_records();
        void _set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details = std::nullopt);
        void _update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary);

        SessionHandle* owner_session_;
        std::optional<int64_t> query_id_;

        std::deque<boltprotocol::RecordMessageParams> raw_record_buffer_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_cache_;

        ResultSummary run_summary_typed_;    // Summary from RUN message (available immediately)
        ResultSummary final_summary_typed_;  // Summary from final PULL/DISCARD (available after consumption)
                                             // This needs careful initialization.

        boltprotocol::FailureMessageParams failure_details_raw_;  // Store raw failure

        bool server_has_more_records_ = false;
        bool initial_server_has_more_records_ = false;
        bool stream_fully_consumed_or_discarded_ = false;
        bool stream_failed_ = false;
        boltprotocol::BoltError failure_reason_ = boltprotocol::BoltError::SUCCESS;
        std::string failure_message_;
        bool is_first_pull_attempt_ = true;

        // For ResultSummary creation
        boltprotocol::versions::Version bolt_version_cache_;
        bool utc_patch_active_cache_;
        std::string server_address_cache_;
        std::optional<std::string> database_name_cache_;
    };

    // Inline simple getters
    inline bool BoltResultStream::is_fully_consumed_or_failed() const {
        return stream_fully_consumed_or_discarded_ || stream_failed_;
    }
    inline bool BoltResultStream::has_failed() const {
        return stream_failed_;
    }
    inline boltprotocol::BoltError BoltResultStream::get_failure_reason() const {
        return failure_reason_;
    }
    inline const std::string& BoltResultStream::get_failure_message() const {
        return failure_message_;
    }
    inline const boltprotocol::FailureMessageParams& BoltResultStream::get_failure_details() const {
        return failure_details_raw_;
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H
#define NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For SuccessMessageParams, Value, Version

namespace neo4j_bolt_transport {

    // Forward declarations for Plan, ProfiledPlan, Notification if they become complex classes
    // struct Plan;
    // struct ProfiledPlan;
    // struct Notification;

    struct QueryCounters {
        int64_t nodes_created = 0;
        int64_t nodes_deleted = 0;
        int64_t relationships_created = 0;
        int64_t relationships_deleted = 0;
        int64_t properties_set = 0;
        int64_t labels_added = 0;
        int64_t labels_removed = 0;
        int64_t indexes_added = 0;
        int64_t indexes_removed = 0;
        int64_t constraints_added = 0;
        int64_t constraints_removed = 0;
        bool contains_updates = false;
        bool contains_system_updates = false;
        int64_t system_updates = 0;

        QueryCounters() = default;
    };

    enum class QueryType { UNKNOWN, READ_ONLY, READ_WRITE, WRITE_ONLY, SCHEMA_WRITE };

    // Simplified notification structure
    struct ServerNotification {
        std::string code;
        std::string title;
        std::string description;
        std::optional<std::map<std::string, boltprotocol::Value>> position;  // e.g., {"offset": <int>, "line": <int>, "column": <int>}
        std::string severity;                                                // e.g., "WARNING", "INFORMATION"
        std::string category;                                                // e.g., "HINT", "UNRECOGNIZED" (Bolt 5.2+)

        ServerNotification() = default;
    };

    class ResultSummary {
      public:
        // Constructor takes the raw success message params and connection info
        ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params,
                      const boltprotocol::versions::Version& bolt_version,
                      bool utc_patch_active,
                      const std::string& server_address,                            // Address of the server that executed the query
                      const std::optional<std::string>& database_name_from_session  // DB name from session config
        );

        const boltprotocol::SuccessMessageParams& raw_params() const {
            return raw_params_;
        }

        QueryType query_type() const {
            return query_type_;
        }
        const QueryCounters& counters() const {
            return counters_;
        }

        const std::string& server_address() const {
            return server_address_;
        }
        const std::string& database_name() const {
            return database_name_;
        }  // Effective DB name for the query

        std::optional<std::chrono::milliseconds> result_available_after() const {
            return result_available_after_ms_;
        }
        std::optional<std::chrono::milliseconds> result_consumed_after() const {
            return result_consumed_after_ms_;
        }

        const std::vector<ServerNotification>& notifications() const {
            return notifications_;
        }

        // std::optional<Plan> plan() const; // TODO if Plan parsing is added
        // std::optional<ProfiledPlan> profiled_plan() const; // TODO if ProfiledPlan parsing is added

      private:
        void parse_metadata(const boltprotocol::versions::Version& bolt_version, bool utc_patch_active);
        void parse_query_type(const boltprotocol::Value& type_val);
        void parse_counters(const boltprotocol::Value& counters_val);
        void parse_notifications(const boltprotocol::Value& notifications_val, const boltprotocol::versions::Version& bolt_version);

        boltprotocol::SuccessMessageParams raw_params_;
        QueryType query_type_ = QueryType::UNKNOWN;
        QueryCounters counters_;
        std::vector<ServerNotification> notifications_;

        std::string server_address_;  // Server that executed the query
        std::string database_name_;   // Effective database for the query

        std::optional<std::chrono::milliseconds> result_available_after_ms_;
        std::optional<std::chrono::milliseconds> result_consumed_after_ms_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H

#include <atomic>
#include <chrono>
#include <mutex>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError (used in status)
#include "server_address.h"

namespace neo4j_bolt_transport {
    namespace routing {

        enum class ServerRole { ROUTER, READER, WRITER };

        class RoutingTable {
          public:
            RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds);

            // Tries to get a server for the given role.
            // Returns nullopt if no suitable server or table is stale.
            std::optional<ServerAddress> get_server(ServerRole role);

            // Updates the table with new data from a ROUTE message response.
            // Returns BoltError::SUCCESS or an error code if parsing fails.
            boltprotocol::BoltError update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds);

            bool is_stale() const;
            void mark_as_stale();  // Forcefully mark as stale, e.g., after a connection error

            const std::string& get_database_context_key() const {
                return database_context_key_;
            }
            const std::vector<ServerAddress>& get_routers() const;

            // Remove a server from all lists (e.g., if it becomes unreachable)
            void forget_server(const ServerAddress& address);

          private:
            std::string database_context_key_;  // e.g., "mydatabase@user" or "system"
            std::vector<ServerAddress> routers_;
            std::vector<ServerAddress> readers_;
            std::vector<ServerAddress> writers_;

            std::chrono::steady_clock::time_point last_updated_time_;
            std::chrono::seconds ttl_;

            std::atomic<std::size_t> next_reader_index_ = 0;
            std::atomic<std::size_t> next_writer_index_ = 0;
            std::atomic<std::size_t> next_router_index_ = 0;  // For trying different routers

            mutable std::mutex mutex_;  // Protects access to server lists and indices
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H

#include <cstdint>
#include <functional>  // For std::hash
#include <string>

namespace neo4j_bolt_transport {
    namespace routing {

        struct ServerAddress {
            std::string host;
            std::uint16_t port;

            ServerAddress(std::string h = "", std::uint16_t p = 0) : host(std::move(h)), port(p) {
            }

            bool operator==(const ServerAddress& other) const {
                return host == other.host && port == other.port;
            }

            bool operator<(const ServerAddress& other) const {
                if (host != other.host) {
                    return host < other.host;
                }
                return port < other.port;
            }

            std::string to_string() const {
                return host + ":" + std::to_string(port);
            }
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

namespace std {
    template <>
    struct hash<neo4j_bolt_transport::routing::ServerAddress> {
        size_t operator()(const neo4j_bolt_transport::routing::ServerAddress& addr) const noexcept {
            size_t h1 = std::hash<std::string>{}(addr.host);
            size_t h2 = std::hash<std::uint16_t>{}(addr.port);
            return h1 ^ (h2 << 1);  // Basic combination
        }
    };
}  // namespace std

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H#ifndef NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H
#define NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H

#include <chrono>
#include <deque>
#include <map>  // For parameters
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "config/session_parameters.h"
#include "internal/bolt_physical_connection.h"
#include "neo4j_transaction_work.h"
#include "result_stream.h"  // Includes ResultSummary transitively

namespace neo4j_bolt_transport {

    class Neo4jBoltTransport;  // Forward declaration

    struct TransactionConfigOverrides {  // New struct for clarity
        std::optional<std::map<std::string, boltprotocol::Value>> metadata;
        std::optional<std::chrono::milliseconds> timeout;
    };

    class SessionHandle {
      public:
        SessionHandle(Neo4jBoltTransport* transport_manager, internal::BoltPhysicalConnection::PooledConnection connection, config::SessionParameters params);
        ~SessionHandle();

        SessionHandle(const SessionHandle&) = delete;
        SessionHandle& operator=(const SessionHandle&) = delete;
        SessionHandle(SessionHandle&& other) noexcept;
        SessionHandle& operator=(SessionHandle&& other) noexcept;

        // --- Explicit Transaction Management ---
        std::pair<boltprotocol::BoltError, std::string> begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt,
                                                                          const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt  // Already present
        );
        std::pair<boltprotocol::BoltError, std::string> commit_transaction();
        std::pair<boltprotocol::BoltError, std::string> rollback_transaction();
        bool is_in_transaction() const {
            return in_explicit_transaction_;
        }

        // --- Managed Transaction Functions ---
        TransactionWorkResult execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);
        TransactionWorkResult execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);

        // --- Query Execution (Auto-commit transactions) ---
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run_query(const std::string& cypher,
                                                                                                                const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                                                const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> run_query_and_consume(const std::string& cypher,
                                                                                                        const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                        const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<boltprotocol::BoltError, std::string> run_query_without_result(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                 const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        const std::vector<std::string>& get_last_bookmarks() const;
        void update_bookmarks(const std::vector<std::string>& new_bookmarks);

        void close();
        bool is_closed() const {
            return is_closed_;
        }
        bool is_connection_valid() const {
            return connection_is_valid_;
        }

        friend class BoltResultStream;
        friend class TransactionContext;

      private:
        std::pair<boltprotocol::BoltError, std::string> _prepare_auto_commit_run(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                 const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,  // Kept for RunMessageParams
                                                                                 const std::optional<std::chrono::milliseconds>& tx_timeout,                    // Kept for RunMessageParams
                                                                                 boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                 boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw);
        std::pair<boltprotocol::BoltError, std::string> _stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw);

        void _release_connection_to_pool(bool mark_healthy = true);
        void _invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message);
        internal::BoltPhysicalConnection* _get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context);

        TransactionWorkResult _execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout);

        Neo4jBoltTransport* transport_manager_;
        internal::BoltPhysicalConnection::PooledConnection connection_;
        config::SessionParameters session_params_;

        bool in_explicit_transaction_ = false;
        std::optional<int64_t> current_transaction_query_id_;

        std::vector<std::string> current_bookmarks_;
        bool is_closed_ = false;
        bool connection_is_valid_ = true;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H#ifndef NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H
#define NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace neo4j_bolt_transport {
    namespace uri {

        // Holds the deconstructed parts of a Neo4j connection URI.
        struct ParsedUri {
            std::string input_uri;
            std::string scheme;

            // For non-routing schemes, hosts will contain one entry.
            // For routing schemes (neo4j://, neo4j+s://), hosts can contain multiple seed router addresses.
            std::vector<std::pair<std::string, uint16_t>> hosts_with_ports;

            // Userinfo extracted from URI (if present)
            std::optional<std::string> username_from_uri;
            std::optional<std::string> password_from_uri;

            // Query parameters from the URI
            std::map<std::string, std::string> query_parameters;

            // Interpretation of the scheme
            bool is_valid = false;
            bool is_routing_scheme = false;
            bool tls_enabled_by_scheme = false;
            enum class SchemeTrustStrategy {
                NONE,            // e.g. bolt, neo4j (depends on server default or further config)
                SYSTEM_CAS,      // e.g. bolt+s, neo4j+s
                TRUST_ALL_CERTS  // e.g. bolt+ssc, neo4j+ssc (discouraged)
            };
            SchemeTrustStrategy trust_strategy_hint = SchemeTrustStrategy::NONE;

            // Standard default ports
            static constexpr uint16_t DEFAULT_BOLT_PORT = 7687;
            // Neo4j typically uses the same port for TLS-enabled Bolt (server-side config)
            static constexpr uint16_t DEFAULT_BOLTS_PORT = 7687;
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H#ifndef NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H
#define NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H

#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "parsed_uri.h"

namespace neo4j_bolt_transport {
    namespace uri {

        class UriParser {
          public:
            UriParser() = delete;  // Static methods only

            // Parses the given URI string and populates the ParsedUri struct.
            // Returns BoltError::SUCCESS on success, or an error code if parsing fails.
            static boltprotocol::BoltError parse(const std::string& uri_string, ParsedUri& out_parsed_uri);
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H#include "neo4j_bolt_transport/bolt_record.h"

namespace neo4j_bolt_transport {

    BoltRecord::BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> names_ptr) : fields_(std::move(fields_data)), field_names_ptr_(std::move(names_ptr)) {
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(size_t index) const {
        if (index >= fields_.size()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Or a more specific "IndexOutOfBounds"
        }
        // Return a copy of the Value, or handle lifetime if Value contains non-copyable shared_ptrs carefully.
        // std::variant copy semantics should handle this correctly.
        return {boltprotocol::BoltError::SUCCESS, fields_[index]};
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // No field names available
        }
        // Could optimize with a cached map if records are accessed by name frequently
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                if (i < fields_.size()) {  // Should always be true if names match fields
                    return {boltprotocol::BoltError::SUCCESS, fields_[i]};
                } else {
                    // This indicates an internal inconsistency (more names than fields)
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
            }
        }
        return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Field name not found
    }

    const std::vector<std::string>& BoltRecord::field_names() const {
        static const std::vector<std::string> empty_field_names;  // For returning if no names ptr
        if (field_names_ptr_) {
            return *field_names_ptr_;
        }
        return empty_field_names;
    }

    // Template method implementations are in the header due to template instantiation.

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/auth_token.h"

namespace neo4j_bolt_transport {
    namespace config {

        AuthTokenVariant AuthTokens::none() {
            return NoAuth{};
        }

        AuthTokenVariant AuthTokens::basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm) {
            return BasicAuth{username, password, realm};
        }

        AuthTokenVariant AuthTokens::kerberos(const std::string& base64_ticket) {
            return KerberosAuth{base64_ticket};
        }

        AuthTokenVariant AuthTokens::bearer(const std::string& token) {
            return BearerAuth{token};
        }

        AuthTokenVariant AuthTokens::custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters) {
            return CustomAuth{principal, credentials, realm, scheme, parameters};
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/transport_config.h"

#include <iostream>

#include "boltprotocol/bolt_errors_versions.h"  // For default versions
#include "neo4j_bolt_transport/uri/parsed_uri.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {
    namespace config {

        TransportConfig::TransportConfig(const std::string& a_uri_string) : uri_string(a_uri_string.empty() ? "bolt://localhost:7687" : a_uri_string) {
            uri::ParsedUri parsed_uri_info;
            if (uri::UriParser::parse(uri_string, parsed_uri_info) == boltprotocol::BoltError::SUCCESS) {
                apply_parsed_uri_settings(parsed_uri_info);
            } else {
                if (logger) {
                    logger->error("Failed to parse URI '{}' during TransportConfig construction. Using defaults where possible.", uri_string);
                } else {
                    std::cerr << "Error: Failed to parse URI '" << uri_string << "' during TransportConfig construction." << std::endl;
                }
            }
            if (preferred_bolt_versions.empty()) {
                preferred_bolt_versions = boltprotocol::versions::get_default_proposed_versions();
            }
            prepare_agent_strings();          // Call prepare_agent_strings before get_or_create_logger
            logger = get_or_create_logger();  // Ensure logger is initialized
        }

        TransportConfig::TransportConfig() : TransportConfig("bolt://localhost:7687") {
        }

        boltprotocol::BoltError TransportConfig::apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri) {
            if (!parsed_uri.is_valid) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            if (encryption_strategy == EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME) {
                if (parsed_uri.tls_enabled_by_scheme) {
                    if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::SYSTEM_CAS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    } else if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS;
                    } else {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    }
                } else {
                    encryption_strategy = EncryptionStrategy::FORCE_PLAINTEXT;
                }
            }

            if (!parsed_uri.is_routing_scheme) {
                client_side_routing_enabled = false;
            }

            if (std::holds_alternative<NoAuth>(auth_token)) {
                if (parsed_uri.username_from_uri.has_value()) {
                    auth_token = AuthTokens::basic(parsed_uri.username_from_uri.value(), parsed_uri.password_from_uri.value_or(""), std::nullopt);
                }
            }

            if (client_side_routing_enabled && initial_router_addresses_override.empty() && !parsed_uri.hosts_with_ports.empty()) {
                std::string initial_context_key = parsed_uri.scheme + "://";
                if (!parsed_uri.hosts_with_ports.empty()) {
                    initial_context_key += parsed_uri.hosts_with_ports.front().first;  // Simplified context key
                }

                std::vector<routing::ServerAddress> initial_routers;
                for (const auto& host_port_pair : parsed_uri.hosts_with_ports) {
                    initial_routers.emplace_back(host_port_pair.first, host_port_pair.second);
                }
                initial_router_addresses_override[initial_context_key] = initial_routers;
            }

            auto it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout");  // Renamed in spec sometimes
            if (it_conn_timeout == parsed_uri.query_parameters.end()) {                     // try alternative name
                it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout_ms");
            }
            if (it_conn_timeout != parsed_uri.query_parameters.end()) {
                try {
                    tcp_connect_timeout_ms = static_cast<uint32_t>(std::stoul(it_conn_timeout->second));
                } catch (const std::exception&) { /* ignore invalid param */
                }
            }

            auto it_max_retry_time = parsed_uri.query_parameters.find("max_transaction_retry_time");
            if (it_max_retry_time != parsed_uri.query_parameters.end()) {
                try {
                    // Assuming time is in ms if specified like "15s" or "15000ms" this needs parsing logic
                    // For simplicity, assume it's just ms for now if it's a number
                    max_transaction_retry_time_ms = static_cast<uint32_t>(std::stoul(it_max_retry_time->second));
                } catch (const std::exception&) { /* ignore */
                }
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        void TransportConfig::prepare_agent_strings(const std::string& default_transport_name_version) {
            if (bolt_agent_info.product.empty()) {
                bolt_agent_info.product = default_transport_name_version;
            }
        }

        std::shared_ptr<spdlog::logger> TransportConfig::get_or_create_logger(const std::string& logger_name) {
            if (logger) {
                logger->set_level(log_level);
                return logger;
            }
            auto default_logger = spdlog::get(logger_name);
            if (!default_logger) {
                try {
                    default_logger = spdlog::stdout_color_mt(logger_name);                            // Or any other default sink
                    default_logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%n] [tid %t] %v");  // Added thread id
                    default_logger->set_level(log_level);
                } catch (const spdlog::spdlog_ex& ex) {
                    std::cerr << "Logger (" << logger_name << ") initialization failed: " << ex.what() << std::endl;
                    return nullptr;  // Or throw
                }
            } else {
                default_logger->set_level(log_level);
            }
            return default_logger;
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,
                                                                                                            std::vector<uint8_t> payload) {  // payload 

            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async send chunked payload on defunct connection.", get_id_for_logging());
                co_return last_error_code_;
            }

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            std::vector<uint8_t> chunk_header_bytes(boltprotocol::CHUNK_HEADER_SIZE);

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);
                std::memcpy(chunk_header_bytes.data(), &chunk_size_be, boltprotocol::CHUNK_HEADER_SIZE);

                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                std::vector<uint8_t> current_chunk_data(data_ptr, data_ptr + chunk_size);
                err = co_await _write_to_active_async_stream(stream_variant_ref, current_chunk_data);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;  // Correctly initialized
                std::memcpy(chunk_header_bytes.data(), &zero_chunk_be, boltprotocol::CHUNK_HEADER_SIZE);
                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
            }

            // _write_to_active_async_stream -> async_io_with_timeout -> callbacks->mark_as_defunct_from_async
            //  mark_as_defunct
            co_return err;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref) {
            std::vector<uint8_t> out_payload_vec;
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async receive chunked payload on defunct connection.", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{last_error_code_, {}};
            }

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;
            std::pair<boltprotocol::BoltError, std::vector<uint8_t>> read_result;

            while (true) {
                read_result = co_await _read_from_active_async_stream(stream_variant_ref, boltprotocol::CHUNK_HEADER_SIZE);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& header_bytes = read_result.second;
                if (header_bytes.size() != boltprotocol::CHUNK_HEADER_SIZE) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    mark_as_defunct_from_async(err, "Async receive chunk header: incorrect size read.");  // 
                    break;
                }
                uint16_t chunk_size_be;
                std::memcpy(&chunk_size_be, header_bytes.data(), boltprotocol::CHUNK_HEADER_SIZE);
                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Async received chunk larger than max: " + std::to_string(chunk_payload_size);
                    mark_as_defunct_from_async(err, msg);  // 
                    if (logger_) logger_->error("[ConnAsyncChunking {}] {}", get_id_for_logging(), msg);
                    break;
                }

                read_result = co_await _read_from_active_async_stream(stream_variant_ref, chunk_payload_size);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& chunk_data = read_result.second;
                if (chunk_data.size() != chunk_payload_size) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    mark_as_defunct_from_async(err, "Async receive chunk payload: incorrect size read.");  // 
                    break;
                }
                try {
                    out_payload_vec.insert(out_payload_vec.end(), chunk_data.begin(), chunk_data.end());
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory appending async chunk to payload buffer.";
                    mark_as_defunct_from_async(err, msg);  // 
                    if (logger_) logger_->critical("[ConnAsyncChunking {}] {}", get_id_for_logging(), msg);
                    break;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{err, {}};
            } else if (total_bytes_read_for_message == 0 && out_payload_vec.empty()) {
                if (logger_) logger_->trace("[ConnAsyncChunking {}] Async received NOOP message.", get_id_for_logging());
            }
            co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, std::move(out_payload_vec)};
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/post.hpp>
// #include <boost/asio/read.hpp> // 
// #include <boost/asio/write.hpp>// 
#include <cstring>
#include <iostream>
#include <optional>
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_utils_decl.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async write on defunct connection.", get_id_for_logging());
                co_return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (data.empty()) {
                co_return boltprotocol::BoltError::SUCCESS;
            }

            std::chrono::milliseconds timeout(conn_config_.socket_write_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Write {} bytes. Timeout: {}ms", get_id_for_logging(), data.size(), timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async write: stream_ptr in variant is null.", get_id_for_logging());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    //  async_write_with_timeout
                    co_return co_await async_utils::async_write_with_timeout(this, *stream_ptr, boost::asio::buffer(data), timeout, "Async Write");
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return get_last_error_code_from_async();
            }
            if (result.second != data.size()) {
                std::string msg = "Partial async write. Expected " + std::to_string(data.size()) + ", wrote " + std::to_string(result.second);
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", get_id_for_logging(), msg);
                co_return get_last_error_code_from_async();
            }
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async read on defunct connection.", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            if (size_to_read == 0) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, {}};
            }

            std::vector<uint8_t> buffer_vec(size_to_read);
            std::chrono::milliseconds timeout(conn_config_.socket_read_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Read {} bytes. Timeout: {}ms", get_id_for_logging(), size_to_read, timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async read: stream_ptr in variant is null.", get_id_for_logging());
                        co_return std::pair<boltprotocol::BoltError, std::size_t>{boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    //  async_read_with_timeout
                    co_return co_await async_utils::async_read_with_timeout(this, *stream_ptr, boost::asio::buffer(buffer_vec), timeout, "Async Read");
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{get_last_error_code_from_async(), {}};
            }
            if (result.second < size_to_read) {
                std::string msg = "Incomplete async read. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(result.second);
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", get_id_for_logging(), msg);
                co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{get_last_error_code_from_async(), {}};
            }
            co_return std::pair<boltprotocol::BoltError, std::vector<uint8_t>>{boltprotocol::BoltError::SUCCESS, std::move(buffer_vec)};
        }
    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <iostream>
#include <variant>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _prepare_logon_params_from_config, _execute_logon_message, perform_logon, perform_logoff 
        // ... ()

        void BoltPhysicalConnection::_prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const {
            out_params.auth_tokens.clear();
            std::visit(
                [&](auto&& arg) {
                    using T = std::decay_t<decltype(arg)>;
                    if constexpr (std::is_same_v<T, config::BasicAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("basic");
                        out_params.auth_tokens["principal"] = arg.username;
                        out_params.auth_tokens["credentials"] = arg.password;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                    } else if constexpr (std::is_same_v<T, config::BearerAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("bearer");
                        out_params.auth_tokens["credentials"] = arg.token;
                    } else if constexpr (std::is_same_v<T, config::KerberosAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("kerberos");
                        out_params.auth_tokens["credentials"] = arg.base64_ticket;
                    } else if constexpr (std::is_same_v<T, config::CustomAuth>) {
                        out_params.auth_tokens["scheme"] = arg.scheme;
                        out_params.auth_tokens["principal"] = arg.principal;
                        out_params.auth_tokens["credentials"] = arg.credentials;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                        if (arg.parameters) {
                            for (const auto& pair_ : *arg.parameters) {  // Renamed pair to pair_
                                if (pair_.first != "scheme" && pair_.first != "principal" && pair_.first != "credentials" && pair_.first != "realm") {
                                    out_params.auth_tokens[pair_.first] = pair_.second;
                                }
                            }
                        }
                    } else if constexpr (std::is_same_v<T, config::NoAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("none");
                    }
                },
                conn_config_.auth_token);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure) {
            InternalState state_before_logon = current_state_.load();
            if (state_before_logon != InternalState::HELLO_AUTH_SENT && state_before_logon != InternalState::READY && state_before_logon != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "LOGON executed in invalid state: " + _get_current_state_as_string());
                if (logger_) logger_->error("[ConnAuth {}] LOGON in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }

            std::vector<uint8_t> logon_payload;
            boltprotocol::PackStreamWriter ps_writer(logon_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnAuth {}] Sending LOGON message (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            err = send_request_receive_summary(logon_payload, out_success, out_failure);

            if (err == boltprotocol::BoltError::SUCCESS) {
                if (last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                    _update_metadata_from_logon_success(out_success);
                    if (current_state_.load() != InternalState::DEFUNCT) {
                        current_state_.store(InternalState::READY);
                    }
                    if (logger_) logger_->info("[ConnAuth {}] LOGON successful.", id_);
                } else {
                    if (logger_) logger_->warn("[ConnAuth {}] LOGON server response not SUCCESS. Code: {}, Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                }
            } else {
                if (logger_) logger_->error("[ConnAuth {}] LOGON message send/receive summary failed. Error: {}", id_, static_cast<int>(err));
            }
            return last_error_code_;
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGON message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }

            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::READY && current_s != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon called in invalid state " + _get_current_state_as_string());
                if (logger_) logger_->warn("[ConnAuth {}] perform_logon in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }
            mark_as_used();

            boltprotocol::FailureMessageParams ignored_failure_details;
            return _execute_logon_message(logon_params, out_success, ignored_failure_details);
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logoff(boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGOFF message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }
            if (!is_ready_for_queries()) {
                std::string msg = "perform_logoff called when connection not ready. Current state: " + _get_current_state_as_string();
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, msg);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuth {}] Performing LOGOFF.", id_);

            std::vector<uint8_t> logoff_payload;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            boltprotocol::FailureMessageParams ignored_failure_details;
            err = send_request_receive_summary(logoff_payload, out_success, ignored_failure_details);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuth {}] LOGOFF successful.", id_);
                current_state_.store((negotiated_bolt_version_ < boltprotocol::versions::V5_1) ? InternalState::HELLO_AUTH_SENT : InternalState::BOLT_HANDSHAKEN);
            } else {
                if (logger_) logger_->warn("[ConnAuth {}] LOGOFF failed. Error: {}, Server Msg: {}", id_, static_cast<int>(err), last_error_message_);
            }
            return last_error_code_;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::_execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                                            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (logger_) logger_->debug("[ConnAuthAsync {}] Executing LOGON message async (scheme: {}).", get_id_for_logging(), params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            bool stream_valid = std::visit(
                [](auto* stream_ptr) {
                    return stream_ptr != nullptr && stream_ptr->lowest_layer().is_open();
                },
                async_stream_variant_ref);
            if (!stream_valid) {
                if (logger_) logger_->error("[ConnAuthAsync {}] _execute_logon_message_async: No valid async stream provided.", get_id_for_logging());
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_ARGUMENT, "_execute_logon_message_async: No valid async stream provided.");
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            std::vector<uint8_t> logon_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logon_payload_storage);

            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                mark_as_defunct_from_async(err, "Async LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGON serialization failed: {}", get_id_for_logging(), static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            boltprotocol::BoltError send_err = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logon_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON send failed: {}", get_id_for_logging(), static_cast<int>(send_err));
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON receive summary failed: {}", get_id_for_logging(), static_cast<int>(recv_err));
                    summary_err = last_error_code_;
                    break;
                }
                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnAuthAsync {}] Received NOOP while awaiting LOGON summary.", get_id_for_logging());
                    continue;
                }

                boltprotocol::MessageTag tag;
                boltprotocol::BoltError peek_err = _peek_message_tag(response_payload, tag);
                if (peek_err != boltprotocol::BoltError::SUCCESS) {
                    mark_as_defunct_from_async(peek_err, "Async LOGON: Failed to peek tag for summary response.");
                    summary_err = last_error_code_;
                    break;
                }

                boltprotocol::PackStreamReader reader(response_payload);
                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) {
                        mark_as_defunct_from_async(summary_err, "Async LOGON: Failed to deserialize SUCCESS summary.");
                        summary_err = last_error_code_;
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    boltprotocol::BoltError deser_fail_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (deser_fail_err != boltprotocol::BoltError::SUCCESS) {
                        mark_as_defunct_from_async(deser_fail_err, "Async LOGON: Failed to deserialize FAILURE summary.");
                        summary_err = last_error_code_;
                    } else {
                        summary_err = _classify_and_set_server_failure(failure_meta);
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    //  INVALID_MESSAGE_FORMAT  MESSAGE_IGNORED_BY_SERVER  BoltError 
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Received IGNORED instead of SUCCESS/FAILURE.");
                    summary_err = last_error_code_;
                    break;
                } else {
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Unexpected message tag " + std::to_string(static_cast<int>(tag)) + " for summary.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                _update_metadata_from_logon_success(success_meta);
                if (current_state_.load() != InternalState::DEFUNCT) {
                    current_state_.store(InternalState::ASYNC_READY);
                }
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGON successful.", get_id_for_logging());
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGON server response not SUCCESS. Final Error: {}, Server/Conn Msg: {}", get_id_for_logging(), static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logon_async(boltprotocol::LogonMessageParams logon_params,
                                                                                                                                                   std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async: LOGON not supported in Bolt < 5.1", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, {}};
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN && current_s != InternalState::ASYNC_BOLT_HANDSHAKEN && current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async in invalid state {}", get_id_for_logging(), _get_current_state_as_string());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon_async in invalid state " + _get_current_state_as_string());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }
            mark_as_used();
            co_return co_await _execute_logon_message_async(std::move(logon_params), async_stream_variant_ref);
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logoff_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async: LOGOFF not supported in Bolt < 5.1", get_id_for_logging());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, {}};
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY && current_s != InternalState::STREAMING && current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::AWAITING_SUMMARY && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async called when not ready/streaming. State: {}", get_id_for_logging(), _get_current_state_as_string());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logoff_async in invalid state " + _get_current_state_as_string());
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuthAsync {}] Performing LOGOFF async.", get_id_for_logging());

            std::vector<uint8_t> logoff_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload_storage);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                mark_as_defunct_from_async(err, "Async LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGOFF serialization failed: {}", get_id_for_logging(), static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            boltprotocol::BoltError send_err = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logoff_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGOFF send failed: {}", get_id_for_logging(), static_cast<int>(send_err));
                co_return std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>{last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    summary_err = last_error_code_;
                    break;
                }
                if (response_payload.empty()) continue;

                boltprotocol::MessageTag tag;
                //  _peek_message_tag 
                if (_peek_message_tag(response_payload, tag) != boltprotocol::BoltError::SUCCESS) {
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGOFF: Peek tag failed.");
                    summary_err = last_error_code_;
                    break;
                }
                boltprotocol::PackStreamReader reader(response_payload);

                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) mark_as_defunct_from_async(summary_err, "Async LOGOFF: Failed to deserialize SUCCESS.");
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    summary_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (summary_err == boltprotocol::BoltError::SUCCESS)
                        summary_err = _classify_and_set_server_failure(failure_meta);
                    else
                        mark_as_defunct_from_async(summary_err, "Async LOGOFF: Failed to deserialize FAILURE.");
                    break;
                } else {  // IGNORED or other unexpected
                    mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGOFF: Unexpected summary tag.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGOFF successful.", get_id_for_logging());
                current_state_.store((negotiated_bolt_version_ < boltprotocol::versions::V5_1) ? InternalState::ASYNC_HELLO_AUTH_SENT : InternalState::ASYNC_BOLT_HANDSHAKEN);
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGOFF failed. Error: {}, Server Msg: {}", get_id_for_logging(), static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // For initial logger checks
#include <utility>   // For std::move

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        std::atomic<uint64_t> BoltPhysicalConnection::next_connection_id_counter_(0);

        BoltPhysicalConnection::BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr)
            : id_(next_connection_id_counter_++),
              conn_config_(std::move(config)),
              io_context_ref_(io_ctx),
              logger_(logger_ptr),  // Directly use passed logger
              current_state_(InternalState::FRESH),
              negotiated_bolt_version_(0, 0),
              creation_timestamp_(std::chrono::steady_clock::now()) {
            if (!logger_) {  // Fallback if a null logger was somehow passed
                std::cerr << "Warning: BoltPhysicalConnection " << id_ << " created with a null logger." << std::endl;
                // Optionally create a default emergency logger here if critical
            }

            last_used_timestamp_.store(creation_timestamp_, std::memory_order_relaxed);
            if (logger_) {
                logger_->debug("[ConnConstruct {}] Constructed. Target: {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            }
        }

        BoltPhysicalConnection::~BoltPhysicalConnection() {
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destructing. Current state: {}", id_, _get_current_state_as_string());
            }
            // Ensure resources are cleaned up. terminate(false) handles most of it.
            // _reset_resources_and_state(true) is a fallback if terminate wasn't called or state is already DEFUNCT/FRESH.
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::DEFUNCT && current_s != InternalState::FRESH) {
                terminate(false);  // Don't send GOODBYE from destructor
            } else {
                // If already defunct or fresh, still ensure resources are reset, especially if construction failed partway.
                _reset_resources_and_state(true);  // called_from_destructor = true
            }
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destruction complete.", id_);
            }
        }

        BoltPhysicalConnection::BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept
            : id_(other.id_),
              conn_config_(std::move(other.conn_config_)),
              io_context_ref_(other.io_context_ref_),
              logger_(std::move(other.logger_)),  // Move the logger
              owned_socket_for_sync_plain_(std::move(other.owned_socket_for_sync_plain_)),
              plain_iostream_wrapper_(std::move(other.plain_iostream_wrapper_)),
              ssl_context_sync_(std::move(other.ssl_context_sync_)),
              ssl_stream_sync_(std::move(other.ssl_stream_sync_)),
              // current_state_ is atomic, needs load/store
              negotiated_bolt_version_(other.negotiated_bolt_version_),
              server_agent_string_(std::move(other.server_agent_string_)),
              server_assigned_conn_id_(std::move(other.server_assigned_conn_id_)),
              utc_patch_active_(other.utc_patch_active_),
              creation_timestamp_(other.creation_timestamp_),
              // last_used_timestamp_ is atomic
              last_error_code_(other.last_error_code_),
              last_error_message_(std::move(other.last_error_message_)) {
            current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
            last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);

            // Invalidate 'other' to prevent double resource management
            other.id_ = static_cast<uint64_t>(-1);  // Mark as moved-from
            other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
            // Logger in 'other' is now nullptr due to move.
            // other's unique_ptrs are now nullptr due to move.

            if (logger_) {
                logger_->trace("[ConnMoveConstruct {}] Move constructed from (now defunct) old connection {}.", id_, other.id_);
            }
        }

        BoltPhysicalConnection& BoltPhysicalConnection::operator=(BoltPhysicalConnection&& other) noexcept {
            if (this != &other) {
                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assigning from old ID {}. Current state before: {}", id_, other.id_, _get_current_state_as_string());
                }
                // Properly terminate current connection's resources before overwriting
                InternalState current_s_before_assign = current_state_.load(std::memory_order_relaxed);
                if (current_s_before_assign != InternalState::DEFUNCT && current_s_before_assign != InternalState::FRESH) {
                    terminate(false);  // Gracefully terminate self if active
                } else {
                    _reset_resources_and_state(false);  // Clean up if FRESH but resources might exist
                }

                id_ = other.id_;
                conn_config_ = std::move(other.conn_config_);
                // io_context_ref_ is a reference, assumed to be compatible and not changed.
                logger_ = std::move(other.logger_);

                owned_socket_for_sync_plain_ = std::move(other.owned_socket_for_sync_plain_);
                plain_iostream_wrapper_ = std::move(other.plain_iostream_wrapper_);
                ssl_context_sync_ = std::move(other.ssl_context_sync_);
                ssl_stream_sync_ = std::move(other.ssl_stream_sync_);

                current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                negotiated_bolt_version_ = other.negotiated_bolt_version_;
                server_agent_string_ = std::move(other.server_agent_string_);
                server_assigned_conn_id_ = std::move(other.server_assigned_conn_id_);
                utc_patch_active_ = other.utc_patch_active_;
                creation_timestamp_ = other.creation_timestamp_;
                last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                last_error_code_ = other.last_error_code_;
                last_error_message_ = std::move(other.last_error_message_);

                // Invalidate 'other'
                other.id_ = static_cast<uint64_t>(-1);
                other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
                // Logger in 'other' is now nullptr.
                // other's unique_ptrs are now nullptr.

                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assignment complete.", id_);
                }
            }
            return *this;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <variant>

#include "boltprotocol/handshake.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_bolt_handshake() {
            InternalState expected_prev_state;
            bool is_ssl = conn_config_.encryption_enabled;

            if (is_ssl) {
                expected_prev_state = InternalState::SSL_HANDSHAKEN;
                if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] SSL stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            } else {
                expected_prev_state = InternalState::TCP_CONNECTED;
                if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] Plain stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            }

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state) {
                std::string msg = "Bolt handshake (sync) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            current_state_.store(InternalState::BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHS {}] Performing (sync) Bolt handshake.", id_);

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for handshake.");
                if (logger_) logger_->error("[ConnBoltHS {}] No Bolt versions to propose.", id_);
                return last_error_code_;
            }

            boltprotocol::BoltError err;
            if (is_ssl) {
                err = boltprotocol::perform_handshake(*ssl_stream_sync_, proposed_versions, negotiated_bolt_version_);
            } else {
                err = boltprotocol::perform_handshake(*plain_iostream_wrapper_, proposed_versions, negotiated_bolt_version_);
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Sync Bolt handshake failed: " + error::bolt_error_to_string(err);
                _mark_as_defunct_internal(err, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (logger_) logger_->debug("[ConnBoltHS {}] Sync Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);

            current_state_.store(InternalState::BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref, std::chrono::milliseconds timeout) {
            bool is_ssl_stream = std::holds_alternative<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>(async_stream_variant_ref);
            InternalState expected_prev_state = is_ssl_stream ? InternalState::SSL_HANDSHAKEN : InternalState::TCP_CONNECTED;

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            // Allow if just finished async SSL HS or async TCP connect, or if already in correct pre-state
            bool correct_prev_state = (current_s == expected_prev_state) || (is_ssl_stream && current_s == InternalState::ASYNC_SSL_HANDSHAKING) || (!is_ssl_stream && current_s == InternalState::ASYNC_TCP_CONNECTING);

            if (!correct_prev_state) {
                std::string msg = "Bolt handshake (async) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl_stream ? "SSL_HANDSHAKEN/ASYNC_SSL_HANDSHAKING" : "TCP_CONNECTED/ASYNC_TCP_CONNECTING");
                mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Performing (async) Bolt handshake. Timeout: {}ms", get_id_for_logging(), timeout.count());

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for async handshake.");
                if (logger_) logger_->error("[ConnBoltHSAsync {}] No Bolt versions to propose.", get_id_for_logging());
                co_return last_error_code_;
            }

            std::vector<uint8_t> handshake_bytes;
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0xB0);
            handshake_bytes.push_back(0x17);
            for (const auto& version : proposed_versions) {
                handshake_bytes.push_back(version.minor);
                handshake_bytes.push_back(version.major);
                handshake_bytes.push_back(0);
                handshake_bytes.push_back(0);
            }
            while (handshake_bytes.size() < 20) {
                handshake_bytes.push_back(0);
            }

            boltprotocol::BoltError err = co_await _write_to_active_async_stream(async_stream_variant_ref, handshake_bytes);
            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to send proposed versions: " + error::bolt_error_to_string(err);
                // _write_to_active_async_stream calls mark_as_defunct_from_async
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            auto [read_err, negotiated_version_bytes] = co_await _read_from_active_async_stream(async_stream_variant_ref, 4);
            if (read_err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to read negotiated version: " + error::bolt_error_to_string(read_err);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (negotiated_version_bytes.size() != 4) {
                std::string msg = "Async Bolt handshake: received incorrect size for negotiated version.";
                mark_as_defunct_from_async(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            // Assuming Version struct does not have patch member, as per previous clarification.
            negotiated_bolt_version_.minor = negotiated_version_bytes[1];
            negotiated_bolt_version_.major = negotiated_version_bytes[0];
            // negotiated_bolt_version_.patch = 0; // No patch field

            bool version_supported = false;
            for (const auto& proposed : proposed_versions) {
                if (proposed.major == negotiated_bolt_version_.major && proposed.minor == negotiated_bolt_version_.minor) {
                    version_supported = true;
                    break;
                }
            }

            if (negotiated_bolt_version_.major == 0 && negotiated_bolt_version_.minor == 0) {
                std::string msg = "Async Bolt handshake: Server rejected all proposed Bolt versions (responded with 0.0).";
                mark_as_defunct_from_async(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (!version_supported) {
                std::string msg = "Async Bolt handshake: Server chose an unsupported Bolt version: " + negotiated_bolt_version_.to_string();
                mark_as_defunct_from_async(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Async Bolt handshake successful. Negotiated version: {}.{}", get_id_for_logging(), (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);  // Corrected enum member was added
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <variant>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_types.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> BoltPhysicalConnection::establish_async() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::ASYNC_TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::ASYNC_READY || current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCAsync {}] Establish_async called but connection is already READY.", get_id_for_logging());
                    std::string msg = "Establish_async called but connection is already READY. Cannot provide a new ActiveAsyncStreamContext.";
                    if (logger_) logger_->warn("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                    mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                std::string msg = "Establish_async called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{(current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (logger_) logger_->info("[ConnLCAsync {}] Establishing (async) connection to {}:{}", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port);

            _reset_resources_and_state(false);
            current_state_.store(InternalState::ASYNC_TCP_CONNECTING, std::memory_order_relaxed);

            boost::asio::ip::tcp::socket temp_socket(io_context_ref_);  // Socket will be moved
            boltprotocol::BoltError err = boltprotocol::BoltError::UNKNOWN_ERROR;

            err = co_await _stage_tcp_connect_async(temp_socket, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async TCP connect stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> final_stream_variant{std::move(temp_socket)};
            bool encryption_used_for_context = false;

            if (conn_config_.encryption_enabled) {
                encryption_used_for_context = true;
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }

                // temp_socket has been moved into final_stream_variant.
                // We need to extract it, construct ssl_socket_stream, and then move ssl_socket_stream back into final_stream_variant.
                boost::asio::ip::tcp::socket plain_socket_for_ssl = std::get<boost::asio::ip::tcp::socket>(std::move(final_stream_variant));
                // Create SSL stream on the stack or as a local unique_ptr before moving
                boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket_stream(std::move(plain_socket_for_ssl), *ssl_context_sync_);

                current_state_.store(InternalState::ASYNC_SSL_HANDSHAKING);
                // _stage_ssl_handshake_async's first parameter should be boost::asio::ssl::stream<boost::asio::ip::tcp::socket>&
                err = co_await _stage_ssl_handshake_async(ssl_socket_stream, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
                if (err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnLCAsync {}] Async SSL handshake stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                final_stream_variant = std::move(ssl_socket_stream);
                current_state_.store(InternalState::SSL_HANDSHAKEN);
            }

            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> active_async_stream_ptr_variant;
            if (std::holds_alternative<boost::asio::ip::tcp::socket>(final_stream_variant)) {
                active_async_stream_ptr_variant = &std::get<boost::asio::ip::tcp::socket>(final_stream_variant);
            } else {
                active_async_stream_ptr_variant = &std::get<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(final_stream_variant);
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING);
            err = co_await _stage_bolt_handshake_async(active_async_stream_ptr_variant, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async Bolt handshake stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);

            current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            err = co_await _stage_send_hello_and_initial_auth_async(active_async_stream_ptr_variant);
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async HELLO/Auth stage failed: {}", get_id_for_logging(), error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (current_state_.load(std::memory_order_relaxed) != InternalState::ASYNC_READY && current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Async connection did not reach READY/ASYNC_READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCAsync {}] {}", get_id_for_logging(), msg);
                mark_as_defunct_from_async(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            mark_as_used();
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCAsync {}] Async Connection established and ready. Bolt version: {}.{}. Server: {}", get_id_for_logging(), (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);

            ActiveAsyncStreamContext async_context(std::move(final_stream_variant), negotiated_bolt_version_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_, encryption_used_for_context);
            co_return std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>{boltprotocol::BoltError::SUCCESS, std::move(async_context)};
        }

        // terminate_async and ping_async
        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::terminate_async(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) {
                logger_->debug("[ConnLCAsync {}] Terminating (async). Previous state was {}. Send goodbye: {}", get_id_for_logging(), (int)previous_state, send_goodbye);
            }

            if (previous_state == InternalState::DEFUNCT) {
                _reset_resources_and_state(false);
                co_return boltprotocol::BoltError::SUCCESS;
            }

            if (send_goodbye && previous_state >= InternalState::ASYNC_BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT && !(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                if (logger_) logger_->trace("[ConnLCAsync {}] Async GOODBYE logic placeholder: This operation would require the ActiveAsyncStreamContext to be passed or managed by the caller of terminate_async. Not sending GOODBYE from BoltPhysicalConnection directly.", get_id_for_logging());
            }

            _reset_resources_and_state(false);
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::ping_async(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCAsync {}] Pinging (async) connection (via async RESET). Timeout hint: {}ms", get_id_for_logging(), timeout.count());
            if (logger_) logger_->error("[ConnLCAsync {}] ping_async is a placeholder and requires an active async stream context to perform a true async RESET.", get_id_for_logging());
            co_return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/ssl.h>  // For SSL_get_shutdown, SSL_RECEIVED_SHUTDOWN, SSL_SENT_SHUTDOWN (needed by _reset_resources_and_state)

#include <boost/asio/ip/tcp.hpp>  // For socket::shutdown_both

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_reset_resources_and_state(bool called_from_destructor) {
            // This function is critical for cleaning up resources.
            // It's called from establish() before new attempt, terminate(), destructor, and move assignment.

            // 1. Close SSL stream (if exists and open)
            if (ssl_stream_sync_) {
                boost::system::error_code ec_ssl_shutdown, ec_tcp_close;
                if (ssl_stream_sync_->lowest_layer().is_open()) {
                    // Attempt graceful SSL shutdown only if not already shut down by peer.
                    // SSL_get_shutdown checks SSL state.
                    if (!(SSL_get_shutdown(ssl_stream_sync_->native_handle()) & (SSL_RECEIVED_SHUTDOWN | SSL_SENT_SHUTDOWN))) {
                        try {
                            ssl_stream_sync_->shutdown(ec_ssl_shutdown);                                                                                                     // Graceful SSL shutdown
                            if (logger_ && ec_ssl_shutdown && ec_ssl_shutdown != boost::asio::error::eof && ec_ssl_shutdown != boost::asio::ssl::error::stream_truncated) {  // EOF/truncated is common on close
                                logger_->trace("[ConnReset {}] SSL shutdown error: {}", id_, ec_ssl_shutdown.message());
                            }
                        } catch (const boost::system::system_error& e) {
                            if (logger_) logger_->trace("[ConnReset {}] Exception during SSL stream shutdown: {}", id_, e.what());
                        }
                    }
                    // Close the underlying socket
                    try {
                        ssl_stream_sync_->lowest_layer().close(ec_tcp_close);
                        if (logger_ && ec_tcp_close) {
                            logger_->trace("[ConnReset {}] SSL lowest_layer close error: {}", id_, ec_tcp_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during SSL lowest_layer close: {}", id_, e.what());
                    }
                }
                ssl_stream_sync_.reset();  // Release the unique_ptr
            }

            // 2. Reset SSL context (if exists)
            if (ssl_context_sync_) {
                ssl_context_sync_.reset();
            }

            // 3. Close plain iostream wrapper (if exists, it owns its socket if not SSL)
            if (plain_iostream_wrapper_) {
                // Destroying iostream wrapper will close its associated socket if it has one.
                plain_iostream_wrapper_.reset();
            }

            // 4. Close the raw owned socket (if it still exists and wasn't moved to iostream/ssl_stream)
            if (owned_socket_for_sync_plain_) {
                if (owned_socket_for_sync_plain_->is_open()) {
                    boost::system::error_code ec_shutdown, ec_close;
                    try {
                        owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_shutdown);
                        if (logger_ && ec_shutdown) {
                            logger_->trace("[ConnReset {}] Plain socket shutdown error: {}", id_, ec_shutdown.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket shutdown: {}", id_, e.what());
                    }
                    try {
                        owned_socket_for_sync_plain_->close(ec_close);
                        if (logger_ && ec_close) {
                            logger_->trace("[ConnReset {}] Plain socket close error: {}", id_, ec_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket close: {}", id_, e.what());
                    }
                }
                owned_socket_for_sync_plain_.reset();
            }

            // 5. Reset Bolt protocol specific state
            negotiated_bolt_version_ = boltprotocol::versions::Version(0, 0);
            server_agent_string_.clear();
            server_assigned_conn_id_.clear();
            utc_patch_active_ = false;

            // 6. Reset error state, unless in destructor of an already defunct connection
            //    or if we want to preserve the "original sin" error.
            //    For a full reset to FRESH for reuse, error should be cleared.
            if (!called_from_destructor || current_state_.load(std::memory_order_relaxed) != InternalState::DEFUNCT) {
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
            }

            // 7. Set state to FRESH, unless in destructor and already DEFUNCT (don't revive it)
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (!called_from_destructor || current_s != InternalState::DEFUNCT) {
                current_state_.store(InternalState::FRESH, std::memory_order_relaxed);
            }

            if (logger_) logger_->trace("[ConnReset {}] Resources and state reset. Current state for reuse (if not dtor): {}", id_, _get_current_state_as_string());
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::establish() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCSync {}] Establish called but connection is already READY.", id_);
                    return boltprotocol::BoltError::SUCCESS;
                }
                std::string msg = "Establish (sync) called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCSync {}] {}", id_, msg);
                return (current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR;
            }

            if (logger_) logger_->info("[ConnLCSync {}] Establishing (sync) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            _reset_resources_and_state(false);
            current_state_.store(InternalState::TCP_CONNECTING, std::memory_order_relaxed);

            boltprotocol::BoltError err = _stage_tcp_connect();
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            if (conn_config_.encryption_enabled) {
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
                err = _stage_ssl_handshake();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
            }

            err = _stage_bolt_handshake();
            if (err != boltprotocol::BoltError::SUCCESS) {
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            err = _stage_send_hello_and_initial_auth();
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {  // Ensure it's FRESH if not READY
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                }
                return last_error_code_;
            }

            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Sync connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCSync {}] {}", id_, msg);
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  //  internal
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            mark_as_used();
            if (last_error_code_ != boltprotocol::BoltError::SUCCESS && logger_) {
                logger_->warn("[ConnLCSync {}] Established but last_error_code_ is {}. Overriding to SUCCESS as state is READY.", id_, static_cast<int>(last_error_code_));
            }
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCSync {}] Sync Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::terminate(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) logger_->debug("[ConnLCSync {}] Terminating (sync). Previous state was {}. Send goodbye: {}", id_, (previous_state == InternalState::DEFUNCT ? "already DEFUNCT" : _get_current_state_as_string()), send_goodbye);

            if (previous_state == InternalState::DEFUNCT) {
                if (logger_) logger_->trace("[ConnLCSync {}] Already defunct, ensuring resources are clean.", id_);
                _reset_resources_and_state(false);
                return boltprotocol::BoltError::SUCCESS;
            }

            if (send_goodbye && previous_state >= InternalState::BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT) {
                if (!(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                    bool can_send = false;
                    if (conn_config_.encryption_enabled) {
                        can_send = ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                    } else {
                        can_send = plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                    }
                    if (can_send) {
                        if (logger_) logger_->trace("[ConnLCSync {}] Attempting to send GOODBYE.", id_);
                        std::vector<uint8_t> goodbye_payload;
                        boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                        if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                            boltprotocol::BoltError goodbye_err = _send_chunked_payload_sync(goodbye_payload);
                            if (goodbye_err != boltprotocol::BoltError::SUCCESS && logger_) {
                                logger_->warn("[ConnLCSync {}] Sending GOODBYE failed: {}", id_, error::bolt_error_to_string(goodbye_err));
                            } else if (logger_ && goodbye_err == boltprotocol::BoltError::SUCCESS) {
                                logger_->trace("[ConnLCSync {}] GOODBYE message sent.", id_);
                            }
                        }
                    } else {
                        if (logger_) logger_->trace("[ConnLCSync {}] Cannot send GOODBYE (stream not ready or Bolt version too low). Previous state was {}.", id_, (int)previous_state);
                    }
                } else {
                    if (logger_) logger_->trace("[ConnLCSync {}] GOODBYE not applicable for Bolt version {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
                }
            }
            _reset_resources_and_state(false);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCSync {}] Pinging (sync) connection (via RESET). Timeout hint: {}ms", id_, timeout.count());
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>
#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const {
            if (payload.empty()) {
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
            }
            boltprotocol::PackStreamReader temp_reader(payload);
            uint8_t raw_tag_byte = 0;
            uint32_t num_fields = 0;

            boltprotocol::BoltError peek_err = boltprotocol::peek_message_structure_header(temp_reader, raw_tag_byte, num_fields);
            if (peek_err != boltprotocol::BoltError::SUCCESS) {
                return peek_err;
            }
            out_tag = static_cast<boltprotocol::MessageTag>(raw_tag_byte);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_summary called in invalid state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;  // _send_chunked_payload_sync calls _mark_as_defunct_internal
            }

            current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);

            std::vector<uint8_t> response_payload;
            while (true) {
                err = _receive_chunked_payload_sync(response_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;  // _receive_chunked_payload_sync calls _mark_as_defunct_internal
                }
                if (!response_payload.empty()) break;
                if (logger_) logger_->trace("[ConnMsg {}] Received NOOP while awaiting summary.", id_);
            }

            boltprotocol::MessageTag tag;
            err = _peek_message_tag(response_payload, tag);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "Failed to peek tag for summary response.");  //  internal
                return last_error_code_;
            }

            boltprotocol::PackStreamReader reader(response_payload);
            if (tag == boltprotocol::MessageTag::SUCCESS) {
                err = boltprotocol::deserialize_success_message(reader, out_summary);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize SUCCESS summary.");  //  internal
                    return last_error_code_;
                }
                if (current_state_.load(std::memory_order_relaxed) == InternalState::AWAITING_SUMMARY) {
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                }
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
                return boltprotocol::BoltError::SUCCESS;

            } else if (tag == boltprotocol::MessageTag::FAILURE) {
                err = boltprotocol::deserialize_failure_message(reader, out_failure);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize FAILURE summary.");  //  internal
                    return last_error_code_;
                }
                return _classify_and_set_server_failure(out_failure);  // This handles defunct state

            } else if (tag == boltprotocol::MessageTag::IGNORED) {
                err = boltprotocol::deserialize_ignored_message(reader);  // Assuming this exists
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to deserialize IGNORED summary.");  //  internal
                    return last_error_code_;
                }
                out_failure.metadata.clear();
                out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");  // Example
                out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = boltprotocol::BoltError::UNKNOWN_ERROR;  // Or a specific IGNORED code if added
                last_error_message_ = "Operation ignored by server.";
                return boltprotocol::BoltError::UNKNOWN_ERROR;  // Treat IGNORED as an operational error for summary
            } else {
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag for summary: " + std::to_string(static_cast<int>(tag)));  //  internal
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            if (!is_ready_for_queries()) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_stream called when not ready. State: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::STREAMING, std::memory_order_relaxed);

            while (true) {
                std::vector<uint8_t> response_payload;
                err = _receive_chunked_payload_sync(response_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }

                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnMsg {}] Received NOOP during stream.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                err = _peek_message_tag(response_payload, tag);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct_internal(err, "Failed to peek tag during streaming.");  //  internal
                    return last_error_code_;
                }

                if (tag == boltprotocol::MessageTag::RECORD) {
                    if (record_handler) {
                        err = record_handler(tag, response_payload, *this);
                        if (err != boltprotocol::BoltError::SUCCESS) {
                            std::string msg = "Record handler returned error: " + error::bolt_error_to_string(err);
                            _mark_as_defunct_internal(err, msg);  //  internal
                            return last_error_code_;
                        }
                    } else {
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, "Received RECORD but no handler provided.");  //  internal
                        return last_error_code_;
                    }
                } else if (tag == boltprotocol::MessageTag::SUCCESS) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_success_message(reader, out_summary);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize SUCCESS summary in stream.");  //  internal
                        return last_error_code_;
                    }
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_.clear();
                    return boltprotocol::BoltError::SUCCESS;

                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_failure_message(reader, out_failure);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize FAILURE summary in stream.");  //  internal
                        return last_error_code_;
                    }
                    return _classify_and_set_server_failure(out_failure);

                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_ignored_message(reader);  // Assuming this exists
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct_internal(err, "Failed to deserialize IGNORED summary in stream.");  //  internal
                        return last_error_code_;
                    }
                    out_failure.metadata.clear();
                    out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                    out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                    current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::UNKNOWN_ERROR;  // Or a specific IGNORED code if added
                    last_error_message_ = "Operation ignored by server.";
                    return boltprotocol::BoltError::UNKNOWN_ERROR;

                } else {
                    _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag in stream: " + std::to_string(static_cast<int>(tag)));  //  internal
                    return last_error_code_;
                }
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_reset() {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT || current_s < InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] perform_reset called in unsuitable state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (logger_) logger_->debug("[ConnMsg {}] Performing RESET...", id_);
            mark_as_used();

            std::vector<uint8_t> reset_payload_bytes;
            boltprotocol::PackStreamWriter writer(reset_payload_bytes);
            boltprotocol::BoltError err = boltprotocol::serialize_reset_message(writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct_internal(err, "RESET serialization failed.");  //  internal
                return last_error_code_;
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;

            err = send_request_receive_summary(reset_payload_bytes, success_meta, failure_meta);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                current_state_.store(InternalState::READY, std::memory_order_relaxed);
                if (logger_) logger_->info("[ConnMsg {}] RESET successful. Connection is READY.", id_);
                return boltprotocol::BoltError::SUCCESS;
            } else {
                // send_request_receive_summary already handles defunct state
                if (logger_) logger_->error("[ConnMsg {}] RESET failed. Error: {}, Last Conn Error Code: {}, Msg: {}", id_, static_cast<int>(err), static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_;
            }
        }

        // ping is an alias for perform_reset
        // boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds /*timeout_placeholder*/) {
        //     if (logger_) logger_->debug("[ConnMsg {}] Pinging connection (via RESET)...", id_);
        //     return perform_reset();
        // }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ssl.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_context_setup() {
            if (!conn_config_.encryption_enabled) {
                if (logger_) logger_->debug("[ConnSSLCTX {}] SSL encryption not enabled, skipping context setup.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::TCP_CONNECTED) {
                std::string msg = "SSL context setup called but TCP not connected. Current state: " + _get_current_state_as_string();
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  //  internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_CONTEXT_SETUP, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLCTX {}] Setting up SSL context.", id_);

            try {
                ssl_context_sync_ = std::make_unique<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12_client);
                boost::system::error_code ec_ssl_setup;

                switch (conn_config_.resolved_encryption_strategy) {
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_none, ec_ssl_setup);
                        if (logger_ && !ec_ssl_setup) logger_->warn("[ConnSSLCTX {}] SSL configured to TRUST_ALL_CERTIFICATES (verify_none). THIS IS INSECURE.", id_);
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS:
                        ssl_context_sync_->set_default_verify_paths(ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_CUSTOM_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            if (conn_config_.trusted_certificates_pem_files.empty() && logger_) {
                                logger_->warn("[ConnSSLCTX {}] SSL configured for custom CAs but no CA certificate files provided. Verification will likely fail.", id_);
                            }
                            for (const auto& cert_path : conn_config_.trusted_certificates_pem_files) {
                                ssl_context_sync_->load_verify_file(cert_path, ec_ssl_setup);
                                if (ec_ssl_setup) {
                                    if (logger_) logger_->error("[ConnSSLCTX {}] Failed to load custom CA certificate file '{}': {}", id_, cert_path, ec_ssl_setup.message());
                                    break;
                                }
                                if (logger_) logger_->debug("[ConnSSLCTX {}] Successfully loaded custom CA certificate file: {}", id_, cert_path);
                            }
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT:
                    case config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME:
                    default:
                        std::string msg = "Invalid or unresolved encryption strategy for SSL context setup: " + std::to_string(static_cast<int>(conn_config_.resolved_encryption_strategy));
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  //  internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                }

                if (ec_ssl_setup) {
                    std::string msg = "SSL context verification setup failed: " + ec_ssl_setup.message();
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                    if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                    return last_error_code_;
                }

                if (conn_config_.client_certificate_pem_file.has_value()) {
                    if (!conn_config_.client_private_key_pem_file.has_value()) {
                        std::string msg = "Client certificate provided, but client private key is missing.";
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  //  internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client certificate: {}", id_, conn_config_.client_certificate_pem_file.value());
                    ssl_context_sync_->use_certificate_chain_file(conn_config_.client_certificate_pem_file.value(), ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client certificate chain file '" + conn_config_.client_certificate_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  //  internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client private key: {}", id_, conn_config_.client_private_key_pem_file.value());
                    if (conn_config_.client_private_key_password.has_value() && !conn_config_.client_private_key_password.value().empty()) {
                        ssl_context_sync_->set_password_callback(
                            [pwd = conn_config_.client_private_key_password.value()](std::size_t, boost::asio::ssl::context_base::password_purpose) {
                                return pwd;
                            },
                            ec_ssl_setup);
                        if (ec_ssl_setup) {
                            std::string msg = "Failed to set password callback for client private key: " + ec_ssl_setup.message();
                            _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  //  internal
                            if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    }
                    ssl_context_sync_->use_private_key_file(conn_config_.client_private_key_pem_file.value(), boost::asio::ssl::context::pem, ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client private key file '" + conn_config_.client_private_key_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);  //  internal
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }
                    if (logger_) logger_->info("[ConnSSLCTX {}] Client certificate and private key loaded successfully for mTLS.", id_);
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL context setup: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL context setup: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  //  internal
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLCTX {}] SSL context setup complete.", id_);
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/err.h>
#include <openssl/ssl.h>

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/asio/ssl/host_name_verification.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// run_with_timeout_sync_internal_hs  ()
namespace {
    template <typename AsyncOperation>
    boost::system::error_code run_with_timeout_sync_internal_hs(
        boost::asio::io_context& io_ctx, std::chrono::milliseconds timeout_duration, AsyncOperation op, std::shared_ptr<spdlog::logger> logger, uint64_t conn_id, const std::string& op_name, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>* stream_to_cancel_on_timeout = nullptr) {
        boost::system::error_code result_ec = boost::asio::error::would_block;
        std::atomic<bool> operation_completed_flag{false};

        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_ref;
                try {
                    co_await op(op_ec_ref);
                } catch (const boost::system::system_error& e) {
                    op_ec_ref = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' sys_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_ref = boost::asio::error::fault;
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_ref;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&](const boost::system::error_code& ec_timer) {
                if (ec_timer != boost::asio::error::operation_aborted) {
                    if (!operation_completed_flag.load(std::memory_order_acquire)) {
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timed out.", conn_id, op_name);
                        timed_out_flag = true;
                        result_ec = boost::asio::error::timed_out;
                        if (stream_to_cancel_on_timeout && stream_to_cancel_on_timeout->lowest_layer().is_open()) {
                            stream_to_cancel_on_timeout->lowest_layer().cancel();
                        }
                        operation_completed_flag.store(true, std::memory_order_release);
                    }
                }
            });
        }

        io_ctx.restart();
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilHS {}] io_ctx stopped during op '{}'.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {
                    result_ec = boost::asio::error::interrupted;
                }
                break;
            }
            io_ctx.poll_one();
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();
                if (io_ctx.stopped()) io_ctx.restart();
            }
        }
        timer.cancel();
        return result_ec;
    }
}  // namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_handshake() {
            if (!conn_config_.encryption_enabled) {
                if (logger_) logger_->debug("[ConnSSLHS {}] SSL encryption not enabled, skipping handshake.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::SSL_CONTEXT_SETUP) {
                std::string msg = "SSL handshake called in unexpected state: " + _get_current_state_as_string() + ". Expected SSL_CONTEXT_SETUP.";
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (!ssl_context_sync_ || !owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                std::string msg = "SSL handshake attempted without a valid SSL context or a connected TCP socket.";
                _mark_as_defunct_internal(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLHS {}] Performing SSL handshake for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, conn_config_.bolt_handshake_timeout_ms);

            try {
                ssl_stream_sync_ = std::make_unique<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(std::move(*owned_socket_for_sync_plain_), *ssl_context_sync_);
                owned_socket_for_sync_plain_.reset();

                if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                    if (!SSL_set_tlsext_host_name(ssl_stream_sync_->native_handle(), conn_config_.target_host.c_str())) {
                        boost::system::error_code sni_ec(static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category());
                        if (logger_) logger_->warn("[ConnSSLHS {}] Failed to set SNI extension for host {}: {}. Handshake will proceed.", id_, conn_config_.target_host, sni_ec.message());
                    } else {
                        if (logger_) logger_->trace("[ConnSSLHS {}] SNI hostname set to: {}", id_, conn_config_.target_host);
                    }
                    ssl_stream_sync_->set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
                    if (logger_) logger_->trace("[ConnSSLHS {}] Hostname verification enabled for: {}", id_, conn_config_.target_host);
                } else {
                    if (logger_) logger_->debug("[ConnSSLHS {}] Hostname verification skipped (disabled or trust_all_certs).", id_);
                }

                boost::system::error_code handshake_ec;
                auto handshake_op = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    try {
                        co_await ssl_stream_sync_->async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    } catch (const boost::system::system_error& e) {
                        op_ec_ref = e.code();
                    }
                    co_return;
                };

                handshake_ec = run_with_timeout_sync_internal_hs(io_context_ref_, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms), handshake_op, logger_, id_, "SSL Handshake", ssl_stream_sync_.get());

                if (handshake_ec) {
                    std::string msg;
                    if (handshake_ec == boost::asio::error::timed_out) {
                        msg = "SSL handshake timed out for host " + conn_config_.target_host + " after " + std::to_string(conn_config_.bolt_handshake_timeout_ms) + "ms.";
                    } else {
                        msg = "SSL handshake failed for host " + conn_config_.target_host + ": " + handshake_ec.message();
                        unsigned long openssl_err_code = ERR_get_error();
                        while (openssl_err_code != 0) {
                            char err_buf[256];
                            ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                            msg += " (OpenSSL: " + std::string(err_buf) + ")";
                            openssl_err_code = ERR_get_error();
                        }
                    }
                    _mark_as_defunct_internal(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                    if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                    return last_error_code_;
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL handshake: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL handshake: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLHS {}] SSL handshake successful for {}.", id_, conn_config_.target_host);
            return boltprotocol::BoltError::SUCCESS;
        }

        //  boost::asio::ssl::stream<boost::asio::ip::tcp::socket>&
        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket>& stream_ref, std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Performing SSL handshake async for host {} (Timeout: {}ms)...", get_id_for_logging(), conn_config_.target_host, timeout.count());
            boost::system::error_code ec;

            if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                if (!SSL_set_tlsext_host_name(stream_ref.native_handle(), conn_config_.target_host.c_str())) {
                    if (logger_) logger_->warn("[ConnSSLHSAsync {}] Failed to set SNI (async) for host {}", get_id_for_logging(), conn_config_.target_host);
                }
                stream_ref.set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
            }

            boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
            std::atomic<bool> handshake_timed_out{false};
            std::atomic<bool> handshake_completed{false};

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            if (!handshake_completed.load(std::memory_order_acquire)) {
                                handshake_timed_out.store(true, std::memory_order_release);
                                stream_ref.lowest_layer().cancel();
                                if (logger_) logger_->warn("[ConnSSLHSAsync {}] SSL handshake async timed out, lowest_layer cancelled.", get_id_for_logging());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await stream_ref.async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            handshake_completed.store(true, std::memory_order_release);
            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (handshake_timed_out.load(std::memory_order_acquire) || ec == boost::asio::error::operation_aborted) {
                    msg = "Async SSL handshake for host " + conn_config_.target_host + " timed out or was cancelled.";
                    ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async SSL handshake failed: " + ec.message();
                    unsigned long openssl_err_code = ERR_get_error();
                    while (openssl_err_code != 0) {
                        char err_buf[256];
                        ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                        msg += " (OpenSSL: " + std::string(err_buf) + ")";
                        openssl_err_code = ERR_get_error();
                    }
                }
                if (logger_) logger_->error("[ConnSSLHSAsync {}] {}", get_id_for_logging(), msg);
                mark_as_defunct_from_async(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                co_return boltprotocol::BoltError::HANDSHAKE_FAILED;
            }

            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Async SSL handshake successful.", get_id_for_logging());
            current_state_.store(InternalState::SSL_HANDSHAKEN);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _update_metadata_from_hello_success  _update_metadata_from_logon_success 

        void BoltPhysicalConnection::_update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_server = meta.metadata.find("server");
            if (it_server != meta.metadata.end() && std::holds_alternative<std::string>(it_server->second)) {
                server_agent_string_ = std::get<std::string>(it_server->second);
            } else {
                server_agent_string_.clear();
            }

            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                server_assigned_conn_id_ = std::get<std::string>(it_conn_id->second);
            } else {
                server_assigned_conn_id_.clear();
            }

            utc_patch_active_ = false;
            if (negotiated_bolt_version_ == boltprotocol::versions::Version(4, 3) || negotiated_bolt_version_ == boltprotocol::versions::Version(4, 4)) {
                auto it_patch = meta.metadata.find("patch_bolt");
                if (it_patch != meta.metadata.end()) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second)) {
                        auto list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second);
                        if (list_ptr) {
                            for (const auto& val : list_ptr->elements) {
                                if (std::holds_alternative<std::string>(val)) {
                                    if (std::get<std::string>(val) == "utc") {
                                        utc_patch_active_ = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (negotiated_bolt_version_ >= boltprotocol::versions::Version(5, 0)) {
                utc_patch_active_ = true;
            }

            if (logger_) logger_->debug("[ConnState {}] Metadata updated from HELLO. Server: '{}', ConnId: '{}', UTC Patch Active: {}", id_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_);
        }

        void BoltPhysicalConnection::_update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                std::string new_conn_id = std::get<std::string>(it_conn_id->second);
                if (server_assigned_conn_id_ != new_conn_id && logger_) {
                    logger_->debug("[ConnState {}] Connection ID changed by LOGON from '{}' to '{}'", id_, server_assigned_conn_id_, new_conn_id);
                }
                server_assigned_conn_id_ = new_conn_id;
            }
            if (logger_) logger_->debug("[ConnState {}] Metadata updated from LOGON. ConnId: '{}'", id_, server_assigned_conn_id_);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta) {
            std::string neo4j_code = "Unknown.Error";
            std::string message = "An unspecified error occurred on the server.";

            auto extract_string_from_map = [&](const std::string& key) -> std::optional<std::string> {
                auto it = meta.metadata.find(key);
                if (it != meta.metadata.end() && std::holds_alternative<std::string>(it->second)) {
                    return std::get<std::string>(it->second);
                }
                return std::nullopt;
            };

            if (auto code_opt = extract_string_from_map("neo4j_code")) {
                neo4j_code = *code_opt;
            } else if (auto legacy_code_opt = extract_string_from_map("code")) {
                neo4j_code = *legacy_code_opt;
            }

            if (auto msg_opt = extract_string_from_map("message")) {
                message = *msg_opt;
            }

            std::string full_error_message = "Server error: [" + neo4j_code + "] " + message;
            //  UNKNOWN_ERROR  NETWORK_ERROR SERVER_FAILURE 
            boltprotocol::BoltError classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            InternalState next_state = InternalState::FAILED_SERVER_REPORTED;

            // 
            if (neo4j_code.find("TransientError") != std::string::npos || neo4j_code.find("DatabaseUnavailable") != std::string::npos || neo4j_code.find("NotALeader") != std::string::npos || neo4j_code.find("ForbiddenOnReadOnlyDatabase") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::NETWORK_ERROR;  // /
            } else if (neo4j_code.find("ClientError.Security") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::HANDSHAKE_FAILED;  // /
                next_state = InternalState::DEFUNCT;
            } else if (neo4j_code.find("ClientError.Statement") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::INVALID_ARGUMENT;  // 
            } else if (neo4j_code.find("ClientError.Transaction") != std::string::npos) {
                //  BoltError UNKNOWN_ERROR
                classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            }
            //  UNKNOWN_ERROR

            if (next_state == InternalState::DEFUNCT) {
                _mark_as_defunct_internal(classified_error_code, full_error_message);
            } else {
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = classified_error_code;
                last_error_message_ = full_error_message;
            }

            if (logger_) logger_->warn("[ConnState {}] Server reported failure. Code: '{}', Msg: '{}'. Classified as: {}, Next state: {}", id_, neo4j_code, message, error::bolt_error_to_string(last_error_code_), _get_current_state_as_string());
            return last_error_code_;
        }

        // _mark_as_defunct_internal, mark_as_defunct_from_async, _get_current_state_as_string,
        // is_ready_for_queries, is_defunct 

        void BoltPhysicalConnection::_mark_as_defunct_internal(boltprotocol::BoltError reason, const std::string& message) {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT && last_error_code_ != boltprotocol::BoltError::SUCCESS && reason == last_error_code_) {
                if (!message.empty() && last_error_message_.find(message) == std::string::npos) {
                    last_error_message_ += "; Additional info: " + message;
                }
                if (message == last_error_message_ && reason == last_error_code_ && logger_) {
                    logger_->trace("[ConnState {}] _mark_as_defunct_internal called again with same reason and message for already defunct connection.", id_);
                }
                return;
            }
            current_state_.store(InternalState::DEFUNCT, std::memory_order_acq_rel);
            last_error_code_ = reason;
            last_error_message_ = message;
            if (logger_) {
                logger_->error("[ConnState {}] Marked as DEFUNCT. Reason: {} ({}), Message: {}", id_, static_cast<int>(reason), error::bolt_error_to_string(reason), message);
            }
        }

        void BoltPhysicalConnection::mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) {
            _mark_as_defunct_internal(reason, message);
        }

        std::string BoltPhysicalConnection::_get_current_state_as_string() const {
            switch (current_state_.load(std::memory_order_relaxed)) {
                case InternalState::FRESH:
                    return "FRESH";
                case InternalState::TCP_CONNECTING:
                    return "TCP_CONNECTING";
                case InternalState::ASYNC_TCP_CONNECTING:
                    return "ASYNC_TCP_CONNECTING";
                case InternalState::TCP_CONNECTED:
                    return "TCP_CONNECTED";
                case InternalState::SSL_CONTEXT_SETUP:
                    return "SSL_CONTEXT_SETUP";
                case InternalState::SSL_HANDSHAKING:
                    return "SSL_HANDSHAKING";
                case InternalState::ASYNC_SSL_HANDSHAKING:
                    return "ASYNC_SSL_HANDSHAKING";
                case InternalState::SSL_HANDSHAKEN:
                    return "SSL_HANDSHAKEN";
                case InternalState::BOLT_HANDSHAKING:
                    return "BOLT_HANDSHAKING";
                case InternalState::ASYNC_BOLT_HANDSHAKING:
                    return "ASYNC_BOLT_HANDSHAKING";
                case InternalState::BOLT_HANDSHAKEN:
                    return "BOLT_HANDSHAKEN";
                case InternalState::ASYNC_BOLT_HANDSHAKEN:
                    return "ASYNC_BOLT_HANDSHAKEN";
                case InternalState::HELLO_AUTH_SENT:
                    return "HELLO_AUTH_SENT";
                case InternalState::ASYNC_HELLO_AUTH_SENT:
                    return "ASYNC_HELLO_AUTH_SENT";
                case InternalState::READY:
                    return "READY";
                case InternalState::ASYNC_READY:
                    return "ASYNC_READY";
                case InternalState::STREAMING:
                    return "STREAMING";
                case InternalState::ASYNC_STREAMING:
                    return "ASYNC_STREAMING";
                case InternalState::AWAITING_SUMMARY:
                    return "AWAITING_SUMMARY";
                case InternalState::ASYNC_AWAITING_SUMMARY:
                    return "ASYNC_AWAITING_SUMMARY";
                case InternalState::FAILED_SERVER_REPORTED:
                    return "FAILED_SERVER_REPORTED";
                case InternalState::DEFUNCT:
                    return "DEFUNCT";
                default:
                    return "UNKNOWN_STATE_" + std::to_string(static_cast<int>(current_state_.load(std::memory_order_relaxed)));
            }
        }

        bool BoltPhysicalConnection::is_ready_for_queries() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                return false;
            }
            if (current_s == InternalState::READY) {
                if (conn_config_.encryption_enabled) {
                    return ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                } else {
                    return plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                }
            }
            if (current_s == InternalState::ASYNC_READY) {
                return true;
            }
            return false;
        }

        bool BoltPhysicalConnection::is_defunct() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT) {
                return true;
            }
            if (current_s > InternalState::FRESH && current_s < InternalState::DEFUNCT) {
                if (current_s != InternalState::ASYNC_TCP_CONNECTING && current_s != InternalState::ASYNC_SSL_HANDSHAKING && current_s != InternalState::ASYNC_BOLT_HANDSHAKING && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::ASYNC_READY &&
                    current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                    if (conn_config_.encryption_enabled) {
                        if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                            return true;
                        }
                    } else {
                        if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_send_chunked_payload_sync(const std::vector<uint8_t>& payload) {
            if (is_defunct()) return last_error_code_;

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);

                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                err = _write_to_active_sync_stream(data_ptr, chunk_size);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&zero_chunk_be), boltprotocol::CHUNK_HEADER_SIZE);
            }
            // _write_to_active_sync_stream calls _mark_as_defunct_internal if needed
            return err;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_receive_chunked_payload_sync(std::vector<uint8_t>& out_payload) {
            out_payload.clear();
            if (is_defunct()) return last_error_code_;

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (true) {
                uint16_t chunk_size_be = 0;
                size_t bytes_read_header = 0;
                err = _read_from_active_sync_stream(reinterpret_cast<uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE, bytes_read_header);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }

                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Received chunk larger than max allowed size: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct_internal(err, msg);  //  internal 
                    if (logger_) logger_->error("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t current_payload_offset = out_payload.size();
                try {
                    out_payload.resize(current_payload_offset + chunk_payload_size);
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory resizing payload buffer for chunk.";
                    _mark_as_defunct_internal(err, msg);  //  internal 
                    if (logger_) logger_->critical("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t bytes_read_payload = 0;
                err = _read_from_active_sync_stream(out_payload.data() + current_payload_offset, chunk_payload_size, bytes_read_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (total_bytes_read_for_message == 0 && out_payload.empty()) {
                if (logger_) logger_->trace("[ConnSyncChunking {}] Received NOOP message (empty payload from chunks).", id_);
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_write_to_active_sync_stream(const uint8_t* data, size_t size) {
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Write attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            boost::system::error_code ec;
            size_t bytes_written = 0;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Write {} bytes", id_, size);
                    bytes_written = boost::asio::write(*ssl_stream_sync_, boost::asio::buffer(data, size), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Write {} bytes via iostream", id_, size);
                    plain_iostream_wrapper_->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
                    if (plain_iostream_wrapper_->fail()) {
                        int stream_errno = errno;
                        ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EPIPE, boost::system::system_category());
                    } else {
                        bytes_written = size;
                        plain_iostream_wrapper_->flush();
                        if (plain_iostream_wrapper_->fail()) {
                            int stream_errno_flush = errno;
                            ec = boost::system::error_code(stream_errno_flush != 0 ? stream_errno_flush : EPIPE, boost::system::system_category());
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync write: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync write: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg = "Sync write to stream failed: " + ec.message();
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_written != size) {
                std::string msg = "Partial sync write to stream. Expected " + std::to_string(size) + ", wrote " + std::to_string(bytes_written);
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read) {
            bytes_read = 0;
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Read attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (size_to_read == 0) return boltprotocol::BoltError::SUCCESS;

            boost::system::error_code ec;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Read {} bytes", id_, size_to_read);
                    bytes_read = boost::asio::read(*ssl_stream_sync_, boost::asio::buffer(buffer, size_to_read), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Read {} bytes via iostream", id_, size_to_read);
                    plain_iostream_wrapper_->read(reinterpret_cast<char*>(buffer), static_cast<std::streamsize>(size_to_read));
                    bytes_read = static_cast<size_t>(plain_iostream_wrapper_->gcount());

                    if (bytes_read < size_to_read) {
                        if (plain_iostream_wrapper_->eof()) {
                            ec = boost::asio::error::eof;
                        } else if (plain_iostream_wrapper_->fail()) {
                            int stream_errno = errno;
                            ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                        } else {
                            ec = boost::asio::error::fault;
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync read: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync read: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg;
                if (ec == boost::asio::error::eof) {
                    msg = "Sync read from stream failed: EOF reached prematurely. Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                } else {
                    msg = "Sync read from stream failed: " + ec.message() + ". Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                }
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_read < size_to_read) {
                std::string msg = "Incomplete sync read from stream. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(bytes_read) + ". No specific stream error reported.";
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <thread>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// run_sync_op_with_timeout_tcp  ()
namespace {
    template <typename AsyncOperation>
    boost::system::error_code run_sync_op_with_timeout_tcp(
        boost::asio::io_context& io_ctx, std::chrono::milliseconds timeout_duration, AsyncOperation op, std::shared_ptr<spdlog::logger> logger, uint64_t conn_id, const std::string& op_name, boost::asio::ip::tcp::socket* socket_to_cancel_on_timeout) {
        boost::system::error_code result_ec = boost::asio::error::would_block;
        std::atomic<bool> operation_completed_flag{false};

        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_local;
                try {
                    co_await op(op_ec_local);
                } catch (const boost::system::system_error& e) {
                    op_ec_local = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_local = boost::asio::error::fault;
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_local;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&, logger, conn_id, op_name, socket_to_cancel_on_timeout](const boost::system::error_code& ec_timer) {
                if (ec_timer != boost::asio::error::operation_aborted) {
                    if (!operation_completed_flag.load(std::memory_order_acquire)) {
                        if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timed out.", conn_id, op_name);
                        timed_out_flag = true;
                        result_ec = boost::asio::error::timed_out;
                        if (socket_to_cancel_on_timeout && socket_to_cancel_on_timeout->is_open()) {
                            socket_to_cancel_on_timeout->cancel();
                        }
                        operation_completed_flag.store(true, std::memory_order_release);
                    }
                }
            });
        }

        io_ctx.restart();
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilTCP {}] io_context stopped during op '{}' before completion.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {
                    result_ec = boost::asio::error::interrupted;
                }
                break;
            }
            io_ctx.poll_one();
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();
                if (io_ctx.stopped()) io_ctx.restart();
            }
        }
        timer.cancel();
        return result_ec;
    }
}  // namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_tcp_connect() {
            if (plain_iostream_wrapper_) plain_iostream_wrapper_.reset();
            if (ssl_stream_sync_) ssl_stream_sync_.reset();
            if (owned_socket_for_sync_plain_ && owned_socket_for_sync_plain_->is_open()) {
                boost::system::error_code ignored_ec;
                try {
                    owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
                    owned_socket_for_sync_plain_->close(ignored_ec);
                } catch (...) {
                }
            }
            owned_socket_for_sync_plain_ = std::make_unique<boost::asio::ip::tcp::socket>(io_context_ref_);

            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, conn_config_.tcp_connect_timeout_ms);

            boost::system::error_code ec;
            try {
                boost::asio::ip::tcp::resolver resolver(io_context_ref_);
                boost::asio::ip::tcp::resolver::results_type endpoints = resolver.resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), ec);

                if (ec) {
                    std::string msg = "DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }
                if (endpoints.empty()) {
                    std::string msg = "DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                auto connect_op_lambda = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    co_await boost::asio::async_connect(*owned_socket_for_sync_plain_, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    co_return;
                };

                ec = run_sync_op_with_timeout_tcp(io_context_ref_, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms), connect_op_lambda, logger_, id_, "Sync TCP Connect", owned_socket_for_sync_plain_.get());

                if (ec) {
                    std::string msg;
                    if (ec == boost::asio::error::timed_out) {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out after " + std::to_string(conn_config_.tcp_connect_timeout_ms) + "ms.";
                    } else {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                    }
                    _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                if (conn_config_.socket_keep_alive_enabled) {
                    boost::system::error_code keep_alive_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                    if (keep_alive_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                    }
                }
                if (conn_config_.tcp_no_delay_enabled) {
                    boost::system::error_code no_delay_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                    if (no_delay_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                    }
                }

                if (!conn_config_.encryption_enabled) {
                    if (!owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, "Socket not open for plain stream wrapper after connect.");  //  internal
                        if (logger_) logger_->error("[ConnTCP {}] Socket not open for plain iostream wrapper post-connect.", id_);
                        return last_error_code_;
                    }
                    try {
                        plain_iostream_wrapper_ = std::make_unique<boost::asio::ip::tcp::iostream>(std::move(*owned_socket_for_sync_plain_));
                        owned_socket_for_sync_plain_.reset();
                        if (!plain_iostream_wrapper_->good()) {
                            std::string msg = "Failed to initialize plain iostream wrapper after TCP connect (stream not good).";
                            _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                            if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    } catch (const std::exception& e) {
                        std::string msg = "Exception creating plain iostream wrapper: " + std::string(e.what());
                        _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                        if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                        return last_error_code_;
                    }
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::NETWORK_ERROR, msg);  //  internal
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct_internal(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  //  internal
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP Connecting to {}:{} (Timeout: {}ms)", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port, timeout.count());

            boost::system::error_code ec;
            boost::asio::ip::tcp::resolver resolver(socket.get_executor());

            auto endpoints = co_await resolver.async_resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            if (ec) {
                std::string msg = "Async DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }
            if (endpoints.empty()) {
                std::string msg = "Async DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            boost::asio::steady_timer timer(socket.get_executor());
            bool timed_out = false;

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    socket.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            timed_out = true;
                            socket.cancel();
                            if (logger_) logger_->trace("[ConnTCPAsync {}] Connect op socket cancel called due to timeout.", get_id_for_logging());
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await boost::asio::async_connect(socket, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, ec));

            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (timed_out || ec == boost::asio::error::operation_aborted) {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out or was cancelled.";
                    if (timed_out) ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                }
                mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, msg);  // 
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", get_id_for_logging(), msg);
                co_return last_error_code_;
            }

            if (conn_config_.socket_keep_alive_enabled) {
                boost::system::error_code keep_alive_ec;
                socket.set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                if (keep_alive_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set SO_KEEPALIVE: {}", get_id_for_logging(), keep_alive_ec.message());
                }
            }
            if (conn_config_.tcp_no_delay_enabled) {
                boost::system::error_code no_delay_ec;
                socket.set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                if (no_delay_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set TCP_NODELAY: {}", get_id_for_logging(), no_delay_ec.message());
                }
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP connection established to {}:{}.", get_id_for_logging(), conn_config_.target_host, conn_config_.target_port);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {

    // Static private helper method definition
    std::string Neo4jBoltTransport::_make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string db_part = database_name.empty() ? "system" : database_name;
        if (impersonated_user && !impersonated_user->empty()) {
            return db_part + "@" + *impersonated_user;
        }
        return db_part;
    }

    Neo4jBoltTransport::Neo4jBoltTransport(config::TransportConfig a_config) : config_(std::move(a_config)) {
        if (!config_.logger) {
            config_.logger = config_.get_or_create_logger();
            if (!config_.logger) {
                std::cerr << "CRITICAL ERROR: Logger creation/retrieval failed during Neo4jBoltTransport initialization!" << std::endl;
                throw std::runtime_error("Logger initialization failed for Neo4jBoltTransport.");
            }
        }

        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initializing with URI: '{}'", config_.uri_string);

        if (uri::UriParser::parse(config_.uri_string, parsed_initial_uri_) != boltprotocol::BoltError::SUCCESS) {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty()) {
                if (config_.logger) config_.logger->error("[TransportLC] URI '{}' parsing failed and no initial router override provided. Routing may not work.", config_.uri_string);
            } else if (config_.logger) {
                config_.logger->warn("[TransportLC] URI '{}' parsing failed, but routing is disabled or initial router override is provided.", config_.uri_string);
            }
        } else {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty() && parsed_initial_uri_.is_routing_scheme && !parsed_initial_uri_.hosts_with_ports.empty()) {
                std::vector<routing::ServerAddress> initial_routers_from_uri;
                for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                    initial_routers_from_uri.emplace_back(hp.first, hp.second);
                }
                std::string default_context_key = _make_routing_context_key("", std::nullopt);
                config_.initial_router_addresses_override[default_context_key] = initial_routers_from_uri;
                if (config_.logger) config_.logger->info("[TransportLC] Set {} initial routers from URI for context '{}'.", initial_routers_from_uri.size(), default_context_key);
            }
        }

        config_.prepare_agent_strings();
        finalized_user_agent_ = config_.user_agent_override.empty() ? config_.bolt_agent_info.product : config_.user_agent_override;
        finalized_bolt_agent_info_ = config_.bolt_agent_info;

        if (io_context_.stopped()) {
            io_context_.restart();
        }
        work_guard_ = std::make_unique<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(boost::asio::make_work_guard(io_context_));

        if (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0) {
            eviction_timer_ = std::make_unique<boost::asio::steady_timer>(io_context_);

            uint32_t first_eviction_delay_ms = 10000;
            if (config_.idle_timeout_ms > 0) {
                first_eviction_delay_ms = config_.idle_timeout_ms / 2;
            } else if (config_.max_connection_lifetime_ms > 0) {
                first_eviction_delay_ms = config_.max_connection_lifetime_ms / 4;
            }
            first_eviction_delay_ms = std::max(1000u, first_eviction_delay_ms);

            eviction_timer_->expires_after(std::chrono::milliseconds(first_eviction_delay_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec_lambda) {
                if (ec_lambda != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->info("[TransportLC] Connection eviction task scheduled in {}ms.", first_eviction_delay_ms);
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initialized.");
    }

    Neo4jBoltTransport::~Neo4jBoltTransport() {
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destructing.");
        close();
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destruction complete.");
    }

    void Neo4jBoltTransport::close() {
        bool already_closing = closing_.exchange(true);
        if (already_closing) {
            if (config_.logger) config_.logger->debug("[TransportLC] Close already called or in progress.");
            return;
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closing...");

        if (eviction_timer_) {
            try {
                std::size_t cancelled_count = eviction_timer_->cancel();  // No error_code parameter
                if (config_.logger) {
                    config_.logger->trace("[TransportLC] Eviction timer cancelled {} pending operations.", cancelled_count);
                }
            } catch (const boost::system::system_error& e) {
                if (config_.logger) {
                    config_.logger->warn("[TransportLC] Exception during eviction_timer_.cancel(): {}", e.what());
                }
            }
            eviction_timer_.reset();
            if (config_.logger) config_.logger->trace("[TransportLC] Eviction timer reset.");
        }

        {
            std::lock_guard<std::mutex> lock(pool_mutex_);
            if (config_.logger) config_.logger->debug("[TransportLC] Terminating {} idle connections.", idle_connections_.size());
            for (auto& conn_ptr : idle_connections_) {
                if (conn_ptr) {
                    conn_ptr->terminate(true);
                }
            }
            idle_connections_.clear();
            total_connections_currently_pooled_ = 0;
        }
        pool_condition_.notify_all();

        {
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            routing_tables_.clear();
            if (config_.logger) config_.logger->debug("[TransportLC] Routing tables cleared.");
        }

        if (work_guard_) {
            work_guard_->reset();
        }
        if (!io_context_.stopped()) {
            io_context_.stop();
        }

        if (own_io_thread_ && io_thread_ && io_thread_->joinable()) {
            if (config_.logger) config_.logger->debug("[TransportLC] Joining IO thread...");
            try {
                io_thread_->join();
                if (config_.logger) config_.logger->debug("[TransportLC] IO thread joined.");
            } catch (const std::system_error& e) {
                if (config_.logger) config_.logger->error("[TransportLC] Error joining IO thread: {}", e.what());
            }
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closed.");
    }

    boltprotocol::BoltError Neo4jBoltTransport::verify_connectivity() {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[TransportVerify] Attempting to verify connectivity on a closing transport.");
            return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Verifying connectivity...");

        routing::ServerAddress address_to_verify;
        bool use_routing_for_verify = config_.client_side_routing_enabled && (parsed_initial_uri_.scheme != "bolt" && parsed_initial_uri_.scheme != "bolt+s" && parsed_initial_uri_.scheme != "bolt+ssc");

        if (use_routing_for_verify) {
            auto [addr_err, router_addr] = _get_server_address_for_session(config::SessionParameters{}.with_database("system"), routing::ServerRole::ROUTER);
            if (addr_err != boltprotocol::BoltError::SUCCESS || router_addr.host.empty()) {
                if (config_.logger) config_.logger->warn("[TransportVerify] Failed to get a router address for verification. Error: {}. Falling back to initial URI if possible.", neo4j_bolt_transport::error::bolt_error_to_string(addr_err));
                if (!parsed_initial_uri_.hosts_with_ports.empty()) {
                    const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
                    address_to_verify = routing::ServerAddress(hp.first, hp.second);
                    if (config_.logger) config_.logger->debug("[TransportVerify] Using direct address from URI for verification: {}", address_to_verify.to_string());
                } else {
                    if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No router available and no direct address in URI.");
                    return boltprotocol::BoltError::NETWORK_ERROR;
                }
            } else {
                address_to_verify = router_addr;
            }
        } else {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No direct address in URI for non-routing scheme.");
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
            address_to_verify = routing::ServerAddress(hp.first, hp.second);
        }

        if (address_to_verify.host.empty()) {
            if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: Final address to verify is empty.");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        routing::ServerAddress resolved_address_to_verify = address_to_verify;
        if (config_.server_address_resolver) {
            resolved_address_to_verify = config_.server_address_resolver(address_to_verify);
        }

        if (config_.logger) config_.logger->debug("[TransportVerify] Attempting to acquire connection to {} (resolved from {}) for verification.", resolved_address_to_verify.to_string(), address_to_verify.to_string());

        auto [conn_err, conn] = _acquire_pooled_connection(resolved_address_to_verify, std::nullopt);

        if (conn_err != boltprotocol::BoltError::SUCCESS || !conn) {
            if (config_.logger) config_.logger->error("[TransportVerify] Failed to acquire connection to {} for verification. Error: {}", resolved_address_to_verify.to_string(), neo4j_bolt_transport::error::bolt_error_to_string(conn_err));
            return conn_err;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Connectivity to {} verified successfully (connection {} acquired).", resolved_address_to_verify.to_string(), conn->get_id());
        release_connection(std::move(conn), true);
        return boltprotocol::BoltError::SUCCESS;
    }

    internal::BoltConnectionConfig Neo4jBoltTransport::_create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const {
        internal::BoltConnectionConfig physical_conf;
        physical_conf.target_host = target_address.host;
        physical_conf.target_port = target_address.port;
        physical_conf.auth_token = config_.auth_token;
        physical_conf.user_agent_for_hello = finalized_user_agent_;
        physical_conf.bolt_agent_info_for_hello = finalized_bolt_agent_info_;

        physical_conf.resolved_encryption_strategy = config_.encryption_strategy;
        if (config_.encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT) {
            physical_conf.encryption_enabled = true;
            physical_conf.trusted_certificates_pem_files = config_.trusted_certificates_pem_files;
            physical_conf.client_certificate_pem_file = config_.client_certificate_pem_file;
            physical_conf.client_private_key_pem_file = config_.client_private_key_pem_file;
            physical_conf.client_private_key_password = config_.client_private_key_password;
            physical_conf.hostname_verification_enabled = config_.hostname_verification_enabled;
        } else {
            physical_conf.encryption_enabled = false;
        }

        physical_conf.tcp_connect_timeout_ms = config_.tcp_connect_timeout_ms;
        physical_conf.socket_read_timeout_ms = config_.socket_read_timeout_ms;
        physical_conf.socket_write_timeout_ms = config_.socket_write_timeout_ms;
        physical_conf.socket_keep_alive_enabled = config_.tcp_keep_alive_enabled;
        physical_conf.tcp_no_delay_enabled = config_.tcp_no_delay_enabled;
        physical_conf.bolt_handshake_timeout_ms = config_.hello_timeout_ms;  // Note: This was hello_timeout_ms, perhaps should be a dedicated handshake_timeout_ms in TransportConfig?
        physical_conf.hello_timeout_ms = config_.hello_timeout_ms;
        physical_conf.goodbye_timeout_ms = config_.goodbye_timeout_ms;

        if (routing_context_for_hello.has_value()) {
            physical_conf.hello_routing_context = routing_context_for_hello;
        }

        if (!config_.preferred_bolt_versions.empty()) {
            physical_conf.preferred_bolt_versions = config_.preferred_bolt_versions;
        }

        if (config_.logger) {
            std::string preferred_versions_str = "default";
            if (physical_conf.preferred_bolt_versions.has_value() && !physical_conf.preferred_bolt_versions->empty()) {
                preferred_versions_str.clear();
                for (const auto& v : physical_conf.preferred_bolt_versions.value()) {
                    preferred_versions_str += v.to_string() + " ";
                }
            }
            config_.logger->trace("[TransportLC] Created physical connection config: Host={}, Port={}, Enc={}, Strategy={}, ReadTimeout={}, WriteTimeout={}, HelloTimeout={}, TCPNoDelay={}, HelloRoutingCtx={}, PreferredBoltVersions=[{}]",
                                  physical_conf.target_host,
                                  physical_conf.target_port,
                                  physical_conf.encryption_enabled,
                                  static_cast<int>(physical_conf.resolved_encryption_strategy),
                                  physical_conf.socket_read_timeout_ms,
                                  physical_conf.socket_write_timeout_ms,
                                  physical_conf.hello_timeout_ms,
                                  physical_conf.tcp_no_delay_enabled,
                                  physical_conf.hello_routing_context.has_value() ? "Yes" : "No",
                                  preferred_versions_str);
        }
        return physical_conf;
    }

}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _acquire_pooled_connection:  ** 
    // 
    std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> Neo4jBoltTransport::_acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint /**/) {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[PoolCore]  transport  {} ", target_address.to_string());
            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
        }

        std::unique_lock<std::mutex> lock(pool_mutex_);
        auto start_time = std::chrono::steady_clock::now();

        while (true) {
            // 1.  target_address 
            for (auto it = idle_connections_.begin(); it != idle_connections_.end(); /* manual increment */) {
                internal::BoltPhysicalConnection::PooledConnection& conn_ptr_ref = *it;

                if (conn_ptr_ref->get_config().target_host == target_address.host && conn_ptr_ref->get_config().target_port == target_address.port) {
                    internal::BoltPhysicalConnection::PooledConnection conn_to_check = std::move(conn_ptr_ref);
                    it = idle_connections_.erase(it);  // 
                    total_connections_currently_pooled_--;

                    bool healthy = true;
                    std::string unhealthy_reason;

                    if (conn_to_check->is_defunct()) {
                        healthy = false;
                        unhealthy_reason = "is_defunct";
                    } else if (config_.max_connection_lifetime_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms))) {
                        healthy = false;
                        unhealthy_reason = "exceeded max lifetime";
                    } else if (config_.idle_time_before_health_check_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_time_before_health_check_ms))) {
                        if (config_.logger) config_.logger->trace("[PoolCore]  {} ( {})  (ping)", conn_to_check->get_id(), target_address.to_string());

                        lock.unlock();
                        boltprotocol::BoltError ping_err = conn_to_check->ping(std::chrono::milliseconds(config_.tcp_connect_timeout_ms));
                        lock.lock();

                        if (closing_.load(std::memory_order_acquire)) {
                            if (config_.logger) config_.logger->warn("[PoolCore] Ping  transport ");
                            if (conn_to_check) conn_to_check->terminate(false);
                            total_connections_ever_created_--;
                            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                        }

                        if (ping_err != boltprotocol::BoltError::SUCCESS) {
                            healthy = false;
                            unhealthy_reason = "ping failed (" + error::bolt_error_to_string(ping_err) + ")";
                        } else {
                            if (config_.logger) config_.logger->trace("[PoolCore]  {} ( {}) ping ", conn_to_check->get_id(), target_address.to_string());
                        }
                    }

                    if (healthy) {
                        if (config_.logger) config_.logger->debug("[PoolCore]  {}  {} (: '{}')", conn_to_check->get_id(), target_address.to_string(), database_name_hint.value_or("<>"));
                        conn_to_check->mark_as_used();
                        return {boltprotocol::BoltError::SUCCESS, std::move(conn_to_check)};
                    } else {
                        if (config_.logger) config_.logger->info("[PoolCore] / {} ( {}) (: {}).", (conn_to_check ? conn_to_check->get_id() : 0), target_address.to_string(), unhealthy_reason);
                        if (conn_to_check) conn_to_check->terminate(false);
                        total_connections_ever_created_--;
                        //  idle_connections_  ( erase )
                        // it = idle_connections_.erase(it)  it++
                        continue;
                    }
                }
                ++it;  // 
            }

            // 2.  target_address 
            if (total_connections_ever_created_ < config_.max_connection_pool_size) {
                std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_ctx_opt;
                if (config_.client_side_routing_enabled) {
                    std::map<std::string, boltprotocol::Value> ctx_map;
                    ctx_map["address"] = target_address.to_string();  // HELLO 
                    hello_routing_ctx_opt = ctx_map;
                }

                internal::BoltConnectionConfig physical_conn_conf = _create_physical_connection_config(target_address, hello_routing_ctx_opt);
                std::shared_ptr<spdlog::logger> conn_logger = config_.get_or_create_logger("BoltConnection");

                lock.unlock();
                if (config_.logger) config_.logger->debug("[PoolCore]  {}  (: '{}')", target_address.to_string(), database_name_hint.value_or("<>"));

                auto new_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(physical_conn_conf), io_context_, conn_logger);
                boltprotocol::BoltError establish_err = new_conn->establish();
                lock.lock();

                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] Transport ");
                    if (new_conn) new_conn->terminate(false);
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }

                if (establish_err == boltprotocol::BoltError::SUCCESS) {
                    if (config_.logger) config_.logger->info("[PoolCore]  {}  {} ", target_address.to_string(), new_conn->get_id());
                    total_connections_ever_created_++;
                    new_conn->mark_as_used();
                    return {boltprotocol::BoltError::SUCCESS, std::move(new_conn)};
                } else {
                    if (config_.logger) config_.logger->error("[PoolCore]  {} : {} ({})", target_address.to_string(), static_cast<int>(establish_err), new_conn ? new_conn->get_last_error_message() : error::bolt_error_to_string(establish_err));
                    //  ** 
                    // 
                    return {establish_err, nullptr};
                }
            }

            // 3. 
            auto time_waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time);
            auto remaining_timeout_ms = std::chrono::milliseconds(config_.connection_acquisition_timeout_ms) - time_waited;

            if (remaining_timeout_ms <= std::chrono::milliseconds(0)) {
                if (config_.logger) config_.logger->error("[PoolCore]  {}  (: {})", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // TODO: 
            }

            if (config_.logger) {
                config_.logger->trace("[PoolCore]  ({}/{}) {}ms  {} ",
                                      total_connections_ever_created_,
                                      config_.max_connection_pool_size,  //  ever_created 
                                      remaining_timeout_ms.count(),
                                      target_address.to_string());
            }

            if (pool_condition_.wait_for(lock, remaining_timeout_ms, [this] {
                    return closing_.load(std::memory_order_relaxed) || !idle_connections_.empty();  // 
                })) {
                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore]  transport ");
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
                if (config_.logger) config_.logger->trace("[PoolCore]  transport ");
            } else {
                if (config_.logger) config_.logger->error("[PoolCore]  {}  wait_for  (: {})", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // 
            }
            // 
        }
    }

    void Neo4jBoltTransport::release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy) {
        if (!connection) return;

        bool transport_is_closing = closing_.load(std::memory_order_acquire);
        uint64_t conn_id = connection->get_id();
        routing::ServerAddress conn_target(connection->get_config().target_host, connection->get_config().target_port);

        if (transport_is_closing) {
            if (config_.logger) config_.logger->debug("[PoolCore]  transport  {} ( {}), ", conn_id, conn_target.to_string());
            connection->terminate(false);  //  GOODBYE
            // total_connections_ever_created_ 
            //  total_connections_ever_created_
            std::lock_guard<std::mutex> lock(pool_mutex_);
            total_connections_ever_created_ = std::max(0, (int)total_connections_ever_created_ - 1);  // 
            return;
        }

        std::lock_guard<std::mutex> lock(pool_mutex_);

        if (!mark_as_healthy || connection->is_defunct()) {
            if (config_.logger) config_.logger->info("[PoolCore] / {} ( {}), : {}, : {}", conn_id, conn_target.to_string(), mark_as_healthy, connection->is_defunct());
            connection->terminate(false);
            total_connections_ever_created_--;
            pool_condition_.notify_one();
            return;
        }

        bool should_retire_due_to_age = false;
        if (config_.max_connection_lifetime_ms > 0) {
            auto age = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - connection->get_creation_timestamp());
            if (age.count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                should_retire_due_to_age = true;
                if (config_.logger) config_.logger->info("[PoolCore]  {} ( {}) ", conn_id, conn_target.to_string());
            }
        }

        // max_connection_pool_size 
        // 
        // max_connection_pool_size  total_connections_ever_created_ 
        // total_connections_currently_pooled_ 
        if (should_retire_due_to_age || total_connections_currently_pooled_ >= config_.max_connection_pool_size) {
            if (config_.logger) config_.logger->debug("[PoolCore]  {} ( {}): {}, : {}, (): {}", conn_id, conn_target.to_string(), should_retire_due_to_age, total_connections_currently_pooled_, config_.max_connection_pool_size);
            connection->terminate(true);  //  GOODBYE
            total_connections_ever_created_--;
            pool_condition_.notify_one();
        } else {
            if (config_.logger) config_.logger->debug("[PoolCore]  {} ( {}) : {}", conn_id, conn_target.to_string(), total_connections_currently_pooled_);
            connection->mark_as_used();  // 
            idle_connections_.push_back(std::move(connection));
            total_connections_currently_pooled_++;
            pool_condition_.notify_one();
        }
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::remove_if
#include <chrono>
#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    void Neo4jBoltTransport::_evict_stale_connections_task() {
        if (closing_.load(std::memory_order_acquire)) return;

        if (config_.logger) config_.logger->trace("[PoolEvictor] ...");

        std::unique_lock<std::mutex> lock(pool_mutex_);
        if (closing_.load(std::memory_order_acquire)) return;  // 

        auto now = std::chrono::steady_clock::now();
        int evicted_count = 0;

        auto it_remove = std::remove_if(idle_connections_.begin(), idle_connections_.end(), [&](const internal::BoltPhysicalConnection::PooledConnection& conn_ptr) {
            if (!conn_ptr) return true;  // 

            bool evict = false;
            std::string reason;
            routing::ServerAddress conn_target(conn_ptr->get_config().target_host, conn_ptr->get_config().target_port);

            if (config_.max_connection_lifetime_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                    evict = true;
                    reason = "";
                }
            }
            if (!evict && config_.idle_timeout_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_timeout_ms)) {
                    evict = true;
                    reason = "";
                }
            }
            if (!evict && conn_ptr->is_defunct()) {  // 
                evict = true;
                reason = "";
            }

            if (evict) {
                if (config_.logger) config_.logger->info("[PoolEvictor]  {} ( {}) : {}.", conn_ptr->get_id(), conn_target.to_string(), reason);
                conn_ptr->terminate(false);  //  GOODBYE
                return true;                 // 
            }
            return false;  // 
        });

        evicted_count = std::distance(it_remove, idle_connections_.end());
        if (evicted_count > 0) {
            idle_connections_.erase(it_remove, idle_connections_.end());
            total_connections_currently_pooled_ -= evicted_count;
            total_connections_ever_created_ -= evicted_count;
            if (config_.logger) config_.logger->debug("[PoolEvictor]  {} : {}. : {}", evicted_count, total_connections_currently_pooled_, total_connections_ever_created_);
            pool_condition_.notify_all();  // 
        }
        lock.unlock();  // 

        //  ( transport )
        if (!closing_.load(std::memory_order_acquire) && eviction_timer_ && (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0)) {
            // 1
            uint32_t next_check_interval_ms = 10000;  // 10
            if (config_.idle_timeout_ms > 0 && config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = std::min(config_.idle_timeout_ms, config_.max_connection_lifetime_ms);
            } else if (config_.idle_timeout_ms > 0) {
                next_check_interval_ms = config_.idle_timeout_ms;
            } else if (config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = config_.max_connection_lifetime_ms;
            }
            next_check_interval_ms = std::max(1000u, next_check_interval_ms / 2);

            eviction_timer_->expires_after(std::chrono::milliseconds(next_check_interval_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec) {
                if (ec != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->trace("[PoolEvictor]  {}ms ", next_check_interval_ms);
        } else if (config_.logger) {
            config_.logger->trace("[PoolEvictor]  (transport/)");
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/session_parameters.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/session_handle.h"
// #include "neo4j_bolt_transport/async_session_handle.h" // 
#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"

namespace neo4j_bolt_transport {

    // --- Neo4jBoltTransport - acquire_session () ---
    std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> Neo4jBoltTransport::acquire_session(const config::SessionParameters& params) {
        if (closing_.load(std::memory_order_acquire)) {
            std::string err_msg = " transport ";
            if (config_.logger) config_.logger->warn("[SessionAcq] {}", err_msg);
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->debug("[SessionAcq] : '{}', : {}", params.database_name.value_or("<>"), (params.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"));

        routing::ServerRole role_hint = (params.default_access_mode == config::AccessMode::READ) ? routing::ServerRole::READER : routing::ServerRole::WRITER;

        auto [addr_err, target_server_address] = _get_server_address_for_session(params, role_hint);

        if (addr_err != boltprotocol::BoltError::SUCCESS || target_server_address.host.empty()) {
            std::string err_msg = " (DB: " + params.database_name.value_or("<>") + ", : " + (role_hint == routing::ServerRole::READER ? "R" : "W") + "): " + error::bolt_error_to_string(addr_err);
            if (!target_server_address.host.empty()) {
                err_msg += " (: " + target_server_address.to_string() + ")";
            }
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);
            return {{addr_err, err_msg}, SessionHandle(this, nullptr, params)};
        }

        auto [conn_err_code, pooled_conn] = _acquire_pooled_connection(target_server_address, params.database_name);

        if (conn_err_code != boltprotocol::BoltError::SUCCESS || !pooled_conn) {
            std::string err_msg = " " + target_server_address.to_string() + " : (" + error::bolt_error_to_string(conn_err_code) + ")";
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);

            if (config_.client_side_routing_enabled && conn_err_code == boltprotocol::BoltError::NETWORK_ERROR) {
                std::string db_name_for_routing_key = params.database_name.value_or("");
                //  Neo4jBoltTransport 
                _handle_routing_failure(target_server_address, Neo4jBoltTransport::_make_routing_context_key(db_name_for_routing_key, params.impersonated_user));
            }
            return {{conn_err_code, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->info("[SessionAcq]  {}  {}", pooled_conn->get_id(), target_server_address.to_string());
        return {{boltprotocol::BoltError::SUCCESS, ""}, SessionHandle(this, std::move(pooled_conn), params)};
    }

    // acquire_async_session 
    /*
    boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
    Neo4jBoltTransport::acquire_async_session(const config::SessionParameters& params) {
        // ... () ...
        if (config_.logger) config_.logger->debug("[SessionAcqAsync]  ()");
        co_return std::make_pair(std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, "Async session acquisition not implemented."), AsyncSessionHandle(this, nullptr, params));
    }
    */

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/neo4j_transaction_context.h"

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionContext::TransactionContext(SessionHandle& session) : owner_session_(session) {
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> TransactionContext::run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters) {
        if (!owner_session_.is_in_transaction()) {
            std::string err_msg = "TransactionContext::run called, but SessionHandle is not in an active explicit transaction.";
            boltprotocol::SuccessMessageParams dummy_run_summary_raw;
            auto dummy_field_names = std::make_shared<const std::vector<std::string>>();
            std::vector<boltprotocol::RecordMessageParams> empty_records;

            //  BoltResultStream 
            std::string server_addr = "unknown_server";
            boltprotocol::versions::Version bolt_ver(0, 0);
            bool utc_patch = false;
            if (owner_session_.connection_ && owner_session_.connection_->is_ready_for_queries()) {  // 
                server_addr = owner_session_.connection_->get_config().target_host + ":" + std::to_string(owner_session_.connection_->get_config().target_port);
                bolt_ver = owner_session_.connection_->get_bolt_version();
                utc_patch = owner_session_.connection_->is_utc_patch_active();
            }

            // 
            auto failed_stream = std::make_unique<BoltResultStream>(&owner_session_,
                                                                    std::nullopt,
                                                                    std::move(dummy_run_summary_raw),
                                                                    dummy_field_names,
                                                                    std::move(empty_records),
                                                                    false,  // server_might_have_more
                                                                    bolt_ver,
                                                                    utc_patch,
                                                                    server_addr,
                                                                    owner_session_.session_params_.database_name,  // session_params_  SessionHandle 
                                                                    boltprotocol::BoltError::INVALID_ARGUMENT,     // initial_error
                                                                    err_msg,                                       // initial_error_message
                                                                    std::nullopt                                   // initial_failure_details
            );
            // failed_stream->_set_failure_state(boltprotocol::BoltError::INVALID_ARGUMENT, err_msg); // 

            return {{boltprotocol::BoltError::INVALID_ARGUMENT, err_msg}, std::move(failed_stream)};
        }
        return owner_session_.run_query(cypher, parameters, std::nullopt);
    }

    // SessionHandle  run_consume  run_query_and_consume ResultSummary
    // TransactionContext::run_consume 
    //  SuccessMessageParams  FailureMessageParams
    //  SessionHandle  TransactionContext  ResultSummary 
    //  TransactionContext::run_consume 
    //  SessionHandle  run_query_and_get_raw_summary 
    //
    //  TransactionContext::run_consume  run_query  consume ResultSummary 
    //  SessionHandle  consume 
    //
    //  TransactionContext::run_consume  ResultSummary
    // SessionHandle 
    //
    //  TransactionContext::run_consume  SessionHandle::run_query_and_consume 
    // 
    //
    // **1:  TransactionContext::run_consume  ()**
    // std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary>
    // TransactionContext::run_consume(const std::string& cypher,
    //                                 const std::map<std::string, boltprotocol::Value>& parameters) {
    //     if (!owner_session_.is_in_transaction()) {
    //         // ...  ResultSummary ...
    //         return {{boltprotocol::BoltError::INVALID_ARGUMENT, "Not in transaction"}, ResultSummary(...)};
    //     }
    //     return owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);
    // }

    // **2:  ()**
    std::pair<boltprotocol::BoltError, std::string> TransactionContext::run_consume(const std::string& cypher,
                                                                                    const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                    boltprotocol::SuccessMessageParams& out_summary_raw,  // 
                                                                                    boltprotocol::FailureMessageParams& out_failure_raw) {
        if (!owner_session_.is_in_transaction()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "TransactionContext::run_consume called, but SessionHandle is not in an active explicit transaction."};
        }

        //  SessionHandle  run_query_and_consume
        auto [err_pair, result_summary_typed] = owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);

        //  ResultSummary 
        out_summary_raw = result_summary_typed.raw_params();  //  ResultSummary  raw_params()
                                                              //  ResultSummary 

        if (err_pair.first != boltprotocol::BoltError::SUCCESS) {
            //  ResultStream  out_failure_raw
            // BoltResultStream *stream_ptr_for_failure = nullptr; // 
            // if (stream_ptr_for_failure && stream_ptr_for_failure->has_failed()){
            //    out_failure_raw = stream_ptr_for_failure->get_failure_details();
            // } else {
            out_failure_raw.metadata["message"] = boltprotocol::Value(err_pair.second);
            // }
        } else {
            out_failure_raw.metadata.clear();  // 
        }
        return err_pair;
    }

}  // namespace neo4j_bolt_transport#include <iostream>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::tuple<boltprotocol::BoltError, std::string, ResultSummary> BoltResultStream::consume() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consuming stream.", (void*)this);

        if (stream_failed_) {
            // If failed, final_summary_typed_ might not be meaningful or might be from RUN.
            // Return run_summary_typed_ or a default-constructed ResultSummary if even that is bad.
            // For now, return existing final_summary_typed_ which should be default/run summary.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }
        if (stream_fully_consumed_or_discarded_) {
            return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
        }

        auto discard_result_pair = _discard_all_remaining_records();  // This will update final_summary_typed_ internally via _update_final_summary

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            // _set_failure_state was called by _discard_all_remaining_records
            // final_summary_typed_ might reflect the RUN summary in this case.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }

        // Update session bookmarks from the final summary for auto-commit sessions.
        // This happens only if consume was successful and it was an auto-commit query.
        if (owner_session_ && !owner_session_->is_in_transaction() && !stream_failed_) {
            auto it_bookmark = final_summary_typed_.raw_params().metadata.find("bookmark");
            if (it_bookmark != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                owner_session_->update_bookmarks({std::get<std::string>(it_bookmark->second)});
            } else {
                if (failure_reason_ == boltprotocol::BoltError::SUCCESS) {  // Only clear if server operation was success
                    owner_session_->update_bookmarks({});
                }
            }
        }
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consume successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 
#include <utility>   // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_fetch_more_records(int64_t n) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            std::string msg = "Fetch records: Invalid session or connection.";
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, msg);
            if (logger) logger->warn("[ResultStreamFETCH {}] {}", (void*)this, msg);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || (stream_fully_consumed_or_discarded_ && !is_first_pull_attempt_)) {
            if (logger) logger->trace("[ResultStreamFETCH {}] Already failed or consumed. Failed: {}, Consumed: {}, FirstPull: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_, is_first_pull_attempt_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::UNKNOWN_ERROR, failure_message_};
        }

        if (logger) logger->trace("[ResultStreamFETCH {}] Fetching {} records. QID: {}", (void*)this, n, (query_id_ ? std::to_string(*query_id_) : "auto"));

        std::vector<boltprotocol::RecordMessageParams> fetched_records;
        boltprotocol::SuccessMessageParams current_pull_summary_raw;  //  _stream_pull_records 

        std::optional<int64_t> qid_for_this_pull = query_id_;

        //  SessionHandle 
        auto pull_result_pair = owner_session_->_stream_pull_records(qid_for_this_pull, n, fetched_records, current_pull_summary_raw);
        is_first_pull_attempt_ = false;  //  PULL

        if (pull_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            //  PULL 
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != pull_result_pair.first) {  // 
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    // temp_fail.metadata["code"] = ... ( BoltPhysicalConnection  Neo4j )
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(pull_result_pair.first, pull_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamFETCH {}] _stream_pull_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(pull_result_pair.first), pull_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        // PULL  SUCCESS 
        _update_final_summary(std::move(current_pull_summary_raw));  //  final_summary_typed_

        for (auto& rec : fetched_records) {
            raw_record_buffer_.push_back(std::move(rec));
        }

        //  final_summary_typed_  has_more
        auto it_has_more = final_summary_typed_.raw_params().metadata.find("has_more");
        if (it_has_more != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
            server_has_more_records_ = std::get<bool>(it_has_more->second);
        } else {
            server_has_more_records_ = false;  //  PULL  "has_more"
        }

        if (!server_has_more_records_ && raw_record_buffer_.empty()) {
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamFETCH {}] Fetched {}. Buffer: {}. ServerMore: {}", (void*)this, fetched_records.size(), raw_record_buffer_.size(), server_has_more_records_);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_discard_all_remaining_records() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discarding. QID: {}", (void*)this, (query_id_ ? std::to_string(*query_id_) : "auto"));

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Discard: Invalid session/connection.");
            if (logger) logger->warn("[ResultStreamDISCARD {}] Invalid session/connection.", (void*)this);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamDISCARD {}] Already failed or consumed. Failed: {}, Consumed: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::SUCCESS, failure_message_};
        }

        raw_record_buffer_.clear();  // 

        //  DISCARD
        // server_has_more_records_  PULL/DISCARD  has_more 
        // initial_server_has_more_records_  RUN  has_more 
        // is_first_pull_attempt_  PULL  DISCARD
        bool needs_server_discard = false;
        if (is_first_pull_attempt_) {  // PULL/DISCARD
            needs_server_discard = initial_server_has_more_records_;
        } else {  // PULL/DISCARD
            needs_server_discard = server_has_more_records_;
        }

        if (!needs_server_discard) {
            stream_fully_consumed_or_discarded_ = true;
            // RUN  consume RUN 
            // final_summary_typed_  run_summary_typed_
            // _update_final_summary  run_summary  final_summary
            // PULLfinal_summary_typed_ PULL
            if (is_first_pull_attempt_) {
                //  final_summary_typed_  run_summary_typed_ 
                // _update_final_summary(boltprotocol::SuccessMessageParams(run_summary_typed_.raw_params()));
                //  final_summary_typed_  run_summary_typed_ 
            }
            if (logger) logger->trace("[ResultStreamDISCARD {}] No records on server to discard. FirstPull: {}, InitialServerMore: {}, CurrentServerMore: {}", (void*)this, is_first_pull_attempt_, initial_server_has_more_records_, server_has_more_records_);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        //  DISCARD
        boltprotocol::SuccessMessageParams discard_summary_raw;  // 
        std::optional<int64_t> qid_for_discard = query_id_;

        auto discard_result_pair = owner_session_->_stream_discard_records(qid_for_discard, -1, discard_summary_raw);
        is_first_pull_attempt_ = false;              //  PULL/DISCARD
        stream_fully_consumed_or_discarded_ = true;  // DISCARD 

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != discard_result_pair.first) {
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(discard_result_pair.first, discard_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamDISCARD {}] _stream_discard_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(discard_result_pair.first), discard_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        _update_final_summary(std::move(discard_summary_raw));  //  final_summary_typed_
        server_has_more_records_ = false;                       // DISCARD 
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discard successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // ... (has_next ) ...
    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::has_next(bool& out_has_next) {
        out_has_next = false;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream already failed. Reason: {}", (void*)this, static_cast<int>(failure_reason_));
            return {failure_reason_, failure_message_};
        }
        if (stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream fully consumed/discarded.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }
        if (!raw_record_buffer_.empty()) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Records in buffer.", (void*)this);
            out_has_next = true;
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        bool effectively_has_more_on_server = is_first_pull_attempt_ ? initial_server_has_more_records_ : server_has_more_records_;

        if (!effectively_has_more_on_server) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, server indicates no more records.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
            //  final_summary_typed_ 
            //  run_summary_typed_  PULL 
            //  PULL/DISCARD RUN final_summary  run_summary
            if (is_first_pull_attempt_) {
                //  final_summary_typed_  run_summary_typed_ 
                //  BoltResultStream final_summary_typed_  run_summary_params_raw 
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        int64_t fetch_n = 1000;  // 
        if (owner_session_ && owner_session_->session_params_.default_fetch_size != 0) {
            fetch_n = (owner_session_->session_params_.default_fetch_size > 0 || owner_session_->session_params_.default_fetch_size == -1) ? owner_session_->session_params_.default_fetch_size : 1000;
        }

        if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, attempting to fetch {} records.", (void*)this, fetch_n);
        auto fetch_result = _fetch_more_records(fetch_n);  //  final_summary_typed_

        if (fetch_result.first != boltprotocol::BoltError::SUCCESS) {
            return fetch_result;  // _fetch_more_records 
        }

        out_has_next = !raw_record_buffer_.empty();
        if (!out_has_next && !server_has_more_records_) {  // 
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Fetched, buffer still empty, PULL confirms no more.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamITER {}] has_next: After fetch, out_has_next={}", (void*)this, out_has_next);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::next() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        bool has_more = false;
        auto has_next_res_pair = has_next(has_more);  // has_next_res_pair  std::pair

        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);  //  pair 

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            return {err_code_has_next, std::move(err_msg_has_next), std::nullopt};
        }
        if (!has_more) {
            if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};
            if (logger) logger->trace("[ResultStreamITER {}] next: No more records.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, "No more records in stream.", std::nullopt};
        }

        if (raw_record_buffer_.empty() && !stream_failed_) {
            _set_failure_state(boltprotocol::BoltError::UNKNOWN_ERROR, "Internal error: has_next() was true but buffer is empty and not failed.");
            if (logger) logger->error("[ResultStreamITER {}] next: Internal error - has_next true but buffer empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }
        if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};

        boltprotocol::RecordMessageParams raw_record_params = std::move(raw_record_buffer_.front());
        raw_record_buffer_.pop_front();

        if (logger) logger->trace("[ResultStreamITER {}] next: Popped one record. Buffer size: {}", (void*)this, raw_record_buffer_.size());

        BoltRecord record(std::move(raw_record_params.fields), field_names_ptr_cache_);
        return {boltprotocol::BoltError::SUCCESS, "", std::make_optional<BoltRecord>(std::move(record))};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::single() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] single() called.", (void*)this);

        auto next_result_tuple = next();  //  next()
        boltprotocol::BoltError err_code_next = std::get<0>(next_result_tuple);
        std::string err_msg_next = std::get<1>(std::move(next_result_tuple));
        std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_result_tuple));

        if (err_code_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error from first next(): {}.", (void*)this, err_msg_next);
            return {err_code_next, std::move(err_msg_next), std::nullopt};
        }
        if (!record_opt.has_value()) {
            if (stream_failed_) {  //  next()  has_next() -> _fetch_more_records() 
                if (logger) logger->trace("[ResultStreamITER {}] single(): No record, stream failed. Reason: {}.", (void*)this, failure_message_);
                return {failure_reason_, failure_message_, std::nullopt};
            }
            //  next() 
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but stream was empty.");
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, stream empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        // 
        bool has_more_records = false;
        auto has_next_res_pair = has_next(has_more_records);
        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error checking for more records after finding one: {}.", (void*)this, err_msg_has_next);
            _set_failure_state(err_code_has_next, "Error checking for subsequent records in single(): " + err_msg_has_next);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (has_more_records) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, but more found. Discarding rest.", (void*)this);
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamITER {}] single(): Discarding extra records failed: {}", (void*)this, discard_res.second);
            }
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but found more.");
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (logger) logger->trace("[ResultStreamITER {}] single() successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", std::move(record_opt)};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> BoltResultStream::list_all() {
        std::vector<BoltRecord> all_records_converted;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] list_all: Starting.", (void*)this);

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] list_all: Stream already failed.", (void*)this);
            return {failure_reason_, failure_message_, std::move(all_records_converted)};
        }

        while (true) {
            auto next_res_tuple = next();
            boltprotocol::BoltError err_code = std::get<0>(next_res_tuple);
            std::string err_msg = std::get<1>(std::move(next_res_tuple));                   // 
            std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_res_tuple));  // 

            if (err_code != boltprotocol::BoltError::SUCCESS) {
                if (logger) logger->warn("[ResultStreamITER {}] list_all: Error from next(): {}.", (void*)this, err_msg);
                // 
                return {err_code, std::move(err_msg), std::move(all_records_converted)};
            }
            if (!record_opt.has_value()) {  // 
                if (logger) logger->trace("[ResultStreamITER {}] list_all: End of stream reached by next().", (void*)this);
                break;
            }
            all_records_converted.push_back(std::move(*record_opt));  //  optional  BoltRecord
        }

        if (logger) logger->trace("[ResultStreamITER {}] list_all: Finished. Records: {}", (void*)this, all_records_converted.size());
        return {boltprotocol::BoltError::SUCCESS, "", std::move(all_records_converted)};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    BoltResultStream::BoltResultStream(SessionHandle* session,
                                       std::optional<int64_t> query_id_for_streaming,
                                       boltprotocol::SuccessMessageParams run_summary_params_raw,
                                       std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                                       std::vector<boltprotocol::RecordMessageParams> initial_records,
                                       bool server_might_have_more,
                                       const boltprotocol::versions::Version& bolt_version,
                                       bool utc_patch_active,
                                       const std::string& server_address_for_summary,
                                       const std::optional<std::string>& database_name_for_summary,
                                       boltprotocol::BoltError initial_error,
                                       const std::string& initial_error_message,
                                       const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details)
        : owner_session_(session),
          query_id_(query_id_for_streaming),
          field_names_ptr_cache_(std::move(field_names_ptr)),
          // Initialize run_summary_typed_ with a copy of raw params for now
          run_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          // final_summary_typed_ initialized similarly, will be updated by _update_final_summary
          final_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          initial_server_has_more_records_(server_might_have_more),
          server_has_more_records_(server_might_have_more),
          bolt_version_cache_(bolt_version),
          utc_patch_active_cache_(utc_patch_active),
          server_address_cache_(server_address_for_summary),
          database_name_cache_(database_name_for_summary) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        for (auto&& rec_param : initial_records) {
            raw_record_buffer_.push_back(std::move(rec_param));
        }

        if (initial_error != boltprotocol::BoltError::SUCCESS) {
            _set_failure_state(initial_error, initial_error_message, initial_failure_details);
        } else if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Session or connection invalid at ResultStream creation.");
        }

        // Ensure field_names_ptr_cache_ is populated from run_summary_typed_ if it was null
        if (!field_names_ptr_cache_ || field_names_ptr_cache_->empty()) {
            auto it_fields = run_summary_typed_.raw_params().metadata.find("fields");
            if (it_fields != run_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
                auto temp_field_names = std::make_shared<std::vector<std::string>>();
                const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
                if (list_ptr) {
                    temp_field_names->reserve(list_ptr->elements.size());
                    for (const auto& field_val : list_ptr->elements) {
                        if (std::holds_alternative<std::string>(field_val)) {
                            temp_field_names->push_back(std::get<std::string>(field_val));
                        }
                    }
                }
                field_names_ptr_cache_ = std::const_pointer_cast<const std::vector<std::string>>(temp_field_names);
            } else {
                field_names_ptr_cache_ = std::make_shared<const std::vector<std::string>>();  // Empty
            }
        }

        if (!stream_failed_) {
            // If no records were pipelined and server RUN summary says no more, then stream is done.
            if (raw_record_buffer_.empty() && !initial_server_has_more_records_) {
                stream_fully_consumed_or_discarded_ = true;
                // final_summary_typed_ is already a copy of run_summary_typed_ here
            }
        }

        // A PULL/DISCARD is needed if: buffer is empty AND server might have more records (initial_server_has_more_records_) AND not failed
        is_first_pull_attempt_ = raw_record_buffer_.empty() && initial_server_has_more_records_ && !stream_failed_;

        if (logger) {
            logger->debug("[ResultStreamLC {}] Created. QID: {}. InitRecs: {}. InitialSrvMore: {}. Failed: {}. FirstPullAttempt: {}", (void*)this, query_id_ ? std::to_string(*query_id_) : "N/A", raw_record_buffer_.size(), initial_server_has_more_records_, stream_failed_, is_first_pull_attempt_);
        }
    }

    BoltResultStream::~BoltResultStream() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->debug("[ResultStreamLC {}] Destructing. Consumed: {}, Failed: {}", (void*)this, stream_fully_consumed_or_discarded_, stream_failed_);
        }

        if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
            if (logger) logger->trace("[ResultStreamLC {}] Auto-discarding in dtor.", (void*)this);
            // This will update final_summary_typed_
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamLC {}] Auto-discard in dtor failed: {}", (void*)this, discard_res.second);
            }
        }
    }

    BoltResultStream::BoltResultStream(BoltResultStream&& other) noexcept
        : owner_session_(other.owner_session_),
          query_id_(other.query_id_),
          raw_record_buffer_(std::move(other.raw_record_buffer_)),
          field_names_ptr_cache_(std::move(other.field_names_ptr_cache_)),
          run_summary_typed_(std::move(other.run_summary_typed_)),
          final_summary_typed_(std::move(other.final_summary_typed_)),
          failure_details_raw_(std::move(other.failure_details_raw_)),
          server_has_more_records_(other.server_has_more_records_),
          initial_server_has_more_records_(other.initial_server_has_more_records_),
          stream_fully_consumed_or_discarded_(other.stream_fully_consumed_or_discarded_),
          stream_failed_(other.stream_failed_),
          failure_reason_(other.failure_reason_),
          failure_message_(std::move(other.failure_message_)),
          is_first_pull_attempt_(other.is_first_pull_attempt_),
          bolt_version_cache_(other.bolt_version_cache_),
          utc_patch_active_cache_(other.utc_patch_active_cache_),
          server_address_cache_(std::move(other.server_address_cache_)),
          database_name_cache_(std::move(other.database_name_cache_)) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamLC {}] Move constructed from ResultStream {}.", (void*)this, (void*)&other);

        other.owner_session_ = nullptr;  // Invalidate other
        other.stream_fully_consumed_or_discarded_ = true;
        other.stream_failed_ = true;  // Mark other as unusable
    }

    BoltResultStream& BoltResultStream::operator=(BoltResultStream&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
            if (logger) logger->trace("[ResultStreamLC {}] Move assigning from ResultStream {}.", (void*)this, (void*)&other);

            // Discard current stream's resources if it's still active
            if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
                _discard_all_remaining_records();
            }

            owner_session_ = other.owner_session_;
            query_id_ = other.query_id_;
            raw_record_buffer_ = std::move(other.raw_record_buffer_);
            field_names_ptr_cache_ = std::move(other.field_names_ptr_cache_);
            run_summary_typed_ = std::move(other.run_summary_typed_);
            final_summary_typed_ = std::move(other.final_summary_typed_);
            failure_details_raw_ = std::move(other.failure_details_raw_);
            server_has_more_records_ = other.server_has_more_records_;
            initial_server_has_more_records_ = other.initial_server_has_more_records_;
            stream_fully_consumed_or_discarded_ = other.stream_fully_consumed_or_discarded_;
            stream_failed_ = other.stream_failed_;
            failure_reason_ = other.failure_reason_;
            failure_message_ = std::move(other.failure_message_);
            is_first_pull_attempt_ = other.is_first_pull_attempt_;
            bolt_version_cache_ = other.bolt_version_cache_;
            utc_patch_active_cache_ = other.utc_patch_active_cache_;
            server_address_cache_ = std::move(other.server_address_cache_);
            database_name_cache_ = std::move(other.database_name_cache_);

            other.owner_session_ = nullptr;  // Invalidate other
            other.stream_fully_consumed_or_discarded_ = true;
            other.stream_failed_ = true;
        }
        return *this;
    }

    const std::vector<std::string>& BoltResultStream::field_names() const {
        static const std::vector<std::string> empty_names_singleton;
        return field_names_ptr_cache_ ? *field_names_ptr_cache_ : empty_names_singleton;
    }

    void BoltResultStream::_set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details) {
        if (stream_failed_ && failure_reason_ != boltprotocol::BoltError::SUCCESS) {
            // Already in a more specific failure state, don't override with a potentially less specific one unless reason is new.
            // However, allow updating message if new details are provided.
            if (!detailed_message.empty() && failure_message_.find(detailed_message) == std::string::npos) {
                failure_message_ += "; Additional detail: " + detailed_message;
            }
            if (details.has_value() && failure_details_raw_.metadata.empty()) {  // Only update raw details if not already set
                failure_details_raw_ = *details;
            }
            return;
        }
        stream_failed_ = true;
        failure_reason_ = reason;
        failure_message_ = std::move(detailed_message);

        if (details.has_value()) {
            failure_details_raw_ = *details;
        } else {
            failure_details_raw_.metadata.clear();  // Ensure it's clear
            if (!failure_message_.empty() && reason != boltprotocol::BoltError::SUCCESS) {
                // Create a minimal failure detail from the message
                failure_details_raw_.metadata["message"] = boltprotocol::Value(failure_message_);
            }
        }
        stream_fully_consumed_or_discarded_ = true;  // A failed stream is considered consumed

        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->warn("[ResultStreamLC {}] Failure state set. Reason: {} ({}), Msg: {}", (void*)this, static_cast<int>(reason), error::bolt_error_to_string(reason), failure_message_);
        }
    }

    // New private helper to update final_summary_typed_
    void BoltResultStream::_update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary) {
        final_summary_typed_ = ResultSummary(std::move(pull_or_discard_raw_summary), bolt_version_cache_, utc_patch_active_cache_, server_address_cache_, database_name_cache_);
    }

}  // namespace neo4j_bolt_transport// Source/result_stream_state.cpp
// This file is intentionally left empty or can be removed from the build
// if its only purpose was to define methods now inlined in result_stream.h
// (has_failed, get_failure_reason, get_failure_message, get_failure_details).

// #include "neo4j_bolt_transport/result_stream.h"
// namespace neo4j_bolt_transport {} // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/result_summary.h"

#include <iostream>  // For potential debug

namespace neo4j_bolt_transport {

    // Helper to safely get a string from a Bolt Value
    std::optional<std::string> get_string_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<std::string>(val)) {
            return std::get<std::string>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get an int64 from a Bolt Value
    std::optional<int64_t> get_int64_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<int64_t>(val)) {
            return std::get<int64_t>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get a bool from a Bolt Value
    std::optional<bool> get_bool_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<bool>(val)) {
            return std::get<bool>(val);
        }
        return std::nullopt;
    }

    ResultSummary::ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active, const std::string& srv_address, const std::optional<std::string>& db_name_from_session)
        : raw_params_(std::move(server_summary_params)), server_address_(srv_address) {
        // Determine effective database name
        auto db_it = raw_params_.metadata.find("db");
        if (db_it != raw_params_.metadata.end()) {
            if (auto db_str = get_string_val(db_it->second)) {
                database_name_ = *db_str;
            }
        }
        if (database_name_.empty() && db_name_from_session.has_value()) {
            database_name_ = *db_name_from_session;
        }
        if (database_name_.empty()) {
            // Fallback if not in summary and not in session (e.g. system db for older Neo4j)
            database_name_ = "system";  // Or "" if that's preferred for default
        }

        parse_metadata(bolt_version, utc_patch_active);
    }

    void ResultSummary::parse_query_type(const boltprotocol::Value& type_val_variant) {
        if (auto type_str_opt = get_string_val(type_val_variant)) {
            const std::string& type_str = *type_str_opt;
            if (type_str == "r")
                query_type_ = QueryType::READ_ONLY;
            else if (type_str == "rw")
                query_type_ = QueryType::READ_WRITE;
            else if (type_str == "w")
                query_type_ = QueryType::WRITE_ONLY;
            else if (type_str == "s")
                query_type_ = QueryType::SCHEMA_WRITE;
            else
                query_type_ = QueryType::UNKNOWN;
        }
    }

    void ResultSummary::parse_counters(const boltprotocol::Value& counters_val_variant) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant)) {
            const auto& counters_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant);
            if (counters_map_ptr) {
                const auto& m = counters_map_ptr->pairs;
                auto get_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_int64_val(it->second).value_or(0);
                    }
                    return int64_t{0};
                };
                auto get_bool_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_bool_val(it->second).value_or(false);
                    }
                    return false;
                };

                counters_.nodes_created = get_counter("nodes-created");
                counters_.nodes_deleted = get_counter("nodes-deleted");
                counters_.relationships_created = get_counter("relationships-created");
                counters_.relationships_deleted = get_counter("relationships-deleted");
                counters_.properties_set = get_counter("properties-set");
                counters_.labels_added = get_counter("labels-added");
                counters_.labels_removed = get_counter("labels-removed");
                counters_.indexes_added = get_counter("indexes-added");
                counters_.indexes_removed = get_counter("indexes-removed");
                counters_.constraints_added = get_counter("constraints-added");
                counters_.constraints_removed = get_counter("constraints-removed");
                counters_.system_updates = get_counter("system-updates");                         // Bolt 4.3+
                counters_.contains_system_updates = get_bool_counter("contains-system-updates");  // Bolt 5.0+

                // contains-updates logic:
                // True if any of the specific counters > 0 OR if "contains-updates" is explicitly true
                counters_.contains_updates = (counters_.nodes_created > 0 || counters_.nodes_deleted > 0 || counters_.relationships_created > 0 || counters_.relationships_deleted > 0 || counters_.properties_set > 0 || counters_.labels_added > 0 || counters_.labels_removed > 0 ||
                                              counters_.indexes_added > 0 || counters_.indexes_removed > 0 || counters_.constraints_added > 0 || counters_.constraints_removed > 0);
                // If server provides "contains-updates", respect it
                auto it_contains_updates = m.find("contains-updates");
                if (it_contains_updates != m.end()) {
                    if (auto b_val = get_bool_val(it_contains_updates->second)) {
                        counters_.contains_updates = *b_val;
                    }
                }

                if (counters_.system_updates > 0 && !counters_.contains_system_updates) {
                    // if system_updates > 0, contains_system_updates should be true.
                    // This might indicate an older server version or an inconsistency.
                    // For safety, set contains_system_updates if system_updates is positive.
                    counters_.contains_system_updates = true;
                }
            }
        }
    }

    void ResultSummary::parse_notifications(const boltprotocol::Value& notifications_val_variant, const boltprotocol::versions::Version& bolt_version) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant);
            if (list_ptr) {
                notifications_.reserve(list_ptr->elements.size());
                for (const auto& item_val : list_ptr->elements) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(item_val)) {
                        const auto& map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(item_val);
                        if (map_ptr) {
                            ServerNotification notif;
                            const auto& m = map_ptr->pairs;
                            auto find_str = [&](const std::string& key) -> std::optional<std::string> {
                                auto it = m.find(key);
                                if (it != m.end()) return get_string_val(it->second);
                                return std::nullopt;
                            };

                            notif.code = find_str("code").value_or("");
                            notif.title = find_str("title").value_or("");
                            notif.description = find_str("description").value_or("");
                            notif.severity = find_str("severity").value_or("");  // Bolt 4.1+
                            if (bolt_version.major > 5 || (bolt_version.major == 5 && bolt_version.minor >= 2)) {
                                notif.category = find_str("category").value_or("");
                            }

                            auto pos_it = m.find("position");
                            if (pos_it != m.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second)) {
                                const auto& pos_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second);
                                if (pos_map_ptr) notif.position = pos_map_ptr->pairs;
                            }
                            notifications_.push_back(std::move(notif));
                        }
                    }
                }
            }
        }
    }

    void ResultSummary::parse_metadata(const boltprotocol::versions::Version& bolt_version, bool /*utc_patch_active*/) {
        // Extract common fields
        auto t_start_it = raw_params_.metadata.find("t_first");  // Time to first record (RUN response) or available (PULL/DISCARD response)
        if (t_start_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_start_it->second)) {
                result_available_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto t_end_it = raw_params_.metadata.find("t_last");  // Time to last record (PULL/DISCARD response)
        if (t_end_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_end_it->second)) {
                result_consumed_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto type_it = raw_params_.metadata.find("type");
        if (type_it != raw_params_.metadata.end()) {
            parse_query_type(type_it->second);
        }

        auto counters_it = raw_params_.metadata.find("stats");
        if (counters_it != raw_params_.metadata.end()) {
            parse_counters(counters_it->second);
        }

        auto notifications_it = raw_params_.metadata.find("notifications");
        if (notifications_it != raw_params_.metadata.end()) {
            parse_notifications(notifications_it->second, bolt_version);
        }

        // Plan and Profile parsing would go here if implemented
        // auto plan_it = raw_params_.metadata.find("plan");
        // if (plan_it != raw_params_.metadata.end()) { ... parse plan ... }
        // auto profile_it = raw_params_.metadata.find("profile"); // or "profiled-plan"
        // if (profile_it != raw_params_.metadata.end()) { ... parse profile ... }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _get_server_address_for_session: 
    std::pair<boltprotocol::BoltError, routing::ServerAddress> Neo4jBoltTransport::_get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint) {
        if (config_.logger) {
            config_.logger->trace(
                "[AddrSelect] , : '{}', : {}, : '{}'", params.database_name.value_or("<>"), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), params.impersonated_user.value_or("<>"));
        }

        //  bolt:// 
        if (!config_.client_side_routing_enabled || parsed_initial_uri_.scheme == "bolt" || parsed_initial_uri_.scheme == "bolt+s" || parsed_initial_uri_.scheme == "bolt+ssc") {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[AddrSelect] ");
                return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            }
            // URI
            const auto& host_port = parsed_initial_uri_.hosts_with_ports.front();
            routing::ServerAddress resolved_address(host_port.first, host_port.second);

            // 
            if (config_.server_address_resolver) {
                routing::ServerAddress original_address = resolved_address;
                resolved_address = config_.server_address_resolver(original_address);
                if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                    config_.logger->debug("[AddrSelect] : {} -> {}", original_address.to_string(), resolved_address.to_string());
                }
            }
            if (config_.logger) config_.logger->debug("[AddrSelect] : {}", resolved_address.to_string());
            return {boltprotocol::BoltError::SUCCESS, resolved_address};
        }

        // ---  ---
        //  neo4j:// /
        //  system 
        //  (database_name, impersonated_user) 
        std::string db_name_for_routing_key = params.database_name.value_or("");

        // 
        std::shared_ptr<routing::RoutingTable> routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);

        if (!routing_table) {
            if (config_.logger) config_.logger->error("[AddrSelect]  '{}'  (: '{}')", db_name_for_routing_key, params.impersonated_user.value_or("<>"));
            return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 
        }

        // 
        // 
        int attempts = 0;
        const int max_selection_attempts = config_.routing_max_retry_attempts > 0 ? config_.routing_max_retry_attempts : 3;  // 1

        while (attempts < max_selection_attempts) {
            attempts++;
            if (routing_table->is_stale() && attempts > 1) {  // 
                if (config_.logger) config_.logger->info("[AddrSelect]  '{}'  {} ", routing_table->get_database_context_key(), attempts);
                // /
                routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);
                if (!routing_table) {
                    if (config_.logger) config_.logger->error("[AddrSelect]  '{}' ", db_name_for_routing_key);
                    return {boltprotocol::BoltError::NETWORK_ERROR, {}};
                }
            }

            std::optional<routing::ServerAddress> server_address_opt = routing_table->get_server(role_hint);

            if (server_address_opt) {
                routing::ServerAddress resolved_address = *server_address_opt;
                // 
                if (config_.server_address_resolver) {
                    routing::ServerAddress original_address = resolved_address;
                    resolved_address = config_.server_address_resolver(original_address);
                    if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                        config_.logger->debug("[AddrSelect] : {} -> {}", original_address.to_string(), resolved_address.to_string());
                    }
                }
                if (config_.logger) config_.logger->info("[AddrSelect] : {} (: {}), : {}", resolved_address.to_string(), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), attempts);
                return {boltprotocol::BoltError::SUCCESS, resolved_address};
            } else {
                if (config_.logger) config_.logger->warn("[AddrSelect]  {} :  '{}'  {} ", attempts, routing_table->get_database_context_key(), static_cast<int>(role_hint));
                if (attempts < max_selection_attempts) {
                    routing_table->mark_as_stale();  // 
                                                     //  sleep
                }
            }
        }  // end while attempts

        if (config_.logger) config_.logger->error("[AddrSelect]  '{}'  {} ", routing_table->get_database_context_key(), static_cast<int>(role_hint));
        return {boltprotocol::BoltError::NETWORK_ERROR, {}};  //  "No suitable server found"
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 
    void Neo4jBoltTransport::_handle_routing_failure(const routing::ServerAddress& failed_address,
                                                     const std::string& database_context_key) {  // database_context_key 

        if (!config_.client_side_routing_enabled) {
            return;  // 
        }

        if (config_.logger) {
            config_.logger->info("[RoutingFail] :  {},  {}", failed_address.to_string(), database_context_key);
        }

        std::lock_guard<std::mutex> lock(routing_table_mutex_);
        auto it = routing_tables_.find(database_context_key);
        if (it != routing_tables_.end()) {
            std::shared_ptr<routing::RoutingTable> table = it->second;
            if (table) {
                table->forget_server(failed_address);  // 
                // writer
                // RoutingTable::forget_server  mark_as_stale()
                //  table->mark_as_stale();
                if (config_.logger) {
                    config_.logger->debug("[RoutingFail]  '{}'  {}", database_context_key, failed_address.to_string());
                    if (table->is_stale()) {
                        config_.logger->info("[RoutingFail]  '{}' ", database_context_key);
                    }
                }
            }
        } else {
            if (config_.logger) {
                config_.logger->warn("[RoutingFail]  '{}' ", database_context_key);
            }
        }
    }

}  // namespace neo4j_bolt_transport#include <chrono>  // For std::chrono::seconds default TTL

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    //  pool_core.cpp 
    // static std::string make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
    //     std::string db_part = database_name.empty() ? "system" : database_name;
    //     if (impersonated_user && !impersonated_user->empty()) {
    //         return db_part + "@" + *impersonated_user;
    //     }
    //     return db_part;
    // }
    // ^^^  .cpp  Neo4jBoltTransport 
    //  neo4j_bolt_transport_pool_core.cpp 
    //  Neo4jBoltTransport 
    // 
    // ( util.h )
    namespace detail {  // 
        std::string make_routing_context_key_for_manager(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
            std::string db_part = database_name.empty() ? "system" : database_name;
            if (impersonated_user && !impersonated_user->empty()) {
                return db_part + "@" + *impersonated_user;
            }
            return db_part;
        }
    }  // namespace detail

    // 
    std::shared_ptr<routing::RoutingTable> Neo4jBoltTransport::_get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string context_key = detail::make_routing_context_key_for_manager(database_name, impersonated_user);
        std::shared_ptr<routing::RoutingTable> table;
        std::vector<routing::ServerAddress> initial_routers_for_this_context;  // 

        {  //  routing_tables_ 
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            auto it = routing_tables_.find(context_key);
            if (it != routing_tables_.end()) {
                table = it->second;
            } else {
                //  TTL (300)
                // : config_.routing_table_default_ttl_seconds ()
                unsigned int default_ttl_seconds = 300;
                // if (config_.routing_table_default_ttl_seconds.has_value()) {
                //    default_ttl_seconds = *config_.routing_table_default_ttl_seconds;
                // }
                table = std::make_shared<routing::RoutingTable>(context_key, std::chrono::seconds(default_ttl_seconds));
                routing_tables_[context_key] = table;
                if (config_.logger) config_.logger->info("[RoutingMgr]  '{}'  (TTL: {}s)", context_key, default_ttl_seconds);
            }
        }  //  routing_table_mutex_

        // 
        // 1.  specific_context_key 2.  "default"  "" key 3. URI
        bool initial_routers_found = false;
        if (config_.initial_router_addresses_override.count(context_key)) {
            initial_routers_for_this_context = config_.initial_router_addresses_override.at(context_key);
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
        }

        if (!initial_routers_found) {
            //  ()
            std::string generic_initial_router_key = "";  // 
            if (config_.initial_router_addresses_override.count(generic_initial_router_key)) {
                initial_routers_for_this_context = config_.initial_router_addresses_override.at(generic_initial_router_key);
                if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
                if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
            }
        }

        if (!initial_routers_found && !parsed_initial_uri_.hosts_with_ports.empty() && parsed_initial_uri_.is_routing_scheme) {
            for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                initial_routers_for_this_context.emplace_back(hp.first, hp.second);
            }
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' URI", context_key);
        }

        if (!initial_routers_found) {
            if (config_.logger) config_.logger->error("[RoutingMgr]  '{}' ", context_key);
            // table->mark_as_stale(); // 
            return nullptr;  // 
        }

        // 
        // 
        if (table->is_stale()) {
            if (config_.logger) config_.logger->info("[RoutingMgr]  '{}' ", context_key);

            // _fetch_and_update_routing_table  ROUTE 
            boltprotocol::BoltError refresh_err = _fetch_and_update_routing_table(table, initial_routers_for_this_context, database_name, impersonated_user);

            if (refresh_err != boltprotocol::BoltError::SUCCESS) {
                if (config_.logger) config_.logger->error("[RoutingMgr]  '{}' : {}", context_key, static_cast<int>(refresh_err));
                // 
                // nullptr
                return nullptr;  // 
            }
            if (config_.logger) config_.logger->info("[RoutingMgr]  '{}' ", context_key);
        } else {
            if (config_.logger) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
        }
        return table;
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/routing/routing_table.h"

#include <algorithm>  // For std::remove

namespace neo4j_bolt_transport {
    namespace routing {

        RoutingTable::RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds)
            : database_context_key_(std::move(db_context_key)),
              last_updated_time_(std::chrono::steady_clock::time_point::min()),  // Stale by default
              ttl_(ttl_seconds) {
        }

        std::optional<ServerAddress> RoutingTable::get_server(ServerRole role) {
            std::lock_guard<std::mutex> lock(mutex_);
            if (is_stale()) {
                return std::nullopt;
            }

            std::vector<ServerAddress>* server_list = nullptr;
            std::atomic<std::size_t>* index_ptr = nullptr;

            switch (role) {
                case ServerRole::ROUTER:
                    server_list = &routers_;
                    index_ptr = &next_router_index_;
                    break;
                case ServerRole::READER:
                    server_list = &readers_;
                    index_ptr = &next_reader_index_;
                    break;
                case ServerRole::WRITER:
                    server_list = &writers_;
                    index_ptr = &next_writer_index_;
                    break;
            }

            if (!server_list || server_list->empty()) {
                return std::nullopt;
            }

            std::size_t current_index = index_ptr->fetch_add(1, std::memory_order_relaxed);
            return (*server_list)[current_index % server_list->size()];
        }

        boltprotocol::BoltError RoutingTable::update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds) {
            std::lock_guard<std::mutex> lock(mutex_);

            // It's crucial that ROUTE message provides absolute lists, not diffs.
            routers_ = new_routers;
            readers_ = new_readers;
            writers_ = new_writers;
            ttl_ = new_ttl_seconds;
            last_updated_time_ = std::chrono::steady_clock::now();

            next_reader_index_ = 0;
            next_writer_index_ = 0;
            next_router_index_ = 0;  // Reset router index as well

            if (routers_.empty() && (readers_.empty() || writers_.empty())) {
                // A routing table must have routers, or if it's a single-instance-like scenario
                // (no explicit routers), it must at least have readers and writers.
                // If all are empty after an update, it's problematic.
                mark_as_stale();                                         // Mark as stale to force re-fetch or error out
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;  // Or a more specific routing error
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        bool RoutingTable::is_stale() const {
            // No lock needed for reading const members or time_point if access is atomic enough,
            // but ttl_ could change. For safety, or if ttl_ wasn't const, use lock.
            // Here, last_updated_time_ is std::chrono, reads are usually atomic. ttl_ is const after construction until update.
            // For simplicity with mutex_:
            // std::lock_guard<std::mutex> lock(mutex_);
            if (last_updated_time_ == std::chrono::steady_clock::time_point::min()) return true;  // Never updated
            return std::chrono::steady_clock::now() > (last_updated_time_ + ttl_);
        }

        void RoutingTable::mark_as_stale() {
            std::lock_guard<std::mutex> lock(mutex_);
            last_updated_time_ = std::chrono::steady_clock::time_point::min();
        }

        const std::vector<ServerAddress>& RoutingTable::get_routers() const {
            std::lock_guard<std::mutex> lock(mutex_);
            return routers_;
        }

        void RoutingTable::forget_server(const ServerAddress& address) {
            std::lock_guard<std::mutex> lock(mutex_);
            auto remove_addr = [&](std::vector<ServerAddress>& vec) {
                vec.erase(std::remove(vec.begin(), vec.end(), address), vec.end());
            };
            remove_addr(routers_);
            remove_addr(readers_);
            remove_addr(writers_);

            // If forgetting a server makes a critical list empty, table might become stale faster
            if ((database_context_key_ != "system" && (readers_.empty() || writers_.empty())) || routers_.empty()) {
                // For simplicity, just mark stale. More complex logic could try other servers first.
                mark_as_stale();
            }
        }

    }  // namespace routing
}  // namespace neo4j_bolt_transport#include "boltprotocol/message_serialization.h"  // For ROUTE message
#include "boltprotocol/packstream_reader.h"      // For parsing ROUTE response
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 
    boltprotocol::BoltError Neo4jBoltTransport::_fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update,
                                                                                const std::vector<routing::ServerAddress>& routers_to_try,
                                                                                const std::string& database_name_hint,                       // ROUTE
                                                                                const std::optional<std::string>& impersonated_user_hint) {  // ROUTE

        if (routers_to_try.empty()) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: ");
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }
        if (!table_to_update) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: table_to_update ");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        boltprotocol::RouteMessageParams route_params;
        // Bolt 4.3-4.4: route_params.routing_table_context (map)
        // Bolt 5.0+:  route_params.routing_table_context (db, imp_user)
        //  routing_table_context NAT
        // 
        // Neo4j JavamapROUTErouting_context
        route_params.routing_table_context = {};  // 
        route_params.bookmarks = {};              // 

        // ROUTE
        boltprotocol::versions::Version version_for_route_message = boltprotocol::versions::V5_0;  // 
        if (!config_.preferred_bolt_versions.empty()) {
            //  Bolt  ROUTE 
            // 
            version_for_route_message = config_.preferred_bolt_versions.front();
        }

        if (version_for_route_message >= boltprotocol::versions::Version(4, 4)) {  // Bolt 4.4+
            route_params.extra_for_v44_plus = std::map<std::string, boltprotocol::Value>();
            if (!database_name_hint.empty()) {
                (*route_params.extra_for_v44_plus)["db"] = database_name_hint;
            }
            // impersonated_user_hint  Bolt 5.1+  ROUTE  extra map
            if (impersonated_user_hint.has_value() && !impersonated_user_hint->empty() && version_for_route_message >= boltprotocol::versions::Version(5, 1)) {
                (*route_params.extra_for_v44_plus)["imp_user"] = *impersonated_user_hint;
            }
        } else if (version_for_route_message == boltprotocol::versions::Version(4, 3)) {  // Bolt 4.3
            if (!database_name_hint.empty()) {
                route_params.db_name_for_v43 = database_name_hint;
            }
        } else {
            if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  Bolt  {}.{}", (int)version_for_route_message.major, (int)version_for_route_message.minor);
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
        }

        std::vector<uint8_t> route_payload;
        boltprotocol::PackStreamWriter writer(route_payload);
        boltprotocol::BoltError err = boltprotocol::serialize_route_message(route_params, writer, version_for_route_message);
        if (err != boltprotocol::BoltError::SUCCESS) {
            if (config_.logger) config_.logger->error("[RoutingFetcher]  ROUTE : {}", static_cast<int>(err));
            table_to_update->mark_as_stale();
            return err;
        }

        boltprotocol::SuccessMessageParams success_meta;
        boltprotocol::FailureMessageParams failure_meta;

        for (const auto& router_address_orig : routers_to_try) {
            if (closing_.load(std::memory_order_acquire)) return boltprotocol::BoltError::UNKNOWN_ERROR;  // 

            routing::ServerAddress router_address = router_address_orig;
            if (config_.server_address_resolver) {  // 
                router_address = config_.server_address_resolver(router_address_orig);
            }

            if (config_.logger) config_.logger->debug("[RoutingFetcher]  {} (: {}) , : '{}'", router_address.to_string(), router_address_orig.to_string(), database_name_hint);

            //  HELLO 
            std::map<std::string, boltprotocol::Value> hello_routing_ctx;
            hello_routing_ctx["address"] = router_address.to_string();  // 

            internal::BoltConnectionConfig conn_conf = _create_physical_connection_config(router_address, hello_routing_ctx);
            auto temp_conn_logger = config_.get_or_create_logger("RouteConn");  // logger
            auto temp_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(conn_conf), io_context_, temp_conn_logger);

            if (temp_conn->establish() == boltprotocol::BoltError::SUCCESS) {
                //  Bolt  ROUTE 
                if (temp_conn->get_bolt_version() < boltprotocol::versions::Version(4, 3)) {
                    if (config_.logger) config_.logger->warn("[RoutingFetcher]  {}  Bolt  ({}.{}) ROUTE ", router_address.to_string(), (int)temp_conn->get_bolt_version().major, (int)temp_conn->get_bolt_version().minor);
                    temp_conn->terminate(true);
                    continue;  // 
                }
                // 
                // ROUTE

                boltprotocol::BoltError route_send_err = temp_conn->send_request_receive_summary(route_payload, success_meta, failure_meta);
                temp_conn->terminate(true);  // 

                if (route_send_err == boltprotocol::BoltError::SUCCESS && temp_conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                    auto rt_it = success_meta.metadata.find("rt");
                    if (rt_it != success_meta.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second)) {
                        const auto& rt_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second);
                        if (rt_map_ptr) {
                            const auto& rt_data = rt_map_ptr->pairs;
                            long long ttl_val_ll = 0;
                            std::vector<routing::ServerAddress> new_routers, new_readers, new_writers;

                            auto ttl_data_it = rt_data.find("ttl");
                            if (ttl_data_it != rt_data.end() && std::holds_alternative<int64_t>(ttl_data_it->second)) {
                                ttl_val_ll = std::get<int64_t>(ttl_data_it->second);
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'ttl' ");
                                // 
                            }
                            std::chrono::seconds ttl_val = std::chrono::seconds(ttl_val_ll > 0 ? ttl_val_ll : 300);  // 300s

                            auto servers_data_it = rt_data.find("servers");
                            if (servers_data_it != rt_data.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second)) {
                                const auto& servers_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second);
                                if (servers_list_ptr) {
                                    for (const auto& server_item_val : servers_list_ptr->elements) {
                                        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val)) {
                                            const auto& server_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val);
                                            if (server_map_ptr) {
                                                std::string role_str;
                                                std::vector<std::string> addresses_str_list;

                                                auto role_it = server_map_ptr->pairs.find("role");
                                                if (role_it != server_map_ptr->pairs.end() && std::holds_alternative<std::string>(role_it->second)) {
                                                    role_str = std::get<std::string>(role_it->second);
                                                }

                                                auto addrs_it = server_map_ptr->pairs.find("addresses");
                                                if (addrs_it != server_map_ptr->pairs.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second)) {
                                                    const auto& addrs_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second);
                                                    if (addrs_list_ptr) {
                                                        for (const auto& addr_val : addrs_list_ptr->elements) {
                                                            if (std::holds_alternative<std::string>(addr_val)) {
                                                                addresses_str_list.push_back(std::get<std::string>(addr_val));
                                                            }
                                                        }
                                                    }
                                                }

                                                auto parse_host_port = [&](const std::string& addr_str) -> std::optional<routing::ServerAddress> {
                                                    //  (bolt://, neo4j:// etc.)
                                                    std::string clean_addr_str = addr_str;
                                                    size_t scheme_end = clean_addr_str.find("://");
                                                    if (scheme_end != std::string::npos) {
                                                        clean_addr_str = clean_addr_str.substr(scheme_end + 3);
                                                    }

                                                    size_t colon_pos = clean_addr_str.rfind(':');
                                                    if (colon_pos == std::string::npos || colon_pos == 0 || colon_pos == clean_addr_str.length() - 1) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}'  ()", addr_str);
                                                        return std::nullopt;
                                                    }
                                                    try {
                                                        std::string host_part = clean_addr_str.substr(0, colon_pos);
                                                        //  IPv6 
                                                        if (host_part.length() > 2 && host_part.front() == '[' && host_part.back() == ']') {
                                                            host_part = host_part.substr(1, host_part.length() - 2);
                                                        }
                                                        if (host_part.empty()) {
                                                            if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}' ", addr_str);
                                                            return std::nullopt;
                                                        }

                                                        uint16_t port = static_cast<uint16_t>(std::stoul(clean_addr_str.substr(colon_pos + 1)));
                                                        return routing::ServerAddress{host_part, port};
                                                    } catch (const std::exception& e) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}' : {}", addr_str, e.what());
                                                        return std::nullopt;
                                                    }
                                                };

                                                std::vector<routing::ServerAddress>* target_list_ptr = nullptr;
                                                if (role_str == "ROUTE")
                                                    target_list_ptr = &new_routers;
                                                else if (role_str == "READ")
                                                    target_list_ptr = &new_readers;
                                                else if (role_str == "WRITE")
                                                    target_list_ptr = &new_writers;

                                                if (target_list_ptr) {
                                                    for (const auto& addr_str : addresses_str_list) {
                                                        if (auto sa_opt = parse_host_port(addr_str)) {
                                                            target_list_ptr->push_back(*sa_opt);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'servers' ");
                                }
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'rt' ");
                                //  send_request_receive_summary 
                                // temp_conn->get_last_error_code()  SUCCESS
                                if (temp_conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE : {}", temp_conn->get_last_error_message());
                                    // 
                                } else {
                                    // 
                                    table_to_update->mark_as_stale();
                                    return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
                                }
                            }
                            // 
                            boltprotocol::BoltError update_err = table_to_update->update(new_routers, new_readers, new_writers, ttl_val);
                            if (update_err == boltprotocol::BoltError::SUCCESS) {
                                if (config_.logger) {
                                    config_.logger->info(
                                        "[RoutingFetcher]  '{}'  {} Routers: {}, Readers: {}, Writers: {}, TTL: {}s", table_to_update->get_database_context_key(), router_address.to_string(), new_routers.size(), new_readers.size(), new_writers.size(), ttl_val.count());
                                }
                            } else {
                                if (config_.logger) config_.logger->error("[RoutingFetcher] ");
                            }
                            return update_err;  // 
                        }  // success_meta.metadata.find("rt")
                    }  // temp_conn->get_last_error_code() == SUCCESS
                }  // route_send_err == SUCCESS

                //  route_send_err != SUCCESS  temp_conn->get_last_error_code() != SUCCESS
                if (config_.logger) {
                    config_.logger->warn(
                        "[RoutingFetcher]  {}  ROUTE : {}, : {} (: {})", router_address.to_string(), error::bolt_error_to_string(route_send_err), error::bolt_error_to_string(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
                }
                // 

            } else {  // temp_conn->establish() failed
                if (config_.logger) config_.logger->warn("[RoutingFetcher]  {} (: {}) : {}, : {}", router_address.to_string(), router_address_orig.to_string(), static_cast<int>(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
            }
            // 
        }

        if (config_.logger) config_.logger->error("[RoutingFetcher]  {}  '{}'", routers_to_try.size(), table_to_update->get_database_context_key());
        table_to_update->mark_as_stale();               // 
        return boltprotocol::BoltError::NETWORK_ERROR;  //  "Routing information unavailable"
    }

}  // namespace neo4j_bolt_transport#include <chrono>    // For std::chrono::milliseconds
#include <iostream>  // 
#include <utility>   // For std::move

#include "boltprotocol/message_serialization.h"  // For serialize_..._message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // <--- 
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // --- Explicit Transaction Methods ---
    std::pair<boltprotocol::BoltError, std::string> SessionHandle::begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "begin_transaction");
        if (!conn) {
            return conn_check_result;
        }
        auto logger = conn->get_logger();  // conn is valid here

        if (in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to begin transaction while already in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot begin transaction; already in an explicit transaction."};
        }

        boltprotocol::BeginMessageParams params;
        params.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) {
            params.db = session_params_.database_name;
        }
        if (session_params_.impersonated_user.has_value()) {
            params.imp_user = session_params_.impersonated_user;
        }

        // Access mode (Bolt 5.0+)
        if (!(conn->get_bolt_version() < boltprotocol::versions::V5_0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                params.other_extra_fields["mode"] = std::string("r");
            }
        }

        if (tx_metadata.has_value()) {
            params.tx_metadata = *tx_metadata;
        }
        if (tx_timeout_opt.has_value()) {
            params.tx_timeout = static_cast<int64_t>(tx_timeout_opt.value().count());
        }

        std::vector<uint8_t> begin_payload_bytes;
        boltprotocol::PackStreamWriter writer(begin_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_begin_message(params, writer, conn->get_bolt_version());
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("BEGIN serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(begin_payload_bytes, success_meta_raw, failure_meta_raw);

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                in_explicit_transaction_ = true;
                current_transaction_query_id_.reset();
                if (logger) {
                    logger->info("[SessionTX {}] Transaction started. DB: '{}', Mode: '{}', Timeout: {}ms, Meta: {}",
                                 conn->get_id(),
                                 params.db.value_or("<default>"),
                                 (session_params_.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"),
                                 params.tx_timeout.has_value() ? std::to_string(params.tx_timeout.value()) : "N/A",
                                 params.tx_metadata.has_value() && !params.tx_metadata.value().empty() ? "Yes" : "No");
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string server_fail_msg = error::format_server_failure(failure_meta_raw);
                std::string msg = error::format_error_message("BEGIN failed on server", conn->get_last_error_code(), server_fail_msg);
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("BEGIN send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::commit_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "commit_transaction");
        if (!conn) return conn_check_result;
        auto logger = conn->get_logger();  // conn is valid here

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to commit transaction while not in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot commit: not in an explicit transaction."};
        }

        std::vector<uint8_t> commit_payload_bytes;
        boltprotocol::PackStreamWriter writer(commit_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_commit_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("COMMIT serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(commit_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                auto it_bookmark = success_meta_raw.metadata.find("bookmark");
                if (it_bookmark != success_meta_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                } else {
                    if (logger) logger->trace("[SessionTX {}] COMMIT successful but no bookmark returned (Bolt version: {}.{}).", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                    update_bookmarks({});
                }
                if (logger) {
                    logger->info("[SessionTX {}] Transaction committed. New bookmark: {}", conn->get_id(), current_bookmarks_.empty() ? "<none>" : current_bookmarks_[0]);
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("COMMIT failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("COMMIT send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::rollback_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "rollback_transaction (pre-check)");

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (conn)
            logger = conn->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)  // transport_manager_ is checked
            logger = transport_manager_->get_config().logger;

        if (!in_explicit_transaction_) {
            if (logger) logger->trace("[SessionTX {}] Rollback called when not in an explicit transaction. No-op.", (conn ? conn->get_id() : 0));
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        if (!conn) {
            std::string msg = "Rollback attempt with no valid connection while in TX: " + conn_check_result.second;
            if (logger) logger->warn("[SessionTX Rollback] {}", msg);
            _invalidate_session_due_to_connection_error(conn_check_result.first, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {conn_check_result.first, msg};
        }

        std::vector<uint8_t> rollback_payload_bytes;
        boltprotocol::PackStreamWriter writer(rollback_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_rollback_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("ROLLBACK serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(rollback_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                if (logger) {
                    logger->info("[SessionTX {}] Transaction rolled back.", conn->get_id());
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("ROLLBACK failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("ROLLBACK send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 
#include <utility>   // For std::move

#include "neo4j_bolt_transport/config/session_parameters.h"          // For config::SessionParameters
#include "neo4j_bolt_transport/error/neo4j_error_util.h"             // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // For internal::BoltPhysicalConnection
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"               // For Neo4jBoltTransport access
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    SessionHandle::SessionHandle(Neo4jBoltTransport* transport_mgr, internal::BoltPhysicalConnection::PooledConnection conn_ptr, config::SessionParameters params_val)
        : transport_manager_(transport_mgr), connection_(std::move(conn_ptr)), session_params_(std::move(params_val)), current_bookmarks_(session_params_.initial_bookmarks) {  // 

        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  //  logger
            drv_logger = transport_manager_->get_config().logger;
        }

        if (!transport_manager_) {
            connection_is_valid_ = false;
            is_closed_ = true;
            if (drv_logger) drv_logger->error("[SessionLC] SessionHandle created without a valid transport manager.");
            // connection_  nullptr_release_connection_to_pool 
            return;
        }

        std::shared_ptr<spdlog::logger> conn_logger = nullptr;
        if (connection_ && connection_->get_logger()) {
            conn_logger = connection_->get_logger();
        } else if (drv_logger) {
            conn_logger = drv_logger;  // 
        }

        if (!connection_ || !connection_->is_ready_for_queries()) {
            boltprotocol::BoltError last_err = connection_ ? connection_->get_last_error_code() : boltprotocol::BoltError::NETWORK_ERROR;
            std::string last_err_msg = connection_ ? connection_->get_last_error_message() : "Connection pointer null or not ready at SessionHandle construction.";

            if (conn_logger) conn_logger->warn("[SessionLC {}] Connection not ready at SessionHandle construction. Error: {}, Msg: {}", connection_ ? connection_->get_id() : 0, static_cast<int>(last_err), last_err_msg);
            _invalidate_session_due_to_connection_error(last_err, "SessionHandle construction: " + last_err_msg);
            _release_connection_to_pool(false);  // 
        } else {
            connection_->mark_as_used();
            if (conn_logger) conn_logger->debug("[SessionLC {}] SessionHandle constructed with ready connection.", connection_->get_id());
        }
    }

    SessionHandle::~SessionHandle() {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] SessionHandle destructing. Closed: {}, InTx: {}", (connection_ ? connection_->get_id() : 0), is_closed_, in_explicit_transaction_);
        close();  // 
    }

    SessionHandle::SessionHandle(SessionHandle&& other) noexcept
        : transport_manager_(other.transport_manager_),
          connection_(std::move(other.connection_)),
          session_params_(std::move(other.session_params_)),
          in_explicit_transaction_(other.in_explicit_transaction_),
          current_transaction_query_id_(other.current_transaction_query_id_),
          current_bookmarks_(std::move(other.current_bookmarks_)),
          is_closed_(other.is_closed_),
          connection_is_valid_(other.connection_is_valid_) {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->trace("[SessionLC {}] SessionHandle move constructed from old SessionHandle.", (connection_ ? connection_->get_id() : 0));

        other.transport_manager_ = nullptr;  // other 
        other.is_closed_ = true;
        other.connection_is_valid_ = false;
    }

    SessionHandle& SessionHandle::operator=(SessionHandle&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = nullptr;
            if (connection_ && connection_->get_logger())
                logger = connection_->get_logger();
            else if (transport_manager_ && transport_manager_->get_config().logger)
                logger = transport_manager_->get_config().logger;
            if (logger) logger->trace("[SessionLC {}] SessionHandle move assigning from other SessionHandle.", (connection_ ? connection_->get_id() : 0));

            close();  // 

            transport_manager_ = other.transport_manager_;
            connection_ = std::move(other.connection_);
            session_params_ = std::move(other.session_params_);
            in_explicit_transaction_ = other.in_explicit_transaction_;
            current_transaction_query_id_ = other.current_transaction_query_id_;
            current_bookmarks_ = std::move(other.current_bookmarks_);
            is_closed_ = other.is_closed_;
            connection_is_valid_ = other.connection_is_valid_;

            other.transport_manager_ = nullptr;  // other 
            other.is_closed_ = true;
            other.connection_is_valid_ = false;
        }
        return *this;
    }

    void SessionHandle::_release_connection_to_pool(bool mark_healthy) {
        if (connection_ && transport_manager_) {
            std::shared_ptr<spdlog::logger> logger = connection_->get_logger();  // logger
            uint64_t conn_id = connection_->get_id();
            if (logger) logger->trace("[SessionLC conn_id={}] Releasing connection to pool. Healthy: {}", conn_id, mark_healthy && connection_is_valid_);
            transport_manager_->release_connection(std::move(connection_), mark_healthy && connection_is_valid_);
            // connection_  nullptr
        }
        connection_is_valid_ = false;  // 
    }

    void SessionHandle::close() {
        if (is_closed_) {
            return;
        }

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] Closing SessionHandle. InTx: {}", (connection_ ? connection_->get_id() : 0), in_explicit_transaction_);

        if (in_explicit_transaction_ && connection_is_valid_ && connection_ && connection_->is_ready_for_queries()) {
            if (logger) logger->info("[SessionLC {}] Rolling back active transaction during close.", connection_->get_id());
            rollback_transaction();  //  in_explicit_transaction_  false
        }
        _release_connection_to_pool(connection_is_valid_);  // 
        is_closed_ = true;
    }

    void SessionHandle::_invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message) {
        connection_is_valid_ = false;
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            logger->warn("[SessionLC {}] Session invalidated due to connection error. Code: {} ({}), Context: {}",
                         (connection_ ? connection_->get_id() : 0),
                         static_cast<int>(error),
                         error::bolt_error_to_string(error),  // 
                         context_message);
        }
    }

    internal::BoltPhysicalConnection* SessionHandle::_get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed_) {
            out_err_pair = {boltprotocol::BoltError::INVALID_ARGUMENT, "Operation on closed session: " + operation_context};
            if (drv_logger) drv_logger->warn("[SessionOp] {}", out_err_pair.second);
            return nullptr;
        }
        if (!connection_is_valid_ || !connection_) {
            out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "No valid connection for operation: " + operation_context};
            std::shared_ptr<spdlog::logger> log_to_use = (connection_ && connection_->get_logger()) ? connection_->get_logger() : drv_logger;
            if (log_to_use) log_to_use->warn("[SessionOp conn_id={}] {}", (connection_ ? connection_->get_id() : 0), out_err_pair.second);
            return nullptr;
        }

        if (!connection_->is_ready_for_queries()) {
            out_err_pair = {connection_->get_last_error_code(), connection_->get_last_error_message()};
            if (out_err_pair.first == boltprotocol::BoltError::SUCCESS) {  //  is_ready  false  SUCCESS
                out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "Connection reported not ready for queries despite no specific error."};
            }
            std::string context_msg_full = operation_context + " (connection not ready: " + out_err_pair.second + ")";
            _invalidate_session_due_to_connection_error(out_err_pair.first, context_msg_full);  // 
            if (connection_->get_logger()) connection_->get_logger()->warn("[SessionOp conn_id={}] {}", connection_->get_id(), context_msg_full);
            return nullptr;
        }

        connection_->mark_as_used();
        out_err_pair = {boltprotocol::BoltError::SUCCESS, ""};
        return connection_.get();
    }

    const std::vector<std::string>& SessionHandle::get_last_bookmarks() const {
        return current_bookmarks_;
    }

    void SessionHandle::update_bookmarks(const std::vector<std::string>& new_bookmarks) {
        if (is_closed_) return;
        current_bookmarks_ = new_bookmarks;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            std::string bookmarks_str;
            if (new_bookmarks.empty()) {
                bookmarks_str = "<empty>";
            } else {
                for (size_t i = 0; i < new_bookmarks.size(); ++i) {
                    bookmarks_str += new_bookmarks[i] + (i == new_bookmarks.size() - 1 ? "" : ", ");
                }
            }
            logger->trace("[SessionLC {}] Bookmarks updated to: [{}]", (connection_ ? connection_->get_id() : 0), bookmarks_str);
        }
    }

}  // namespace neo4j_bolt_transport#include <utility>  // For std::move

#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionWork typedef
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        // Note: The mode_hint (AccessMode::READ) is passed to _execute_transaction_work_internal.
        // That internal function will temporarily set session_params_.default_access_mode
        // for the duration of the managed transaction.
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::READ, tx_metadata, tx_timeout);
    }

    TransactionWorkResult SessionHandle::execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::WRITE, tx_metadata, tx_timeout);
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <chrono>     // For std::chrono::milliseconds
#include <iostream>   // 
#include <thread>     // For std::this_thread::sleep_for
#include <utility>    // For std::move

#include "neo4j_bolt_transport/config/transport_config.h"  // For retry config access
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"       // For transport_manager_ to get config
#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionContext definition
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::_execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // Check transport_manager_
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed()) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Session is closed, cannot execute transaction work.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Session is closed, cannot execute transaction work."};
        }
        if (in_explicit_transaction_) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Cannot start managed transaction; an explicit transaction is already active.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot start managed transaction; an explicit transaction is already active."};
        }

        uint32_t max_retry_time_ms = 30000;
        uint32_t current_delay_ms = 1000;
        uint32_t max_delay_ms = 60000;
        double multiplier = 2.0;

        if (transport_manager_) {
            const auto& driver_conf = transport_manager_->get_config();
            max_retry_time_ms = driver_conf.max_transaction_retry_time_ms;
            current_delay_ms = driver_conf.transaction_retry_delay_initial_ms > 0 ? driver_conf.transaction_retry_delay_initial_ms : 1000;
            max_delay_ms = driver_conf.transaction_retry_delay_max_ms > 0 ? driver_conf.transaction_retry_delay_max_ms : 60000;
            multiplier = driver_conf.transaction_retry_delay_multiplier > 1 ? static_cast<double>(driver_conf.transaction_retry_delay_multiplier) : 2.0;
        }

        auto overall_deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(max_retry_time_ms);
        TransactionWorkResult last_attempt_result = {boltprotocol::BoltError::UNKNOWN_ERROR, "Transaction work did not complete successfully within retry budget."};
        int attempt_count = 0;

        config::AccessMode original_session_access_mode = session_params_.default_access_mode;
        session_params_.default_access_mode = mode_hint;

        while (std::chrono::steady_clock::now() < overall_deadline) {
            attempt_count++;
            std::shared_ptr<spdlog::logger> current_op_logger = drv_logger;

            std::pair<boltprotocol::BoltError, std::string> conn_check_for_log;
            internal::BoltPhysicalConnection* temp_conn_for_log_check = _get_valid_connection_for_operation(conn_check_for_log, "managed_tx_log_setup");
            if (temp_conn_for_log_check && temp_conn_for_log_check->get_logger()) {
                current_op_logger = temp_conn_for_log_check->get_logger();
            }

            if (current_op_logger) {
                current_op_logger->debug("[SessionTX Managed][Attempt {}] Starting transaction work (Mode: {}).", attempt_count, (mode_hint == config::AccessMode::READ ? "READ" : "WRITE"));
            }

            std::pair<boltprotocol::BoltError, std::string> pre_begin_conn_check;
            if (!_get_valid_connection_for_operation(pre_begin_conn_check, "managed_tx_pre_begin")) {
                last_attempt_result = {pre_begin_conn_check.first, "Managed TX: Connection unavailable before BEGIN (Attempt " + std::to_string(attempt_count) + "): " + pre_begin_conn_check.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                bool is_retryable_failure = (pre_begin_conn_check.first == boltprotocol::BoltError::NETWORK_ERROR || pre_begin_conn_check.first == boltprotocol::BoltError::HANDSHAKE_FAILED);  // More specific retry conditions
                if (is_retryable_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection unavailability before BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    // If connection was invalidated, _release_connection_to_pool would have been called.
                    // Next iteration _get_valid_connection_for_operation will try to get a new one if pool manager is used.
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            auto begin_res = begin_transaction(tx_metadata, tx_timeout_opt);
            if (begin_res.first != boltprotocol::BoltError::SUCCESS) {
                bool is_retryable_begin_failure = (begin_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                last_attempt_result = {begin_res.first, "Managed TX: Failed to begin (Attempt " + std::to_string(attempt_count) + "): " + begin_res.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                if (is_retryable_begin_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            if (connection_ && connection_->get_logger()) current_op_logger = connection_->get_logger();

            TransactionContext tx_context(*this);
            TransactionWorkResult work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "User work lambda not called."};

            try {
                work_res = work(tx_context);
            } catch (const std::exception& e) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Exception from user transaction work: " + std::string(e.what())};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Exception in user work: {}", e.what());
            } catch (...) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Unknown exception from user transaction work."};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Unknown exception in user work.");
            }

            if (!connection_is_valid_) {
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Connection became invalid during user work. Last conn error code: {}", connection_ ? static_cast<int>(connection_->get_last_error_code()) : -1);
                work_res = {boltprotocol::BoltError::NETWORK_ERROR, "Connection lost during transaction work execution."};
                rollback_transaction();
                last_attempt_result = work_res;
                if (std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection loss in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                } else {
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            }

            if (work_res.first == boltprotocol::BoltError::SUCCESS) {
                auto commit_res = commit_transaction();
                if (commit_res.first == boltprotocol::BoltError::SUCCESS) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Transaction work committed successfully.");
                    session_params_.default_access_mode = original_session_access_mode;
                    return {boltprotocol::BoltError::SUCCESS, ""};
                } else {
                    last_attempt_result = {commit_res.first, "Managed TX: Commit failed (Attempt " + std::to_string(attempt_count) + "): " + commit_res.second};
                    if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);
                    bool is_commit_retryable = (commit_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                    // Potentially check for specific Neo4j error codes from commit_res.second if available
                    if (is_commit_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                        if (current_op_logger) current_op_logger->info("[SessionTX Managed] COMMIT failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                        std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                        current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                        continue;
                    }
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            } else {  // User lambda returned error
                auto rollback_res = rollback_transaction();
                if (rollback_res.first != boltprotocol::BoltError::SUCCESS && connection_is_valid_ && current_op_logger) {
                    current_op_logger->warn("[SessionTX Managed] Rollback failed after work error ('{}'): {}", work_res.second, rollback_res.second);
                }
                last_attempt_result = work_res;
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Work failed (Attempt {}): {}", attempt_count, work_res.second);
                bool is_work_error_retryable = (work_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                // Potentially check for specific Neo4j error codes for retry
                if (is_work_error_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Work failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }
        }

        if (drv_logger) {
            drv_logger->warn("[SessionTX Managed] Transaction work failed after all {} retries or timeout. Last error: {}", attempt_count, last_attempt_result.second);
        }
        session_params_.default_access_mode = original_session_access_mode;
        return last_attempt_result;
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"  // For serialize_run_message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // Required for transport_manager_ access
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> SessionHandle::run_query(const std::string& cypher,
                                                                                                                           const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                           const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        boltprotocol::SuccessMessageParams run_summary_raw;
        boltprotocol::FailureMessageParams run_failure_details_raw;
        std::pair<boltprotocol::BoltError, std::string> prepare_result = {boltprotocol::BoltError::SUCCESS, ""};
        std::optional<int64_t> qid_for_stream;
        bool server_can_have_more_records_after_run = false;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string current_server_address = "unknown_server:0";
        boltprotocol::versions::Version current_bolt_version(0, 0);
        bool current_utc_patch_active = false;

        std::pair<boltprotocol::BoltError, std::string> conn_check_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_pair, "run_query (initial check)");

        if (conn) {
            logger = conn->get_logger();
            current_server_address = conn->get_config().target_host + ":" + std::to_string(conn->get_config().target_port);
            current_bolt_version = conn->get_bolt_version();
            current_utc_patch_active = conn->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (!conn) {
            prepare_result = conn_check_pair;
            if (logger) logger->warn("[SessionExec] run_query: Connection unavailable. Error: {}, Msg: {}", static_cast<int>(prepare_result.first), prepare_result.second);
        } else {
            std::optional<std::map<std::string, boltprotocol::Value>> metadata_to_pass;
            std::optional<std::chrono::milliseconds> timeout_to_pass;

            if (tx_config_overrides.has_value()) {
                metadata_to_pass = tx_config_overrides->metadata;
                timeout_to_pass = tx_config_overrides->timeout;
            } else {  // Use defaults from TransportConfig if no overrides
                if (transport_manager_ && transport_manager_->get_config().explicit_transaction_timeout_default_ms > 0 && !is_in_transaction()) {
                    timeout_to_pass = std::chrono::milliseconds(transport_manager_->get_config().explicit_transaction_timeout_default_ms);
                }
            }

            if (is_in_transaction()) {
                if (metadata_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_metadata_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                if (timeout_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_timeout_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                // For explicit TX, RUN does not take metadata/timeout. Those are on BEGIN.
                prepare_result = _prepare_explicit_tx_run(cypher, parameters, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = current_transaction_query_id_;  // Set by _prepare_explicit_tx_run
                    server_can_have_more_records_after_run = true;
                }
            } else {  // Auto-commit
                prepare_result = _prepare_auto_commit_run(cypher, parameters, metadata_to_pass, timeout_to_pass, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = std::nullopt;
                    auto it_qid = run_summary_raw.metadata.find("qid");
                    if (it_qid != run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                        qid_for_stream = std::get<int64_t>(it_qid->second);
                    }
                    server_can_have_more_records_after_run = true;
                }
            }
        }

        std::shared_ptr<std::vector<std::string>> fields_ptr = std::make_shared<std::vector<std::string>>();
        auto it_fields = run_summary_raw.metadata.find("fields");
        if (it_fields != run_summary_raw.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
            if (list_ptr) {
                fields_ptr->reserve(list_ptr->elements.size());
                for (const auto& field_val : list_ptr->elements) {
                    if (std::holds_alternative<std::string>(field_val)) {
                        fields_ptr->push_back(std::get<std::string>(field_val));
                    }
                }
            }
        }

        if (logger && prepare_result.first == boltprotocol::BoltError::SUCCESS) {
            logger->debug("[SessionExec] run_query successful prep. Fields: {}. QID for stream: {}", fields_ptr->size(), qid_for_stream.has_value() ? std::to_string(qid_for_stream.value()) : "none");
        }

        auto result_stream = std::make_unique<BoltResultStream>(this,
                                                                qid_for_stream,
                                                                std::move(run_summary_raw),
                                                                fields_ptr,
                                                                std::vector<boltprotocol::RecordMessageParams>{},
                                                                server_can_have_more_records_after_run,
                                                                current_bolt_version,
                                                                current_utc_patch_active,
                                                                current_server_address,
                                                                session_params_.database_name,
                                                                prepare_result.first,
                                                                prepare_result.second,
                                                                (prepare_result.first != boltprotocol::BoltError::SUCCESS ? std::make_optional(run_failure_details_raw) : std::nullopt));

        return {std::move(prepare_result), std::move(result_stream)};
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> SessionHandle::run_query_and_consume(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                   const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string srv_addr_cache = "unknown_server:0";
        boltprotocol::versions::Version bolt_ver_cache(0, 0);
        bool utc_patch_cache = false;

        if (connection_) {
            if (connection_->get_logger()) logger = connection_->get_logger();
            srv_addr_cache = connection_->get_config().target_host + ":" + std::to_string(connection_->get_config().target_port);
            bolt_ver_cache = connection_->get_bolt_version();
            utc_patch_cache = connection_->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume starting for cypher: {:.30}...", cypher);

        auto [initial_err_pair, result_stream_ptr] = run_query(cypher, parameters, tx_config_overrides);  // Pass overrides

        if (initial_err_pair.first != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: run_query failed initially. Error: {}, Msg: {}", static_cast<int>(initial_err_pair.first), initial_err_pair.second);
            if (result_stream_ptr) {
                boltprotocol::SuccessMessageParams params_copy = result_stream_ptr->get_run_summary().raw_params();
                return {initial_err_pair, ResultSummary(std::move(params_copy), bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
            }
            return {initial_err_pair, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        if (!result_stream_ptr) {
            if (logger) logger->error("[SessionExec] run_query_and_consume: Internal error - run_query succeeded but returned null stream.");
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, "Null result stream post run_query."}, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        auto [consume_err_code, consume_err_msg, final_summary_typed] = result_stream_ptr->consume();

        if (consume_err_code != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: stream consume failed. Error: {}, Msg: {}", static_cast<int>(consume_err_code), consume_err_msg);
            return {{consume_err_code, std::move(consume_err_msg)}, std::move(final_summary_typed)};
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume successful.");

        if (!connection_is_valid_) {
            boltprotocol::BoltError conn_last_err = boltprotocol::BoltError::NETWORK_ERROR;
            std::string conn_last_msg = "Connection lost during operation.";
            if (connection_ && connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                conn_last_err = connection_->get_last_error_code();
                conn_last_msg = connection_->get_last_error_message();
                if (logger) logger->warn("[SessionExec] run_query_and_consume: Connection became invalid. Last conn error: {}", conn_last_msg);
            } else if (logger) {
                logger->warn("[SessionExec] run_query_and_consume: Connection became invalid (no specific error).");
            }
            return {{conn_last_err, conn_last_msg}, std::move(final_summary_typed)};
        }
        return {{boltprotocol::BoltError::SUCCESS, ""}, std::move(final_summary_typed)};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::run_query_without_result(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        auto [err_pair_outer, summary_typed] = run_query_and_consume(cypher, parameters, tx_config_overrides);  // Pass overrides
        return err_pair_outer;
    }
}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_auto_commit_run(const std::string& cypher,
                                                                                            const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,
                                                                                            const std::optional<std::chrono::milliseconds>& tx_timeout,
                                                                                            boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                            boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_auto_commit_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;
        run_p.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) run_p.db = session_params_.database_name;
        if (session_params_.impersonated_user.has_value()) run_p.imp_user = session_params_.impersonated_user;

        // Compare with a constructed Version object for Bolt 5.0
        if (conn->get_bolt_version() < boltprotocol::versions::Version(5, 0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                run_p.mode = "r";
            }
        }

        if (tx_metadata.has_value()) {
            run_p.tx_metadata = tx_metadata.value();
        }
        if (tx_timeout.has_value()) {
            run_p.tx_timeout = static_cast<int64_t>(tx_timeout.value().count());
        }

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_writer(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_writer, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger)
            logger->trace(
                "[SessionStream {}] Sending auto-commit RUN. Cypher: {:.30}, Timeout: {}ms, Meta: {}", conn->get_id(), cypher, run_p.tx_timeout.has_value() ? std::to_string(run_p.tx_timeout.value()) : "N/A", run_p.tx_metadata.has_value() && !run_p.tx_metadata.value().empty() ? "Yes" : "No");

        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }
        if (conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Auto-commit RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }

        if (logger) logger->trace("[SessionStream {}] Auto-commit RUN successful, got its summary.", conn->get_id());
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_explicit_tx_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionStream {}] _prepare_explicit_tx_run called when not in transaction.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot run query in explicit TX mode; not in transaction."};
        }

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_w(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_w, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending explicit TX RUN. Cypher: {:.30}", conn->get_id(), cypher);
        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            current_transaction_query_id_.reset();
            // Compare with a constructed Version object for Bolt 4.0
            if (!(conn->get_bolt_version() < boltprotocol::versions::Version(4, 0))) {  // If Bolt version is >= 4.0
                auto it_qid = out_run_summary_raw.metadata.find("qid");
                if (it_qid != out_run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                    current_transaction_query_id_ = std::get<int64_t>(it_qid->second);
                    if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful, qid: {}.", conn->get_id(), *current_transaction_query_id_);
                } else {
                    if (logger) logger->warn("[SessionStream {}] Missing qid in RUN SUCCESS for explicit transaction (Bolt version {}.{}). Subsequent PULL/DISCARD may need to be implicit.", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                }
            } else {
                if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful (Bolt < 4.0, no qid expected from RUN).", conn->get_id());
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Explicit TX RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_pull_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::PullMessageParams pull_p;
        pull_p.n = n;
        pull_p.qid = qid;

        std::vector<uint8_t> pull_payload_bytes;
        boltprotocol::PackStreamWriter writer(pull_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_pull_message(pull_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending PULL (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;

        auto record_processor = [&](boltprotocol::MessageTag /*tag*/, const std::vector<uint8_t>& rec_payload, internal::BoltPhysicalConnection& /*connection_ref*/) {
            boltprotocol::RecordMessageParams rec;
            boltprotocol::PackStreamReader r(rec_payload);
            if (boltprotocol::deserialize_record_message(r, rec) == boltprotocol::BoltError::SUCCESS) {
                out_records.push_back(std::move(rec));
                return boltprotocol::BoltError::SUCCESS;
            }
            if (logger) logger->error("[SessionStream {}] Failed to deserialize RECORD message during PULL.", conn->get_id());
            return boltprotocol::BoltError::DESERIALIZATION_ERROR;
        };

        err = conn->send_request_receive_stream(pull_payload_bytes, record_processor, out_pull_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL stream processing", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_pull_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_pull_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after PULL: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after PULL, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) {
                bool has_more = false;
                auto it_has_more = out_pull_summary_raw.metadata.find("has_more");
                if (it_has_more != out_pull_summary_raw.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more = std::get<bool>(it_has_more->second);
                }
                logger->trace("[SessionStream {}] PULL successful. Records received: {}. HasMore: {}", conn->get_id(), out_records.size(), has_more);
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("PULL server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_discard_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::DiscardMessageParams discard_p;
        discard_p.n = n;
        discard_p.qid = qid;

        std::vector<uint8_t> discard_payload_bytes;
        boltprotocol::PackStreamWriter writer(discard_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_discard_message(discard_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending DISCARD (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;
        err = conn->send_request_receive_summary(discard_payload_bytes, out_discard_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_discard_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_discard_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after DISCARD: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after DISCARD, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) logger->trace("[SessionStream {}] DISCARD successful.", conn->get_id());
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("DISCARD server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/uri/uri_parser.h"

#include <algorithm>  // For std::transform, std::remove_if
#include <cctype>     // For std::tolower, std::isspace
#include <stdexcept>  // For std::stoi, std::stoul exceptions

namespace neo4j_bolt_transport {
    namespace uri {

        // Basic URL decoding (handles %XY and +)
        static std::string url_decode_component(const std::string& encoded) {
            std::string decoded;
            decoded.reserve(encoded.length());
            for (size_t i = 0; i < encoded.length(); ++i) {
                if (encoded[i] == '%' && i + 2 < encoded.length()) {
                    try {
                        std::string hex = encoded.substr(i + 1, 2);
                        char c = static_cast<char>(std::stoi(hex, nullptr, 16));
                        decoded += c;
                        i += 2;
                    } catch (const std::invalid_argument&) {  // Not a hex number
                        decoded += '%';                       // Treat as literal '%'
                    } catch (const std::out_of_range&) {      // Hex value too large for char
                        decoded += '%';                       // Treat as literal '%'
                    }
                } else if (encoded[i] == '+') {
                    decoded += ' ';
                } else {
                    decoded += encoded[i];
                }
            }
            return decoded;
        }

        // Helper to trim leading/trailing whitespace
        static std::string trim_whitespace(const std::string& s) {
            auto first = std::find_if_not(s.begin(), s.end(), [](unsigned char c) {
                return std::isspace(c);
            });
            if (first == s.end()) return "";  // String is all whitespace
            auto last = std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {
                            return std::isspace(c);
                        }).base();
            return std::string(first, last);
        }

        boltprotocol::BoltError UriParser::parse(const std::string& uri_string, ParsedUri& out_parsed_uri) {
            out_parsed_uri = {};  // Reset
            out_parsed_uri.input_uri = uri_string;

            if (uri_string.empty()) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 1. Scheme
            size_t scheme_end_pos = uri_string.find("://");
            if (scheme_end_pos == std::string::npos || scheme_end_pos == 0) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            out_parsed_uri.scheme = uri_string.substr(0, scheme_end_pos);
            std::transform(out_parsed_uri.scheme.begin(), out_parsed_uri.scheme.end(), out_parsed_uri.scheme.begin(), [](unsigned char c) {
                return std::tolower(c);
            });

            std::string remaining_uri = uri_string.substr(scheme_end_pos + 3);
            if (remaining_uri.empty() || remaining_uri[0] == '/' || remaining_uri[0] == '?') {  // Authority must exist
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 2. Authority (and userinfo within it)
            size_t authority_terminator_pos = remaining_uri.find_first_of("/?");
            std::string authority_part_full = remaining_uri.substr(0, authority_terminator_pos);

            std::string path_and_query_part;
            if (authority_terminator_pos != std::string::npos) {
                path_and_query_part = remaining_uri.substr(authority_terminator_pos);
            }

            // Userinfo (username:password@)
            size_t userinfo_terminator_pos = authority_part_full.find('@');
            std::string host_port_list_str = authority_part_full;

            if (userinfo_terminator_pos != std::string::npos) {
                std::string userinfo_str = authority_part_full.substr(0, userinfo_terminator_pos);
                host_port_list_str = authority_part_full.substr(userinfo_terminator_pos + 1);
                if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host missing after @

                size_t password_delim_pos = userinfo_str.find(':');
                if (password_delim_pos != std::string::npos) {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str.substr(0, password_delim_pos));
                    out_parsed_uri.password_from_uri = url_decode_component(userinfo_str.substr(password_delim_pos + 1));
                } else {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str);
                }
            }
            if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host(s) part is mandatory

            // Parse host(s) and port(s)
            // Host part can be a comma-separated list for routing schemes
            size_t current_token_pos = 0;
            while (current_token_pos < host_port_list_str.length()) {
                size_t next_host_separator = host_port_list_str.find(',', current_token_pos);
                std::string current_host_port_token = trim_whitespace(host_port_list_str.substr(current_token_pos, next_host_separator - current_token_pos));
                if (current_host_port_token.empty()) {  // Handles cases like ",," or leading/trailing commas
                    if (next_host_separator == std::string::npos) break;
                    current_token_pos = next_host_separator + 1;
                    continue;
                }

                std::string current_host_str;
                uint16_t current_port_val = 0;  // Default based on scheme later if not specified here

                size_t port_separator_pos = current_host_port_token.rfind(':');
                size_t ipv6_bracket_end_pos = current_host_port_token.rfind(']');

                if (port_separator_pos != std::string::npos && (ipv6_bracket_end_pos == std::string::npos || port_separator_pos > ipv6_bracket_end_pos)) {
                    // Port is specified
                    current_host_str = trim_whitespace(current_host_port_token.substr(0, port_separator_pos));
                    std::string port_str = trim_whitespace(current_host_port_token.substr(port_separator_pos + 1));
                    if (port_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port num missing after ':'
                    try {
                        unsigned long p_val = std::stoul(port_str);
                        if (p_val == 0 || p_val > 65535) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Invalid port range
                        current_port_val = static_cast<uint16_t>(p_val);
                    } catch (const std::exception&) {                      // std::invalid_argument or std::out_of_range
                        return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port not a number or out of range
                    }
                } else {
                    // No port specified for this token
                    current_host_str = current_host_port_token;
                }

                // Remove IPv6 brackets if present
                if (current_host_str.length() >= 2 && current_host_str.front() == '[' && current_host_str.back() == ']') {
                    current_host_str = current_host_str.substr(1, current_host_str.length() - 2);
                }
                if (current_host_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host cannot be empty

                out_parsed_uri.hosts_with_ports.emplace_back(current_host_str, current_port_val);

                if (next_host_separator == std::string::npos) break;
                current_token_pos = next_host_separator + 1;
            }
            if (out_parsed_uri.hosts_with_ports.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // No valid host found

            // 3. Query Parameters (Path component is usually ignored or used for specific DB in some drivers, simplified here)
            if (!path_and_query_part.empty()) {
                size_t query_start_pos = path_and_query_part.find('?');
                if (query_start_pos != std::string::npos) {
                    std::string query_string = path_and_query_part.substr(query_start_pos + 1);
                    size_t current_param_pos = 0;
                    while (current_param_pos < query_string.length()) {
                        size_t next_amp_pos = query_string.find('&', current_param_pos);
                        std::string param_pair_str = query_string.substr(current_param_pos, next_amp_pos - current_param_pos);
                        size_t eq_pos = param_pair_str.find('=');
                        if (eq_pos != std::string::npos) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str.substr(0, eq_pos)));
                            std::string value = trim_whitespace(url_decode_component(param_pair_str.substr(eq_pos + 1)));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = value;
                        } else if (!param_pair_str.empty()) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = "";
                        }
                        if (next_amp_pos == std::string::npos) break;
                        current_param_pos = next_amp_pos + 1;
                    }
                }
            }

            // Apply scheme-specific logic and default ports
            uint16_t default_port_for_scheme = 0;

            if (out_parsed_uri.scheme == "bolt") {
                out_parsed_uri.tls_enabled_by_scheme = false;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "bolt+s") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "bolt+ssc") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = false;  // Routing table will dictate TLS for resolved servers
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+s") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+ssc") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else {
                return boltprotocol::BoltError::INVALID_ARGUMENT;  // Unknown scheme
            }

            // Apply default port if any host_with_port has port 0
            for (auto& host_port_pair : out_parsed_uri.hosts_with_ports) {
                if (host_port_pair.second == 0) {
                    if (default_port_for_scheme == 0) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Scheme needs explicit port
                    host_port_pair.second = default_port_for_scheme;
                }
            }

            out_parsed_uri.is_valid = true;
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace uri
}  // namespace neo4j_bolt_transport