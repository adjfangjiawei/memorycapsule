file(GLOB_RECURSE MYSQL_PROTOCOL_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(MysqlProtocol ${MYSQL_PROTOCOL_SOURCES})

target_include_directories(MysqlProtocol
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(MysqlProtocol PUBLIC Boost::asio OpenSSL::SSL OpenSSL::Crypto unofficial::libmysql::libmysql)
# build example, no condition
# add_subdirectory(Example)// Include/mysql_protocol/mysql_constants.h
#pragma once
#include <cstdint>

namespace mysql_protocol {

    // MySQL PacketMarker (这些是我们自己定义的，不太可能与 <mysql/mysql.h> 冲突)
    namespace PacketMarker {
        constexpr uint8_t OK_HEADER = 0x00;
        constexpr uint8_t ERR_HEADER = 0xFF;
        constexpr uint8_t EOF_HEADER = 0xFE;
        constexpr uint8_t LOCAL_INFILE_REQUEST = 0xFB;
    }  // namespace PacketMarker

    // 如果您有其他绝对自定义的、与 MySQL 协议实现相关的、
    // 且名称保证不与 <mysql/mysql.h> 中任何宏冲突的常量，可以放在这里。
    // 例如，内部状态机的状态值等。

    // !!! 重要: 所有之前定义的 Command::XXX, FieldType::XXX, ColumnFlag::XXX,
    // ServerStatus::XXX, CharacterSet::XXX, ClientCapability::XXX
    // 都已移除，因为它们很可能与 <mysql/mysql.h> 中的全局宏冲突。
    // 我们将在使用它们的地方直接调用 ::XXX_OFFICIAL_MYSQL_MACRO_NAME。

}  // namespace mysql_protocol// Include/mysql_protocol/mysql_type_converter.h
#pragma once

#include <mysql/mysql.h>

#include <chrono>    // For std::chrono types
#include <cstring>   // For std::strcmp, std::strncpy
#include <expected>  // C++23, for std::expected
#include <limits>    // For std::numeric_limits
#include <optional>  // For std::optional in get_if
#include <string>
#include <string_view>
#include <variant>
#include <vector>

namespace mysql_protocol {

    // 自定义内部错误码，用于 MySqlProtocolError::error_code
    namespace InternalErrc {
        constexpr unsigned int SUCCESS = 0;  // 成功

        // 类型转换错误码 (10000 - 10099)
        constexpr unsigned int CONVERSION_INVALID_INPUT_ARGUMENT = 10000;
        constexpr unsigned int CONVERSION_INVALID_FORMAT = 10001;
        constexpr unsigned int CONVERSION_VALUE_OUT_OF_RANGE = 10002;
        constexpr unsigned int CONVERSION_UNSUPPORTED_TYPE = 10003;
        constexpr unsigned int CONVERSION_NULL_INPUT_UNEXPECTED = 10004;
        constexpr unsigned int CONVERSION_TYPE_MISMATCH_ACCESS = 10005;

        // MYSQL_TIME 解析/格式化/转换错误码 (10100 - 10199)
        constexpr unsigned int TIME_STRING_PARSE_EMPTY_INPUT = 10101;
        constexpr unsigned int TIME_STRING_PARSE_INVALID_FORMAT = 10102;
        constexpr unsigned int TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE = 10103;
        constexpr unsigned int TIME_FORMAT_INVALID_MYSQL_TIME_STRUCT = 10104;
        constexpr unsigned int TIME_FORMAT_STREAM_ERROR = 10105;
        constexpr unsigned int TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME = 10106;  // MYSQL_TIME to chrono
        constexpr unsigned int TIME_CHRONO_CONVERSION_OUT_OF_RANGE = 10107;        // chrono value out of MYSQL_TIME range or vice-versa
        constexpr unsigned int TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE = 10108;    // e.g. trying to convert TIME to full time_point

        // MYSQL_BIND 设置错误码 (10200 - 10299)
        constexpr unsigned int BIND_SETUP_NULL_POINTER_ARGUMENT = 10201;

        // MySqlNativeValue 辅助函数错误 (10300 - 10399)
        constexpr unsigned int NATIVE_VALUE_TO_STRING_ERROR = 10301;

        // 通用逻辑/状态错误 (19000 - ...)
        constexpr unsigned int LOGIC_ERROR_INVALID_STATE = 19001;
        constexpr unsigned int UNKNOWN_ERROR = 19999;
    }  // namespace InternalErrc

    struct MySqlProtocolError {
        unsigned int error_code = InternalErrc::SUCCESS;
        char sql_state[SQLSTATE_LENGTH + 1];
        std::string error_message;

        MySqlProtocolError() noexcept {
            error_code = InternalErrc::SUCCESS;
            sql_state[0] = '0';
            sql_state[1] = '0';
            sql_state[2] = '0';
            sql_state[3] = '0';
            sql_state[4] = '0';
            sql_state[SQLSTATE_LENGTH] = '\0';
            error_message = "Success";
        }

        MySqlProtocolError(unsigned int mysql_err_code, const char* mysql_sql_state, std::string mysql_msg) noexcept : error_code(mysql_err_code), error_message(std::move(mysql_msg)) {
            if (mysql_sql_state) {
                std::strncpy(sql_state, mysql_sql_state, SQLSTATE_LENGTH);
                sql_state[SQLSTATE_LENGTH] = '\0';
            } else {  // 如果 mysql_sql_state 为空，也提供一个默认值
                sql_state[0] = 'H';
                sql_state[1] = 'Y';
                sql_state[2] = '0';
                sql_state[3] = '0';
                sql_state[4] = '0';  // "HY000" General error
                sql_state[SQLSTATE_LENGTH] = '\0';
            }
            // 确保如果 MySQL 返回错误码 0，我们的 error_message 也反映成功（即使 mysql_error 可能返回非空字符串）
            if (error_code == 0 && (mysql_sql_state == nullptr || std::strncmp(mysql_sql_state, "00000", SQLSTATE_LENGTH) != 0)) {
                // 如果 mysql_errno 是 0，但 sqlstate 不是 "00000" (或 null)，这很罕见。
                // 我们的 error_message 应该优先反映成功状态。
                if (error_message.empty() || error_message == "NULL") {  // "NULL" string is sometimes returned by mysql_error
                    this->error_message = "Success (MySQL error code 0)";
                } else if (error_message.find(" অভ") != std::string::npos) {  // Common non-error "OK" messages in some locales
                    this->error_message = "Success (MySQL: " + error_message + ")";
                } else if (error_code == 0) {  // If truly error_code 0, ensure message doesn't mislead
                    this->error_message = "Success (MySQL error code 0, non-standard state: " + std::string(sql_state) + ")";
                }
            }
        }

        MySqlProtocolError(unsigned int internal_code, std::string msg) noexcept : error_code(internal_code), error_message(std::move(msg)) {
            // 对于内部错误，error_code 是 InternalErrc::* 之一
            // sql_state 可以设置为一个通用的内部错误状态
            sql_state[0] = 'P';
            sql_state[1] = 'I';
            sql_state[2] = '0';
            sql_state[3] = '0';
            sql_state[4] = '0';  // "PI000" for Protocol Internal
            sql_state[SQLSTATE_LENGTH] = '\0';
        }

        bool isOk() const noexcept {
            // 主要判断标准：协议层内部错误码是否为 SUCCESS
            return error_code == InternalErrc::SUCCESS;
        }
    };

    struct MySqlNativeValue {
        std::variant<std::monostate, bool, int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t, float, double, std::string, std::vector<unsigned char>, MYSQL_TIME> data;

        enum enum_field_types original_mysql_type = ::MYSQL_TYPE_NULL;
        unsigned int original_mysql_flags = 0;
        uint16_t original_charsetnr = 0;  // 新增：存储原始字符集编号

        MySqlNativeValue() = default;
        bool is_null() const noexcept {
            return data.index() == 0;
        }

        std::expected<std::string, MySqlProtocolError> toString() const;

        template <typename T>
        std::optional<T> get_if() const noexcept {
            if (std::holds_alternative<T>(data)) {
                return std::get<T>(data);
            }
            return std::nullopt;
        }

        template <typename T>
        std::expected<T, MySqlProtocolError> get_as() const noexcept {
            if (std::holds_alternative<T>(data)) {
                return std::get<T>(data);
            }
            // 简单的类型名称获取，可以根据需要扩展
            std::string requested_type_name = "unknown_requested_type";
            if constexpr (std::is_same_v<T, bool>)
                requested_type_name = "bool";
            else if constexpr (std::is_same_v<T, int8_t>)
                requested_type_name = "int8_t";
            else if constexpr (std::is_same_v<T, uint8_t>)
                requested_type_name = "uint8_t";
            else if constexpr (std::is_same_v<T, int16_t>)
                requested_type_name = "int16_t";
            else if constexpr (std::is_same_v<T, uint16_t>)
                requested_type_name = "uint16_t";
            else if constexpr (std::is_same_v<T, int32_t>)
                requested_type_name = "int32_t";
            else if constexpr (std::is_same_v<T, uint32_t>)
                requested_type_name = "uint32_t";
            else if constexpr (std::is_same_v<T, int64_t>)
                requested_type_name = "int64_t";
            else if constexpr (std::is_same_v<T, uint64_t>)
                requested_type_name = "uint64_t";
            else if constexpr (std::is_same_v<T, float>)
                requested_type_name = "float";
            else if constexpr (std::is_same_v<T, double>)
                requested_type_name = "double";
            else if constexpr (std::is_same_v<T, std::string>)
                requested_type_name = "std::string";
            else if constexpr (std::is_same_v<T, std::vector<unsigned char>>)
                requested_type_name = "std::vector<unsigned char>";
            else if constexpr (std::is_same_v<T, MYSQL_TIME>)
                requested_type_name = "MYSQL_TIME";

            return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_TYPE_MISMATCH_ACCESS, "Attempted to get value as type '" + requested_type_name + "' but it holds a different type. Original MySQL type ID: " + std::to_string(original_mysql_type)));
        }
    };

    // --- MySQL Native Value Conversion Functions (Declarations) ---
    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlRowFieldToNativeValue(const char* c_str_value, unsigned long length, const MYSQL_FIELD* field_meta);
    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlBoundResultToNativeValue(const MYSQL_BIND* bind_info, unsigned int original_flags_if_known = 0, uint16_t original_charsetnr_if_known = 0);

    // --- MYSQL_BIND Preparation for Statement Parameters (Declarations) ---
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int8_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int16_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int32_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int64_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, float);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, double);

    std::expected<void, MySqlProtocolError> setupMySqlBindForInputString(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, unsigned long* length_indicator_ptr, enum enum_field_types mysql_type, char* str_buffer, unsigned long str_actual_length);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInputBlob(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, unsigned long* length_indicator_ptr, enum enum_field_types mysql_type, unsigned char* blob_buffer, unsigned long blob_actual_length);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInputTime(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, enum enum_field_types mysql_type, MYSQL_TIME* time_buffer);
    std::expected<void, MySqlProtocolError> setupMySqlBindForNull(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, enum enum_field_types mysql_type);

    // --- MYSQL_TIME <-> String Conversion Utilities (Declarations) ---
    std::expected<MYSQL_TIME, MySqlProtocolError> parseDateTimeStringToMySqlTime(std::string_view dt_string, enum enum_field_types expected_type);
    std::expected<std::string, MySqlProtocolError> formatMySqlTimeToString(const MYSQL_TIME& mysql_time, enum enum_field_types original_type);

    // --- MYSQL_TIME <-> std::chrono Conversion Utilities (Declarations) ---
    std::expected<std::chrono::system_clock::time_point, MySqlProtocolError> mySqlTimeToSystemClockTimePoint(const MYSQL_TIME& mysql_time);
    std::expected<MYSQL_TIME, MySqlProtocolError> systemClockTimePointToMySqlTime(const std::chrono::system_clock::time_point& time_point, enum enum_field_types target_mysql_type = MYSQL_TYPE_DATETIME);

    // C++20 date/time types might be more direct for some conversions
    // For DATE:
    std::expected<std::chrono::year_month_day, MySqlProtocolError> mySqlTimeToYearMonthDay(const MYSQL_TIME& mysql_time);
    std::expected<MYSQL_TIME, MySqlProtocolError> yearMonthDayToMySqlDate(const std::chrono::year_month_day& ymd);

    // For TIME: (duration from midnight)
    std::expected<std::chrono::microseconds, MySqlProtocolError> mySqlTimeToDuration(const MYSQL_TIME& mysql_time);  // Returns duration, handles 'neg'
    std::expected<MYSQL_TIME, MySqlProtocolError> durationToMySqlTime(std::chrono::microseconds duration_from_midnight);

    // --- MySQL Error Reporting (Declarations) ---
    MySqlProtocolError getMySqlHandleError(MYSQL* handle);
    MySqlProtocolError getMySqlStmtError(MYSQL_STMT* stmt_handle);

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_bind_setup_null.cpp
#include <cstring>  // For std::memset

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<void, MySqlProtocolError> setupMySqlBindForNull(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, enum enum_field_types mysql_type) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (null setup)."));
        }

        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = mysql_type;  // Type still needs to be known by the server
        bind_struct.buffer = nullptr;          // No data buffer for NULL
        bind_struct.buffer_length = 0;         // No length for NULL

        *is_null_indicator_ptr = true;  // Mark as SQL NULL
        bind_struct.is_null = is_null_indicator_ptr;

        bind_struct.length = nullptr;  // Length is not relevant for NULL
        // is_unsigned is also not relevant for NULL
        return {};  // Success
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_bind_setup_numeric.cpp
#include <cstring>  // For std::memset

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool /*value_to_bind_type_deduction_only*/) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (bool)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_TINY;  // Booleans are often bound as TINYINT
        bind_struct.buffer_length = sizeof(char);   // MySQL C API often uses char for bool (0 or 1)
        bind_struct.is_unsigned = 0;                // Typically signed tinyint(1)
        *is_null_indicator_ptr = false;             // Assume not null by default, caller sets buffer and can update this
        bind_struct.is_null = is_null_indicator_ptr;
        // bind_struct.buffer is set by the caller (Transport layer)
        return {};  // Success
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned_val, int8_t) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (int8_t)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_TINY;
        bind_struct.buffer_length = sizeof(int8_t);
        bind_struct.is_unsigned = is_unsigned_val ? 1 : 0;
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned_val, int16_t) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (int16_t)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_SHORT;
        bind_struct.buffer_length = sizeof(int16_t);
        bind_struct.is_unsigned = is_unsigned_val ? 1 : 0;
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned_val, int32_t) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (int32_t)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_LONG;
        bind_struct.buffer_length = sizeof(int32_t);
        bind_struct.is_unsigned = is_unsigned_val ? 1 : 0;
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned_val, int64_t) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (int64_t)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_LONGLONG;
        bind_struct.buffer_length = sizeof(int64_t);
        bind_struct.is_unsigned = is_unsigned_val ? 1 : 0;
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, float) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (float)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_FLOAT;
        bind_struct.buffer_length = sizeof(float);
        bind_struct.is_unsigned = 0;  // Floats are not unsigned in MySQL bind context
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, double) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (double)."));
        }
        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = MYSQL_TYPE_DOUBLE;
        bind_struct.buffer_length = sizeof(double);
        bind_struct.is_unsigned = 0;
        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_bind_setup_string_blob_time.cpp
#include <cstring>  // For std::memset

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<void, MySqlProtocolError> setupMySqlBindForInputString(MYSQL_BIND& bind_struct,
                                                                         bool* is_null_indicator_ptr,
                                                                         unsigned long* length_indicator_ptr,
                                                                         enum enum_field_types mysql_type,
                                                                         char* str_buffer,  // Buffer provided by caller
                                                                         unsigned long str_actual_length) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (string)."));
        }
        if (!length_indicator_ptr) {
            // For strings/blobs, length_indicator_ptr is crucial.
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "length_indicator_ptr cannot be null for MYSQL_BIND (string)."));
        }
        // str_buffer can be null IF str_actual_length is 0, representing an empty string.
        // However, the C API might expect a non-null (even if dummy) buffer for empty strings.
        // Let's assume caller manages this; if str_actual_length > 0, str_buffer must be valid.
        if (str_actual_length > 0 && !str_buffer) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "str_buffer cannot be null for non-empty string."));
        }

        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = mysql_type;  // e.g., MYSQL_TYPE_STRING, MYSQL_TYPE_VAR_STRING, MYSQL_TYPE_JSON
        bind_struct.buffer = static_cast<void*>(str_buffer);
        // For input, buffer_length is the max capacity of the buffer.
        // The actual length of data is given by *bind_struct.length.
        // Let's assume str_actual_length is the actual data length, and the buffer is at least this large.
        // The C API documentation for mysql_stmt_bind_param specifies buffer_length as "the size of the buffer".
        // For input of variable-length data, `*length` points to the actual length.
        // It's safer to set buffer_length to the actual data length being sent for string/blob types if that's what's in str_buffer.
        bind_struct.buffer_length = str_actual_length;

        *length_indicator_ptr = str_actual_length;
        bind_struct.length = length_indicator_ptr;

        *is_null_indicator_ptr = false;  // Buffer is provided, so not SQL NULL initially
        bind_struct.is_null = is_null_indicator_ptr;
        // bind_struct.is_unsigned is not relevant for string types
        return {};  // Success
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInputBlob(MYSQL_BIND& bind_struct,
                                                                       bool* is_null_indicator_ptr,
                                                                       unsigned long* length_indicator_ptr,
                                                                       enum enum_field_types mysql_type,
                                                                       unsigned char* blob_buffer,  // Buffer provided by caller
                                                                       unsigned long blob_actual_length) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (blob)."));
        }
        if (!length_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "length_indicator_ptr cannot be null for MYSQL_BIND (blob)."));
        }
        if (blob_actual_length > 0 && !blob_buffer) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "blob_buffer cannot be null for non-empty blob."));
        }

        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = mysql_type;  // e.g., MYSQL_TYPE_BLOB
        bind_struct.buffer = static_cast<void*>(blob_buffer);
        bind_struct.buffer_length = blob_actual_length;  // Similar to string, actual length of data in buffer

        *length_indicator_ptr = blob_actual_length;
        bind_struct.length = length_indicator_ptr;

        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        return {};  // Success
    }

    std::expected<void, MySqlProtocolError> setupMySqlBindForInputTime(MYSQL_BIND& bind_struct,
                                                                       bool* is_null_indicator_ptr,
                                                                       enum enum_field_types mysql_type,
                                                                       MYSQL_TIME* time_buffer  // Buffer provided by caller
    ) {
        if (!is_null_indicator_ptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "is_null_indicator_ptr cannot be null for MYSQL_BIND (time)."));
        }
        if (!time_buffer) {
            return std::unexpected(MySqlProtocolError(InternalErrc::BIND_SETUP_NULL_POINTER_ARGUMENT, "time_buffer cannot be null for MYSQL_BIND (time)."));
        }

        std::memset(&bind_struct, 0, sizeof(MYSQL_BIND));
        bind_struct.buffer_type = mysql_type;  // e.g., MYSQL_TYPE_DATETIME, MYSQL_TYPE_TIMESTAMP
        bind_struct.buffer = static_cast<void*>(time_buffer);
        bind_struct.buffer_length = sizeof(MYSQL_TIME);  // Fixed size for MYSQL_TIME

        *is_null_indicator_ptr = false;
        bind_struct.is_null = is_null_indicator_ptr;
        // bind_struct.length is not typically used for MYSQL_TIME input binding for fixed-size types.
        // mysql_stmt_bind_param infers length from buffer_type for fixed-size types.
        // Setting it to nullptr is common.
        bind_struct.length = nullptr;
        return {};  // Success
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_error_reporting.cpp
#include <cstring>  // For std::strncpy, std::strcmp
#include <string>   // For std::string

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    MySqlProtocolError getMySqlHandleError(MYSQL* handle) {
        if (!handle) {
            return MySqlProtocolError(InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT, "MYSQL handle is null.");
        }
        unsigned int err_no = mysql_errno(handle);
        const char* sql_state = mysql_sqlstate(handle);
        std::string err_msg = mysql_error(handle);

        if (err_no == 0) {
            // Even if err_no is 0, check sql_state. "00000" is success.
            // If sql_state is not "00000" but err_no is 0, it's unusual but treat as success from error code perspective.
            // MySqlProtocolError() default constructor handles success.
            // We can make the success message more explicit if mysql_error also returns something.
            MySqlProtocolError success_err;  // Defaults to InternalErrc::SUCCESS and "00000"
            if (!err_msg.empty() && err_msg != "NULL" && err_msg.find(" অভ") == std::string::npos /* common non-error msg */) {
                // Sometimes mysql_error returns non-empty for success, e.g. "Query OK..."
                // For consistency, let's keep the default "Success" or be more specific.
                success_err.error_message = "Success (MySQL: " + err_msg + ")";
            } else {
                success_err.error_message = "Success";
            }
            return success_err;
        }
        // Error from MySQL C API
        return MySqlProtocolError(err_no, sql_state, err_msg);
    }

    MySqlProtocolError getMySqlStmtError(MYSQL_STMT* stmt_handle) {
        if (!stmt_handle) {
            return MySqlProtocolError(InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT, "MYSQL_STMT handle is null.");
        }
        unsigned int err_no = mysql_stmt_errno(stmt_handle);
        const char* sql_state = mysql_stmt_sqlstate(stmt_handle);
        std::string err_msg = mysql_stmt_error(stmt_handle);

        if (err_no == 0) {
            MySqlProtocolError success_err;
            if (!err_msg.empty() && err_msg != "NULL" && err_msg.find(" অভ") == std::string::npos) {
                success_err.error_message = "Success (MySQL STMT: " + err_msg + ")";
            } else {
                success_err.error_message = "Success";
            }
            return success_err;
        }
        // Error from MySQL C API
        return MySqlProtocolError(err_no, sql_state, err_msg);
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_native_value_from_bind.cpp
#include <string>  // For std::string, std::to_string
#include <vector>  // For std::vector

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected>, <variant> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlBoundResultToNativeValue(const MYSQL_BIND* bind_info, unsigned int original_flags_if_known, uint16_t original_charsetnr_if_known) {
        if (!bind_info) {
            return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT, "MYSQL_BIND info is null."));
        }

        MySqlNativeValue native_val;
        native_val.original_mysql_type = bind_info->buffer_type;
        native_val.original_mysql_flags = original_flags_if_known;
        native_val.original_charsetnr = original_charsetnr_if_known;  // Store charset

        if (bind_info->is_null == nullptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT, "MYSQL_BIND.is_null pointer is null."));
        }
        if (*bind_info->is_null) {
            native_val.data = std::monostate{};
            return native_val;
        }

        unsigned long length = 0;
        if (bind_info->length) {
            length = *bind_info->length;
        }

        if (!bind_info->buffer) {
            bool type_needs_buffer_even_if_empty = false;
            switch (bind_info->buffer_type) {
                case MYSQL_TYPE_TINY:
                case MYSQL_TYPE_SHORT:
                case MYSQL_TYPE_INT24:
                case MYSQL_TYPE_LONG:
                case MYSQL_TYPE_LONGLONG:
                case MYSQL_TYPE_FLOAT:
                case MYSQL_TYPE_DOUBLE:
                case MYSQL_TYPE_DATE:
                case MYSQL_TYPE_TIME:
                case MYSQL_TYPE_DATETIME:
                case MYSQL_TYPE_TIMESTAMP:
                case MYSQL_TYPE_YEAR:
                case MYSQL_TYPE_TIMESTAMP2:
                case MYSQL_TYPE_DATETIME2:
                case MYSQL_TYPE_TIME2:
                case MYSQL_TYPE_NEWDATE:
                    type_needs_buffer_even_if_empty = true;
                    break;
                // For string/blob types, if length is 0, buffer *could* be null, though C API usually provides a valid pointer.
                // If length > 0, buffer must not be null.
                case MYSQL_TYPE_STRING:
                case MYSQL_TYPE_VAR_STRING:
                case MYSQL_TYPE_VARCHAR:
                case MYSQL_TYPE_DECIMAL:
                case MYSQL_TYPE_NEWDECIMAL:
                case MYSQL_TYPE_ENUM:
                case MYSQL_TYPE_SET:
                case MYSQL_TYPE_JSON:
                case MYSQL_TYPE_TINY_BLOB:
                case MYSQL_TYPE_MEDIUM_BLOB:
                case MYSQL_TYPE_LONG_BLOB:
                case MYSQL_TYPE_BLOB:
                case MYSQL_TYPE_GEOMETRY:
                case MYSQL_TYPE_BIT:
                    if (length > 0) type_needs_buffer_even_if_empty = true;
                    break;
                default:  // Unknown types, assume they need a buffer if not null
                    type_needs_buffer_even_if_empty = true;
                    break;
            }
            if (type_needs_buffer_even_if_empty) {
                return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "MYSQL_BIND buffer is null unexpectedly for type: " + std::to_string(bind_info->buffer_type)));
            }
            // If we reach here, buffer is null, but it's for a 0-length string/blob, or a type that doesn't strictly need a buffer if null (unlikely for bind output)
            // The switch cases for string/blob will handle creating empty string/vector.
        }

        switch (bind_info->buffer_type) {
            case MYSQL_TYPE_TINY:
                if (!bind_info->buffer && bind_info->buffer_length > 0) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for TINY with non-zero buffer_length."));
                }
                if (bind_info->buffer_length == 1 && !bind_info->is_unsigned && (original_flags_if_known & NUM_FLAG)) {
                    if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for TINY bool heuristic."));
                    native_val.data = (*static_cast<char*>(bind_info->buffer) != 0);
                } else if (bind_info->is_unsigned) {
                    if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for unsigned TINY."));
                    native_val.data = static_cast<uint8_t>(*static_cast<unsigned char*>(bind_info->buffer));
                } else {
                    if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for signed TINY."));
                    native_val.data = static_cast<int8_t>(*static_cast<char*>(bind_info->buffer));
                }
                break;
            case MYSQL_TYPE_SHORT:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for SHORT."));
                native_val.data = bind_info->is_unsigned ? static_cast<uint16_t>(*static_cast<unsigned short*>(bind_info->buffer)) : static_cast<int16_t>(*static_cast<short*>(bind_info->buffer));
                break;
            case MYSQL_TYPE_INT24:
            case MYSQL_TYPE_LONG:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for LONG/INT24."));
                native_val.data = bind_info->is_unsigned ? static_cast<uint32_t>(*static_cast<unsigned int*>(bind_info->buffer)) : static_cast<int32_t>(*static_cast<int*>(bind_info->buffer));
                break;
            case MYSQL_TYPE_LONGLONG:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for LONGLONG."));
                native_val.data = bind_info->is_unsigned ? static_cast<uint64_t>(*static_cast<unsigned long long*>(bind_info->buffer)) : static_cast<int64_t>(*static_cast<long long*>(bind_info->buffer));
                break;
            case MYSQL_TYPE_FLOAT:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for FLOAT."));
                native_val.data = *static_cast<float*>(bind_info->buffer);
                break;
            case MYSQL_TYPE_DOUBLE:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for DOUBLE."));
                native_val.data = *static_cast<double*>(bind_info->buffer);
                break;
            case MYSQL_TYPE_STRING:
            case MYSQL_TYPE_VAR_STRING:
            case MYSQL_TYPE_VARCHAR:
            case MYSQL_TYPE_DECIMAL:
            case MYSQL_TYPE_NEWDECIMAL:
            case MYSQL_TYPE_ENUM:
            case MYSQL_TYPE_SET:
            case MYSQL_TYPE_JSON:
                if (length > 0 && !bind_info->buffer) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for non-empty string type (type: " + std::to_string(bind_info->buffer_type) + ")."));
                }
                native_val.data = bind_info->buffer ? std::string(static_cast<char*>(bind_info->buffer), length) : std::string();
                break;
            case MYSQL_TYPE_TINY_BLOB:
            case MYSQL_TYPE_MEDIUM_BLOB:
            case MYSQL_TYPE_LONG_BLOB:
            case MYSQL_TYPE_BLOB:
            case MYSQL_TYPE_GEOMETRY:
            case MYSQL_TYPE_BIT:
                if (length > 0 && !bind_info->buffer) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for non-empty blob type (type: " + std::to_string(bind_info->buffer_type) + ")."));
                }
                native_val.data = bind_info->buffer ? std::vector<unsigned char>(static_cast<unsigned char*>(bind_info->buffer), static_cast<unsigned char*>(bind_info->buffer) + length) : std::vector<unsigned char>();
                break;
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_TIME:
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_TIMESTAMP:
            case MYSQL_TYPE_YEAR:
            case MYSQL_TYPE_TIMESTAMP2:
            case MYSQL_TYPE_DATETIME2:
            case MYSQL_TYPE_TIME2:
            case MYSQL_TYPE_NEWDATE:
                if (!bind_info->buffer) return std::unexpected(MySqlProtocolError(InternalErrc::LOGIC_ERROR_INVALID_STATE, "Null buffer for TIME type (type: " + std::to_string(bind_info->buffer_type) + ")."));
                native_val.data = *static_cast<MYSQL_TIME*>(bind_info->buffer);
                break;
            case MYSQL_TYPE_NULL:
                native_val.data = std::monostate{};
                break;
            default:
                return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_UNSUPPORTED_TYPE, "Unsupported MySQL field type encountered in binary protocol: " + std::to_string(bind_info->buffer_type)));
        }
        return native_val;
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_native_value_from_row.cpp
#include <charconv>     // For std::from_chars
#include <limits>       // For std::numeric_limits
#include <string>       // For std::string, std::to_string
#include <string_view>  // For std::string_view
#include <vector>       // For std::vector

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected>, <variant> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlRowFieldToNativeValue(const char* c_str_value, unsigned long length, const MYSQL_FIELD* field_meta) {
        if (!field_meta) {
            return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT, "MYSQL_FIELD metadata is null."));
        }

        MySqlNativeValue native_val;
        native_val.original_mysql_type = field_meta->type;
        native_val.original_mysql_flags = field_meta->flags;
        native_val.original_charsetnr = field_meta->charsetnr;

        if (c_str_value == nullptr) {
            native_val.data = std::monostate{};
            return native_val;
        }

        std::string_view sv(c_str_value, length);

        switch (field_meta->type) {
            case MYSQL_TYPE_TINY:
                if (field_meta->length == 1 && !(field_meta->flags & UNSIGNED_FLAG) && (field_meta->flags & NUM_FLAG)) {
                    if (sv == "1")
                        native_val.data = true;
                    else if (sv == "0")
                        native_val.data = false;
                    else {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "TINYINT(1) for bool expected '0' or '1', got: " + std::string(sv)));
                    }
                } else if (field_meta->flags & UNSIGNED_FLAG) {
                    unsigned long long ull_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ull_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "TINY UNSIGNED conversion failed: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ull_val > std::numeric_limits<uint8_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "TINY UNSIGNED conversion failed: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<uint8_t>(ull_val);
                } else {
                    long long ll_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ll_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "TINY SIGNED conversion failed: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ll_val < std::numeric_limits<int8_t>::min() || ll_val > std::numeric_limits<int8_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "TINY SIGNED conversion failed: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<int8_t>(ll_val);
                }
                break;
            case MYSQL_TYPE_SHORT:
                if (field_meta->flags & UNSIGNED_FLAG) {
                    unsigned long long ull_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ull_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "SHORT UNSIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ull_val > std::numeric_limits<uint16_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "SHORT UNSIGNED: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<uint16_t>(ull_val);
                } else {
                    long long ll_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ll_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "SHORT SIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ll_val < std::numeric_limits<int16_t>::min() || ll_val > std::numeric_limits<int16_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "SHORT SIGNED: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<int16_t>(ll_val);
                }
                break;
            case MYSQL_TYPE_INT24:
            case MYSQL_TYPE_LONG:
                if (field_meta->flags & UNSIGNED_FLAG) {
                    unsigned long long ull_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ull_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "LONG/INT24 UNSIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ull_val > std::numeric_limits<uint32_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "LONG/INT24 UNSIGNED: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<uint32_t>(ull_val);
                } else {
                    long long ll_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ll_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "LONG/INT24 SIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    if (ll_val < std::numeric_limits<int32_t>::min() || ll_val > std::numeric_limits<int32_t>::max()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_VALUE_OUT_OF_RANGE, "LONG/INT24 SIGNED: value '" + std::string(sv) + "' out of range."));
                    }
                    native_val.data = static_cast<int32_t>(ll_val);
                }
                break;
            case MYSQL_TYPE_LONGLONG:
                if (field_meta->flags & UNSIGNED_FLAG) {
                    unsigned long long ull_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ull_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "LONGLONG UNSIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    native_val.data = ull_val;
                } else {
                    long long ll_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), ll_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "LONGLONG SIGNED: invalid format for '" + std::string(sv) + "'."));
                    }
                    native_val.data = ll_val;
                }
                break;
            case MYSQL_TYPE_FLOAT:
                {
                    float f_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), f_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "FLOAT conversion failed for '" + std::string(sv) + "'."));
                    }
                    native_val.data = f_val;
                    break;
                }
            case MYSQL_TYPE_DOUBLE:
                {
                    double d_val;
                    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), d_val);
                    if (ec != std::errc() || ptr != sv.data() + sv.size()) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_INVALID_FORMAT, "DOUBLE conversion failed for '" + std::string(sv) + "'."));
                    }
                    native_val.data = d_val;
                    break;
                }
            case MYSQL_TYPE_DECIMAL:
            case MYSQL_TYPE_NEWDECIMAL:
            case MYSQL_TYPE_ENUM:
            case MYSQL_TYPE_SET:
            case MYSQL_TYPE_YEAR:
            case MYSQL_TYPE_JSON:
                native_val.data = std::string(sv);
                break;
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_TIME:
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_TIMESTAMP:
            case MYSQL_TYPE_TIMESTAMP2:
            case MYSQL_TYPE_DATETIME2:
            case MYSQL_TYPE_TIME2:
            case MYSQL_TYPE_NEWDATE:
                {
                    auto time_result = parseDateTimeStringToMySqlTime(sv, field_meta->type);
                    if (time_result) {
                        native_val.data = time_result.value();
                    } else {
                        return std::unexpected(time_result.error());
                    }
                    break;
                }
            case MYSQL_TYPE_STRING:
            case MYSQL_TYPE_VAR_STRING:
            case MYSQL_TYPE_VARCHAR:
                // The character set number 63 is commonly used for 'binary' collation (e.g., latin1_bin, utf8mb4_bin)
                // or the specific binary character set (charset `binary`).
                // `field_meta->charsetnr == 63` is a strong indicator for binary data.
                if ((field_meta->flags & BINARY_FLAG) && field_meta->charsetnr == 63) {
                    native_val.data = std::vector<unsigned char>(reinterpret_cast<const unsigned char*>(c_str_value), reinterpret_cast<const unsigned char*>(c_str_value) + length);
                } else {
                    native_val.data = std::string(sv);
                }
                break;
            case MYSQL_TYPE_TINY_BLOB:
            case MYSQL_TYPE_MEDIUM_BLOB:
            case MYSQL_TYPE_LONG_BLOB:
            case MYSQL_TYPE_BLOB:
            case MYSQL_TYPE_GEOMETRY:
            case MYSQL_TYPE_BIT:
                native_val.data = std::vector<unsigned char>(reinterpret_cast<const unsigned char*>(c_str_value), reinterpret_cast<const unsigned char*>(c_str_value) + length);
                break;
            case MYSQL_TYPE_NULL:
                native_val.data = std::monostate{};
                break;
            default:
                return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_UNSUPPORTED_TYPE, "Unsupported MySQL field type encountered in text protocol: " + std::to_string(field_meta->type)));
        }
        return native_val;
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_native_value_utils.cpp
#include <charconv>  // For std::to_chars (C++17, usable in C++26 context) for floats/doubles if needed
#include <iomanip>   // For std::hex, std::setw, std::setfill
#include <sstream>   // For std::ostringstream
#include <string>    // For std::to_string, std::string
#include <variant>   // For std::visit
#include <vector>    // For std::vector

#include "mysql_protocol/mysql_type_converter.h"  // For MySqlNativeValue, MySqlProtocolError, formatMySqlTimeToString

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    // Helper to convert std::vector<unsigned char> to hex string
    std::string blobToHexString(const std::vector<unsigned char>& blob) {
        std::ostringstream oss;
        oss << "0x";
        oss << std::hex << std::setfill('0');
        for (unsigned char byte : blob) {
            oss << std::setw(2) << static_cast<int>(byte);
        }
        return oss.str();
    }

    std::expected<std::string, MySqlProtocolError> MySqlNativeValue::toString() const {
        return std::visit(
            [this](auto&& arg) -> std::expected<std::string, MySqlProtocolError> {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    return "NULL";
                } else if constexpr (std::is_same_v<T, bool>) {
                    return arg ? "true" : "false";
                } else if constexpr (std::is_integral_v<T> || std::is_floating_point_v<T>) {
                    // For floats/doubles, std::to_string can lose precision or have locale issues.
                    // std::format (C++20) or std::to_chars (C++17) are better alternatives for production.
                    // Using std::to_string for simplicity here, assuming default locale is fine.
                    // For C++26, std::format would be ideal.
                    if constexpr (std::is_floating_point_v<T>) {
                        // Using ostringstream for better control over float/double formatting
                        std::ostringstream temp_oss;
                        temp_oss << arg;  // Default precision
                        if (temp_oss.fail()) {
                            return std::unexpected(MySqlProtocolError(InternalErrc::NATIVE_VALUE_TO_STRING_ERROR, "Failed to convert float/double to string using ostringstream."));
                        }
                        return temp_oss.str();
                    } else {
                        return std::to_string(arg);
                    }
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return "'" + arg + "'";  // Quote strings
                } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                    return blobToHexString(arg);
                } else if constexpr (std::is_same_v<T, MYSQL_TIME>) {
                    // Use the existing formatting function. original_mysql_type should be set correctly
                    // when MySqlNativeValue was created.
                    return formatMySqlTimeToString(arg, this->original_mysql_type);
                }
                // Fallback for any unhandled type in the variant (should not happen if variant is exhaustive)
                return std::unexpected(MySqlProtocolError(InternalErrc::NATIVE_VALUE_TO_STRING_ERROR, "Unhandled type in MySqlNativeValue::toString."));
            },
            data);
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_time_chrono_conversion.cpp
#include <chrono>
#include <ctime>    // For std::mktime, std::gmtime_r/localtime_r (or _s versions on Windows)
#include <iomanip>  // For std::get_time (C++11, but might be less robust than manual parsing for specific formats)
#include <string>   // For std::to_string

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected>, <vector> are included via mysql_type_converter.h

namespace mysql_protocol {

    // Helper to check if a year is a leap year
    bool is_leap(int year) {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    }

    // Helper to get days in month
    int days_in_month(int year, int month) {
        if (month < 1 || month > 12) return 0;  // Invalid month
        if (month == 2) return is_leap(year) ? 29 : 28;
        if (month == 4 || month == 6 || month == 9 || month == 11) return 30;
        return 31;
    }

    std::expected<std::chrono::system_clock::time_point, MySqlProtocolError> mySqlTimeToSystemClockTimePoint(const MYSQL_TIME& mysql_time) {
        // MYSQL_TIME for TIMESTAMP columns usually has time_type = MYSQL_TIMESTAMP_DATETIME.
        // We accept DATE as well, assuming time part is midnight.
        if (mysql_time.time_type != MYSQL_TIMESTAMP_DATETIME && mysql_time.time_type != MYSQL_TIMESTAMP_DATE) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE, "MYSQL_TIME must be a DATETIME or DATE type to convert to system_clock::time_point. Actual type: " + std::to_string(mysql_time.time_type)));
        }
        if (mysql_time.year == 0 && mysql_time.month == 0 && mysql_time.day == 0) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "Zero date (0000-00-00) in MYSQL_TIME cannot be converted to time_point."));
        }
        if (mysql_time.month == 0 || mysql_time.day == 0) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "MYSQL_TIME has month or day as 0, invalid for time_point conversion."));
        }
        if (mysql_time.day > days_in_month(mysql_time.year, mysql_time.month)) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "MYSQL_TIME has invalid day for month/year."));
        }

        std::tm t{};
        t.tm_year = mysql_time.year - 1900;
        t.tm_mon = mysql_time.month - 1;
        t.tm_mday = mysql_time.day;
        t.tm_hour = mysql_time.hour;
        t.tm_min = mysql_time.minute;
        t.tm_sec = mysql_time.second;
        t.tm_isdst = -1;

        std::time_t time_since_epoch = std::mktime(&t);
        if (time_since_epoch == -1) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Failed to convert MYSQL_TIME to time_t (mktime failed), possibly out of range or invalid. Year: " + std::to_string(mysql_time.year)));
        }

        auto tp = std::chrono::system_clock::from_time_t(time_since_epoch);
        tp += std::chrono::microseconds(mysql_time.second_part);

        return tp;
    }

    std::expected<MYSQL_TIME, MySqlProtocolError> systemClockTimePointToMySqlTime(const std::chrono::system_clock::time_point& time_point, enum enum_field_types target_mysql_type) {
        MYSQL_TIME mt{};
        std::memset(&mt, 0, sizeof(MYSQL_TIME));

        std::time_t time_since_epoch = std::chrono::system_clock::to_time_t(time_point);

        std::tm t{};
#ifdef _WIN32
        if (gmtime_s(&t, &time_since_epoch) != 0) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "gmtime_s failed to convert time_point."));
        }
#else
        if (gmtime_r(&time_since_epoch, &t) == nullptr) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "gmtime_r failed to convert time_point."));
        }
#endif

        mt.year = t.tm_year + 1900;
        mt.month = t.tm_mon + 1;
        mt.day = t.tm_mday;
        mt.hour = t.tm_hour;
        mt.minute = t.tm_min;
        mt.second = t.tm_sec;

        auto micros_duration = std::chrono::duration_cast<std::chrono::microseconds>(time_point.time_since_epoch() % std::chrono::seconds(1));
        long long micros_count = micros_duration.count();
        mt.second_part = (micros_count < 0) ? 0 : static_cast<unsigned long>(micros_count);

        mt.neg = false;

        switch (target_mysql_type) {
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_DATETIME2:
            case MYSQL_TYPE_TIMESTAMP:
            case MYSQL_TYPE_TIMESTAMP2:
                mt.time_type = MYSQL_TIMESTAMP_DATETIME;
                break;
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_NEWDATE:
                mt.time_type = MYSQL_TIMESTAMP_DATE;
                mt.hour = 0;
                mt.minute = 0;
                mt.second = 0;
                mt.second_part = 0;
                break;
            default:
                return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE, "Unsupported target MySQL type for system_clock::time_point conversion: " + std::to_string(target_mysql_type)));
        }

        if (mt.year > 9999 || mt.month > 12 || mt.month == 0 || mt.day > days_in_month(mt.year, mt.month) || mt.day == 0 || mt.hour > 23 || mt.minute > 59 || mt.second > 59) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Converted time_point results in MYSQL_TIME component out of typical range."));
        }

        return mt;
    }

    std::expected<std::chrono::year_month_day, MySqlProtocolError> mySqlTimeToYearMonthDay(const MYSQL_TIME& mysql_time) {
        // A MYSQL_TIME representing a DATE or DATETIME can be converted.
        if (mysql_time.time_type != MYSQL_TIMESTAMP_DATE && mysql_time.time_type != MYSQL_TIMESTAMP_DATETIME) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE, "MYSQL_TIME must be DATE or DATETIME compatible for year_month_day. Actual type: " + std::to_string(mysql_time.time_type)));
        }
        if (mysql_time.year == 0 || mysql_time.month == 0 || mysql_time.day == 0) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "MYSQL_TIME has zero year, month, or day."));
        }
        if (mysql_time.day > days_in_month(mysql_time.year, mysql_time.month)) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "MYSQL_TIME has invalid day for month/year for ymd conversion."));
        }

        try {
            auto y = std::chrono::year(static_cast<int>(mysql_time.year));
            auto m = std::chrono::month(static_cast<unsigned int>(mysql_time.month));
            auto d = std::chrono::day(static_cast<unsigned int>(mysql_time.day));

            std::chrono::year_month_day ymd(y, m, d);
            if (!ymd.ok()) {
                return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Constructed chrono::year_month_day is not valid."));
            }
            return ymd;

        } catch (const std::exception& e) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "chrono::year_month_day construction failed: " + std::string(e.what())));
        }
    }

    std::expected<MYSQL_TIME, MySqlProtocolError> yearMonthDayToMySqlDate(const std::chrono::year_month_day& ymd) {
        MYSQL_TIME mt{};
        std::memset(&mt, 0, sizeof(MYSQL_TIME));
        mt.time_type = MYSQL_TIMESTAMP_DATE;

        if (!ymd.ok()) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME, "Input std::chrono::year_month_day is invalid."));
        }

        int y = static_cast<int>(ymd.year());
        unsigned int m = static_cast<unsigned int>(ymd.month());
        unsigned int d = static_cast<unsigned int>(ymd.day());

        // MySQL typical range for DATE parts
        if (y < 1000 || y > 9999 || m < 1 || m > 12 || d < 1 || d > 31) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "year_month_day components out of typical MySQL DATE range (1000-01-01 to 9999-12-31). Year: " + std::to_string(y)));
        }
        if (d > days_in_month(y, m)) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Invalid day for month/year in year_month_day for MySQL DATE."));
        }

        mt.year = static_cast<unsigned int>(y);
        mt.month = m;
        mt.day = d;
        return mt;
    }

    std::expected<std::chrono::microseconds, MySqlProtocolError> mySqlTimeToDuration(const MYSQL_TIME& mysql_time) {
        if (mysql_time.time_type != MYSQL_TIMESTAMP_TIME) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE, "MYSQL_TIME must be of type MYSQL_TIMESTAMP_TIME for duration conversion. Actual type: " + std::to_string(mysql_time.time_type)));
        }

        if (mysql_time.hour > 838 || mysql_time.minute > 59 || mysql_time.second > 59 || mysql_time.second_part > 999999) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "MYSQL_TIME components for TIME type out of range."));
        }

        std::chrono::microseconds total_micros = std::chrono::hours(mysql_time.hour) + std::chrono::minutes(mysql_time.minute) + std::chrono::seconds(mysql_time.second) + std::chrono::microseconds(mysql_time.second_part);

        if (mysql_time.neg) {
            return -total_micros;
        }
        return total_micros;
    }

    std::expected<MYSQL_TIME, MySqlProtocolError> durationToMySqlTime(std::chrono::microseconds duration) {
        MYSQL_TIME mt{};
        std::memset(&mt, 0, sizeof(MYSQL_TIME));
        mt.time_type = MYSQL_TIMESTAMP_TIME;

        if (duration.count() < 0) {
            mt.neg = true;
            duration = -duration;
        }

        constexpr long long max_mysql_hours = 838LL;
        constexpr std::chrono::microseconds max_mysql_time_duration = std::chrono::hours(max_mysql_hours) + std::chrono::minutes(59) + std::chrono::seconds(59) + std::chrono::microseconds(999999);

        if (duration > max_mysql_time_duration) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Duration exceeds MySQL TIME range (max 838:59:59.999999)."));
        }

        auto hrs_count = std::chrono::duration_cast<std::chrono::hours>(duration).count();
        if (hrs_count > max_mysql_hours) {  // Extra check due to potential large microsecond values that don't roll over hours correctly with simple modulo
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_CHRONO_CONVERSION_OUT_OF_RANGE, "Duration hours component exceeds MySQL TIME range."));
        }
        mt.hour = static_cast<unsigned int>(hrs_count);
        duration -= std::chrono::hours(hrs_count);

        auto mins_count = std::chrono::duration_cast<std::chrono::minutes>(duration).count();
        mt.minute = static_cast<unsigned int>(mins_count);
        duration -= std::chrono::minutes(mins_count);

        auto secs_count = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
        mt.second = static_cast<unsigned int>(secs_count);
        duration -= std::chrono::seconds(secs_count);

        mt.second_part = static_cast<unsigned long>(duration.count());

        return mt;
    }

}  // namespace mysql_protocol// Source/mysql_protocol/mysql_time_conversion.cpp
#include <cstdio>       // For std::sscanf, snprintf
#include <cstring>      // For std::memset
#include <iomanip>      // For std::setfill, std::setw
#include <sstream>      // For std::ostringstream
#include <string>       // For std::string, std::to_string
#include <string_view>  // For std::string_view

#include "mysql_protocol/mysql_type_converter.h"

// <mysql/mysql.h>, <expected> are included via mysql_type_converter.h

namespace mysql_protocol {

    std::expected<MYSQL_TIME, MySqlProtocolError> parseDateTimeStringToMySqlTime(std::string_view dt_string, enum enum_field_types expected_type) {
        MYSQL_TIME out_mysql_time;
        std::memset(&out_mysql_time, 0, sizeof(MYSQL_TIME));
        out_mysql_time.time_type = MYSQL_TIMESTAMP_ERROR;  // Default to error

        if (dt_string.empty()) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_EMPTY_INPUT, "Input date/time string is empty."));
        }

        std::string s(dt_string);  // sscanf requires a null-terminated string.
        const char* str = s.c_str();

        int year = 0, month = 0, day = 0, hour = 0, minute = 0, sec = 0;  // Renamed to sec to avoid conflict
        unsigned long local_microsecond = 0;                              // Renamed to avoid any potential conflict
        int fields_read = 0;
        bool neg = false;

        if (expected_type == MYSQL_TYPE_TIME || expected_type == MYSQL_TYPE_TIME2) {
            out_mysql_time.time_type = MYSQL_TIMESTAMP_TIME;
            if (str[0] == '-') {
                neg = true;
                str++;
            }
            // Use local_microsecond for sscanf
            fields_read = std::sscanf(str, "%d:%d:%d.%6lu", &hour, &minute, &sec, &local_microsecond);
            if (fields_read < 4) {
                local_microsecond = 0;
                fields_read = std::sscanf(str, "%d:%d:%d", &hour, &minute, &sec);
                if (fields_read < 3) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_INVALID_FORMAT, "Invalid TIME format: '" + s + "'. Expected H:M:S[.US]."));
                }
            }
            if (hour < 0 || hour > 838 || minute < 0 || minute > 59 || sec < 0 || sec > 59 || local_microsecond > 999999) {
                return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE, "Parsed TIME component out of range in '" + s + "'."));
            }
            out_mysql_time.neg = neg;
            out_mysql_time.hour = static_cast<unsigned int>(hour);
            out_mysql_time.minute = static_cast<unsigned int>(minute);
            out_mysql_time.second = static_cast<unsigned int>(sec);  // Assign to MYSQL_TIME::second
            out_mysql_time.second_part = local_microsecond;          // Assign to MYSQL_TIME::second_part
            return out_mysql_time;
        }

        if (expected_type == MYSQL_TYPE_DATE || expected_type == MYSQL_TYPE_NEWDATE || expected_type == MYSQL_TYPE_YEAR) {
            if (expected_type == MYSQL_TYPE_YEAR) {
                fields_read = std::sscanf(str, "%d", &year);
                if (fields_read == 1) {
                    // MySQL YEAR can be '0000' or 1901 to 2155. For parsing, allow wider range.
                    if (year < 0 || year > 9999) {
                        return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE, "Parsed YEAR component '" + std::to_string(year) + "' out of range in '" + s + "'."));
                    }
                    out_mysql_time.time_type = MYSQL_TIMESTAMP_DATE;  // Treat YEAR as a special date with only year component
                    out_mysql_time.year = static_cast<unsigned int>(year);
                    out_mysql_time.month = 0;  // For pure YEAR, month/day can be 0
                    out_mysql_time.day = 0;
                    return out_mysql_time;
                }
            }

            out_mysql_time.time_type = MYSQL_TIMESTAMP_DATE;
            fields_read = std::sscanf(str, "%d-%d-%d", &year, &month, &day);
            if (fields_read == 3) {
                if (year < 0 || year > 9999 || month < 1 || month > 12 || day < 1 || day > 31) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE, "Parsed DATE component out of range in '" + s + "'."));
                }
                out_mysql_time.year = static_cast<unsigned int>(year);
                out_mysql_time.month = static_cast<unsigned int>(month);
                out_mysql_time.day = static_cast<unsigned int>(day);
                return out_mysql_time;
            }
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_INVALID_FORMAT, "Invalid DATE/YEAR format: '" + s + "'. Expected YYYY-MM-DD or YYYY."));
        }

        if (expected_type == MYSQL_TYPE_DATETIME || expected_type == MYSQL_TYPE_TIMESTAMP || expected_type == MYSQL_TYPE_DATETIME2 || expected_type == MYSQL_TYPE_TIMESTAMP2) {
            out_mysql_time.time_type = MYSQL_TIMESTAMP_DATETIME;
            // Use local_microsecond for sscanf
            fields_read = std::sscanf(str, "%d-%d-%d %d:%d:%d.%6lu", &year, &month, &day, &hour, &minute, &sec, &local_microsecond);
            if (fields_read < 7) {
                local_microsecond = 0;
                fields_read = std::sscanf(str, "%d-%d-%d %d:%d:%d", &year, &month, &day, &hour, &minute, &sec);
                if (fields_read < 6) {
                    return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_INVALID_FORMAT, "Invalid DATETIME/TIMESTAMP format: '" + s + "'. Expected YYYY-MM-DD HH:MM:SS[.US]."));
                }
            }
            if (year < 0 || year > 9999 || month < 1 || month > 12 || day < 1 || day > 31 || hour < 0 || hour > 23 || minute < 0 || minute > 59 || sec < 0 || sec > 59 || local_microsecond > 999999) {
                return std::unexpected(MySqlProtocolError(InternalErrc::TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE, "Parsed DATETIME/TIMESTAMP component out of range in '" + s + "'."));
            }
            out_mysql_time.year = static_cast<unsigned int>(year);
            out_mysql_time.month = static_cast<unsigned int>(month);
            out_mysql_time.day = static_cast<unsigned int>(day);
            out_mysql_time.hour = static_cast<unsigned int>(hour);
            out_mysql_time.minute = static_cast<unsigned int>(minute);
            out_mysql_time.second = static_cast<unsigned int>(sec);  // Assign to MYSQL_TIME::second
            out_mysql_time.second_part = local_microsecond;          // Assign to MYSQL_TIME::second_part
            return out_mysql_time;
        }

        return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_UNSUPPORTED_TYPE, "Unsupported expected type for date/time string parsing: " + std::to_string(expected_type)));
    }

    std::expected<std::string, MySqlProtocolError> formatMySqlTimeToString(const MYSQL_TIME& mysql_time, enum enum_field_types original_type) {
        std::ostringstream oss;
        oss << std::setfill('0');

        if (original_type == MYSQL_TYPE_YEAR) {
            // For YEAR, only year component is relevant. time_type might be DATE or even ERROR if only year was set.
            oss << std::setw(4) << mysql_time.year;
            if (oss.fail()) return std::unexpected(MySqlProtocolError(InternalErrc::TIME_FORMAT_STREAM_ERROR, "String stream failed formatting YEAR."));
            return oss.str();
        }

        // Check for generally invalid MYSQL_TIME state if not a simple YEAR type
        if (mysql_time.time_type == MYSQL_TIMESTAMP_ERROR) {
            bool is_zero_date = mysql_time.year == 0 && mysql_time.month == 0 && mysql_time.day == 0;
            bool is_zero_time = mysql_time.hour == 0 && mysql_time.minute == 0 && mysql_time.second == 0 && mysql_time.second_part == 0;

            if (original_type == MYSQL_TYPE_DATE || original_type == MYSQL_TYPE_NEWDATE) {
                if (is_zero_date) return "0000-00-00";  // Standard zero date representation
            } else if (original_type == MYSQL_TYPE_TIME || original_type == MYSQL_TYPE_TIME2) {
                if (is_zero_time) return "00:00:00";  // Standard zero time representation
            } else if (original_type == MYSQL_TYPE_DATETIME || original_type == MYSQL_TYPE_TIMESTAMP || original_type == MYSQL_TYPE_DATETIME2 || original_type == MYSQL_TYPE_TIMESTAMP2) {
                if (is_zero_date && is_zero_time) return "0000-00-00 00:00:00";  // Standard zero datetime
            }
            // If not a recognized "zero" pattern with error type, then it's an unformattable error state.
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_FORMAT_INVALID_MYSQL_TIME_STRUCT, "Cannot format MYSQL_TIME with time_type=MYSQL_TIMESTAMP_ERROR and non-standard zero components."));
        }

        if (mysql_time.time_type == MYSQL_TIMESTAMP_DATE || (original_type == MYSQL_TYPE_DATE || original_type == MYSQL_TYPE_NEWDATE)) {  // Ensure correct type check
            if (mysql_time.year == 0 && mysql_time.month == 0 && mysql_time.day == 0) {
                oss << "0000-00-00";
            } else {
                oss << std::setw(4) << mysql_time.year << "-" << std::setw(2) << mysql_time.month << "-" << std::setw(2) << mysql_time.day;
            }
        } else if (mysql_time.time_type == MYSQL_TIMESTAMP_TIME || (original_type == MYSQL_TYPE_TIME || original_type == MYSQL_TYPE_TIME2)) {
            if (mysql_time.neg) oss << "-";
            oss << std::setw(2) << mysql_time.hour << ":" << std::setw(2) << mysql_time.minute << ":" << std::setw(2) << mysql_time.second;
            if (mysql_time.second_part > 0) {
                char micro_buf[7];
                snprintf(micro_buf, sizeof(micro_buf), "%06lu", mysql_time.second_part % 1000000UL);
                oss << "." << micro_buf;
            }
        } else if (mysql_time.time_type == MYSQL_TIMESTAMP_DATETIME || (original_type == MYSQL_TYPE_DATETIME || original_type == MYSQL_TYPE_TIMESTAMP || original_type == MYSQL_TYPE_DATETIME2 || original_type == MYSQL_TYPE_TIMESTAMP2)) {
            if (mysql_time.year == 0 && mysql_time.month == 0 && mysql_time.day == 0 && mysql_time.hour == 0 && mysql_time.minute == 0 && mysql_time.second == 0 && mysql_time.second_part == 0) {
                oss << "0000-00-00 00:00:00";
            } else {
                oss << std::setw(4) << mysql_time.year << "-" << std::setw(2) << mysql_time.month << "-" << std::setw(2) << mysql_time.day << " " << std::setw(2) << mysql_time.hour << ":" << std::setw(2) << mysql_time.minute << ":" << std::setw(2) << mysql_time.second;
                if (mysql_time.second_part > 0) {
                    char micro_buf[7];
                    snprintf(micro_buf, sizeof(micro_buf), "%06lu", mysql_time.second_part % 1000000UL);
                    oss << "." << micro_buf;
                }
            }
        } else {
            // This case might be hit if mysql_time.time_type is valid (e.g. MYSQL_TIMESTAMP_NONE) but original_type is not directly handled above.
            // Or if mysql_time has a valid type but components that don't make sense for original_type.
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_FORMAT_INVALID_MYSQL_TIME_STRUCT, "Unhandled MYSQL_TIME.time_type (" + std::to_string(mysql_time.time_type) + ") or original_type (" + std::to_string(original_type) + ") combination for formatting."));
        }

        if (oss.fail()) {
            return std::unexpected(MySqlProtocolError(InternalErrc::TIME_FORMAT_STREAM_ERROR, "String stream failed during MYSQL_TIME formatting."));
        }
        return oss.str();
    }

}  // namespace mysql_protocolfile(GLOB_RECURSE SQL_DRIVER_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(SqlDriver ${SQL_DRIVER_SOURCE})

target_include_directories(SqlDriver
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(SqlDriver PUBLIC Qt6::Core MySqlTransport)

# # build example, no condition
# add_subdirectory(Example)
#pragma once
#include <optional>
#include <string>
#include <vector>

#include "sqldriver/sql_value.h"  // For SqlValue::ChronoDate etc.

namespace cpporm_sqldriver {
    namespace detail {

        template <typename IntType>
        std::optional<IntType> stringToInteger(const std::string& s, bool* ok);

        template <typename FloatType>
        std::optional<FloatType> stringToFloat(const std::string& s, bool* ok);

        bool isValidChronoDate(const SqlValue::ChronoDate& cd);
        bool isValidChronoDateTime(const SqlValue::ChronoDateTime& cdt);

        std::string blobToHexString(const std::vector<unsigned char>& blob);

    }  // namespace detail
}  // namespace cpporm_sqldriver// sqldriver/i_sql_driver.h
#pragma once

#include <any>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_connection_parameters.h"  // Provides ConnectionParameters
#include "sql_enums.h"                  // Provides Feature, IdentifierType, StatementType, TransactionIsolationLevel, ISqlDriverNs::TableType
#include "sql_error.h"
#include "sql_index.h"
#include "sql_record.h"
#include "sql_value.h"  // For SqlValue, SqlValueType

namespace cpporm_sqldriver {

    class SqlResult;
    class SqlField;

    class ISqlDriver {
      public:
        virtual ~ISqlDriver() = default;

        virtual bool open(const ConnectionParameters& params) = 0;
        virtual void close() = 0;
        virtual bool isOpen() const = 0;
        virtual bool isOpenError() const = 0;
        virtual bool ping(int timeout_seconds = 2) = 0;

        virtual bool beginTransaction() = 0;
        virtual bool commitTransaction() = 0;
        virtual bool rollbackTransaction() = 0;
        virtual bool setTransactionIsolationLevel(TransactionIsolationLevel level) = 0;
        virtual TransactionIsolationLevel transactionIsolationLevel() const = 0;
        virtual bool setSavepoint(const std::string& name) = 0;
        virtual bool rollbackToSavepoint(const std::string& name) = 0;
        virtual bool releaseSavepoint(const std::string& name) = 0;

        virtual std::unique_ptr<SqlResult> createResult() const = 0;

        virtual std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const = 0;
        virtual std::vector<std::string> schemas(const std::string& schemaFilter = "") const = 0;
        virtual SqlRecord record(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const = 0;

        virtual bool hasFeature(Feature feature) const = 0;
        virtual SqlError lastError() const = 0;
        virtual std::string databaseProductVersion() const = 0;
        virtual std::string driverVersion() const = 0;

        virtual std::string formatValue(const SqlValue& value, SqlValueType type_hint = SqlValueType::Null, const SqlField* field_meta_hint = nullptr) const = 0;
        virtual std::string escapeIdentifier(const std::string& identifier, IdentifierType type) const = 0;
        virtual std::string sqlStatement(StatementType type, const std::string& tableName, const SqlRecord& rec, bool prepared, const std::string& schema = "") const = 0;

        virtual bool setClientCharset(const std::string& charsetName) = 0;
        virtual std::string clientCharset() const = 0;

        virtual SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "") = 0;

        virtual SqlValue nativeHandle() const = 0;
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/mysql/mysql_driver_helper.h
#pragma once

#include "sqldriver/sql_connection_parameters.h"
#include "sqldriver/sql_enums.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_field.h"
#include "sqldriver/sql_index.h"
#include "sqldriver/sql_record.h"
#include "sqldriver/sql_value.h"

// Transport 层暴露的类型 - 需要包含这些头文件以获得完整类型定义
#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_metadata.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "cpporm_mysql_transport/mysql_transport_types.h"

// Protocol 层暴露的类型 (作为与 SqlValue 转换的桥梁)
#include "mysql_protocol/mysql_type_converter.h"

// 前向声明 MYSQL 结构体 (来自 C API)
struct st_mysql;  // MYSQL 由 mysql.h 定义，通常由 transport 层头文件包含

namespace cpporm_sqldriver {

    namespace mysql_helper {

        // --- 在 mysql_param_converter.cpp 中实现的声明 ---
        // 将 ConnectionParameters (SqlDriver 层) 转换为 MySqlTransportConnectionParams (Transport 层)
        ::cpporm_mysql_transport::MySqlTransportConnectionParams toMySqlTransportParams(const ConnectionParameters& params);

        // --- 在 mysql_error_converter.cpp 中实现的声明 ---
        // 将 MySqlTransportError (Transport 层) 转换为 SqlError (SqlDriver 层)
        SqlError transportErrorToSqlError(const ::cpporm_mysql_transport::MySqlTransportError& transportError);
        // 将 MySqlProtocolError (Protocol 层) 转换为 SqlError (SqlDriver 层)
        SqlError protocolErrorToSqlError(const mysql_protocol::MySqlProtocolError& protocolError, const std::string& context_message = "");

        // --- 在 mysql_value_converter.cpp 中实现的声明 ---
        // 将 SqlValue (SqlDriver 层) 转换为 MySqlNativeValue (Protocol 层，用于 Transport)
        mysql_protocol::MySqlNativeValue sqlValueToMySqlNativeValue(const SqlValue& value);
        // 将 MySqlNativeValue (Protocol 层) 转换为 SqlValue (SqlDriver 层)
        SqlValue mySqlNativeValueToSqlValue(const mysql_protocol::MySqlNativeValue& nativeValue);

        // --- 在 mysql_metadata_converter.cpp 中实现的声明 ---
        // 将 MySqlTransportFieldMeta (Transport 层) 转换为 SqlField (SqlDriver 层)
        SqlField metaToSqlField(const ::cpporm_mysql_transport::MySqlTransportFieldMeta& transportMeta);
        // 将 MySqlTransportFieldMeta 向量转换为 SqlRecord (SqlDriver 层)
        SqlRecord metasToSqlRecord(const std::vector<::cpporm_mysql_transport::MySqlTransportFieldMeta>& transportMetas);
        // 将 MySqlTransportIndexInfo (Transport 层) 转换为 SqlIndex (SqlDriver 层)
        SqlIndex metaToSqlIndex(const ::cpporm_mysql_transport::MySqlTransportIndexInfo& transportIndexInfo);
        // 将 MySqlTransportIndexInfo 向量转换为 SqlIndex 向量 (SqlDriver 层)
        std::vector<SqlIndex> metasToSqlIndexes(const std::vector<::cpporm_mysql_transport::MySqlTransportIndexInfo>& transportIndexInfos);

        // --- 在 mysql_enum_converter.cpp 中实现的声明 ---
        // 事务隔离级别枚举转换
        ::cpporm_mysql_transport::TransactionIsolationLevel toMySqlTransportIsolationLevel(TransactionIsolationLevel driverLevel);
        TransactionIsolationLevel fromMySqlTransportIsolationLevel(::cpporm_mysql_transport::TransactionIsolationLevel transportLevel);

        // --- 在 mysql_placeholder_processor.cpp 中实现的声明 ---
        // 处理命名占位符的结构体和函数
        struct NamedPlaceholderInfo {
            std::string processedQuery;                                // 处理后（通常替换为 '?'）的查询字符串
            std::vector<std::string> orderedParamNames;                // 命名参数按其在查询中出现的顺序
            std::map<std::string, std::vector<int>> nameToIndicesMap;  // 参数名到其在原始查询中出现位置的映射 (0-based)
            bool hasNamedPlaceholders = false;                         // 原始查询是否包含命名占位符
        };
        NamedPlaceholderInfo processQueryForPlaceholders(const std::string& originalQuery, SqlResultNs::NamedBindingSyntax syntax);

        // --- 在 mysql_type_mapper.cpp 中实现的声明 ---
        // 将 MySQL C API 的列类型 ID (enum_field_types) 映射到 SqlValueType (SqlDriver 层)
        SqlValueType mySqlColumnTypeToSqlValueType(int mysql_col_type_id, unsigned int mysql_flags);

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/mysql/mysql_specific_driver.h
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "sqldriver/i_sql_driver.h"
#include "sqldriver/sql_connection_parameters.h"  // For m_current_params_cache
#include "sqldriver/sql_error.h"                  // For m_last_error_cache

// 前向声明 MySqlTransport 类
namespace cpporm_mysql_transport {
    class MySqlTransportConnection;
    class MySqlTransportMetadata;
}  // namespace cpporm_mysql_transport

namespace cpporm_sqldriver {

    class MySqlSpecificResult;  // 前向声明

    class MySqlSpecificDriver : public ISqlDriver {
      public:
        MySqlSpecificDriver();
        ~MySqlSpecificDriver() override;

        // --- ISqlDriver 接口实现 ---
        bool open(const ConnectionParameters& params) override;
        void close() override;
        bool isOpen() const override;
        bool isOpenError() const override;  // 如果上次 open() 失败或连接意外断开，则为 true
        bool ping(int timeout_seconds = 2) override;

        bool beginTransaction() override;
        bool commitTransaction() override;
        bool rollbackTransaction() override;
        bool setTransactionIsolationLevel(TransactionIsolationLevel level) override;
        TransactionIsolationLevel transactionIsolationLevel() const override;
        bool setSavepoint(const std::string& name) override;
        bool rollbackToSavepoint(const std::string& name) override;
        bool releaseSavepoint(const std::string& name) override;

        std::unique_ptr<SqlResult> createResult() const override;

        std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const override;
        std::vector<std::string> schemas(const std::string& schemaFilter = "") const override;
        SqlRecord record(const std::string& tablename, const std::string& schema = "") const override;
        SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const override;
        std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const override;

        bool hasFeature(Feature feature) const override;
        SqlError lastError() const override;
        std::string databaseProductVersion() const override;
        std::string driverVersion() const override;

        std::string formatValue(const SqlValue& value, SqlValueType type_hint = SqlValueType::Null, const SqlField* field_meta_hint = nullptr) const override;
        std::string escapeIdentifier(const std::string& identifier, IdentifierType type) const override;
        std::string sqlStatement(StatementType type, const std::string& tableName, const SqlRecord& rec, bool prepared, const std::string& schema = "") const override;

        bool setClientCharset(const std::string& charsetName) override;
        std::string clientCharset() const override;

        SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "") override;

        SqlValue nativeHandle() const override;
        // --- End ISqlDriver 接口实现 ---

        // 供 MySqlSpecificResult 访问 transport connection
        cpporm_mysql_transport::MySqlTransportConnection* getTransportConnection() const;

      private:
        std::unique_ptr<cpporm_mysql_transport::MySqlTransportConnection> m_transport_connection;
        std::unique_ptr<cpporm_mysql_transport::MySqlTransportMetadata> m_transport_metadata;  // 添加 MySqlTransportMetadata 实例

        mutable SqlError m_last_error_cache;          // 存储最近的错误信息，声明为 mutable 以便 const 方法可以更新它
        ConnectionParameters m_current_params_cache;  // 缓存当前连接参数
        bool m_open_error_flag;                       // 标记上次打开操作是否失败

        // 辅助函数，用于从 transport 层更新 m_last_error_cache
        void updateLastErrorCacheFromTransport(bool success_of_operation) const;  // 声明为 const

        // 解析 schema 名称 (如果参数为空，则使用连接参数中的 db_name)
        std::string resolveSchemaName(const std::string& schemaFilterFromArgs) const;
    };

    // 驱动初始化函数声明
    void MySqlDriver_Initialize();

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/mysql/mysql_specific_result.h
#pragma once

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // 包含 MySqlTransportBindParam 的定义
#include "sqldriver/mysql/mysql_driver_helper.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_result.h"

// 前向声明
namespace cpporm_mysql_transport {
    class MySqlTransportStatement;
    class MySqlTransportResult;
}  // namespace cpporm_mysql_transport

namespace cpporm_sqldriver {
    class MySqlSpecificDriver;

    class MySqlSpecificResult : public SqlResult {
      public:
        explicit MySqlSpecificResult(const MySqlSpecificDriver* driver);
        ~MySqlSpecificResult() override;

        MySqlSpecificResult(const MySqlSpecificResult&) = delete;
        MySqlSpecificResult& operator=(const MySqlSpecificResult&) = delete;
        MySqlSpecificResult(MySqlSpecificResult&&) noexcept;
        MySqlSpecificResult& operator=(MySqlSpecificResult&&) noexcept;

        // --- SqlResult 接口实现 ---
        bool prepare(const std::string& query, const std::map<std::string, SqlValueType>* named_bindings_type_hints = nullptr, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly) override;
        bool exec() override;
        bool setQueryTimeout(int seconds) override;
        bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) override;
        bool setPrefetchSize(int rows) override;
        int prefetchSize() const override;

        void addPositionalBindValue(const SqlValue& value, ParamType type = ParamType::In) override;
        void setNamedBindValue(const std::string& placeholder, const SqlValue& value, ParamType type = ParamType::In) override;
        void bindBlobStream(int pos, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) override;
        void bindBlobStream(const std::string& placeholder, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) override;
        void clearBindValues() override;
        void reset() override;
        bool setForwardOnly(bool forward) override;

        bool fetchNext(SqlRecord& record_buffer) override;
        bool fetchPrevious(SqlRecord& record_buffer) override;
        bool fetchFirst(SqlRecord& record_buffer) override;
        bool fetchLast(SqlRecord& record_buffer) override;
        bool fetch(int index, SqlRecord& record_buffer, CursorMovement movement = CursorMovement::Absolute) override;

        SqlValue data(int column_index) override;
        std::shared_ptr<std::istream> openReadableBlobStream(int column_index) override;
        std::shared_ptr<std::ostream> openWritableBlobStream(int column_index, long long initial_size_hint = 0) override;

        bool isNull(int column_index) override;
        SqlRecord recordMetadata() const override;
        SqlRecord currentFetchedRow() const override;
        SqlField field(int column_index) const override;

        long long numRowsAffected() override;
        SqlValue lastInsertId() override;
        int columnCount() const override;
        int size() override;
        int at() const override;

        bool isActive() const override;
        bool isValid() const override;
        SqlError error() const override;
        const std::string& lastQuery() const override;
        const std::string& preparedQueryText() const override;

        void finish() override;
        void clear() override;

        bool nextResult() override;

        SqlValue getOutParameter(int pos) const override;
        SqlValue getOutParameter(const std::string& name) const override;
        std::map<std::string, SqlValue> getAllOutParameters() const override;

        bool setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) override;
        // --- End SqlResult 接口实现 ---

      private:
        const MySqlSpecificDriver* m_driver;
        std::unique_ptr<cpporm_mysql_transport::MySqlTransportStatement> m_transport_statement;
        std::unique_ptr<cpporm_mysql_transport::MySqlTransportResult> m_transport_result_set;

        std::string m_original_query_text;
        mysql_helper::NamedPlaceholderInfo m_placeholder_info;

        std::vector<SqlValue> m_positional_bind_values;
        std::map<std::string, SqlValue> m_named_bind_values_map;
        // 使用完整的命名空间
        std::vector<cpporm_mysql_transport::MySqlTransportBindParam> m_ordered_transport_bind_params;

        SqlRecord m_current_record_buffer_cache;
        long long m_current_row_index;
        my_ulonglong m_num_rows_affected_cache;  // my_ulonglong 来自 mysql.h
        SqlValue m_last_insert_id_cache;

        mutable SqlError m_last_error_cache;
        bool m_is_active_flag;
        NumericalPrecisionPolicy m_precision_policy;
        SqlResultNs::NamedBindingSyntax m_named_binding_syntax;
        SqlResultNs::ScrollMode m_scroll_mode_hint;
        int m_prefetch_size_hint;

        void updateLastErrorCacheFromTransportStatement();
        void updateLastErrorCacheFromTransportResult();
        void clearLastErrorCache();
        bool applyBindingsToTransportStatement();
        void cleanupAfterExecution(bool retain_result_set = false);
        bool ensureResultSet();
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_connection_parameters.h
#pragma once

#include <map>
#include <optional>
#include <string>
#include <vector>  // Not directly used here, but often associated with parameter sets

#include "sql_value.h"  // For SqlValue used as map value

namespace cpporm_sqldriver {

    struct ConnectionParameters : public std::map<std::string, SqlValue> {
        // 定义键常量 (声明)
        static const std::string KEY_DRIVER_TYPE;
        static const std::string KEY_DB_NAME;
        static const std::string KEY_USER_NAME;
        static const std::string KEY_PASSWORD;
        static const std::string KEY_HOST_NAME;
        static const std::string KEY_PORT;
        static const std::string KEY_CONNECT_OPTIONS;
        static const std::string KEY_CLIENT_CHARSET;
        static const std::string KEY_APPLICATION_NAME;
        static const std::string KEY_CONNECTION_TIMEOUT_SECONDS;
        static const std::string KEY_READ_TIMEOUT_SECONDS;
        static const std::string KEY_WRITE_TIMEOUT_SECONDS;
        static const std::string KEY_SSL_MODE;
        static const std::string KEY_SSL_CERT_PATH;
        static const std::string KEY_SSL_KEY_PATH;
        static const std::string KEY_SSL_CA_PATH;
        static const std::string KEY_SSL_CIPHER;
        static const std::string KEY_POOL_MAX_SIZE;
        static const std::string KEY_POOL_MIN_SIZE;
        static const std::string KEY_POOL_ACQUIRE_TIMEOUT_MS;
        static const std::string KEY_POOL_CONNECTION_LIFETIME_MS;
        static const std::string KEY_POOL_IDLE_TIMEOUT_MS;

        // Setters (声明)
        void setDriverType(const std::string& v);
        void setDbName(const std::string& v);
        void setUserName(const std::string& v);
        void setPassword(const std::string& v);
        void setHostName(const std::string& v);
        void setPort(int v);
        void setConnectOptions(const std::string& v);
        void setClientCharset(const std::string& v);
        void setApplicationName(const std::string& v);
        void setConnectionTimeoutSeconds(int v);
        void setReadTimeoutSeconds(int v);
        void setWriteTimeoutSeconds(int v);
        void setSslMode(const std::string& v);
        void setSslCertPath(const std::string& v);
        void setSslKeyPath(const std::string& v);
        void setSslCaPath(const std::string& v);
        void setSslCipher(const std::string& v);
        void setPoolMaxSize(int v);
        void setPoolMinSize(int v);
        void setPoolAcquireTimeoutMs(long long v);
        void setPoolConnectionLifetimeMs(long long v);
        void setPoolIdleTimeoutMs(long long v);

        // Getters (声明)
        template <typename T>
        std::optional<T> get(const std::string& key) const;

        std::optional<std::string> driverType() const;
        std::optional<std::string> dbName() const;
        std::optional<std::string> userName() const;
        std::optional<std::string> password() const;
        std::optional<std::string> hostName() const;
        std::optional<int> port() const;
        std::optional<std::string> connectOptions() const;
        std::optional<std::string> clientCharset() const;
        std::optional<std::string> applicationName() const;
        std::optional<int> connectionTimeoutSeconds() const;
        std::optional<int> readTimeoutSeconds() const;
        std::optional<int> writeTimeoutSeconds() const;
        std::optional<std::string> sslMode() const;
        std::optional<std::string> sslCertPath() const;
        std::optional<std::string> sslKeyPath() const;
        std::optional<std::string> sslCaPath() const;
        std::optional<std::string> sslCipher() const;
        std::optional<int> poolMaxSize() const;
        std::optional<int> poolMinSize() const;
        std::optional<long long> poolAcquireTimeoutMs() const;
        std::optional<long long> poolConnectionLifetimeMs() const;
        std::optional<long long> poolIdleTimeoutMs() const;
    };

    template <typename T>
    std::optional<T> ConnectionParameters::get(const std::string& key) const {
        auto it = find(key);
        if (it != end() && !it->second.isNull()) {
            bool ok = false;
            T result{};
            if constexpr (std::is_same_v<T, std::string>) {
                result = it->second.toString(&ok);
            } else if constexpr (std::is_same_v<T, int>) {
                result = it->second.toInt32(&ok);
            } else if constexpr (std::is_same_v<T, unsigned int>) {
                result = it->second.toUInt32(&ok);
            } else if constexpr (std::is_same_v<T, long long>) {
                result = it->second.toInt64(&ok);
            } else if constexpr (std::is_same_v<T, unsigned long long>) {
                result = it->second.toUInt64(&ok);
            } else if constexpr (std::is_same_v<T, bool>) {
                result = it->second.toBool(&ok);
            } else if constexpr (std::is_same_v<T, float>) {
                result = it->second.toFloat(&ok);
            } else if constexpr (std::is_same_v<T, double>) {
                result = it->second.toDouble(&ok);
            } else if constexpr (std::is_same_v<T, long double>) {
                result = it->second.toLongDouble(&ok);
            } else if constexpr (std::is_same_v<T, QByteArray>) {
                result = it->second.toByteArray(&ok);
            } else if constexpr (std::is_same_v<T, QDate>) {
                result = it->second.toDate(&ok);
            } else if constexpr (std::is_same_v<T, QTime>) {
                result = it->second.toTime(&ok);
            } else if constexpr (std::is_same_v<T, QDateTime>) {
                result = it->second.toDateTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDate>) {
                result = it->second.toChronoDate(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoTime>) {
                result = it->second.toChronoTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDateTime>) {
                result = it->second.toChronoDateTime(&ok);
            } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                result = it->second.toStdVectorUChar(&ok);
            }
            // else if constexpr (std::is_same_v<T, SqlDecimal>) { result = it->second.toDecimal(&ok); } // Example for custom types
            // else if constexpr (std::is_same_v<T, SqlJsonDocument>) { result = it->second.toJsonDocument(&ok); }
            else {
                // For std::any or other unlisted types, this path would be taken.
                // Consider if a static_assert(false, "Unsupported type T for ConnectionParameters::get") is appropriate,
                // or if it should attempt a toStdAny() and std::any_cast, which is more risky.
                // For now, ok will remain false if no specific conversion is matched.
            }
            if (ok) return result;
        }
        return std::nullopt;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_database.h
#pragma once
#include <any>
#include <map>
#include <memory>  // Changed to std::shared_ptr for m_driver
#include <string>
#include <vector>

#include "sqldriver/i_sql_driver.h"
#include "sqldriver/sql_connection_parameters.h"
#include "sqldriver/sql_enums.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_index.h"
#include "sqldriver/sql_record.h"
#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    class SqlQuery;

    class SqlDatabase {
      public:
        ~SqlDatabase();

        bool open(const ConnectionParameters& params);
        bool open();
        bool open(const std::string& user, const std::string& password);
        void close();
        bool isOpen() const;
        bool isValid() const;
        bool ping(int timeout_seconds = 2);

        bool transaction();
        bool commit();
        bool rollback();
        bool isTransactionActive() const;  // Checks underlying driver's transaction state
        bool setTransactionIsolationLevel(TransactionIsolationLevel level);
        TransactionIsolationLevel transactionIsolationLevel() const;
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        std::string driverName() const;
        std::string databaseName() const;
        void setDatabaseName(const std::string& name);
        std::string userName() const;
        void setUserName(const std::string& name);
        std::string password() const;
        void setPassword(const std::string& password);
        std::string hostName() const;
        void setHostName(const std::string& host);
        int port() const;
        void setPort(int port);
        std::string connectOptionsString() const;
        void setConnectOptionsString(const std::string& options);
        const ConnectionParameters& connectionParameters() const;
        void setConnectionParameter(const std::string& key, const SqlValue& value);
        SqlValue connectionParameter(const std::string& key) const;
        SqlError lastError() const;

        ISqlDriver* driver() const;  // Returns raw pointer, lifetime managed by shared_ptr
        std::string connectionName() const;

        std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const;
        std::vector<std::string> schemas(const std::string& schemaFilter = "") const;
        SqlRecord record(const std::string& tablename, const std::string& schema = "") const;
        SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const;
        std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const;

        bool hasFeature(Feature feature) const;
        SqlValue nativeHandle() const;
        std::string databaseProductVersion() const;
        std::string driverVersion() const;

        bool setClientCharset(const std::string& charsetName);
        std::string clientCharset() const;

        SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "");

        // Copy constructor and assignment for shared ownership
        SqlDatabase(const SqlDatabase& other);
        SqlDatabase& operator=(const SqlDatabase& other);

        // Move constructor and assignment
        SqlDatabase(SqlDatabase&&) noexcept;
        SqlDatabase& operator=(SqlDatabase&&) noexcept;

      private:
        friend class SqlDriverManager;
        friend class SqlQuery;

        // Private constructor for SqlDriverManager
        SqlDatabase(const std::string& driverTypeFromManager, const std::string& assignedConnectionName,
                    std::shared_ptr<ISqlDriver> driverImplementation);  // Changed to shared_ptr

        std::string m_driver_type_name;
        std::string m_connection_name;
        std::shared_ptr<ISqlDriver> m_driver;  // Changed to shared_ptr
        ConnectionParameters m_parameters;
        mutable SqlError m_last_error;
        // m_transaction_active is removed from SqlDatabase. State is now queried from ISqlDriver.

        void updateLastErrorFromDriver() const;
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_driver_manager.h
#pragma once
#include <functional>
#include <map>  // For storing drivers and factories
#include <memory>
#include <mutex>  // For thread-safe access to static members
#include <string>
#include <vector>

// Forward declare SqlDatabase to avoid circular dependency if SqlDatabase needs SqlDriverManager
namespace cpporm_sqldriver {
    class SqlDatabase;
    class ISqlDriver;  // Already forward declared if i_sql_driver.h is included by SqlDatabase
}  // namespace cpporm_sqldriver

namespace cpporm_sqldriver {

    class SqlDriverManager {
      public:
        using DriverFactory = std::function<std::unique_ptr<ISqlDriver>()>;

        // Connection management
        // Returns a SqlDatabase object. The caller owns the unique_ptr to the driver inside SqlDatabase.
        static SqlDatabase addDatabase(const std::string& driverType, const std::string& connectionName = defaultConnectionName());

        // Retrieves an existing database connection.
        // Note: SqlDatabase objects themselves are not stored directly in the manager in this design.
        // This method would typically re-create a SqlDatabase wrapper around a potentially pooled or re-established driver.
        // For simplicity, if we are not managing SqlDatabase objects themselves, this might be better named
        // 'createDatabaseAccess' or similar. Or, it could return a reference/pointer if we store them (adds complexity).
        // Let's assume for now `database()` re-constructs a SqlDatabase object using a stored factory or a new driver instance if not connection pooling.
        // If `connectionName` already exists and implies a live, shared connection (pooling), then it's more complex.
        // For a simple manager, `addDatabase` creates, and `database` might just re-create or error if not found.
        // Let's refine: `database()` will attempt to find a previously "added" configuration if `open` is false,
        // or create and open if `open` is true. This implies some state per connectionName.
        // For now, `database()` will be similar to `addDatabase` but might check if a driver for `connectionName` already implies specific params.
        // This part needs careful design based on how connections are "managed" vs "created".

        // Let's simplify: `database()` returns a new SqlDatabase instance, potentially configured by `connectionName`.
        // If a connection with `connectionName` was previously created and its params are stored, `open=false` would return it configured but closed.
        // This still requires the manager to store more than just factories.
        //
        // Simpler model for now:
        // addDatabase is the primary way to get a SqlDatabase configured with a driver.
        // database() is a convenience that calls addDatabase and optionally opens.
        static SqlDatabase database(const std::string& connectionName = defaultConnectionName(), bool open = true);

        static void removeDatabase(const std::string& connectionName);  // What does this remove? The factory? A stored SqlDatabase instance?
                                                                        // If we only store factories, this might not make sense unless we are un-registering a connection configuration.
                                                                        // For now, assume it refers to removing a named configuration if we were to store them.
                                                                        // Or, if we stored SqlDatabase instances (not recommended for static manager), it would remove that.
                                                                        // Let's assume it removes any configuration associated with connectionName for now.

        static bool contains(const std::string& connectionName = defaultConnectionName());  // Checks if a configuration for connectionName exists.

        // Driver information
        static std::vector<std::string> drivers();  // Lists registered driver *types*
        static bool isDriverAvailable(const std::string& driverType);

        static std::string defaultConnectionName();

        // Driver registration (called by specific driver plugins/modules)
        static bool registerDriver(const std::string& driverName, DriverFactory factory);
        static void unregisterDriver(const std::string& driverName);  // Optional

      private:
        SqlDriverManager() = delete;  // Static class

        // Internal storage for factories and potentially named connection configurations
        // This requires a static PImpl or static members directly.
        struct ManagerData {
            std::map<std::string, DriverFactory> driverFactories;
            // If we want to manage "named connections" beyond just driver type:
            // std::map<std::string, ConnectionParameters> namedConnectionParams;
            // std::map<std::string, std::string> namedConnectionDriverTypes; // driverType for a connectionName
            std::string defaultConnName = "qt_sql_default_connection";
            std::mutex managerMutex;
        };

        static ManagerData& data();  // Access to static data
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_enums.h
#pragma once

namespace cpporm_sqldriver {

    // --- Enums used across driver interfaces ---

    enum class Feature {
        Transactions,
        QuerySize,
        BLOB,
        Unicode,
        PreparedQueries,
        NamedPlaceholders,
        PositionalPlaceholders,
        LastInsertId,
        BatchOperations,
        SimpleScrollOnError,
        EventNotifications,
        FinishQuery,
        MultipleResultSets,
        LowPrecisionNumbers,
        CancelQuery,
        InsertAndReturnId,
        NamedSavepoints,
        ThreadSafe,
        SchemaOperations,
        SequenceOperations,
        UpdatableCursors,
        TransactionIsolationLevel,
        GetTypeInfo,
        PingConnection,
        SetQueryTimeout,
        StreamBlob,
        CallableStatements,
        BatchWithErrorDetails
    };

    enum class IdentifierType { Table, Field, Index, Schema, Sequence, Trigger, View, Constraint, User, Role, Procedure, Function };

    enum class StatementType { Select, Insert, Update, Delete, DDL, DCL, TCL, Call, Begin, Commit, Rollback, Savepoint, Unknown };

    enum class TransactionIsolationLevel { ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, Snapshot, Default };

    enum class ParamType { In, Out, InOut, Binary, ReturnValue };

    enum class CursorMovement { Absolute, RelativeFirst, RelativeNext, RelativePrevious, RelativeLast };

    namespace ISqlDriverNs {
        enum class TableType { All, Tables, Views, SystemTables, Aliases, Synonyms, TemporaryTables, GlobalTemporaryTables };
    }  // namespace ISqlDriverNs

    namespace SqlResultNs {
        enum class ScrollMode { ForwardOnly, Scrollable };
        enum class ConcurrencyMode { ReadOnly, Updatable };
        enum class NamedBindingSyntax { Colon, AtSign, QuestionMark };
    }  // namespace SqlResultNs

}  // namespace cpporm_sqldriver// sqldriver/sql_error.h
#pragma once
#include <optional>
#include <string>

namespace cpporm_sqldriver {

    // ErrorCategory 和 ErrorType 枚举定义在文件顶部或类的外部
    enum class ErrorCategory { NoError, Connectivity, Syntax, Constraint, Permissions, DataRelated, Resource, Transaction, DriverInternal, DatabaseInternal, OperationCancelled, FeatureNotSupported, Unknown };

    // 旧的 ErrorType，如果仍需保留用于映射或兼容
    enum class ErrorType {
        NoError = 0,  // 保持与Qt QSqlError::NoError 一致
        ConnectionError,
        StatementError,
        TransactionError,
        UnknownError,
        FeatureNotSupportedError,
        DataError,
        ConstraintViolationError
    };

    class SqlError {
      public:
        SqlError();
        SqlError(ErrorCategory category,
                 const std::string& databaseText,
                 const std::string& driverText = "",
                 const std::string& nativeErrorCode = "",
                 int nativeDbCodeNumeric = 0,
                 const std::string& failedQuery = "",
                 const std::string& constraintName = "",
                 const std::optional<int>& errorOffset = std::nullopt);

        ErrorCategory category() const;
        ErrorType type() const;  // 可以基于 category() 返回一个映射的 ErrorType
        std::string databaseText() const;
        std::string driverText() const;
        std::string text() const;
        std::string nativeErrorCode() const;
        int nativeErrorCodeNumeric() const;
        std::string failedQuery() const;
        std::string constraintName() const;
        std::optional<int> errorOffsetInQuery() const;
        bool isValid() const;  // category() != ErrorCategory::NoError

        void setCategory(ErrorCategory category);
        void setType(ErrorType type);
        void setDatabaseText(const std::string& text);
        void setDriverText(const std::string& text);
        void setNativeErrorCode(const std::string& code);
        void setNativeErrorCodeNumeric(int code);
        void setFailedQuery(const std::string& query);
        void setConstraintName(const std::string& name);
        void setErrorOffsetInQuery(const std::optional<int>& offset);
        void clear();

      private:
        ErrorCategory category_ = ErrorCategory::NoError;
        ErrorType legacy_type_ = ErrorType::NoError;
        std::string database_text_;
        std::string driver_text_;
        std::string native_error_code_str_;
        int native_error_code_num_ = 0;
        std::string failed_query_;
        std::string constraint_name_;
        std::optional<int> error_offset_;
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_field.h
#pragma once
#include <any>
#include <memory>  // For std::unique_ptr if PImpl were used
#include <optional>
#include <string>
#include <vector>

#include "sqldriver/sql_value.h"  // Contains SqlValueType and SqlValue

namespace cpporm_sqldriver {

    // RequiredStatus indicates if a field must have a value.
    // Based on database's NOT NULL constraint.
    enum class RequiredStatus {
        Unknown = -1,  // Status cannot be determined
        Optional = 0,  // Field can be NULL (is nullable)
        Required = 1   // Field must not be NULL (is NOT NULL)
    };

    class SqlField {
      public:
        // Constructors
        SqlField(const std::string& name = "", SqlValueType type = SqlValueType::Null, const std::string& db_type_name = "");
        ~SqlField();

        // Copy and Move semantics
        SqlField(const SqlField& other);
        SqlField& operator=(const SqlField& other);
        SqlField(SqlField&& other) noexcept;
        SqlField& operator=(SqlField&& other) noexcept;

        // Basic Properties
        std::string name() const;
        void setName(const std::string& name);

        SqlValue value() const;  // Current value of the field
        void setValue(const SqlValue& value);
        void clearValue();           // Sets the value to null
        bool isNullInValue() const;  // Checks if the current value is null

        // Type Information
        SqlValueType type() const;  // Generic CppOrm SqlValueType
        void setType(SqlValueType type);

        std::string databaseTypeName() const;  // Native database type name (e.g., "VARCHAR(255)")
        void setDatabaseTypeName(const std::string& name);

        int driverType() const;          // Driver-specific type ID (e.g., from an enum like MYSQL_TYPE_*)
        void setDriverType(int typeId);  // Set driver-specific type ID

        // Size and Precision
        int length() const;  // For strings: max chars; For numerics: display width or total digits
        void setLength(int len);

        int precision() const;  // For numerics: total number of digits (excluding sign/decimal point for some DBs)
                                // For time/timestamp: fractional seconds precision
        void setPrecision(int prec);

        int scale() const;     // For numerics: number of digits after the decimal point
        void setScale(int s);  // For numerics like DECIMAL(P,S)

        // Constraints and Attributes
        RequiredStatus requiredStatus() const;  // Is the field NOT NULL?
        void setRequiredStatus(RequiredStatus status);

        bool isAutoValue() const;  // Is it an auto-incrementing or identity column?
        void setAutoValue(bool autoVal);

        bool isReadOnly() const;  // Is the field read-only (e.g., computed column, not updatable)?
        void setReadOnly(bool ro);

        SqlValue defaultValue() const;  // Default value as defined in the database schema
        void setDefaultValue(const SqlValue& value);

        // Status flags
        bool isValid() const;  // Is the field metadata considered valid/complete? (e.g., name is not empty)

        bool isGenerated() const;  // Is the field a generated column (e.g. STORED/VIRTUAL in MySQL)?
        void setGenerated(bool generated);

        // Key Information
        bool isPrimaryKeyPart() const;
        void setPrimaryKeyPart(bool is_pk);

        bool isForeignKeyPart() const;
        void setForeignKeyPart(bool is_fk);

        // Foreign Key Details (if applicable)
        std::optional<std::string> referencedTableName() const;
        void setReferencedTableName(const std::optional<std::string>& name);
        std::optional<std::string> referencedColumnName() const;
        void setReferencedColumnName(const std::optional<std::string>& name);

        // Collation
        std::optional<std::string> collationName() const;
        void setCollationName(const std::optional<std::string>& name);

        // For fields derived from expressions or aliased in SELECT statements
        bool isExpression() const;  // True if this field is the result of an expression
        void setIsExpression(bool is_expr);
        std::optional<std::string> aliasName() const;  // Alias given to this field/expression in a query
        void setAliasName(const std::optional<std::string>& alias);

        // Origin Information (if the field comes from a base table column in a view or complex query)
        std::optional<std::string> baseTableName() const;
        void setBaseTableName(const std::optional<std::string>& name);
        std::optional<std::string> baseColumnName() const;
        void setBaseColumnName(const std::optional<std::string>& name);
        std::optional<std::string> baseSchemaName() const;
        void setBaseSchemaName(const std::optional<std::string>& name);

        // Generic metadata storage (e.g., for driver-specific flags or properties)
        std::any metaData() const;               // Get custom metadata
        void setMetaData(const std::any& data);  // Set custom metadata

      private:
        // Direct members
        std::string m_name;
        SqlValue m_value;  // The actual data value
        SqlValueType m_type_enum;
        std::string m_database_type_name;
        int m_driver_type_id;  // Driver-specific internal type enum value

        int m_length;     // Max length (chars for string, display for number)
        int m_precision;  // Total digits for numeric, or sub-second precision for time
        int m_scale;      // Digits after decimal for numeric

        RequiredStatus m_required_status;
        bool m_is_auto_value;  // Identity, auto_increment
        bool m_is_read_only;   // e.g. computed column
        SqlValue m_default_value;
        bool m_is_generated;  // STORED/VIRTUAL generated column

        bool m_is_primary_key_part;
        bool m_is_foreign_key_part;
        std::optional<std::string> m_referenced_table_name;
        std::optional<std::string> m_referenced_column_name;

        std::optional<std::string> m_collation_name;

        bool m_is_expression;
        std::optional<std::string> m_alias_name;
        std::optional<std::string> m_base_table_name;
        std::optional<std::string> m_base_column_name;
        std::optional<std::string> m_base_schema_name;

        std::any m_custom_meta_data;
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_index.h
#pragma once
#include <map>
#include <memory>  // For std::unique_ptr if PImpl were used
#include <optional>
#include <string>
#include <vector>

#include "sqldriver/sql_value.h"  // For SqlValue in options
// SqlField is not directly part of SqlIndex definition usually, but IndexColumnDefinition uses fieldName.

namespace cpporm_sqldriver {

    enum class IndexSortOrder {
        Default,  // Let the database decide (usually Ascending)
        Ascending,
        Descending
    };

    enum class IndexNullsPosition {
        Default,  // Database default (e.g., NULLS LAST for ASC, NULLS FIRST for DESC in PG)
        First,    // NULLS FIRST
        Last      // NULLS LAST
    };

    struct IndexColumnDefinition {
        std::string fieldName;  // Name of the column in the index
        IndexSortOrder sortOrder = IndexSortOrder::Default;
        IndexNullsPosition nullsPosition = IndexNullsPosition::Default;  // If DB supports NULLS FIRST/LAST
        std::optional<std::string> expression;                           // For functional indexes, this holds the expression if fieldName isn't sufficient
        std::optional<std::string> opClass;                              // For DBs like PostgreSQL (e.g., "text_pattern_ops")
        // std::optional<std::string> collation; // Per-column collation in index (less common)
        // std::optional<int> subPartLength; // For prefix indexing (e.g. MySQL VARCHAR(255) a_column(10))
    };

    class SqlIndex {
      public:
        SqlIndex(const std::string& name = "", const std::string& tableName = "", const std::string& schemaName = "");
        ~SqlIndex();

        // Copy and Move semantics
        SqlIndex(const SqlIndex& other);
        SqlIndex& operator=(const SqlIndex& other);
        SqlIndex(SqlIndex&& other) noexcept;
        SqlIndex& operator=(SqlIndex&& other) noexcept;

        // Basic Properties
        std::string name() const;  // Index name
        void setName(const std::string& name);

        std::string tableName() const;  // Table this index belongs to (renamed from cursorName for clarity)
        void setTableName(const std::string& name);

        std::string schemaName() const;  // Schema of the table
        void setSchemaName(const std::string& schema);

        // Index Characteristics
        bool isUnique() const;
        void setUnique(bool unique);

        bool isPrimaryKey() const;
        void setPrimaryKey(bool pk);

        bool isFunctional() const;  // True if index is on an expression rather than just columns
        void setFunctional(bool functional);

        std::string typeMethod() const;  // Index method (e.g., "BTREE", "HASH", "GIN", "SPATIAL")
        void setTypeMethod(const std::string& method);

        // Columns in the Index
        void appendColumn(const IndexColumnDefinition& colDef);
        void appendColumn(const std::string& fieldName, IndexSortOrder order = IndexSortOrder::Default, const std::optional<std::string>& expression = std::nullopt, IndexNullsPosition nulls = IndexNullsPosition::Default, const std::optional<std::string>& opClass = std::nullopt);

        int columnCount() const;
        IndexColumnDefinition column(int i) const;                  // Get definition of i-th column in index
        const std::vector<IndexColumnDefinition>& columns() const;  // Get all column definitions

        // Advanced Index Properties
        std::string condition() const;  // Partial index condition (WHERE clause for CREATE INDEX)
        void setCondition(const std::string& cond);

        std::vector<std::string> includedColumnNames() const;  // For covering indexes (e.g., SQL Server INCLUDE)
        void addIncludedColumn(const std::string& columnName);
        void setIncludedColumns(const std::vector<std::string>& columnNames);

        // Driver/DB specific options
        std::map<std::string, SqlValue> options() const;  // e.g., FILLFACTOR, WITH (...)
        void setOption(const std::string& optionName, const SqlValue& value);
        SqlValue option(const std::string& optionName) const;

        void clear();  // Resets the SqlIndex to a default state

      private:
        // Direct members
        std::string m_name;
        std::string m_table_name;
        std::string m_schema_name;
        bool m_is_unique;
        bool m_is_primary_key;
        bool m_is_functional;
        std::string m_type_method;  // e.g. BTREE
        std::vector<IndexColumnDefinition> m_columns;

        std::string m_condition;                      // For partial indexes
        std::vector<std::string> m_included_columns;  // For covering indexes
        std::map<std::string, SqlValue> m_options;    // Other options like fillfactor etc.
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_query.h
#pragma once
#include <functional>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "sql_enums.h"  // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_field.h"  // For SqlField return type
#include "sql_record.h"
#include "sql_value.h"  // Provides NumericalPrecisionPolicy, SqlValue

namespace cpporm_sqldriver {

    class SqlDatabase;  // Forward declaration
    class ISqlDriver;   // Forward declaration
    class SqlResult;    // Forward declaration, SqlQuery uses an instance of this

    class SqlQuery {
      public:
        // Construction
        explicit SqlQuery(SqlDatabase& db);                                           // Create query associated with a database
        explicit SqlQuery(const std::string& query = "", SqlDatabase* db = nullptr);  // Create with optional query and database
        ~SqlQuery();

        // Preparation and Execution
        bool prepare(const std::string& query, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly);
        bool exec();                          // Execute a prepared query
        bool exec(const std::string& query);  // Prepare and execute a query

        bool setQueryTimeout(int seconds);  // Sets timeout for query execution

        // Binding Values
        void bindValue(int pos, const SqlValue& val, ParamType type = ParamType::In);
        void bindValue(const std::string& placeholderName, const SqlValue& val, ParamType type = ParamType::In);
        void addBindValue(const SqlValue& val, ParamType type = ParamType::In);  // For batch or simple positional

        // Batch binding (conceptual, depends on how SqlResult handles it)
        // void bindValues(const std::vector<SqlValue>& values, ParamType type = ParamType::In);
        // void bindValues(const std::map<std::string, SqlValue>& values, ParamType type = ParamType::In);

        SqlValue boundValue(int pos) const;
        SqlValue boundValue(const std::string& placeholderName) const;
        // const std::map<std::string, SqlValue>& namedBoundValues() const; // Might expose too much internal state
        // const std::vector<SqlValue>& positionalBoundValues() const;
        void clearBoundValues();
        // int numberOfBoundValues() const;

        // Navigation
        bool next();
        bool previous();                                                           // Requires scrollable cursor
        bool first();                                                              // Requires scrollable cursor
        bool last();                                                               // Requires scrollable cursor
        bool seek(int index, CursorMovement movement = CursorMovement::Absolute);  // Requires scrollable cursor

        // Data Retrieval
        SqlRecord recordMetadata() const;     // Returns metadata of the current result set
        SqlRecord currentFetchedRow() const;  // Returns the currently fetched row as a SqlRecord
        SqlValue value(int index) const;
        SqlValue value(const std::string& name) const;
        bool isNull(int index) const;
        bool isNull(const std::string& name) const;
        SqlField field(int index) const;                // Get field metadata by index
        SqlField field(const std::string& name) const;  // Get field metadata by name

        // Information / State
        int at() const;    // Current 0-based row index in the result set, -1 if not on a valid row
        int size() const;  // Number of rows in the result set (-1 if unknown or not applicable)

        bool isActive() const;  // Is query prepared and/or executed and not finished?
        bool isValid() const;   // Is the result set valid for navigation/data retrieval?
        bool isSelect() const;  // Heuristic: does the query appear to be a SELECT?

        bool setForwardOnly(bool forward);  // Attempt to set result set to forward-only
        bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy);
        NumericalPrecisionPolicy numericalPrecisionPolicy() const;

        SqlError lastError() const;
        std::string lastQuery() const;      // The last query string passed to prepare or exec
        std::string executedQuery() const;  // The query text after any placeholder processing by the driver

        // Post-Execution Information
        long long numRowsAffected() const;
        SqlValue lastInsertId() const;  // ID of the last inserted row, if applicable

        // Control
        void finish();  // Releases resources associated with the query and its result. Invalidates the query.
        void clear();   // Synonym for finish()

        // Associated objects
        SqlDatabase* database() const;  // Database this query is associated with
        ISqlDriver* driver() const;     // Underlying driver (use with caution)
        SqlResult* result() const;      // Underlying SqlResult object (use with caution)

        // Batch Execution (conceptual)
        // bool execBatch(BatchExecutionMode mode = BatchExecutionMode::ValuesAsRows);

        // Multiple Result Sets
        bool nextResult();  // Advance to the next result set from a query (e.g., stored procedure)

        // Placeholder syntax
        bool setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax);
        SqlResultNs::NamedBindingSyntax namedBindingSyntax() const;

        // Non-copyable, but movable
        SqlQuery(const SqlQuery&) = delete;
        SqlQuery& operator=(const SqlQuery&) = delete;
        SqlQuery(SqlQuery&& other) noexcept;
        SqlQuery& operator=(SqlQuery&& other) noexcept;

      private:
        // Direct members, no PImpl for simplicity as requested
        SqlDatabase* m_db;                    // Non-owning pointer to the associated database
        std::unique_ptr<SqlResult> m_result;  // The underlying driver-specific result object
        std::string m_last_query_text;
        bool m_is_active;
        bool m_is_select_query;  // Heuristic
        NumericalPrecisionPolicy m_precision_policy;
        SqlResultNs::NamedBindingSyntax m_binding_syntax;

        // Helper to ensure m_result is valid
        bool checkResult(const char* methodName) const;
        void updateSelectStatus();  // Helper to guess if query is SELECT
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_record.h
#pragma once
#include <memory>  // For std::unique_ptr in PImpl if used, or for direct members
#include <optional>
#include <string>
#include <vector>

#include "sqldriver/sql_field.h"  // SqlField is part of SqlRecord
#include "sqldriver/sql_value.h"  // For SqlValue as return type of value()

namespace cpporm_sqldriver {

    class SqlRecord {
      public:
        SqlRecord();
        ~SqlRecord();

        // Copy and Move semantics
        SqlRecord(const SqlRecord& other);
        SqlRecord& operator=(const SqlRecord& other);
        SqlRecord(SqlRecord&& other) noexcept;
        SqlRecord& operator=(SqlRecord&& other) noexcept;

        // Status and Count
        bool isEmpty() const;
        int count() const;

        // Field access by index
        SqlField field(int index) const;  // Returns a copy of the SqlField object
        std::string fieldName(int index) const;
        SqlValue value(int index) const;
        bool isNull(int index) const;
        void setValue(int index, const SqlValue& val);
        void setNull(int index);

        // Field access by name
        SqlField field(const std::string& name) const;
        SqlValue value(const std::string& name) const;
        bool isNull(const std::string& name) const;
        void setValue(const std::string& name, const SqlValue& val);
        void setNull(const std::string& name);

        // Lookup and containment
        int indexOf(const std::string& name) const;  // Returns -1 if not found
        bool contains(const std::string& name) const;

        // Modification (primarily for driver internal use or manual record construction)
        void append(const SqlField& field);
        void insert(int pos, const SqlField& field);
        void remove(int pos);
        void replace(int pos, const SqlField& field);  // Replaces field at pos
        void clear();                                  // Removes all fields

        // Direct access to fields vector (use with caution)
        // const std::vector<SqlField>& fields() const; // Might be useful for iteration

      private:
        // Direct member implementation (no PImpl as per last directive)
        std::vector<SqlField> m_fields;
        // For faster name lookup, an optional map could be used, built on demand or kept in sync.
        // mutable std::map<std::string, int> m_name_to_index_cache;
        // mutable bool m_cache_is_dirty;
        // void rebuildNameCache() const;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_result.h
#pragma once

#include <iosfwd>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_enums.h"  // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_record.h"
#include "sql_value.h"  // Provides SqlValue, NumericalPrecisionPolicy, SqlValueType
// #include "sql_field.h" // Forward declare or include if needed

namespace cpporm_sqldriver {

    class SqlField;  // Forward declare for SqlResult::field()
    // struct SqlFieldExtendedInfo; // Forward declare if used

    class SqlResult {
      public:
        virtual ~SqlResult() = default;

        virtual bool prepare(const std::string& query, const std::map<std::string, SqlValueType>* named_bindings_type_hints = nullptr, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly) = 0;
        virtual bool exec() = 0;
        virtual bool setQueryTimeout(int seconds) = 0;
        virtual bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) = 0;
        virtual bool setPrefetchSize(int rows) = 0;
        virtual int prefetchSize() const = 0;

        virtual void addPositionalBindValue(const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void setNamedBindValue(const std::string& placeholder, const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(int pos, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(const std::string& placeholder, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void clearBindValues() = 0;
        virtual void reset() = 0;
        virtual bool setForwardOnly(bool forward) = 0;

        virtual bool fetchNext(SqlRecord& record_buffer) = 0;
        virtual bool fetchPrevious(SqlRecord& record_buffer) = 0;
        virtual bool fetchFirst(SqlRecord& record_buffer) = 0;
        virtual bool fetchLast(SqlRecord& record_buffer) = 0;
        virtual bool fetch(int index, SqlRecord& record_buffer, CursorMovement movement = CursorMovement::Absolute) = 0;

        virtual SqlValue data(int column_index) = 0;
        virtual std::shared_ptr<std::istream> openReadableBlobStream(int column_index) = 0;
        virtual std::shared_ptr<std::ostream> openWritableBlobStream(int column_index, long long initial_size_hint = 0) = 0;

        virtual bool isNull(int column_index) = 0;
        virtual SqlRecord recordMetadata() const = 0;
        virtual SqlRecord currentFetchedRow() const = 0;
        virtual SqlField field(int column_index) const = 0;
        // virtual SqlFieldExtendedInfo fieldExtendedInfo(int column_index) const = 0;

        virtual long long numRowsAffected() = 0;
        virtual SqlValue lastInsertId() = 0;
        virtual int columnCount() const = 0;
        virtual int size() = 0;
        virtual int at() const = 0;

        virtual bool isActive() const = 0;
        virtual bool isValid() const = 0;
        virtual SqlError error() const = 0;
        virtual const std::string& lastQuery() const = 0;
        virtual const std::string& preparedQueryText() const = 0;

        virtual void finish() = 0;
        virtual void clear() = 0;

        virtual bool nextResult() = 0;

        virtual SqlValue getOutParameter(int pos) const = 0;
        virtual SqlValue getOutParameter(const std::string& name) const = 0;
        virtual std::map<std::string, SqlValue> getAllOutParameters() const = 0;

        virtual bool setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) = 0;
    };

}  // namespace cpporm_sqldriver// SqlDriver/Include/sqldriver/sql_value.h
#pragma once
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>
#include <QTimeZone>  // For Qt 6 deprecated API fixes
#include <QVariant>
#include <any>
#include <chrono>
#include <iosfwd>
#include <memory>
#include <optional>
#include <string>
#include <typeinfo>
#include <variant>
#include <vector>

namespace cpporm_sqldriver {

    enum class SqlValueType {
        Null,
        Bool,
        Int8,
        UInt8,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        LongDouble,
        String,
        FixedString,
        ByteArray,             // Represents a byte sequence, from QByteArray or std::vector<unsigned char>
        BinaryLargeObject,     // Semantic type for BLOB stream (uses InputStreamPtr in variant)
        CharacterLargeObject,  // Semantic type for CLOB stream (uses InputStreamPtr in variant)
        Date,
        Time,
        DateTime,
        Timestamp,
        Interval,
        Decimal,
        Numeric,
        Json,
        Xml,
        Array,
        RowId,
        Custom,
        Unknown
    };

    enum class NumericalPrecisionPolicy { LowPrecision, HighPrecision, ExactRepresentation };

    class SqlValue {
      public:
        using ChronoDate = std::chrono::year_month_day;
        using ChronoTime = std::chrono::nanoseconds;
        using ChronoDateTime = std::chrono::system_clock::time_point;

        using InputStreamPtr = std::shared_ptr<std::istream>;  // 通用输入流指针

        SqlValue();
        SqlValue(std::nullptr_t);
        SqlValue(bool val);
        SqlValue(int8_t val);
        SqlValue(uint8_t val);
        SqlValue(int16_t val);
        SqlValue(uint16_t val);
        SqlValue(int32_t val);
        SqlValue(uint32_t val);
        SqlValue(int64_t val);
        SqlValue(uint64_t val);
        SqlValue(float val);
        SqlValue(double val);
        SqlValue(long double val);
        SqlValue(const char* val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::string& val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::vector<unsigned char>& val);  // 用于原始字节

        // LOB 流构造函数 (使用通用 InputStreamPtr 和一个类型提示)
        SqlValue(InputStreamPtr stream_handle, SqlValueType lob_type /* 必须是 BinaryLargeObject 或 CharacterLargeObject */, long long size = -1);

        SqlValue(const QByteArray& val);
        SqlValue(const QDate& val);
        SqlValue(const QTime& val);
        SqlValue(const QDateTime& val);

        SqlValue(const ChronoDate& val);
        SqlValue(const ChronoTime& val);
        SqlValue(const ChronoDateTime& val);

        SqlValue(const SqlValue& other);
        SqlValue& operator=(const SqlValue& other);
        SqlValue(SqlValue&& other) noexcept;
        SqlValue& operator=(SqlValue&& other) noexcept;
        ~SqlValue();

        bool isNull() const;
        bool isValid() const;
        SqlValueType type() const;
        const char* typeName() const;
        std::string driverTypeName() const;
        void setDriverTypeName(const std::string& name);
        long long lobSizeHint() const;

        bool toBool(bool* ok = nullptr) const;
        int8_t toInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint8_t toUInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int16_t toInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint16_t toUInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int32_t toInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint32_t toUInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int64_t toInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint64_t toUInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        float toFloat(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        double toDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        long double toLongDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::string toString(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::vector<unsigned char> toStdVectorUChar(bool* ok = nullptr) const;

        InputStreamPtr toInputStream(bool* ok = nullptr) const;  // 通用获取输入流方法

        QByteArray toByteArray(bool* ok = nullptr) const;
        QDate toDate(bool* ok = nullptr) const;
        QTime toTime(bool* ok = nullptr) const;
        QDateTime toDateTime(bool* ok = nullptr) const;

        ChronoDate toChronoDate(bool* ok = nullptr) const;
        ChronoTime toChronoTime(bool* ok = nullptr) const;
        ChronoDateTime toChronoDateTime(bool* ok = nullptr) const;

        bool operator==(const SqlValue& other) const;
        bool operator!=(const SqlValue& other) const;

        void clear();

        QVariant toQVariant() const;
        static SqlValue fromQVariant(const QVariant& qv);

        std::any toStdAny() const;
        static SqlValue fromStdAny(const std::any& val, SqlValueType type_hint = SqlValueType::Custom);

      private:
        // StorageType 确保类型不重复
        using StorageType = std::variant<  // 索引从0开始
            std::monostate,                // 0: Null
            bool,                          // 1
            int8_t,                        // 2
            uint8_t,                       // 3
            int16_t,                       // 4
            uint16_t,                      // 5
            int32_t,                       // 6
            uint32_t,                      // 7
            int64_t,                       // 8
            uint64_t,                      // 9
            float,                         // 10
            double,                        // 11
            long double,                   // 12
            std::string,                   // 13: String, FixedString, CLOB data, Json, Xml, Decimal, Numeric
            std::vector<unsigned char>,    // 14: ByteArray, BLOB data (non-stream)
            InputStreamPtr,                // 15: BLOB/CLOB streams
            QDate,                         // 16
            QTime,                         // 17
            QDateTime,                     // 18
            ChronoDate,                    // 19
            ChronoTime,                    // 20
            ChronoDateTime,                // 21
            std::any                       // 22: Custom
            >;

        StorageType m_value_storage;
        SqlValueType m_current_type_enum;
        std::string m_driver_type_name_cache;
        long long m_lob_size_hint;

        void updateCurrentTypeEnumFromStorage();
    };

}  // namespace cpporm_sqldriver#include "sqldriver/detail/sql_value_helpers.h"  // Corresponding header

#include <charconv>
#include <iomanip>
#include <limits>
#include <sstream>
#include <string_view>  // For std::string_view

namespace cpporm_sqldriver {
    namespace detail {

        template <typename IntType>
        std::optional<IntType> stringToInteger(const std::string& s, bool* ok) {
            if (s.empty()) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            IntType val{};
            size_t first = s.find_first_not_of(" \t\n\r\f\v");
            if (first == std::string::npos) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t last = s.find_last_not_of(" \t\n\r\f\v");
            std::string_view sv_trimmed = std::string_view(s).substr(first, last - first + 1);
            auto [ptr, ec] = std::from_chars(sv_trimmed.data(), sv_trimmed.data() + sv_trimmed.size(), val);
            if (ec == std::errc() && ptr == sv_trimmed.data() + sv_trimmed.size()) {
                if (ok) *ok = true;
                return val;
            }
            if (ok) *ok = false;
            return std::nullopt;
        }

        // Explicit instantiations for common integer types if needed, or keep as full template.
        template std::optional<int8_t> stringToInteger<int8_t>(const std::string&, bool*);
        template std::optional<uint8_t> stringToInteger<uint8_t>(const std::string&, bool*);
        template std::optional<int16_t> stringToInteger<int16_t>(const std::string&, bool*);
        template std::optional<uint16_t> stringToInteger<uint16_t>(const std::string&, bool*);
        template std::optional<int32_t> stringToInteger<int32_t>(const std::string&, bool*);
        template std::optional<uint32_t> stringToInteger<uint32_t>(const std::string&, bool*);
        template std::optional<int64_t> stringToInteger<int64_t>(const std::string&, bool*);
        template std::optional<uint64_t> stringToInteger<uint64_t>(const std::string&, bool*);

        template <typename FloatType>
        std::optional<FloatType> stringToFloat(const std::string& s, bool* ok) {
            if (s.empty()) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t first = s.find_first_not_of(" \t\n\r\f\v");
            if (first == std::string::npos) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t last = s.find_last_not_of(" \t\n\r\f\v");
            std::string s_trimmed = s.substr(first, last - first + 1);
            try {
                size_t idx = 0;
                FloatType val{};
                if constexpr (std::is_same_v<FloatType, float>)
                    val = std::stof(s_trimmed, &idx);
                else if constexpr (std::is_same_v<FloatType, double>)
                    val = std::stod(s_trimmed, &idx);
                else if constexpr (std::is_same_v<FloatType, long double>)
                    val = std::stold(s_trimmed, &idx);
                else
                    static_assert(!std::is_same_v<FloatType, FloatType>, "Unsupported float type");

                if (idx == s_trimmed.length()) {
                    if (ok) *ok = true;
                    return val;
                }
            } catch (...) {
            }
            if (ok) *ok = false;
            return std::nullopt;
        }
        template std::optional<float> stringToFloat<float>(const std::string&, bool*);
        template std::optional<double> stringToFloat<double>(const std::string&, bool*);
        template std::optional<long double> stringToFloat<long double>(const std::string&, bool*);

        bool isValidChronoDate(const SqlValue::ChronoDate& cd) {
            return cd.ok();
        }
        bool isValidChronoDateTime(const SqlValue::ChronoDateTime& cdt) {
            // Simplified check: not epoch (often default for invalid) unless it's explicitly zero epoch
            return cdt.time_since_epoch().count() != std::chrono::system_clock::from_time_t(0).time_since_epoch().count() || (cdt.time_since_epoch() == std::chrono::system_clock::duration::zero());
        }

        std::string blobToHexString(const std::vector<unsigned char>& blob) {
            std::ostringstream oss;
            oss << "0x";
            oss << std::hex << std::setfill('0');
            for (unsigned char byte_val : blob) {
                oss << std::setw(2) << static_cast<int>(byte_val);
            }
            return oss.str();
        }

    }  // namespace detail
}  // namespace cpporm_sqldriver#include "sqldriver/mysql/mysql_driver_helper.h"
// 不需要其他特定包含，因为枚举都在头文件中定义

namespace cpporm_sqldriver {
    namespace mysql_helper {

        cpporm_mysql_transport::TransactionIsolationLevel toMySqlTransportIsolationLevel(TransactionIsolationLevel driverLevel) {
            switch (driverLevel) {
                case TransactionIsolationLevel::ReadUncommitted:
                    return cpporm_mysql_transport::TransactionIsolationLevel::ReadUncommitted;
                case TransactionIsolationLevel::ReadCommitted:
                    return cpporm_mysql_transport::TransactionIsolationLevel::ReadCommitted;
                case TransactionIsolationLevel::RepeatableRead:
                    return cpporm_mysql_transport::TransactionIsolationLevel::RepeatableRead;
                case TransactionIsolationLevel::Serializable:
                    return cpporm_mysql_transport::TransactionIsolationLevel::Serializable;
                case TransactionIsolationLevel::Snapshot:
                    // MySQL 的 REPEATABLE READ 通过 MVCC 提供了快照隔离
                    return cpporm_mysql_transport::TransactionIsolationLevel::RepeatableRead;
                case TransactionIsolationLevel::Default:
                default:
                    // 让 Transport 层决定使用服务器的默认隔离级别
                    return cpporm_mysql_transport::TransactionIsolationLevel::None;
            }
        }

        TransactionIsolationLevel fromMySqlTransportIsolationLevel(cpporm_mysql_transport::TransactionIsolationLevel transportLevel) {
            switch (transportLevel) {
                case cpporm_mysql_transport::TransactionIsolationLevel::ReadUncommitted:
                    return TransactionIsolationLevel::ReadUncommitted;
                case cpporm_mysql_transport::TransactionIsolationLevel::ReadCommitted:
                    return TransactionIsolationLevel::ReadCommitted;
                case cpporm_mysql_transport::TransactionIsolationLevel::RepeatableRead:
                    // MySQL 的 REPEATABLE READ 行为上是快照隔离
                    return TransactionIsolationLevel::RepeatableRead;  // 或者 Snapshot，取决于您想如何映射
                case cpporm_mysql_transport::TransactionIsolationLevel::Serializable:
                    return TransactionIsolationLevel::Serializable;
                case cpporm_mysql_transport::TransactionIsolationLevel::None:  // 表示 Transport 层未指定或未知
                default:
                    return TransactionIsolationLevel::Default;  // 映射回 Driver 的默认/未知状态
            }
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_error_converter.cpp
#include <mysql/errmsg.h>  // For CR_* client error codes from the version you provided
#include <mysql/mysql.h>   // For CR_MIN_ERROR, CR_MAX_ERROR (used for range check only)

#include "sqldriver/mysql/mysql_driver_helper.h"

// NO server-side ER_* numeric values will be used for classification.
// Classification will rely on MySqlTransportError::category and SQLSTATE.

namespace cpporm_sqldriver {
    namespace mysql_helper {

        SqlError transportErrorToSqlError(const ::cpporm_mysql_transport::MySqlTransportError& transportError) {
            ErrorCategory category = ErrorCategory::Unknown;
            std::string db_text = transportError.native_mysql_error_msg;
            if (db_text.empty()) {
                db_text = transportError.message;
            }
            std::string driver_text = transportError.message;
            int native_err_no = transportError.native_mysql_errno;  // Primarily for debugging or CR_* specifics
            const std::string sqlstate = transportError.native_mysql_sqlstate;

            // 1. Primary mapping based on MySqlTransportError::Category
            switch (transportError.category) {
                case ::cpporm_mysql_transport::MySqlTransportError::Category::NoError:
                    category = ErrorCategory::NoError;
                    break;

                case ::cpporm_mysql_transport::MySqlTransportError::Category::ConnectionError:
                    category = ErrorCategory::Connectivity;  // Default for this transport category
                    // Refine based on SQLSTATE for common connection issues
                    if (sqlstate == "08001" || sqlstate == "08004" || sqlstate == "08S01") {
                        category = ErrorCategory::Connectivity;
                    } else if (sqlstate == "28000") {  // Invalid authorization specification
                        category = ErrorCategory::Permissions;
                    } else {
                        // Check specific CR_* codes that clearly indicate a type of connection failure
                        // Only use CR_* macros that are confirmed to be in your errmsg.h
                        switch (native_err_no) {
                            case CR_CONN_HOST_ERROR:
                            case CR_CONNECTION_ERROR:
                            case CR_SERVER_GONE_ERROR:
                            case CR_SERVER_LOST:
                            case CR_SERVER_LOST_EXTENDED:
                            case CR_SSL_CONNECTION_ERROR:
                            case CR_CONN_UNKNOW_PROTOCOL:  // Sic, from your errmsg.h
                                category = ErrorCategory::Connectivity;
                                break;
                            case CR_AUTH_PLUGIN_CANNOT_LOAD:
                            case CR_AUTH_PLUGIN_ERR:
                                category = ErrorCategory::Permissions;
                                break;
                                // Other CR_* connection errors default to Connectivity
                        }
                    }
                    break;

                case ::cpporm_mysql_transport::MySqlTransportError::Category::QueryError:
                    // For QueryError, SQLSTATE is the primary classifier.
                    if (sqlstate.empty() || sqlstate == "00000") {
                        category = (native_err_no == 0) ? ErrorCategory::NoError : ErrorCategory::DatabaseInternal;
                    } else if (sqlstate.rfind("01", 0) == 0) {  // Warning
                        // Assuming transport's QueryError means it's an actual error for SqlError context
                        category = ErrorCategory::DataRelated;  // Warnings often related to data issues
                    } else if (sqlstate.rfind("21", 0) == 0) {  // Cardinality violation
                        category = ErrorCategory::DataRelated;
                    } else if (sqlstate.rfind("22", 0) == 0) {  // Data exception
                        category = ErrorCategory::DataRelated;
                    } else if (sqlstate.rfind("23", 0) == 0) {  // Integrity constraint violation
                        category = ErrorCategory::Constraint;
                    } else if (sqlstate.rfind("28", 0) == 0) {  // Invalid authorization specification
                        category = ErrorCategory::Permissions;
                    } else if (sqlstate.rfind("3D", 0) == 0 || sqlstate.rfind("3F", 0) == 0) {  // Invalid catalog/schema name
                        category = ErrorCategory::Syntax;
                    } else if (sqlstate.rfind("40", 0) == 0) {  // Transaction rollback (e.g., deadlock, serialization failure)
                        category = ErrorCategory::Transaction;
                        // SQLSTATE 40001 is serialization_failure (includes deadlock)
                        // SQLSTATE 40000 is transaction_rollback
                        // SQLSTATE 40002 is transaction_integrity_constraint_violation
                        // No need to check native_err_no for deadlock/lock_timeout if SQLSTATE is 40xxx
                    } else if (sqlstate.rfind("42", 0) == 0) {  // Syntax error or access rule violation
                        // SQLSTATE class 42 covers a broad range.
                        // "42000" can be syntax error OR access rule violation.
                        // "42S01" table already exists, "42S02" table not found, "42S22" column not found.
                        // Defaulting to Syntax as it covers structural/naming issues.
                        // If "Access denied" type messages are present in db_text for 42000, it's a hint,
                        // but string parsing is fragile. The transport layer's initial category is key.
                        category = ErrorCategory::Syntax;
                    } else if (sqlstate == "HY000") {  // General error
                        // This is very generic. MySqlTransportError::category was QueryError.
                        // Only rely on specific CR_* codes if they indicate API misuse.
                        if (native_err_no == CR_COMMANDS_OUT_OF_SYNC) {
                            category = ErrorCategory::DriverInternal;  // Client API misuse
                        } else {
                            // If it's a server-originated error (native_err_no < CR_MIN_ERROR typically for ER_*)
                            // and SQLSTATE is HY000, it's a general server-side failure.
                            if (native_err_no > 0 && native_err_no < CR_MIN_ERROR) {
                                category = ErrorCategory::DatabaseInternal;
                            } else {
                                category = ErrorCategory::Unknown;  // Could be an unmapped client error or other
                            }
                        }
                    } else {
                        // Unmapped SQLSTATE that is not a warning, and not HY000.
                        // Could be a more specific server error class.
                        category = ErrorCategory::DatabaseInternal;  // Default for unrecognised SQLSTATEs indicating server issues
                    }
                    break;

                case ::cpporm_mysql_transport::MySqlTransportError::Category::DataError:
                    category = ErrorCategory::DataRelated;
                    if (native_err_no == CR_DATA_TRUNCATED) { /* Confirms DataRelated */
                    }
                    break;
                case ::cpporm_mysql_transport::MySqlTransportError::Category::ResourceError:
                    category = ErrorCategory::Resource;
                    break;
                case ::cpporm_mysql_transport::MySqlTransportError::Category::TransactionError:
                    category = ErrorCategory::Transaction;
                    break;
                case ::cpporm_mysql_transport::MySqlTransportError::Category::ProtocolError:
                    category = ErrorCategory::DriverInternal;
                    driver_text = "Protocol Layer: " + transportError.message;
                    break;
                case ::cpporm_mysql_transport::MySqlTransportError::Category::InternalError:
                    category = ErrorCategory::DriverInternal;
                    driver_text = "Transport Internal: " + transportError.message;
                    break;
                case ::cpporm_mysql_transport::MySqlTransportError::Category::ApiUsageError:
                    // These are issues with how the transport layer's API was called.
                    // Specific CR_* codes from your errmsg.h for API misuse:
                    switch (native_err_no) {
                        case CR_NULL_POINTER:
                        case CR_NO_PREPARE_STMT:
                        case CR_PARAMS_NOT_BOUND:
                        case CR_NO_PARAMETERS_EXISTS:
                        case CR_INVALID_PARAMETER_NO:
                        case CR_INVALID_BUFFER_USE:
                        case CR_UNSUPPORTED_PARAM_TYPE:
                        case CR_NO_STMT_METADATA:
                        case CR_STMT_CLOSED:
                        case CR_INVALID_CONN_HANDLE:
                        case CR_FETCH_CANCELED:  // Can be API induced or server
                        case CR_NOT_IMPLEMENTED:
                            category = ErrorCategory::DriverInternal;  // Clear API misuse by client of transport/driver
                            break;
                        default:
                            category = ErrorCategory::DriverInternal;  // Generic API usage error
                            break;
                    }
                    driver_text = "Transport API Usage: " + transportError.message;
                    break;
                default:
                    category = ErrorCategory::Unknown;
            }

            // Final consistency check: if transport error indicates success, SqlError should also be NoError,
            // unless a DriverInternal error (like ProtocolError) occurred despite underlying success.
            if (transportError.isOk() && category != ErrorCategory::NoError) {
                if (!(category == ErrorCategory::DriverInternal && (transportError.category == ::cpporm_mysql_transport::MySqlTransportError::Category::ProtocolError || transportError.category == ::cpporm_mysql_transport::MySqlTransportError::Category::InternalError ||
                                                                    transportError.category == ::cpporm_mysql_transport::MySqlTransportError::Category::ApiUsageError))) {
                    // If transport said OK, but we derived an error (and it's not an overriding DriverInternal issue),
                    // then force NoError. This prioritizes the transport layer's success signal.
                    category = ErrorCategory::NoError;
                }
            }

            return SqlError(category,
                            db_text,
                            driver_text,
                            transportError.native_mysql_sqlstate,
                            native_err_no,  // Still pass for logging/debugging
                            transportError.failed_query);
        }

        SqlError protocolErrorToSqlError(const mysql_protocol::MySqlProtocolError& protocolError, const std::string& context_message) {
            ErrorCategory category = ErrorCategory::DriverInternal;  // Default for protocol issues
            std::string combined_message = context_message;
            if (!combined_message.empty() && !protocolError.error_message.empty()) {
                combined_message += " - ";
            }
            combined_message += protocolError.error_message;

            unsigned int pe_code = protocolError.error_code;  // This is MySqlProtocol::InternalErrc

            if (pe_code == mysql_protocol::InternalErrc::SUCCESS) {
                category = ErrorCategory::NoError;
            } else if (pe_code >= mysql_protocol::InternalErrc::CONVERSION_INVALID_INPUT_ARGUMENT && pe_code <= mysql_protocol::InternalErrc::CONVERSION_TYPE_MISMATCH_ACCESS) {
                category = ErrorCategory::DataRelated;
            } else if (pe_code >= mysql_protocol::InternalErrc::TIME_STRING_PARSE_EMPTY_INPUT && pe_code <= mysql_protocol::InternalErrc::TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE) {
                category = ErrorCategory::DataRelated;
            } else if (pe_code == mysql_protocol::InternalErrc::NATIVE_VALUE_TO_STRING_ERROR) {
                category = ErrorCategory::DataRelated;
            }
            // Other InternalErrc codes like BIND_SETUP, LOGIC_ERROR_INVALID_STATE, UNKNOWN_ERROR
            // will correctly default to ErrorCategory::DriverInternal.

            return SqlError(category,
                            protocolError.error_message,
                            combined_message,
                            std::string(protocolError.sql_state),  // Protocol's SQLSTATE
                            static_cast<int>(pe_code),             // Use protocol's internal code
                            "");
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_metadata_converter.cpp
#include "sqldriver/mysql/mysql_driver_helper.h"
#include "sqldriver/sql_field.h"
#include "sqldriver/sql_index.h"
#include "sqldriver/sql_record.h"
#include "sqldriver/sql_value.h"  // For SqlValueType

// Make sure these are included for the transport types
#include "cpporm_mysql_transport/mysql_transport_types.h"

namespace cpporm_sqldriver {
    namespace mysql_helper {

        // --- Implementation for metaToSqlField ---
        SqlField metaToSqlField(const ::cpporm_mysql_transport::MySqlTransportFieldMeta& transportMeta) {
            SqlField field(transportMeta.name,
                           mySqlColumnTypeToSqlValueType(transportMeta.native_type_id, transportMeta.flags),  // Assuming this helper exists and is correct
                           "");                                                                               // SqlField's db_type_name will be set if parseMySQLTypeStringInternal in transport layer was more detailed

            // Basic properties from transportMeta
            field.setLength(static_cast<int>(transportMeta.length));       // MySQL length might be bigger
            field.setPrecision(static_cast<int>(transportMeta.decimals));  // For numeric types, decimals is precision for MySQL
                                                                           // Scale would be part of decimals if it's like DECIMAL(P,S)
                                                                           // For simplicity, using decimals as precision.
                                                                           // A more detailed parsing of original type string is needed for true P,S.
            field.setRequiredStatus(transportMeta.isNotNull() ? RequiredStatus::Required : RequiredStatus::Optional);
            field.setAutoValue(transportMeta.isAutoIncrement());
            field.setPrimaryKeyPart(transportMeta.isPrimaryKey());
            // transportMeta doesn't directly tell if it's FK, read-only, or generated in a simple way.
            // These might need more complex schema introspection or be set based on convention/hints.

            // Set original database type name if available from transportMeta's parsing of type string
            // (Assuming MySqlTransportFieldMeta might store the full original type string if needed)
            // For now, we derive a generic SqlValueType. SqlField's databaseTypeName could be set
            // if MySqlTransportFieldMeta retained the raw type string.

            // Example for default value (if transportMeta.default_value is MySqlNativeValue)
            if (!transportMeta.default_value.is_null()) {
                field.setDefaultValue(mySqlNativeValueToSqlValue(transportMeta.default_value));  // Assuming this helper exists
            }

            // Set flags in SqlField based on transportMeta.flags
            // (This is a bit redundant if SqlField properties are set directly,
            //  but good for completeness if SqlField has its own internal flag system)

            return field;
        }

        // --- Implementation for metasToSqlRecord ---
        SqlRecord metasToSqlRecord(const std::vector<::cpporm_mysql_transport::MySqlTransportFieldMeta>& transportMetas) {
            SqlRecord record;
            for (const auto& tm : transportMetas) {
                record.append(metaToSqlField(tm));
            }
            return record;
        }

        // --- Implementation for metaToSqlIndex ---
        SqlIndex metaToSqlIndex(const ::cpporm_mysql_transport::MySqlTransportIndexInfo& transportIndexInfo) {
            SqlIndex index(transportIndexInfo.indexName, transportIndexInfo.tableName);
            index.setUnique(!transportIndexInfo.isNonUnique);
            index.setPrimaryKey(transportIndexInfo.indexName == "PRIMARY");  // MySQL convention
            index.setTypeMethod(transportIndexInfo.indexType);

            for (const auto& tCol : transportIndexInfo.columns) {
                IndexColumnDefinition colDef;
                colDef.fieldName = tCol.columnName;
                // MySQL SHOW INDEX doesn't directly give ASC/DESC for columns, typically ASC
                colDef.sortOrder = IndexSortOrder::Default;  // Or Ascending
                if (tCol.expression.has_value()) {
                    colDef.expression = tCol.expression;
                    index.setFunctional(true);
                }
                // Other properties like opClass, subPart, collation can be mapped if needed
                index.appendColumn(colDef);
            }
            // transportIndexInfo.comment and indexComment can be stored if SqlIndex supports them.
            return index;
        }

        // --- Implementation for metasToSqlIndexes ---
        std::vector<SqlIndex> metasToSqlIndexes(const std::vector<::cpporm_mysql_transport::MySqlTransportIndexInfo>& transportIndexInfos) {
            std::vector<SqlIndex> indexes;
            indexes.reserve(transportIndexInfos.size());
            for (const auto& ti : transportIndexInfos) {
                indexes.push_back(metaToSqlIndex(ti));
            }
            return indexes;
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_param_converter.cpp
#include "sqldriver/mysql/mysql_driver_helper.h"
// #include <mysql/mysql.h> // Not needed for param conversion logic itself
#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportConnectionParams definition

namespace cpporm_sqldriver {
    namespace mysql_helper {

        // Use fully qualified name for transport params type
        ::cpporm_mysql_transport::MySqlTransportConnectionParams toMySqlTransportParams(const ConnectionParameters& params) {
            ::cpporm_mysql_transport::MySqlTransportConnectionParams transport_params;
            bool conv_ok_flag = true;

            auto get_opt_string = [&](const std::string& key) -> std::optional<std::string> {
                auto it = params.find(key);
                if (it != params.end() && !it->second.isNull()) {
                    bool ok_local = false;
                    std::string val = it->second.toString(&ok_local);
                    if (!ok_local) conv_ok_flag = false;
                    return val;
                }
                return std::nullopt;
            };
            // Removed unused get_opt_int
            auto get_opt_uint = [&](const std::string& key) -> std::optional<unsigned int> {
                auto it = params.find(key);
                if (it != params.end() && !it->second.isNull()) {
                    bool ok_local = false;
                    // SqlValue toUInt32 should be used for unsigned int
                    unsigned int val = it->second.toUInt32(&ok_local);
                    if (!ok_local) conv_ok_flag = false;
                    return val;
                }
                return std::nullopt;
            };

            transport_params.host = params.hostName().value_or("localhost");
            transport_params.port = static_cast<unsigned int>(params.port().value_or(3306));
            transport_params.user = params.userName().value_or("");
            transport_params.password = params.password().value_or("");
            transport_params.db_name = params.dbName().value_or("");

            if (auto val = get_opt_string(ConnectionParameters::KEY_CLIENT_CHARSET)) transport_params.charset = val;
            // Corrected key name:
            if (auto val = get_opt_uint(ConnectionParameters::KEY_CONNECTION_TIMEOUT_SECONDS)) transport_params.connect_timeout_seconds = val;
            if (auto val = get_opt_uint(ConnectionParameters::KEY_READ_TIMEOUT_SECONDS)) transport_params.read_timeout_seconds = val;
            if (auto val = get_opt_uint(ConnectionParameters::KEY_WRITE_TIMEOUT_SECONDS)) transport_params.write_timeout_seconds = val;

            if (auto val = get_opt_string(ConnectionParameters::KEY_SSL_MODE)) transport_params.ssl_options["ssl_mode"] = *val;
            if (auto val = get_opt_string(ConnectionParameters::KEY_SSL_KEY_PATH)) transport_params.ssl_options["ssl_key"] = *val;
            if (auto val = get_opt_string(ConnectionParameters::KEY_SSL_CERT_PATH)) transport_params.ssl_options["ssl_cert"] = *val;
            if (auto val = get_opt_string(ConnectionParameters::KEY_SSL_CA_PATH)) transport_params.ssl_options["ssl_ca"] = *val;
            if (auto val = get_opt_string(ConnectionParameters::KEY_SSL_CIPHER)) transport_params.ssl_options["ssl_cipher"] = *val;

            // Handling for generic_options and init_commands needs a defined convention in ConnectionParameters
            // Example: iterate all params and check for a prefix like "mysql.option.<mysql_option_enum_as_string>"
            // or "mysql.init_command.<command_key>"
            // This part is complex due to mapping string keys to mysql_option enums and string values to void* or specific types.
            // For simplicity, this is often handled by dedicated setters in ConnectionParameters or a more elaborate parsing mechanism.
            // The current MySqlTransportConnectionParams expects generic_options as std::map<mysql_option, std::string>
            // and init_commands as std::map<std::string, std::string>.
            // A simple pass-through of ConnectionParameters::KEY_CONNECT_OPTIONS string is not directly usable.

            if (auto conn_opts_str = get_opt_string(ConnectionParameters::KEY_CONNECT_OPTIONS)) {
                // Here you would parse conn_opts_str, which could be like "CLIENT_FOUND_ROWS=1;MYSQL_OPT_RECONNECT=true"
                // And populate transport_params.client_flag or transport_params.generic_options accordingly.
                // This parsing is non-trivial and omitted for brevity.
                // Example of setting client_flag if it was a simple integer option:
                // if (conn_opts_str->find("SOME_CLIENT_FLAG_NAME") != std::string::npos) {
                //    transport_params.client_flag |= SOME_MYSQL_CLIENT_FLAG_MACRO;
                // }
            }

            if (!conv_ok_flag) {
                // Optionally log a warning here that some parameters might not have converted correctly.
            }

            return transport_params;
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver#include <cctype>  // For std::isalpha, std::isalnum
#include <string>
#include <vector>

#include "sqldriver/mysql/mysql_driver_helper.h"

namespace cpporm_sqldriver {
    namespace mysql_helper {

        NamedPlaceholderInfo processQueryForPlaceholders(const std::string& originalQuery, SqlResultNs::NamedBindingSyntax syntax) {
            NamedPlaceholderInfo info;
            info.hasNamedPlaceholders = false;  // 默认没有命名占位符

            if (syntax == SqlResultNs::NamedBindingSyntax::QuestionMark || originalQuery.empty()) {
                info.processedQuery = originalQuery;  // 问号占位符或空查询，无需处理
                return info;
            }

            char placeholder_char_start = 0;
            switch (syntax) {
                case SqlResultNs::NamedBindingSyntax::Colon:
                    placeholder_char_start = ':';
                    break;
                case SqlResultNs::NamedBindingSyntax::AtSign:
                    placeholder_char_start = '@';
                    break;
                default:  // Should not happen if QuestionMark is handled above
                    info.processedQuery = originalQuery;
                    return info;
            }

            std::string& result_query = info.processedQuery;
            result_query.reserve(originalQuery.length());

            char in_quote_char = 0;  // ' или "
            bool after_backslash = false;

            for (size_t i = 0; i < originalQuery.length(); ++i) {
                char current_char = originalQuery[i];

                if (after_backslash) {
                    result_query += current_char;
                    after_backslash = false;
                    continue;
                }

                if (current_char == '\\') {
                    result_query += current_char;
                    after_backslash = true;
                    continue;
                }

                if (in_quote_char != 0) {  // 如果在引号内
                    result_query += current_char;
                    if (current_char == in_quote_char) {
                        in_quote_char = 0;  // 结束引号
                    }
                    continue;
                }

                if (current_char == '\'' || current_char == '"') {
                    result_query += current_char;
                    in_quote_char = current_char;  // 进入引号
                    continue;
                }

                // 检查是否是占位符开始符 (例如 :)
                if (current_char == placeholder_char_start) {
                    // 检查下一个字符是否是合法的占位符名称开头（字母或下划线）
                    if (i + 1 < originalQuery.length() && (std::isalpha(static_cast<unsigned char>(originalQuery[i + 1])) || originalQuery[i + 1] == '_')) {
                        size_t name_start_idx = i + 1;
                        size_t name_end_idx = name_start_idx;
                        while (name_end_idx < originalQuery.length() && (std::isalnum(static_cast<unsigned char>(originalQuery[name_end_idx])) || originalQuery[name_end_idx] == '_')) {
                            name_end_idx++;
                        }

                        if (name_end_idx > name_start_idx) {  // 找到了一个有效的占位符名称
                            std::string param_name = originalQuery.substr(name_start_idx, name_end_idx - name_start_idx);
                            info.orderedParamNames.push_back(param_name);
                            result_query += '?';  // 替换为问号
                            info.hasNamedPlaceholders = true;
                            i = name_end_idx - 1;  // 更新主循环的索引
                            continue;              // 继续下一个字符的处理
                        }
                    }
                }
                // 如果不是占位符的一部分，或者不是特殊字符，则直接追加
                result_query += current_char;
            }

            // 如果在处理后没有发现任何命名占位符，则处理后的查询应与原始查询相同
            if (!info.hasNamedPlaceholders) {
                info.processedQuery = originalQuery;
                info.orderedParamNames.clear();  // 确保为空
            }

            return info;
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_driver_core.cpp
#include <stdexcept>  // For std::runtime_error

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_metadata.h"  // 包含 MySqlTransportMetadata 的完整定义
#include "cpporm_mysql_transport/mysql_transport_types.h"     // For MySqlTransportConnectionParams etc.
#include "sqldriver/mysql/mysql_driver_helper.h"
#include "sqldriver/mysql/mysql_specific_driver.h"
#include "sqldriver/mysql/mysql_specific_result.h"
#include "sqldriver/sql_driver_manager.h"  // Needed for registration

namespace cpporm_sqldriver {

    MySqlSpecificDriver::MySqlSpecificDriver()
        : m_transport_connection(nullptr),
          m_transport_metadata(nullptr),  // 初始化为 nullptr
          m_open_error_flag(false) {
        try {
            m_transport_connection = std::make_unique<cpporm_mysql_transport::MySqlTransportConnection>();
        } catch (const std::exception& e) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Failed to initialize MySqlTransportConnection: " + std::string(e.what()), "MySqlSpecificDriver constructor");
            m_open_error_flag = true;
        }
        // m_transport_metadata 将在 open() 成功时创建
    }

    MySqlSpecificDriver::~MySqlSpecificDriver() {
        // 直接执行 close() 的逻辑，避免从析构函数调用虚函数
        if (m_transport_connection && m_transport_connection->isConnected()) {
            m_transport_connection->disconnect();
        }
        m_transport_metadata.reset();    // 确保 MySqlTransportMetadata 在连接之前销毁（如果它依赖连接）
        m_transport_connection.reset();  // 销毁 transport connection
    }

    // const 方法现在可以安全地调用 getTransportConnection()->getLastError()
    // 并通过 mysql_helper 转换后更新 mutable m_last_error_cache
    void MySqlSpecificDriver::updateLastErrorCacheFromTransport(bool success_of_operation) const {
        if (m_transport_connection) {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_connection->getLastError());
            if (!success_of_operation && m_last_error_cache.category() == ErrorCategory::NoError) {
                // 如果操作明确失败，但 transport 层没有报告错误，则这是一个驱动内部问题
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Operation reported failure, but transport layer shows no specific error.", "MySqlSpecificDriver");
            }
        } else {
            // 如果 transport_connection 本身就是 null，且上一个错误是 NoError，则更新
            if (m_last_error_cache.category() == ErrorCategory::NoError) {
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Transport connection is not available.", "MySqlSpecificDriver");
            }
        }
    }

    std::string MySqlSpecificDriver::resolveSchemaName(const std::string& schema_filter_from_args) const {
        if (!schema_filter_from_args.empty()) {
            return schema_filter_from_args;
        }
        // 从缓存的连接参数中获取数据库名
        if (auto dbName = m_current_params_cache.dbName()) {
            return *dbName;
        }
        return "";  // 如果都为空，则返回空字符串
    }

    bool MySqlSpecificDriver::open(const ConnectionParameters& params) {
        if (!m_transport_connection) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Transport connection not initialized.", "open");
            m_open_error_flag = true;
            return false;
        }

        if (isOpen()) {  // 使用 isOpen() 而不是直接访问 m_is_connected
            close();     // 调用自身的 close 方法
        }

        m_open_error_flag = false;        // 重置打开错误标记
        m_last_error_cache = SqlError();  // 清除之前的错误
        m_current_params_cache = params;  // 缓存参数

        ::cpporm_mysql_transport::MySqlTransportConnectionParams transport_params = mysql_helper::toMySqlTransportParams(params);
        bool success = m_transport_connection->connect(transport_params);
        updateLastErrorCacheFromTransport(success);  // 从 transport 层更新错误

        if (success) {
            // 连接成功后，初始化元数据提供者
            try {
                m_transport_metadata = std::make_unique<cpporm_mysql_transport::MySqlTransportMetadata>(m_transport_connection.get());
                if (!m_transport_metadata) {  // 确保创建成功
                    throw std::runtime_error("MySqlTransportMetadata could not be created.");
                }
            } catch (const std::exception& e) {
                if (m_transport_connection->isConnected()) m_transport_connection->disconnect();  // 创建元数据失败，则断开连接
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Failed to initialize metadata provider: " + std::string(e.what()), "open");
                success = false;  // 标记为失败
            }
        }

        if (!success) {
            m_open_error_flag = true;      // 标记打开操作失败
            m_transport_metadata.reset();  // 如果元数据创建失败或连接失败，则重置
        }
        return success;
    }

    void MySqlSpecificDriver::close() {
        bool had_error_before_close = m_open_error_flag || (m_last_error_cache.category() != ErrorCategory::NoError);

        if (m_transport_connection && m_transport_connection->isConnected()) {
            m_transport_connection->disconnect();
            // 不需要显式调用 updateLastErrorCacheFromTransport，因为 disconnect 通常不应该产生新错误
            // 如果 disconnect 自身可能失败并设置错误，则需要处理
        }
        m_transport_metadata.reset();  // 清除元数据对象

        // 如果关闭前没有错误，则清除错误状态
        if (!had_error_before_close) {
            m_last_error_cache = SqlError();
            m_open_error_flag = false;
        }
        // 如果关闭前有错误，则保留该错误状态
    }

    bool MySqlSpecificDriver::isOpen() const {
        return m_transport_connection && m_transport_connection->isConnected();
    }

    bool MySqlSpecificDriver::isOpenError() const {
        // 如果未打开，并且 m_open_error_flag 为 true，则表示上次打开失败
        return !isOpen() && m_open_error_flag;
    }

    bool MySqlSpecificDriver::ping(int timeout_seconds) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open for ping.", "ping");
            return false;
        }
        std::optional<unsigned int> transport_timeout;
        if (timeout_seconds >= 0) {
            transport_timeout = static_cast<unsigned int>(timeout_seconds);
        }
        bool success = m_transport_connection->ping(transport_timeout);
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    std::unique_ptr<SqlResult> MySqlSpecificDriver::createResult() const {
        return std::make_unique<MySqlSpecificResult>(this);
    }

    SqlError MySqlSpecificDriver::lastError() const {
        return m_last_error_cache;
    }

    SqlValue MySqlSpecificDriver::nativeHandle() const {
        if (m_transport_connection && m_transport_connection->getNativeHandle()) {
            // MYSQL* 是一个不透明指针，将其转换为 void* 存储在 std::any 中
            return SqlValue::fromStdAny(std::any(static_cast<void*>(m_transport_connection->getNativeHandle())));
        }
        return SqlValue();  // 返回一个表示 NULL 的 SqlValue
    }

    cpporm_mysql_transport::MySqlTransportConnection* MySqlSpecificDriver::getTransportConnection() const {
        return m_transport_connection.get();
    }

    // 驱动初始化函数定义
    void MySqlDriver_Initialize() {
        SqlDriverManager::registerDriver("MYSQL",  // This is the key used in DbConfig.driver_type
                                         []() -> std::unique_ptr<ISqlDriver> {
                                             return std::make_unique<MySqlSpecificDriver>();
                                         });
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_driver_feature.cpp
#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For version checks
#include "sqldriver/mysql/mysql_specific_driver.h"

namespace cpporm_sqldriver {

    bool MySqlSpecificDriver::hasFeature(Feature feature) const {
        if (!m_transport_connection) {  // 如果 transport connection 未初始化，则大部分功能不可用
            switch (feature) {
                // 即使没有连接，某些元特性也可能为 true
                case Feature::PositionalPlaceholders:
                    return true;  // MySQL C API 支持 '?'
                // 其他依赖连接状态的特性应返回 false
                default:
                    return false;
            }
        }

        switch (feature) {
            case Feature::Transactions:
                return true;  // MySQL 支持事务 (通常使用 InnoDB 引擎)
            case Feature::QuerySize:
                return true;  // 可以通过 mysql_stmt_num_rows (预处理) 或 mysql_num_rows (非预处理) 获取行数
            case Feature::BLOB:
                return true;  // 支持 BLOB 类型
            case Feature::Unicode:
                return true;  // 假设连接已正确配置为 UTF-8 等
            case Feature::PreparedQueries:
                return true;  // MySQL C API 支持预处理语句
            case Feature::NamedPlaceholders:
                // C API 本身不支持命名占位符，但驱动程序可以通过 SqlResult 层模拟
                // 此处返回 false 表示 C API 层面不支持，模拟是在上层
                return false;
            case Feature::PositionalPlaceholders:
                return true;  // C API 支持 '?'
            case Feature::LastInsertId:
                return true;  // mysql_stmt_insert_id 或 mysql_insert_id
            case Feature::BatchOperations:
                // C API 本身不直接支持批处理的单一函数调用，但可以通过重复执行预处理语句来模拟
                // 返回 false 表示没有单一的、高效的 C API 级批处理。模拟是另一回事。
                return false;
            case Feature::MultipleResultSets:
                return true;  // 支持存储过程返回多个结果集 (mysql_stmt_next_result)
            case Feature::NamedSavepoints:
                return true;  // 支持 SAVEPOINT name, ROLLBACK TO SAVEPOINT name, RELEASE SAVEPOINT name
            case Feature::SchemaOperations:
                return true;  // 可以通过 SHOW DATABASES, SHOW TABLES 等获取
            case Feature::TransactionIsolationLevel:
                return true;  // 支持设置事务隔离级别
            case Feature::PingConnection:
                return true;  // mysql_ping
            case Feature::SimpleScrollOnError:
                // 默认 C API 结果集是仅向前的，除非使用 mysql_stmt_store_result 后进行 data_seek
                return false;
            case Feature::EventNotifications:
                return false;  // 不是标准的 MySQL C API 功能
            case Feature::FinishQuery:
                return true;  // mysql_stmt_free_result / mysql_free_result
            case Feature::LowPrecisionNumbers:
                // MySQL 可以返回高精度数字作为字符串，驱动可以控制此行为
                return true;
            case Feature::CancelQuery:
                // mysql_kill 可以终止连接/查询，但不是通用的取消操作
                return false;
            case Feature::InsertAndReturnId:
                // 通过 LastInsertId 间接支持，没有类似 PostgreSQL 的 RETURNING 子句
                // 许多驱动将此特性标记为 true，因为可以获取 ID
                return true;
            case Feature::ThreadSafe:
                // MySQL C API 本身是线程安全的，如果每个线程使用自己的 MYSQL 句柄
                // 并且 mysql_library_init/end 被正确调用。
                return true;
            case Feature::GetTypeInfo:
                return false;  // 没有直接的 ODBC 风格的 GetTypeInfo
            case Feature::SetQueryTimeout:
                // MySQL C API 有 MYSQL_OPT_READ_TIMEOUT, MYSQL_OPT_WRITE_TIMEOUT
                // 但通常不是针对单个查询的超时，而是套接字操作。
                // MYSQL_STMT_ATTR_UPDATE_MAX_LENGTH 可用于流式结果，但不完全是查询超时。
                // 严格来说，单个语句的执行超时不直接支持。
                return false;
            case Feature::StreamBlob:
                // mysql_stmt_send_long_data 用于发送大数据块
                // 读取 BLOB 通常是获取整个块或使用 mysql_fetch_fields_direct 配合 buffer
                // 直接的流式 API (如 C++ iostream) 需要驱动包装。
                // 如果指 C API 的分块能力，则部分为真。如果指高级流，则为 false。
                return false;  // 假设指高级流
            case Feature::CallableStatements:
                return true;  // 支持 CALL procedure_name(...)
            case Feature::BatchWithErrorDetails:
                // 如果 BatchOperations 为 false，这个也应为 false。
                // 如果模拟批处理，错误细节是每次执行的结果。
                return false;

            case Feature::SequenceOperations:
                if (isOpen() && m_transport_connection) {
                    // MySQL 8.0.0 开始支持原生序列。MariaDB 10.3。
                    unsigned long server_ver_num = m_transport_connection->getServerVersionNumber();
                    // server_ver_num 格式如 80023 for 8.0.23.
                    // 检查是否为 MySQL 8+ 或 MariaDB 10.3+
                    // 这是一个简化的检查，实际可能需要区分 MySQL 和 MariaDB 的版本字符串。
                    // 假设 m_transport_connection->getServerVersionString() 可用于区分。
                    std::string ver_str = m_transport_connection->getServerVersionString();
                    bool is_mariadb = (ver_str.find("MariaDB") != std::string::npos);

                    if (is_mariadb) {
                        // MariaDB: 主版本号 * 10000 + 次版本号 * 100 + 补丁级别
                        // 10.3.0 -> 100300
                        unsigned long mariadb_maj = server_ver_num / 10000;
                        unsigned long mariadb_min = (server_ver_num / 100) % 100;
                        if (mariadb_maj > 10 || (mariadb_maj == 10 && mariadb_min >= 3)) {
                            return true;
                        }
                    } else {                            // Assume MySQL
                        if (server_ver_num >= 80000) {  // MySQL 8.0.0
                            return true;
                        }
                    }
                }
                return false;  // 未连接或版本不支持

            case Feature::UpdatableCursors:
                return false;  // MySQL C API 通常不直接支持可更新游标

            default:
                return false;
        }
    }

    std::string MySqlSpecificDriver::databaseProductVersion() const {
        if (!isOpen() || !m_transport_connection) return "";
        return m_transport_connection->getServerVersionString();
    }

    std::string MySqlSpecificDriver::driverVersion() const {
        // 这应该是驱动程序本身的硬编码版本
        return "CppOrmSqlDriver-MySQL-1.0.3";  // 示例版本
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_driver_metadata.cpp
#include <algorithm>  // For std::sort, std::unique
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For isOpen through driver
#include "cpporm_mysql_transport/mysql_transport_metadata.h"    // 确保 MySqlTransportMetadata 的完整定义可见
#include "sqldriver/mysql/mysql_driver_helper.h"                // For metadata converters
#include "sqldriver/mysql/mysql_specific_driver.h"

namespace cpporm_sqldriver {

    std::vector<std::string> MySqlSpecificDriver::tables(ISqlDriverNs::TableType type, const std::string& schemaFilter, const std::string& tableNameFilter) const {
        if (!isOpen() || !m_transport_metadata) {
            // 如果驱动未打开或元数据对象未初始化，则返回空列表
            // const 方法不应修改 m_last_error_cache，除非它是 mutable
            // 调用者应检查 isOpen() 和/或 lastError()
            return {};
        }
        std::string current_schema = resolveSchemaName(schemaFilter);
        std::optional<std::vector<std::string>> result_opt;

        // 清除之前的错误，因为这是一个新的操作
        m_last_error_cache = SqlError();

        switch (type) {
            case ISqlDriverNs::TableType::Tables:
                result_opt = m_transport_metadata->listTables(current_schema, tableNameFilter);
                break;
            case ISqlDriverNs::TableType::Views:
                result_opt = m_transport_metadata->listViews(current_schema, tableNameFilter);
                break;
            case ISqlDriverNs::TableType::All:  // 获取表和视图
                {
                    std::vector<std::string> all_list;
                    auto tables_opt = m_transport_metadata->listTables(current_schema, tableNameFilter);
                    if (tables_opt) {
                        all_list.insert(all_list.end(), tables_opt->begin(), tables_opt->end());
                    } else {
                        // 如果 listTables 失败，获取错误
                        m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
                        // 如果一个失败，可能不继续尝试获取视图，或者由调用者决定
                    }

                    auto views_opt = m_transport_metadata->listViews(current_schema, tableNameFilter);
                    if (views_opt) {
                        all_list.insert(all_list.end(), views_opt->begin(), views_opt->end());
                    } else if (!tables_opt.has_value()) {  // 如果获取表也失败了
                                                           // 错误已经从 listTables 获取，不再覆盖
                    } else {                               // 表获取成功，但视图获取失败
                        m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
                    }

                    std::sort(all_list.begin(), all_list.end());
                    all_list.erase(std::unique(all_list.begin(), all_list.end()), all_list.end());
                    return all_list;  // 返回组合列表
                }
            case ISqlDriverNs::TableType::SystemTables:
                // MySQL information_schema 可以被视为系统表所在之处
                // 如果 schemaFilter 为空，则可以列出 information_schema 中的表
                if (current_schema.empty() || current_schema == "information_schema") {
                    result_opt = m_transport_metadata->listTables("information_schema", tableNameFilter);
                } else {  // 如果指定了其他 schema，则系统表为空
                    return {};
                }
                break;
            default:  // 其他类型目前不支持
                return {};
        }

        if (result_opt) {
            return *result_opt;
        } else {
            // 如果 result_opt 为空 (std::nullopt)，表示 transport 层操作失败
            // 从 transport metadata 获取错误并转换
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
            return {};
        }
    }

    std::vector<std::string> MySqlSpecificDriver::schemas(const std::string& schemaFilter) const {
        if (!isOpen() || !m_transport_metadata) {
            return {};
        }
        m_last_error_cache = SqlError();  // 清除错误
        auto result_opt = m_transport_metadata->listDatabases(schemaFilter);
        if (result_opt) {
            return *result_opt;
        } else {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
            return {};
        }
    }

    SqlRecord MySqlSpecificDriver::record(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_transport_metadata || tablename.empty()) {
            return SqlRecord();  // 返回空记录
        }
        m_last_error_cache = SqlError();  // 清除错误
        std::string current_schema = resolveSchemaName(schema);

        auto transport_fields_opt = m_transport_metadata->getTableColumns(tablename, current_schema);
        if (transport_fields_opt) {
            return mysql_helper::metasToSqlRecord(*transport_fields_opt);
        } else {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
            return SqlRecord();
        }
    }

    SqlIndex MySqlSpecificDriver::primaryIndex(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_transport_metadata || tablename.empty()) {
            return SqlIndex();  // 返回空索引
        }
        m_last_error_cache = SqlError();  // 清除错误
        std::string current_schema = resolveSchemaName(schema);

        auto transport_pk_opt = m_transport_metadata->getPrimaryIndex(tablename, current_schema);
        if (transport_pk_opt) {
            return mysql_helper::metaToSqlIndex(*transport_pk_opt);
        } else {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
            return SqlIndex();
        }
    }

    std::vector<SqlIndex> MySqlSpecificDriver::indexes(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_transport_metadata || tablename.empty()) {
            return {};
        }
        m_last_error_cache = SqlError();  // 清除错误
        std::string current_schema = resolveSchemaName(schema);

        auto transport_indexes_opt = m_transport_metadata->getTableIndexes(tablename, current_schema);
        if (transport_indexes_opt) {
            return mysql_helper::metasToSqlIndexes(*transport_indexes_opt);
        } else {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_metadata->getLastError());
            return {};
        }
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_driver_transaction.cpp
#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For full type definition
#include "cpporm_mysql_transport/mysql_transport_types.h"       // For TransactionIsolationLevel enum from transport
#include "sqldriver/mysql/mysql_driver_helper.h"                // For enum converters
#include "sqldriver/mysql/mysql_specific_driver.h"

namespace cpporm_sqldriver {

    bool MySqlSpecificDriver::beginTransaction() {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "beginTransaction");
            return false;
        }
        // m_transport_connection is std::unique_ptr<MySqlTransportConnection>
        bool success = m_transport_connection->beginTransaction();
        updateLastErrorCacheFromTransport(success);  // updateLastErrorCacheFromTransport is now const
        return success;
    }

    bool MySqlSpecificDriver::commitTransaction() {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "commitTransaction");
            return false;
        }
        bool success = m_transport_connection->commit();
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    bool MySqlSpecificDriver::rollbackTransaction() {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "rollbackTransaction");
            return false;
        }
        bool success = m_transport_connection->rollback();
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    bool MySqlSpecificDriver::setTransactionIsolationLevel(TransactionIsolationLevel level) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "setTransactionIsolationLevel");
            return false;
        }
        // Use fully qualified name for transport's enum
        ::cpporm_mysql_transport::TransactionIsolationLevel transport_level = mysql_helper::toMySqlTransportIsolationLevel(level);
        bool success = m_transport_connection->setTransactionIsolation(transport_level);
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    TransactionIsolationLevel MySqlSpecificDriver::transactionIsolationLevel() const {
        if (!isOpen() || !m_transport_connection) {  // Added check for m_transport_connection
            return TransactionIsolationLevel::Default;
        }
        // Use fully qualified name for transport's enum
        std::optional<::cpporm_mysql_transport::TransactionIsolationLevel> transport_level_opt = m_transport_connection->getTransactionIsolation();
        if (transport_level_opt) {
            // If querying isolation level itself caused an error in transport, update cache
            // Note: getTransactionIsolation in transport might not set error if it just returns cached.
            // We assume if transport_level_opt is empty, transport layer has an error set.
            updateLastErrorCacheFromTransport(transport_level_opt.has_value());  // Update error based on success of getting level
            return mysql_helper::fromMySqlTransportIsolationLevel(transport_level_opt.value());
        } else {
            updateLastErrorCacheFromTransport(false);   // Getting isolation level failed
            return TransactionIsolationLevel::Default;  // Or some error indicator if possible
        }
    }

    bool MySqlSpecificDriver::setSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "setSavepoint");
            return false;
        }
        bool success = m_transport_connection->setSavepoint(name);
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    bool MySqlSpecificDriver::rollbackToSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "rollbackToSavepoint");
            return false;
        }
        bool success = m_transport_connection->rollbackToSavepoint(name);
        updateLastErrorCacheFromTransport(success);
        return success;
    }

    bool MySqlSpecificDriver::releaseSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection is not open.", "releaseSavepoint");
            return false;
        }
        bool success = m_transport_connection->releaseSavepoint(name);
        updateLastErrorCacheFromTransport(success);
        return success;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_driver_utility.cpp
#include <sstream>  // For sqlStatement

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For full type definition
#include "cpporm_mysql_transport/mysql_transport_types.h"       // For MySqlNativeValue
#include "mysql_protocol/mysql_type_converter.h"                // For MySqlNativeValue definition
#include "sqldriver/mysql/mysql_driver_helper.h"                // For value converters and SQL formatting
#include "sqldriver/mysql/mysql_specific_driver.h"
#include "sqldriver/mysql/mysql_specific_result.h"  // For nextSequenceValue which uses createResult

namespace cpporm_sqldriver {

    std::string MySqlSpecificDriver::formatValue(const SqlValue& value, SqlValueType /*type_hint*/, const SqlField* /*field_meta_hint*/) const {
        if (!m_transport_connection) {
            // 如果没有 transport 连接，进行基本的、不安全的格式化
            if (value.isNull()) return "NULL";
            bool conv_ok = false;
            std::string s_val = value.toString(&conv_ok);  // 尝试转换为字符串
            if (!conv_ok) return "NULL /* CONVERSION ERROR TO STRING */";

            SqlValueType v_type = value.type();
            // 对于字符串和日期时间类型，简单地用单引号包围
            // 注意：这种转义非常不安全，容易受到 SQL 注入攻击
            if (v_type == SqlValueType::String || v_type == SqlValueType::FixedString || v_type == SqlValueType::CharacterLargeObject || v_type == SqlValueType::Json || v_type == SqlValueType::Xml || v_type == SqlValueType::Date || v_type == SqlValueType::Time || v_type == SqlValueType::DateTime ||
                v_type == SqlValueType::Timestamp) {
                std::string temp_s_val;
                temp_s_val.reserve(s_val.length() + 2);
                temp_s_val += '\'';
                for (char c : s_val) {
                    if (c == '\'') temp_s_val += "''";  // 简单的单引号转义
                    // 没有处理反斜杠等其他特殊字符
                    else
                        temp_s_val += c;
                }
                temp_s_val += '\'';
                return temp_s_val + " /* NO_CONN_LITERAL_UNSAFE_ESCAPE */";
            } else if (v_type == SqlValueType::ByteArray || v_type == SqlValueType::BinaryLargeObject) {
                // 对于 BLOB，没有连接无法安全格式化为 X'...'
                return "'BLOB_DATA_UNFORMATTED_NO_CONN_UNSAFE'";
            }
            // 对于数字和布尔值，直接返回字符串形式
            return s_val;
        }
        // 使用 transport 连接进行安全的格式化
        mysql_protocol::MySqlNativeValue native_value = mysql_helper::sqlValueToMySqlNativeValue(value);
        return m_transport_connection->formatNativeValueAsLiteral(native_value);
    }

    std::string MySqlSpecificDriver::escapeIdentifier(const std::string& identifier, IdentifierType /*type*/) const {
        if (!m_transport_connection) {
            // 如果没有 transport 连接，进行基本的、不安全的标识符转义
            if (identifier.empty()) return "``";  // 空标识符
            std::string escaped_id = "`";
            for (char c : identifier) {
                if (c == '`')
                    escaped_id += "``";  // ` 转义为 ``
                else
                    escaped_id += c;
            }
            escaped_id += '`';
            return escaped_id + " /* NO_CONN_BASIC_ESCAPE */";
        }
        // 使用 transport 连接进行安全的标识符转义
        return m_transport_connection->escapeSqlIdentifier(identifier);
    }

    std::string MySqlSpecificDriver::sqlStatement(StatementType type, const std::string& tableName, const SqlRecord& rec, bool prepared, const std::string& schema) const {
        if (tableName.empty()) return "";

        std::string current_schema_resolved = resolveSchemaName(schema);
        std::string fq_table_name_part = escapeIdentifier(tableName, IdentifierType::Table);
        if (!current_schema_resolved.empty()) {
            fq_table_name_part = escapeIdentifier(current_schema_resolved, IdentifierType::Schema) + "." + fq_table_name_part;
        }
        // 注意：上面的 fq_table_name_part 可能已经被反引号包围，再次调用 escapeIdentifier 可能导致双重包围。
        // escapeIdentifier 应该能处理已经被引用的情况，或者这里逻辑调整。
        // 假设 escapeIdentifier 是幂等的或能正确处理。
        // 或者，我们只对未引用的部分调用 escapeIdentifier:
        std::string fq_table_name;
        if (!current_schema_resolved.empty()) {
            fq_table_name = escapeIdentifier(current_schema_resolved, IdentifierType::Schema) + "." + escapeIdentifier(tableName, IdentifierType::Table);
        } else {
            fq_table_name = escapeIdentifier(tableName, IdentifierType::Table);
        }

        std::ostringstream oss;
        switch (type) {
            case StatementType::Select:
                oss << "SELECT ";
                if (rec.isEmpty() || rec.count() == 0) {
                    oss << "*";
                } else {
                    for (int i = 0; i < rec.count(); ++i) {
                        oss << (i > 0 ? ", " : "") << escapeIdentifier(rec.fieldName(i), IdentifierType::Field);
                    }
                }
                oss << " FROM " << fq_table_name;
                // WHERE 子句通常不在这里生成，而是由查询构建器处理
                break;
            case StatementType::Insert:
                {
                    oss << "INSERT INTO " << fq_table_name;
                    if (rec.isEmpty() || rec.count() == 0) {  // 插入默认值
                        oss << " () VALUES ()";               // 或者 " DEFAULT VALUES" 取决于数据库
                    } else {
                        std::string columns_part = " (";
                        std::string values_part = ") VALUES (";
                        bool first_col = true;

                        for (int i = 0; i < rec.count(); ++i) {
                            const SqlField& field = rec.field(i);
                            // 对于 INSERT，通常不应跳过主键，除非它是自动生成的且值为 null
                            if (field.isAutoValue() && field.isPrimaryKeyPart() && field.value().isNull()) {
                                // 如果是自增主键且值为 NULL，则不应包含在列列表和值列表中，让数据库生成
                                continue;
                            }

                            if (!first_col) {
                                columns_part += ", ";
                                values_part += ", ";
                            }
                            columns_part += escapeIdentifier(field.name(), IdentifierType::Field);
                            if (prepared) {
                                values_part += "?";
                            } else {
                                values_part += formatValue(field.value(), field.type(), &field);
                            }
                            first_col = false;
                        }
                        if (first_col) {             // 没有列被添加到语句中（例如，只有一个自增主key）
                            oss << " () VALUES ()";  // MySQL/MariaDB 允许此语法
                        } else {
                            oss << columns_part << values_part << ")";
                        }
                    }
                }
                break;
            case StatementType::Update:
                {
                    oss << "UPDATE " << fq_table_name << " SET ";
                    bool first_set = true;
                    bool has_updatable_column = false;
                    for (int i = 0; i < rec.count(); ++i) {
                        const SqlField& field = rec.field(i);
                        if (field.isPrimaryKeyPart() || field.isReadOnly()) {  // 不更新主键或只读字段
                            continue;
                        }
                        has_updatable_column = true;
                        if (!first_set) oss << ", ";
                        oss << escapeIdentifier(field.name(), IdentifierType::Field) << " = ";
                        if (prepared) {
                            oss << "?";
                        } else {
                            oss << formatValue(field.value(), field.type(), &field);
                        }
                        first_set = false;
                    }
                    if (!has_updatable_column) {  // 没有可更新的列
                        return "";                // 返回空字符串表示无法生成有效的 UPDATE 语句
                    }
                    // WHERE 子句通常不在这里生成
                }
                break;
            case StatementType::Delete:
                oss << "DELETE FROM " << fq_table_name;
                // WHERE 子句通常不在这里生成
                break;
            default:
                return "";  // 不支持的语句类型
        }
        return oss.str();
    }

    bool MySqlSpecificDriver::setClientCharset(const std::string& charsetName) {
        if (!m_transport_connection) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Transport connection not initialized.", "setClientCharset");
            return false;
        }
        bool success = m_transport_connection->setClientCharset(charsetName);
        updateLastErrorCacheFromTransport(success);
        if (success) {
            // 更新缓存的连接参数
            m_current_params_cache.setClientCharset(charsetName);
        }
        return success;
    }

    std::string MySqlSpecificDriver::clientCharset() const {
        if (!isOpen() || !m_transport_connection) {  // 确保连接已打开
            // 如果未连接，从缓存参数中返回
            auto charset_opt_val = m_current_params_cache.clientCharset();
            return charset_opt_val.value_or("");
        }
        std::optional<std::string> charset_opt = m_transport_connection->getClientCharset();
        return charset_opt.value_or("");
    }

    SqlValue MySqlSpecificDriver::nextSequenceValue(const std::string& sequenceName, const std::string& schema) {
        if (!isOpen()) {
            m_last_error_cache = SqlError(ErrorCategory::Connectivity, "Connection not open.", "nextSequenceValue");
            return SqlValue();
        }
        if (sequenceName.empty()) {
            m_last_error_cache = SqlError(ErrorCategory::Syntax, "Sequence name cannot be empty.", "nextSequenceValue");
            return SqlValue();
        }
        if (!hasFeature(Feature::SequenceOperations)) {
            m_last_error_cache = SqlError(ErrorCategory::FeatureNotSupported, "Sequence operations not supported by this driver/database version.", "nextSequenceValue");
            return SqlValue();
        }

        std::string current_schema_resolved = resolveSchemaName(schema);
        std::string fq_seq_name_part = escapeIdentifier(sequenceName, IdentifierType::Sequence);
        if (!current_schema_resolved.empty()) {
            fq_seq_name_part = escapeIdentifier(current_schema_resolved, IdentifierType::Schema) + "." + fq_seq_name_part;
        }
        // 与 sqlStatement 中的 fq_table_name 逻辑类似，确保正确引用
        std::string fq_seq_name;
        if (!current_schema_resolved.empty()) {
            fq_seq_name = escapeIdentifier(current_schema_resolved, IdentifierType::Schema) + "." + escapeIdentifier(sequenceName, IdentifierType::Sequence);
        } else {
            fq_seq_name = escapeIdentifier(sequenceName, IdentifierType::Sequence);
        }

        std::string query_str = "SELECT NEXT VALUE FOR " + fq_seq_name;

        std::unique_ptr<SqlResult> result = createResult();
        if (!result) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Failed to create result object for sequence.", "nextSequenceValue");
            return SqlValue();
        }

        // 使用 SqlResultNs::NamedBindingSyntax::QuestionMark，因为这是简单查询
        if (!result->prepare(query_str, nullptr, SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode::ReadOnly)) {
            m_last_error_cache = result->error();
            return SqlValue();
        }
        if (!result->exec()) {
            m_last_error_cache = result->error();
            return SqlValue();
        }
        SqlRecord temp_rec;  // 缓冲区
        if (result->fetchNext(temp_rec) && temp_rec.count() > 0) {
            m_last_error_cache = SqlError();  // 清除之前的错误
            return temp_rec.value(0);         // 返回序列值
        } else {
            m_last_error_cache = result->error();                           // 获取 fetchNext 或 exec 的错误
            if (m_last_error_cache.category() == ErrorCategory::NoError) {  // 如果没有错误但没有行
                m_last_error_cache = SqlError(ErrorCategory::DataRelated, "Sequence query returned no rows or no value.", "nextSequenceValue", "", 0, query_str);
            }
        }
        return SqlValue();  // 返回空 SqlValue 表示失败
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/mysql/mysql_specific_result.cpp
#include "sqldriver/mysql/mysql_specific_result.h"

#include <stdexcept>  // For std::logic_error

#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportBindParam
#include "sqldriver/mysql/mysql_driver_helper.h"           // For converters and NamedPlaceholderInfo
#include "sqldriver/mysql/mysql_specific_driver.h"

namespace cpporm_sqldriver {

    MySqlSpecificResult::MySqlSpecificResult(const MySqlSpecificDriver* driver)
        : m_driver(driver),
          m_transport_statement(nullptr),
          m_transport_result_set(nullptr),
          m_current_row_index(-1),
          m_num_rows_affected_cache(0),
          m_is_active_flag(false),
          m_precision_policy(NumericalPrecisionPolicy::LowPrecision),  // 直接使用，因为它在 cpporm_sqldriver 命名空间中定义
          m_named_binding_syntax(SqlResultNs::NamedBindingSyntax::Colon),
          m_scroll_mode_hint(SqlResultNs::ScrollMode::ForwardOnly),
          m_prefetch_size_hint(0) {
        if (!m_driver || !m_driver->getTransportConnection()) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "MySqlSpecificResult: Invalid driver or transport connection.", "Constructor");
        }
    }

    MySqlSpecificResult::~MySqlSpecificResult() {
        finish();
    }

    MySqlSpecificResult::MySqlSpecificResult(MySqlSpecificResult&& other) noexcept
        : m_driver(other.m_driver),
          m_transport_statement(std::move(other.m_transport_statement)),
          m_transport_result_set(std::move(other.m_transport_result_set)),
          m_original_query_text(std::move(other.m_original_query_text)),
          m_placeholder_info(std::move(other.m_placeholder_info)),
          m_positional_bind_values(std::move(other.m_positional_bind_values)),
          m_named_bind_values_map(std::move(other.m_named_bind_values_map)),
          m_ordered_transport_bind_params(std::move(other.m_ordered_transport_bind_params)),
          m_current_record_buffer_cache(std::move(other.m_current_record_buffer_cache)),
          m_current_row_index(other.m_current_row_index),
          m_num_rows_affected_cache(other.m_num_rows_affected_cache),
          m_last_insert_id_cache(std::move(other.m_last_insert_id_cache)),
          m_last_error_cache(std::move(other.m_last_error_cache)),
          m_is_active_flag(other.m_is_active_flag),
          m_precision_policy(other.m_precision_policy),
          m_named_binding_syntax(other.m_named_binding_syntax),
          m_scroll_mode_hint(other.m_scroll_mode_hint),
          m_prefetch_size_hint(other.m_prefetch_size_hint) {
        other.m_driver = nullptr;
        other.m_is_active_flag = false;
        other.m_current_row_index = -1;
    }

    MySqlSpecificResult& MySqlSpecificResult::operator=(MySqlSpecificResult&& other) noexcept {
        if (this != &other) {
            finish();  // 清理当前资源

            m_driver = other.m_driver;
            m_transport_statement = std::move(other.m_transport_statement);
            m_transport_result_set = std::move(other.m_transport_result_set);
            m_original_query_text = std::move(other.m_original_query_text);
            m_placeholder_info = std::move(other.m_placeholder_info);
            m_positional_bind_values = std::move(other.m_positional_bind_values);
            m_named_bind_values_map = std::move(other.m_named_bind_values_map);
            m_ordered_transport_bind_params = std::move(other.m_ordered_transport_bind_params);
            m_current_record_buffer_cache = std::move(other.m_current_record_buffer_cache);
            m_current_row_index = other.m_current_row_index;
            m_num_rows_affected_cache = other.m_num_rows_affected_cache;
            m_last_insert_id_cache = std::move(other.m_last_insert_id_cache);
            m_last_error_cache = std::move(other.m_last_error_cache);
            m_is_active_flag = other.m_is_active_flag;
            m_precision_policy = other.m_precision_policy;
            m_named_binding_syntax = other.m_named_binding_syntax;
            m_scroll_mode_hint = other.m_scroll_mode_hint;
            m_prefetch_size_hint = other.m_prefetch_size_hint;

            other.m_driver = nullptr;
            other.m_is_active_flag = false;
            other.m_current_row_index = -1;
        }
        return *this;
    }

    void MySqlSpecificResult::updateLastErrorCacheFromTransportStatement() {
        if (m_transport_statement) {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_statement->getError());
        } else {
            // 只有在之前没有错误时才设置，以避免覆盖更具体的错误
            if (m_last_error_cache.category() == ErrorCategory::NoError) {
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Transport statement is null.", "updateLastErrorCacheFromTransportStatement");
            }
        }
    }

    void MySqlSpecificResult::updateLastErrorCacheFromTransportResult() {
        if (m_transport_result_set) {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_result_set->getError());
        } else if (m_transport_statement && !m_transport_statement->getError().isOk()) {
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_transport_statement->getError());
        } else {
            if (m_last_error_cache.category() == ErrorCategory::NoError) {
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Transport result set is null and no prior statement error.", "updateLastErrorCacheFromTransportResult");
            }
        }
    }

    void MySqlSpecificResult::clearLastErrorCache() {
        m_last_error_cache = SqlError();
    }

    bool MySqlSpecificResult::prepare(const std::string& query, const std::map<std::string, SqlValueType>* /*named_bindings_type_hints*/, SqlResultNs::ScrollMode scroll, SqlResultNs::ConcurrencyMode /*concur*/) {
        if (!m_driver || !m_driver->getTransportConnection()) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Driver or transport connection not available for prepare.", "prepare");
            return false;
        }
        finish();
        clearLastErrorCache();

        m_original_query_text = query;
        m_scroll_mode_hint = scroll;

        if (m_named_binding_syntax != SqlResultNs::NamedBindingSyntax::QuestionMark) {
            m_placeholder_info = mysql_helper::processQueryForPlaceholders(m_original_query_text, m_named_binding_syntax);
        } else {
            m_placeholder_info.processedQuery = m_original_query_text;
            m_placeholder_info.hasNamedPlaceholders = false;
            m_placeholder_info.orderedParamNames.clear();
            m_placeholder_info.nameToIndicesMap.clear();
        }

        m_transport_statement = m_driver->getTransportConnection()->createStatement(m_placeholder_info.processedQuery);
        if (!m_transport_statement) {
            // 假设 MySqlTransportConnection::createStatement 失败时会在连接上设置错误
            m_last_error_cache = mysql_helper::transportErrorToSqlError(m_driver->getTransportConnection()->getLastError());
            if (m_last_error_cache.category() == ErrorCategory::NoError) {  // 如果连接上没有特定错误
                m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Failed to create transport statement.", "prepare");
            }
            return false;
        }

        bool success = m_transport_statement->prepare();
        updateLastErrorCacheFromTransportStatement();
        m_is_active_flag = success;
        return success;
    }

    bool MySqlSpecificResult::applyBindingsToTransportStatement() {
        if (!m_transport_statement || !m_transport_statement->isPrepared()) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Statement not prepared for binding.", "applyBindingsToTransportStatement");
            return false;
        }
        m_ordered_transport_bind_params.clear();

        if (m_placeholder_info.hasNamedPlaceholders) {
            m_ordered_transport_bind_params.reserve(m_placeholder_info.orderedParamNames.size());
            for (const std::string& name : m_placeholder_info.orderedParamNames) {
                auto it = m_named_bind_values_map.find(name);
                if (it == m_named_bind_values_map.end()) {
                    m_last_error_cache = SqlError(ErrorCategory::Syntax, "Named parameter ':" + name + "' used in query but not bound.", "applyBindings");
                    return false;
                }
                m_ordered_transport_bind_params.emplace_back(mysql_helper::sqlValueToMySqlNativeValue(it->second));
            }
        } else {
            m_ordered_transport_bind_params.reserve(m_positional_bind_values.size());
            for (const auto& sql_val : m_positional_bind_values) {
                m_ordered_transport_bind_params.emplace_back(mysql_helper::sqlValueToMySqlNativeValue(sql_val));
            }
        }
        // MySqlTransportBindParam 的构造函数现在接受 MySqlNativeValue
        bool success = m_transport_statement->bindParams(m_ordered_transport_bind_params);
        if (!success) updateLastErrorCacheFromTransportStatement();
        return success;
    }

    bool MySqlSpecificResult::exec() {
        if (!m_transport_statement) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Statement not initialized for exec.", "exec");
            return false;
        }
        if (!m_transport_statement->isPrepared()) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Statement not prepared for exec.", "exec");
            return false;
        }
        cleanupAfterExecution(false);
        clearLastErrorCache();

        if (!applyBindingsToTransportStatement()) {
            return false;
        }

        std::optional<my_ulonglong> affected_opt = m_transport_statement->execute();
        if (affected_opt) {
            m_num_rows_affected_cache = *affected_opt;
            // MySqlTransportStatement::getLastInsertId() 返回 my_ulonglong
            // MySqlNativeValue 构造函数需要能够处理 uint64_t (my_ulonglong 通常是这个类型)
            mysql_protocol::MySqlNativeValue last_id_native;
            last_id_native.data = static_cast<uint64_t>(m_transport_statement->getLastInsertId());
            last_id_native.original_mysql_type = MYSQL_TYPE_LONGLONG;  // 假设 ID 是 LONGLONG
            last_id_native.original_mysql_flags = UNSIGNED_FLAG;       // 通常自增 ID 是无符号的
            m_last_insert_id_cache = mysql_helper::mySqlNativeValueToSqlValue(last_id_native);

            if (m_driver->getTransportConnection()->getNativeHandle() && m_transport_statement->getNativeStatementHandle() &&  // 确保语句句柄有效
                mysql_stmt_field_count(m_transport_statement->getNativeStatementHandle()) > 0) {
                m_transport_result_set = m_transport_statement->executeQuery();
                if (!m_transport_result_set || !m_transport_result_set->isValid()) {
                    updateLastErrorCacheFromTransportResult();
                    m_is_active_flag = false;
                    return false;
                }
            } else {
                m_transport_result_set.reset();
            }
            m_is_active_flag = true;
            return true;
        } else {
            updateLastErrorCacheFromTransportStatement();
            m_is_active_flag = false;
            return false;
        }
    }

    void MySqlSpecificResult::cleanupAfterExecution(bool retain_result_set) {
        m_current_row_index = -1;
        m_current_record_buffer_cache.clear();
        // DML 操作后 m_num_rows_affected_cache 和 m_last_insert_id_cache 应该保留
        // 直到下一次 exec。 cleanupAfterExecution 主要清理结果集相关的状态。
        // 所以，不重置 m_num_rows_affected_cache 和 m_last_insert_id_cache。

        if (!retain_result_set) {
            m_transport_result_set.reset();
        }
    }

    bool MySqlSpecificResult::ensureResultSet() {
        if (m_transport_result_set && m_transport_result_set->isValid()) {
            return true;
        }
        if (m_transport_statement && m_transport_statement->isPrepared() && m_is_active_flag) {
            // 如果语句是活动的，并且没有结果集，尝试执行 executeQuery 获取结果集
            if (m_driver->getTransportConnection()->getNativeHandle() && m_transport_statement->getNativeStatementHandle() && mysql_stmt_field_count(m_transport_statement->getNativeStatementHandle()) > 0) {
                m_transport_result_set = m_transport_statement->executeQuery();
                if (m_transport_result_set && m_transport_result_set->isValid()) {
                    return true;
                } else {
                    updateLastErrorCacheFromTransportResult();
                    return false;
                }
            }
        }
        // 修正 ErrorCategory
        m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "No valid result set available or statement not a query.", "ensureResultSet");
        return false;
    }

    void MySqlSpecificResult::addPositionalBindValue(const SqlValue& value, ParamType /*type*/) {
        m_positional_bind_values.push_back(value);
    }

    void MySqlSpecificResult::setNamedBindValue(const std::string& placeholder, const SqlValue& value, ParamType /*type*/) {
        std::string clean_placeholder = placeholder;
        if (!placeholder.empty() && (placeholder[0] == ':' || placeholder[0] == '@')) {
            clean_placeholder = placeholder.substr(1);
        }
        m_named_bind_values_map[clean_placeholder] = value;
    }

    void MySqlSpecificResult::clearBindValues() {
        m_positional_bind_values.clear();
        m_named_bind_values_map.clear();
        m_ordered_transport_bind_params.clear();
    }

    bool MySqlSpecificResult::fetchNext(SqlRecord& record_buffer) {
        if (!ensureResultSet()) return false;
        clearLastErrorCache();
        record_buffer.clear();

        if (m_transport_result_set->fetchNextRow()) {
            m_current_row_index++;
            const auto& fields_meta_transport = m_transport_result_set->getFieldsMeta();
            for (unsigned int i = 0; i < fields_meta_transport.size(); ++i) {
                SqlField sql_driver_field = mysql_helper::metaToSqlField(fields_meta_transport[i]);
                auto native_val_opt = m_transport_result_set->getValue(i);
                if (native_val_opt) {
                    sql_driver_field.setValue(mysql_helper::mySqlNativeValueToSqlValue(*native_val_opt));
                } else {
                    sql_driver_field.setValue(SqlValue());  // Null
                }
                record_buffer.append(sql_driver_field);
            }
            m_current_record_buffer_cache = record_buffer;
            return true;
        } else {
            updateLastErrorCacheFromTransportResult();
            m_current_row_index = -1;
            m_current_record_buffer_cache.clear();
            return false;
        }
    }

    SqlValue MySqlSpecificResult::data(int column_index) {
        if (!ensureResultSet()) return SqlValue();
        if (m_current_row_index < 0 || column_index < 0 || static_cast<unsigned int>(column_index) >= (m_transport_result_set ? m_transport_result_set->getFieldCount() : 0)) {
            m_last_error_cache = SqlError(ErrorCategory::DataRelated, "Invalid index or no current row for data().", "data");  // 使用 DataRelated
            return SqlValue();
        }
        clearLastErrorCache();
        auto native_val_opt = m_transport_result_set->getValue(static_cast<unsigned int>(column_index));
        if (native_val_opt) {
            return mysql_helper::mySqlNativeValueToSqlValue(*native_val_opt);
        } else {
            updateLastErrorCacheFromTransportResult();
            return SqlValue();
        }
    }

    bool MySqlSpecificResult::isNull(int column_index) {
        if (!ensureResultSet()) return true;
        if (m_current_row_index < 0 || column_index < 0 || static_cast<unsigned int>(column_index) >= (m_transport_result_set ? m_transport_result_set->getFieldCount() : 0)) {
            return true;
        }
        clearLastErrorCache();
        bool is_null_val = m_transport_result_set->isNull(static_cast<unsigned int>(column_index));
        // isNull 本身不太可能在 transport 层产生新错误，除非状态非法
        if (!m_transport_result_set->getError().isOk()) {
            updateLastErrorCacheFromTransportResult();
        }
        return is_null_val;
    }

    SqlRecord MySqlSpecificResult::recordMetadata() const {
        if (m_transport_result_set && m_transport_result_set->isValid()) {
            return mysql_helper::metasToSqlRecord(m_transport_result_set->getFieldsMeta());
        }
        return SqlRecord();
    }

    long long MySqlSpecificResult::numRowsAffected() {
        return static_cast<long long>(m_num_rows_affected_cache);
    }

    SqlValue MySqlSpecificResult::lastInsertId() {
        return m_last_insert_id_cache;
    }

    int MySqlSpecificResult::columnCount() const {
        if (m_transport_result_set && m_transport_result_set->isValid()) {
            return static_cast<int>(m_transport_result_set->getFieldCount());
        }
        return 0;
    }

    int MySqlSpecificResult::size() {
        if (m_transport_result_set && m_transport_result_set->isValid()) {
            return static_cast<int>(m_transport_result_set->getRowCount());
        }
        return -1;
    }

    int MySqlSpecificResult::at() const {
        return static_cast<int>(m_current_row_index);
    }

    bool MySqlSpecificResult::isActive() const {
        return m_is_active_flag;
    }

    bool MySqlSpecificResult::isValid() const {
        // 一个结果集要有效，它必须是活动的，并且 transport 结果集也必须是有效的
        return m_is_active_flag && m_transport_result_set && m_transport_result_set->isValid();
    }

    SqlError MySqlSpecificResult::error() const {
        return m_last_error_cache;
    }

    const std::string& MySqlSpecificResult::lastQuery() const {
        return m_original_query_text;
    }

    const std::string& MySqlSpecificResult::preparedQueryText() const {
        return m_placeholder_info.processedQuery;
    }

    void MySqlSpecificResult::finish() {
        cleanupAfterExecution(false);
        if (m_transport_statement) {
            m_transport_statement->close();
        }
        m_is_active_flag = false;
        m_positional_bind_values.clear();
        m_named_bind_values_map.clear();
        m_ordered_transport_bind_params.clear();
    }
    void MySqlSpecificResult::clear() {
        finish();
        m_original_query_text.clear();
        m_placeholder_info = mysql_helper::NamedPlaceholderInfo();
    }

    bool MySqlSpecificResult::setQueryTimeout(int /*seconds*/) {
        return false;
    }
    bool MySqlSpecificResult::setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) {
        m_precision_policy = policy;
        return true;
    }
    bool MySqlSpecificResult::setPrefetchSize(int rows) {
        m_prefetch_size_hint = rows;
        return false;
    }
    int MySqlSpecificResult::prefetchSize() const {
        return m_prefetch_size_hint;
    }
    void MySqlSpecificResult::bindBlobStream(int /*pos*/, std::shared_ptr<std::istream> /*stream*/, long long /*size*/, ParamType /*type*/) { /* TODO */
    }
    void MySqlSpecificResult::bindBlobStream(const std::string& /*placeholder*/, std::shared_ptr<std::istream> /*stream*/, long long /*size*/, ParamType /*type*/) { /* TODO */
    }
    void MySqlSpecificResult::reset() {
        if (m_transport_statement && m_transport_statement->getNativeStatementHandle()) {
            if (mysql_stmt_reset(m_transport_statement->getNativeStatementHandle()) == 0) {
                cleanupAfterExecution(false);
                m_is_active_flag = m_transport_statement->isPrepared();
                // 清除绑定值，因为 mysql_stmt_reset 后它们不再有效，需要重新绑定
                clearBindValues();
                return;
            } else {
                updateLastErrorCacheFromTransportStatement();
            }
        }
        m_is_active_flag = false;
    }
    bool MySqlSpecificResult::setForwardOnly(bool forward) {
        if (forward) m_scroll_mode_hint = SqlResultNs::ScrollMode::ForwardOnly;
        // 实际的滚动能力取决于MySQL和驱动的实现，通常是仅向前的
        return forward;
    }
    bool MySqlSpecificResult::fetchPrevious(SqlRecord& /*record_buffer*/) {
        // MySQL C API + store_result 后，可以使用 mysql_stmt_data_seek 模拟
        // 但这会增加复杂性。目前返回 false。
        return false;
    }
    bool MySqlSpecificResult::fetchFirst(SqlRecord& /*record_buffer*/) {
        // 同上
        return false;
    }
    bool MySqlSpecificResult::fetchLast(SqlRecord& /*record_buffer*/) {
        // 同上
        return false;
    }
    bool MySqlSpecificResult::fetch(int /*index*/, SqlRecord& /*record_buffer*/, CursorMovement /*movement*/) {
        // 同上
        return false;
    }
    std::shared_ptr<std::istream> MySqlSpecificResult::openReadableBlobStream(int /*column_index*/) {
        return nullptr;
    }
    std::shared_ptr<std::ostream> MySqlSpecificResult::openWritableBlobStream(int /*column_index*/, long long /*initial_size_hint*/) {
        return nullptr;
    }
    SqlRecord MySqlSpecificResult::currentFetchedRow() const {
        return m_current_record_buffer_cache;
    }
    SqlField MySqlSpecificResult::field(int column_index) const {
        if (m_transport_result_set && m_transport_result_set->isValid()) {
            auto transport_field_meta_opt = m_transport_result_set->getFieldMeta(static_cast<unsigned int>(column_index));
            if (transport_field_meta_opt) {
                return mysql_helper::metaToSqlField(*transport_field_meta_opt);
            }
        }
        return SqlField();
    }

    bool MySqlSpecificResult::nextResult() {
        if (!m_transport_statement || !m_transport_statement->getNativeStatementHandle()) {
            m_last_error_cache = SqlError(ErrorCategory::DriverInternal, "Statement handle not available for nextResult.", "nextResult");
            return false;
        }
        cleanupAfterExecution(false);
        clearLastErrorCache();

        int status = mysql_stmt_next_result(m_transport_statement->getNativeStatementHandle());
        if (status == 0) {             // 更多结果存在
            m_current_row_index = -1;  // 重置行索引
            m_num_rows_affected_cache = mysql_stmt_affected_rows(m_transport_statement->getNativeStatementHandle());
            // 检查这个新结果集是否有列
            if (m_driver->getTransportConnection()->getNativeHandle() && mysql_stmt_field_count(m_transport_statement->getNativeStatementHandle()) > 0) {
                m_transport_result_set = m_transport_statement->executeQuery();  // 这会获取新的元数据和结果
                if (!m_transport_result_set || !m_transport_result_set->isValid()) {
                    updateLastErrorCacheFromTransportResult();
                    m_is_active_flag = false;
                    return false;
                }
            } else {
                m_transport_result_set.reset();  // 这个结果没有列 (例如，存储过程中的 DML 语句)
            }
            m_is_active_flag = true;
            return true;
        } else if (status == -1) {  // 没有更多结果了
            m_is_active_flag = false;
            // 检查 mysql_stmt_errno 是否为0，以确认这确实是 "no more results" 而不是一个错误
            if (mysql_stmt_errno(m_transport_statement->getNativeStatementHandle()) != 0) {
                updateLastErrorCacheFromTransportStatement();  // 如果有错误，则更新
            }
            return false;
        } else {  // 出错 (status > 0)
            updateLastErrorCacheFromTransportStatement();
            m_is_active_flag = false;
            return false;
        }
    }
    SqlValue MySqlSpecificResult::getOutParameter(int /*pos*/) const {
        return SqlValue();
    }
    SqlValue MySqlSpecificResult::getOutParameter(const std::string& /*name*/) const {
        return SqlValue();
    }
    std::map<std::string, SqlValue> MySqlSpecificResult::getAllOutParameters() const {
        return {};
    }

    bool MySqlSpecificResult::setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) {
        m_named_binding_syntax = syntax;
        return true;
    }

}  // namespace cpporm_sqldriver#include <mysql/mysql.h>  // For MYSQL_TYPE_* constants and UNSIGNED_FLAG, BINARY_FLAG etc.

#include "sqldriver/mysql/mysql_driver_helper.h"

namespace cpporm_sqldriver {
    namespace mysql_helper {

        SqlValueType mySqlColumnTypeToSqlValueType(int mysql_col_type_id, unsigned int mysql_flags) {
            // mysql_col_type_id 是来自 MYSQL_FIELD::type (enum_field_types)
            // mysql_flags 是来自 MYSQL_FIELD::flags
            switch (mysql_col_type_id) {
                case MYSQL_TYPE_DECIMAL:
                case MYSQL_TYPE_NEWDECIMAL:
                    return SqlValueType::Decimal;  // SqlValue 应能处理Decimal，可能作为字符串或特定类型

                case MYSQL_TYPE_TINY:
                    return (mysql_flags & UNSIGNED_FLAG) ? SqlValueType::UInt8 : SqlValueType::Int8;

                case MYSQL_TYPE_SHORT:
                    return (mysql_flags & UNSIGNED_FLAG) ? SqlValueType::UInt16 : SqlValueType::Int16;

                case MYSQL_TYPE_LONG:  // 通常是32位整数
                    return (mysql_flags & UNSIGNED_FLAG) ? SqlValueType::UInt32 : SqlValueType::Int32;

                case MYSQL_TYPE_FLOAT:
                    return SqlValueType::Float;

                case MYSQL_TYPE_DOUBLE:
                    return SqlValueType::Double;

                case MYSQL_TYPE_NULL:  // 通常表示结果集中的 NULL 值，而不是列本身的类型
                    return SqlValueType::Null;

                case MYSQL_TYPE_TIMESTAMP:          // 通常映射到 DateTime
                    return SqlValueType::DateTime;  // 或者 Timestamp，取决于 SqlValue 的语义

                case MYSQL_TYPE_LONGLONG:  // 64位整数
                    return (mysql_flags & UNSIGNED_FLAG) ? SqlValueType::UInt64 : SqlValueType::Int64;

                case MYSQL_TYPE_INT24:  // 中等整数，通常也作为32位整数处理
                    return (mysql_flags & UNSIGNED_FLAG) ? SqlValueType::UInt32 : SqlValueType::Int32;

                case MYSQL_TYPE_DATE:
                case MYSQL_TYPE_NEWDATE:  // 内部类型，通常作为 DATE 返回
                    return SqlValueType::Date;

                case MYSQL_TYPE_TIME:
                    return SqlValueType::Time;

                case MYSQL_TYPE_DATETIME:
                    return SqlValueType::DateTime;

                case MYSQL_TYPE_YEAR:            // YEAR 类型可以存为 smallint
                    return SqlValueType::Int16;  // 或 UInt16，取决于 SqlValue 的偏好

                case MYSQL_TYPE_VARCHAR:
                case MYSQL_TYPE_VAR_STRING:  // 旧的 VARCHAR
                    return SqlValueType::String;

                case MYSQL_TYPE_BIT:
                    // BIT(1) 通常用于布尔值
                    // BIT(M) 当 M > 1 时，通常作为二进制数据或整数处理
                    // 假设 MySqlTransportFieldMeta::length 存储了 M
                    // 如果长度为1，可以映射为 Bool。否则，可能是 UInt64 或 ByteArray。
                    // 这里简单处理为 UInt64，更精确的需要 transportMeta.length
                    return SqlValueType::UInt64;  // 或 ByteArray，或 Bool

                case MYSQL_TYPE_JSON:
                    return SqlValueType::Json;  // SqlValue 需要能处理JSON，可能通过字符串

                case MYSQL_TYPE_ENUM:
                case MYSQL_TYPE_SET:
                    return SqlValueType::String;  // ENUM 和 SET 通常作为字符串返回

                case MYSQL_TYPE_TINY_BLOB:
                case MYSQL_TYPE_MEDIUM_BLOB:
                case MYSQL_TYPE_LONG_BLOB:
                case MYSQL_TYPE_BLOB:
                    // 需要区分 TEXT 类型 (CharacterLargeObject) 和真正的 BLOB (BinaryLargeObject)
                    // 如果 flags 中没有 BINARY_FLAG，且字符集不是 binary，则可能是 TEXT 类的
                    // 这是一个启发式方法，更准确的判断可能需要字符集信息 (MYSQL_FIELD::charsetnr)
                    if (mysql_flags & BINARY_FLAG) {             // 如果明确是二进制
                        return SqlValueType::BinaryLargeObject;  // 或 ByteArray
                    } else {
                        // 检查是否是 TEXT 变体 (TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT)
                        // 这些类型在元数据中 flags 可能没有 BINARY_FLAG，但有 BLOB_FLAG
                        // 并且它们的字符集不是 binary collation
                        // 这里简化：如果不是明确的 BINARY，且是 BLOB 类，则可能是 CLOB
                        // TODO: 这里的区分需要更精确的逻辑，可能依赖 MySqlTransportFieldMeta::charsetnr
                        bool is_text_heuristic =
                            ((mysql_col_type_id == MYSQL_TYPE_TINY_BLOB && (mysql_flags & BLOB_FLAG) && !(mysql_flags & BINARY_FLAG) /* && charsetnr is not binary */) || (mysql_col_type_id == MYSQL_TYPE_BLOB && (mysql_flags & BLOB_FLAG) && !(mysql_flags & BINARY_FLAG) /* && ... */) ||
                             (mysql_col_type_id == MYSQL_TYPE_MEDIUM_BLOB && (mysql_flags & BLOB_FLAG) && !(mysql_flags & BINARY_FLAG) /* && ... */) || (mysql_col_type_id == MYSQL_TYPE_LONG_BLOB && (mysql_flags & BLOB_FLAG) && !(mysql_flags & BINARY_FLAG) /* && ... */));
                        if (is_text_heuristic) {  // 这是一个粗略的判断
                            return SqlValueType::CharacterLargeObject;
                        }
                        return SqlValueType::BinaryLargeObject;  // 默认是二进制大对象
                    }

                case MYSQL_TYPE_STRING:                    // 包括 CHAR, BINARY
                    if (mysql_flags & BINARY_FLAG) {       // BINARY(M)
                        return SqlValueType::ByteArray;    // 或者 FixedString 如果需要区分
                    } else {                               // CHAR(M)
                        return SqlValueType::FixedString;  // 或 String
                    }

                case MYSQL_TYPE_GEOMETRY:
                    return SqlValueType::ByteArray;  // Geometry 类型通常作为 WKB (二进制) 返回

                default:
                    return SqlValueType::Unknown;  // 未知或不直接映射的 MySQL 类型
            }
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver#include <mysql/mysql.h>  // For MYSQL_TIME and ::MYSQL_TYPE_ constants

#include <chrono>  // For std::chrono conversions

#include "sqldriver/mysql/mysql_driver_helper.h"

namespace cpporm_sqldriver {
    namespace mysql_helper {

        mysql_protocol::MySqlNativeValue sqlValueToMySqlNativeValue(const SqlValue& value) {
            mysql_protocol::MySqlNativeValue native_value;  // 默认构造为 monostate (NULL)
            native_value.original_mysql_type = ::MYSQL_TYPE_NULL;
            bool conversion_successful = true;  // 跟踪 SqlValue -> C++类型的转换是否成功

            if (value.isNull()) {
                return native_value;  // 已是 NULL
            }

            switch (value.type()) {
                case SqlValueType::Bool:
                    native_value.data = value.toBool(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_TINY;
                    break;
                case SqlValueType::Int8:
                    native_value.data = value.toInt8(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_TINY;
                    break;
                case SqlValueType::UInt8:
                    native_value.data = value.toUInt8(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_TINY;
                    native_value.original_mysql_flags = UNSIGNED_FLAG;
                    break;
                case SqlValueType::Int16:
                    native_value.data = value.toInt16(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_SHORT;
                    break;
                case SqlValueType::UInt16:
                    native_value.data = value.toUInt16(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_SHORT;
                    native_value.original_mysql_flags = UNSIGNED_FLAG;
                    break;
                case SqlValueType::Int32:
                    native_value.data = value.toInt32(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_LONG;
                    break;
                case SqlValueType::UInt32:
                    native_value.data = value.toUInt32(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_LONG;
                    native_value.original_mysql_flags = UNSIGNED_FLAG;
                    break;
                case SqlValueType::Int64:
                    native_value.data = value.toInt64(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_LONGLONG;
                    break;
                case SqlValueType::UInt64:
                    native_value.data = value.toUInt64(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_LONGLONG;
                    native_value.original_mysql_flags = UNSIGNED_FLAG;
                    break;
                case SqlValueType::Float:
                    native_value.data = value.toFloat(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_FLOAT;
                    break;
                case SqlValueType::Double:
                    native_value.data = value.toDouble(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_DOUBLE;
                    break;
                case SqlValueType::String:
                case SqlValueType::FixedString:           // MySQL中通常作为 CHAR/VARCHAR 处理
                case SqlValueType::CharacterLargeObject:  // MySQL中作为 TEXT 类型处理，绑定时为字符串
                    native_value.data = value.toString(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_VAR_STRING;  // 或更具体的 TEXT 类型
                    break;
                case SqlValueType::ByteArray:
                case SqlValueType::BinaryLargeObject:
                    native_value.data = value.toStdVectorUChar(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_BLOB;
                    break;
                case SqlValueType::Date:
                    {
                        SqlValue::ChronoDate cd = value.toChronoDate(&conversion_successful);
                        if (conversion_successful) {
                            // mysql_protocol::yearMonthDayToMySqlDate 应返回 std::expected<MYSQL_TIME, MySqlProtocolError>
                            auto mt_expected = mysql_protocol::yearMonthDayToMySqlDate(cd);
                            if (mt_expected.has_value()) {
                                native_value.data = mt_expected.value();
                                native_value.original_mysql_type = ::MYSQL_TYPE_DATE;
                            } else {
                                conversion_successful = false;  // 标记协议层转换失败
                            }
                        }
                        break;
                    }
                case SqlValueType::Time:
                    {
                        SqlValue::ChronoTime ct_ns = value.toChronoTime(&conversion_successful);  // SqlValue 返回纳秒
                        if (conversion_successful) {
                            auto ct_us = std::chrono::duration_cast<std::chrono::microseconds>(ct_ns);  // MySQL TIME 通常用微秒
                            auto mt_expected = mysql_protocol::durationToMySqlTime(ct_us);
                            if (mt_expected.has_value()) {
                                native_value.data = mt_expected.value();
                                native_value.original_mysql_type = ::MYSQL_TYPE_TIME;
                            } else {
                                conversion_successful = false;
                            }
                        }
                        break;
                    }
                case SqlValueType::DateTime:
                case SqlValueType::Timestamp:
                    {  // MySQL TIMESTAMP 和 DATETIME 在绑定时通常类似
                        SqlValue::ChronoDateTime cdt = value.toChronoDateTime(&conversion_successful);
                        if (conversion_successful) {
                            auto mt_expected = mysql_protocol::systemClockTimePointToMySqlTime(cdt, ::MYSQL_TYPE_DATETIME);
                            if (mt_expected.has_value()) {
                                native_value.data = mt_expected.value();
                                native_value.original_mysql_type = ::MYSQL_TYPE_DATETIME;
                            } else {
                                conversion_successful = false;
                            }
                        }
                        break;
                    }
                case SqlValueType::Decimal:
                case SqlValueType::Numeric:
                    // MySQL 的 DECIMAL/NUMERIC 类型在 C API 中通常作为字符串进行绑定和检索
                    native_value.data = value.toString(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_NEWDECIMAL;
                    break;
                case SqlValueType::Json:
                    // MySQL JSON 类型在 C API 中作为字符串绑定
                    native_value.data = value.toString(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_JSON;
                    break;
                case SqlValueType::Xml:  // MySQL XML 类型也可能作为字符串处理
                    native_value.data = value.toString(&conversion_successful);
                    native_value.original_mysql_type = ::MYSQL_TYPE_VAR_STRING;  // 或者特定的XML类型（如果MySQL C API支持）
                    break;
                case SqlValueType::Interval:  // MySQL 不直接支持 INTERVAL 类型的绑定，通常构造字符串
                case SqlValueType::Array:     // MySQL 不直接支持 ARRAY 类型的绑定
                case SqlValueType::RowId:     // MySQL 没有通用的 RowId 类型
                case SqlValueType::Custom:
                case SqlValueType::Unknown:
                default:
                    conversion_successful = false;  // 不支持或未知类型
                    // TODO: Log a warning for unsupported SqlValueType
                    break;
            }

            if (!conversion_successful && !value.isNull()) {
                // 如果 SqlValue 非空，但转换失败，则将 native_value 重置为 NULL
                // 这确保我们不会发送一个部分转换或无效的数据
                native_value.data = std::monostate{};
                native_value.original_mysql_type = ::MYSQL_TYPE_NULL;
                native_value.original_mysql_flags = 0;
                // TODO: Log a warning about conversion failure for a non-null SqlValue
            }

            return native_value;
        }

        SqlValue mySqlNativeValueToSqlValue(const mysql_protocol::MySqlNativeValue& nativeValue) {
            if (nativeValue.is_null()) {
                return SqlValue();  // SqlValue 默认构造为 null
            }

            // 使用 std::visit 或一系列的 std::get_if 来处理 std::variant
            if (const bool* val = std::get_if<bool>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const int8_t* val = std::get_if<int8_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const uint8_t* val = std::get_if<uint8_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const int16_t* val = std::get_if<int16_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const uint16_t* val = std::get_if<uint16_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const int32_t* val = std::get_if<int32_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const uint32_t* val = std::get_if<uint32_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const int64_t* val = std::get_if<int64_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const uint64_t* val = std::get_if<uint64_t>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const float* val = std::get_if<float>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const double* val = std::get_if<double>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const std::string* val = std::get_if<std::string>(&nativeValue.data)) {
                // 对于字符串，可以根据 nativeValue.original_mysql_type 提供类型提示给 SqlValue
                // 假设 SqlValue 构造函数可以接受 (const std::string&, SqlValueType type_hint)
                // SqlValueType hint = mySqlColumnTypeToSqlValueType(nativeValue.original_mysql_type, nativeValue.original_mysql_flags);
                // return SqlValue(*val, hint);
                return SqlValue(*val);  // 简单版本
            } else if (const std::vector<unsigned char>* val = std::get_if<std::vector<unsigned char>>(&nativeValue.data)) {
                return SqlValue(*val);
            } else if (const MYSQL_TIME* mt_ptr = std::get_if<MYSQL_TIME>(&nativeValue.data)) {
                const MYSQL_TIME& mt = *mt_ptr;
                // 使用 mysql_protocol 中的辅助函数将 MYSQL_TIME 转换为 std::chrono 类型
                switch (mt.time_type) {
                    case MYSQL_TIMESTAMP_DATE:
                        {
                            auto ymd_expected = mysql_protocol::mySqlTimeToYearMonthDay(mt);
                            if (ymd_expected.has_value()) {
                                return SqlValue(ymd_expected.value());
                            }
                            // TODO: Log protocol conversion error: ymd_expected.error().message
                            break;
                        }
                    case MYSQL_TIMESTAMP_TIME:
                        {
                            auto dur_expected = mysql_protocol::mySqlTimeToDuration(mt);  // 返回 std::chrono::microseconds
                            if (dur_expected.has_value()) {
                                // SqlValue 需要能从 std::chrono::microseconds 或 std::chrono::nanoseconds 构造 Time 类型
                                return SqlValue(std::chrono::duration_cast<SqlValue::ChronoTime>(dur_expected.value()));
                            }
                            // TODO: Log protocol conversion error
                            break;
                        }
                    case MYSQL_TIMESTAMP_DATETIME:
                    case MYSQL_TIMESTAMP_DATETIME_TZ:
                        {  // SqlValue 通常不处理时区，依赖 UTC 或本地时间
                            auto tp_expected = mysql_protocol::mySqlTimeToSystemClockTimePoint(mt);
                            if (tp_expected.has_value()) {
                                return SqlValue(tp_expected.value());
                            }
                            // TODO: Log protocol conversion error
                            break;
                        }
                    default:
                        // TODO: Log unhandled MYSQL_TIME type_type
                        break;
                }
            }

            // 如果没有匹配的类型或转换失败
            // TODO: Log a warning: "Failed to convert MySqlNativeValue (original type: "
            //       << nativeValue.original_mysql_type << ") to SqlValue."
            return SqlValue();  // 返回一个表示 null 的 SqlValue
        }

    }  // namespace mysql_helper
}  // namespace cpporm_sqldriver// Source/sql_connection_parameters.cpp
#include "sqldriver/sql_connection_parameters.h"

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // 定义静态常量成员
    const std::string ConnectionParameters::KEY_DRIVER_TYPE = "driver_type";
    const std::string ConnectionParameters::KEY_DB_NAME = "db_name";
    const std::string ConnectionParameters::KEY_USER_NAME = "user_name";
    const std::string ConnectionParameters::KEY_PASSWORD = "password";
    const std::string ConnectionParameters::KEY_HOST_NAME = "host_name";
    const std::string ConnectionParameters::KEY_PORT = "port";
    const std::string ConnectionParameters::KEY_CONNECT_OPTIONS = "connect_options";
    const std::string ConnectionParameters::KEY_CLIENT_CHARSET = "client_charset";
    const std::string ConnectionParameters::KEY_APPLICATION_NAME = "application_name";
    const std::string ConnectionParameters::KEY_CONNECTION_TIMEOUT_SECONDS = "connection_timeout_seconds";
    const std::string ConnectionParameters::KEY_READ_TIMEOUT_SECONDS = "read_timeout_seconds";
    const std::string ConnectionParameters::KEY_WRITE_TIMEOUT_SECONDS = "write_timeout_seconds";
    const std::string ConnectionParameters::KEY_SSL_MODE = "ssl_mode";
    const std::string ConnectionParameters::KEY_SSL_CERT_PATH = "ssl_cert_path";
    const std::string ConnectionParameters::KEY_SSL_KEY_PATH = "ssl_key_path";
    const std::string ConnectionParameters::KEY_SSL_CA_PATH = "ssl_ca_path";
    const std::string ConnectionParameters::KEY_SSL_CIPHER = "ssl_cipher";
    const std::string ConnectionParameters::KEY_POOL_MAX_SIZE = "pool_max_size";
    const std::string ConnectionParameters::KEY_POOL_MIN_SIZE = "pool_min_size";
    const std::string ConnectionParameters::KEY_POOL_ACQUIRE_TIMEOUT_MS = "pool_acquire_timeout_ms";
    const std::string ConnectionParameters::KEY_POOL_CONNECTION_LIFETIME_MS = "pool_connection_lifetime_ms";
    const std::string ConnectionParameters::KEY_POOL_IDLE_TIMEOUT_MS = "pool_idle_timeout_ms";

    // Setters (实现)
    void ConnectionParameters::setDriverType(const std::string& v) {
        (*this)[KEY_DRIVER_TYPE] = SqlValue(v);
    }
    void ConnectionParameters::setDbName(const std::string& v) {
        (*this)[KEY_DB_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setUserName(const std::string& v) {
        (*this)[KEY_USER_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setPassword(const std::string& v) {
        (*this)[KEY_PASSWORD] = SqlValue(v);
    }
    void ConnectionParameters::setHostName(const std::string& v) {
        (*this)[KEY_HOST_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setPort(int v) {
        (*this)[KEY_PORT] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setConnectOptions(const std::string& v) {
        (*this)[KEY_CONNECT_OPTIONS] = SqlValue(v);
    }
    void ConnectionParameters::setClientCharset(const std::string& v) {
        (*this)[KEY_CLIENT_CHARSET] = SqlValue(v);
    }
    void ConnectionParameters::setApplicationName(const std::string& v) {
        (*this)[KEY_APPLICATION_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setConnectionTimeoutSeconds(int v) {
        (*this)[KEY_CONNECTION_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setReadTimeoutSeconds(int v) {
        (*this)[KEY_READ_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setWriteTimeoutSeconds(int v) {
        (*this)[KEY_WRITE_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setSslMode(const std::string& v) {
        (*this)[KEY_SSL_MODE] = SqlValue(v);
    }
    void ConnectionParameters::setSslCertPath(const std::string& v) {
        (*this)[KEY_SSL_CERT_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslKeyPath(const std::string& v) {
        (*this)[KEY_SSL_KEY_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslCaPath(const std::string& v) {
        (*this)[KEY_SSL_CA_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslCipher(const std::string& v) {
        (*this)[KEY_SSL_CIPHER] = SqlValue(v);
    }
    void ConnectionParameters::setPoolMaxSize(int v) {
        (*this)[KEY_POOL_MAX_SIZE] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setPoolMinSize(int v) {
        (*this)[KEY_POOL_MIN_SIZE] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setPoolAcquireTimeoutMs(long long v) {
        (*this)[KEY_POOL_ACQUIRE_TIMEOUT_MS] = SqlValue(static_cast<int64_t>(v));
    }
    void ConnectionParameters::setPoolConnectionLifetimeMs(long long v) {
        (*this)[KEY_POOL_CONNECTION_LIFETIME_MS] = SqlValue(static_cast<int64_t>(v));
    }
    void ConnectionParameters::setPoolIdleTimeoutMs(long long v) {
        (*this)[KEY_POOL_IDLE_TIMEOUT_MS] = SqlValue(static_cast<int64_t>(v));
    }

    // Getters (实现 - 使用模板的 get<T>)
    std::optional<std::string> ConnectionParameters::driverType() const {
        return get<std::string>(KEY_DRIVER_TYPE);
    }
    std::optional<std::string> ConnectionParameters::dbName() const {
        return get<std::string>(KEY_DB_NAME);
    }
    std::optional<std::string> ConnectionParameters::userName() const {
        return get<std::string>(KEY_USER_NAME);
    }
    std::optional<std::string> ConnectionParameters::password() const {
        return get<std::string>(KEY_PASSWORD);
    }
    std::optional<std::string> ConnectionParameters::hostName() const {
        return get<std::string>(KEY_HOST_NAME);
    }
    std::optional<int> ConnectionParameters::port() const {
        return get<int>(KEY_PORT);
    }
    std::optional<std::string> ConnectionParameters::connectOptions() const {
        return get<std::string>(KEY_CONNECT_OPTIONS);
    }
    std::optional<std::string> ConnectionParameters::clientCharset() const {
        return get<std::string>(KEY_CLIENT_CHARSET);
    }
    std::optional<std::string> ConnectionParameters::applicationName() const {
        return get<std::string>(KEY_APPLICATION_NAME);
    }
    std::optional<int> ConnectionParameters::connectionTimeoutSeconds() const {
        return get<int>(KEY_CONNECTION_TIMEOUT_SECONDS);
    }
    std::optional<int> ConnectionParameters::readTimeoutSeconds() const {
        return get<int>(KEY_READ_TIMEOUT_SECONDS);
    }
    std::optional<int> ConnectionParameters::writeTimeoutSeconds() const {
        return get<int>(KEY_WRITE_TIMEOUT_SECONDS);
    }
    std::optional<std::string> ConnectionParameters::sslMode() const {
        return get<std::string>(KEY_SSL_MODE);
    }
    std::optional<std::string> ConnectionParameters::sslCertPath() const {
        return get<std::string>(KEY_SSL_CERT_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslKeyPath() const {
        return get<std::string>(KEY_SSL_KEY_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslCaPath() const {
        return get<std::string>(KEY_SSL_CA_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslCipher() const {
        return get<std::string>(KEY_SSL_CIPHER);
    }
    std::optional<int> ConnectionParameters::poolMaxSize() const {
        return get<int>(KEY_POOL_MAX_SIZE);
    }
    std::optional<int> ConnectionParameters::poolMinSize() const {
        return get<int>(KEY_POOL_MIN_SIZE);
    }
    std::optional<long long> ConnectionParameters::poolAcquireTimeoutMs() const {
        return get<long long>(KEY_POOL_ACQUIRE_TIMEOUT_MS);
    }
    std::optional<long long> ConnectionParameters::poolConnectionLifetimeMs() const {
        return get<long long>(KEY_POOL_CONNECTION_LIFETIME_MS);
    }
    std::optional<long long> ConnectionParameters::poolIdleTimeoutMs() const {
        return get<long long>(KEY_POOL_IDLE_TIMEOUT_MS);
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_database_connection.cpp
#include "sqldriver/i_sql_driver.h"  // For ISqlDriver methods
#include "sqldriver/sql_connection_parameters.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"

namespace cpporm_sqldriver {

    // Helper function implementation (if not already in a common place or header)
    void SqlDatabase::updateLastErrorFromDriver() const {
        if (m_driver) {
            m_last_error = m_driver->lastError();
        } else {
            // If driver is null, it's an internal error with SqlDatabase setup
            m_last_error = SqlError(ErrorCategory::DriverInternal, "Internal driver instance is null.", "updateLastErrorFromDriver");
        }
    }

    // --- Connection Management ---
    bool SqlDatabase::open(const ConnectionParameters& params) {
        if (!m_driver) {
            if (m_last_error.category() == ErrorCategory::NoError) {  // Only set if no prior error from constructor
                m_last_error = SqlError(ErrorCategory::DriverInternal, "Driver not loaded.", "SqlDatabase::open");
            }
            return false;
        }
        if (m_driver->isOpen()) {
            m_driver->close();  // Close before re-opening with new/current parameters
        }
        m_parameters = params;  // Store/update the parameters for this open attempt
        bool success = m_driver->open(m_parameters);
        updateLastErrorFromDriver();
        // m_transaction_active was removed; transaction state is now on the driver
        return success;
    }

    bool SqlDatabase::open() {
        if (!m_driver) {
            if (m_last_error.category() == ErrorCategory::NoError) {
                m_last_error = SqlError(ErrorCategory::DriverInternal, "Driver not loaded.", "SqlDatabase::open");
            }
            return false;
        }
        // Use current stored m_parameters.
        // If m_parameters is empty and driver is not already open, this might use driver defaults or fail.
        if (m_parameters.empty() && !m_driver->isOpen()) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Cannot open: connection parameters not set and not already open.", "SqlDatabase::open");
            return false;
        }
        // Calls the overload: open(const ConnectionParameters&)
        return open(m_parameters);
    }

    bool SqlDatabase::open(const std::string& user, const std::string& password) {
        if (!m_driver) {
            if (m_last_error.category() == ErrorCategory::NoError) {
                m_last_error = SqlError(ErrorCategory::DriverInternal, "Driver not loaded.", "SqlDatabase::open");
            }
            return false;
        }
        ConnectionParameters temp_params = m_parameters;  // Copy current parameters
        temp_params.setUserName(user);
        temp_params.setPassword(password);
        return open(temp_params);  // Call overload with modified parameters
    }

    void SqlDatabase::close() {
        if (m_driver && m_driver->isOpen()) {
            m_driver->close();
            updateLastErrorFromDriver();  // Get any error that occurred during close
        }
        // m_transaction_active was removed
    }

    bool SqlDatabase::isOpen() const {
        return m_driver && m_driver->isOpen();
    }

    bool SqlDatabase::isValid() const {
        // A valid SqlDatabase must have a non-null (shared) ISqlDriver instance
        return m_driver != nullptr;
    }

    bool SqlDatabase::ping(int timeout_seconds) {
        if (!isOpen()) {  // Use the public isOpen() which checks m_driver && m_driver->isOpen()
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection is not open to ping.", "SqlDatabase::ping");
            return false;
        }
        // m_driver is guaranteed to be non-null here due to isOpen() check
        bool success = m_driver->ping(timeout_seconds);
        updateLastErrorFromDriver();
        return success;
    }

    // --- Charset ---
    bool SqlDatabase::setClientCharset(const std::string& charsetName) {
        if (!m_driver) {
            m_last_error = SqlError(ErrorCategory::DriverInternal, "Driver not loaded.", "SqlDatabase::setClientCharset");
            return false;
        }
        // ISqlDriver::setClientCharset should handle whether it's pre- or post-connection.
        bool success = m_driver->setClientCharset(charsetName);
        updateLastErrorFromDriver();
        if (success) {
            m_parameters.setClientCharset(charsetName);  // Update cached parameters
        }
        return success;
    }

    std::string SqlDatabase::clientCharset() const {
        if (!m_driver) return "";
        // If connected, query the driver. Otherwise, return cached parameter.
        if (isOpen()) {
            return m_driver->clientCharset();
        } else {
            return m_parameters.clientCharset().value_or("");
        }
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_database_lifecycle.cpp
#include <utility>  // For std::move

#include "sqldriver/i_sql_driver.h"  // For ISqlDriver methods
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"  // For SqlError

namespace cpporm_sqldriver {

    // Constructor for SqlDriverManager
    SqlDatabase::SqlDatabase(const std::string& driverTypeName,
                             const std::string& assignedConnectionName,
                             std::shared_ptr<ISqlDriver> driverImplementation)  // Changed to shared_ptr
        : m_driver_type_name(driverTypeName),
          m_connection_name(assignedConnectionName),
          m_driver(std::move(driverImplementation)),  // Take ownership of the shared_ptr
          m_parameters(),
          m_last_error()
    // m_transaction_active removed
    {
        if (!m_driver) {
            m_last_error = SqlError(ErrorCategory::DriverInternal, "Driver for type '" + m_driver_type_name + "' not loaded or failed to instantiate.", "SqlDatabase initialization", "", 0, "Connection: " + m_connection_name);
        }
    }

    SqlDatabase::~SqlDatabase() {
        // The shared_ptr m_driver will manage the ISqlDriver's lifetime.
        // If this is the last SqlDatabase object holding a reference to the driver,
        // and the driver is open, its destructor (or ISqlDriver's close) should handle closing.
        // Explicitly calling close() here might be redundant or interfere if other shared owners exist.
        // However, if a SqlDatabase instance itself logically "closes" its view of the connection:
        // if (m_driver && m_driver->isOpen()) {
        //    m_driver->close(); // This would affect all sharers.
        // }
        // For simplicity now, let shared_ptr handle ISqlDriver destruction, which should call its close.
    }

    // Copy constructor
    SqlDatabase::SqlDatabase(const SqlDatabase& other)
        : m_driver_type_name(other.m_driver_type_name),
          m_connection_name(other.m_connection_name),
          m_driver(other.m_driver),  // Copy the shared_ptr (increments ref count)
          m_parameters(other.m_parameters),
          m_last_error(other.m_last_error)
    // m_transaction_active removed
    {
    }

    // Copy assignment
    SqlDatabase& SqlDatabase::operator=(const SqlDatabase& other) {
        if (this != &other) {
            m_driver_type_name = other.m_driver_type_name;
            m_connection_name = other.m_connection_name;
            m_driver = other.m_driver;  // Assign shared_ptr
            m_parameters = other.m_parameters;
            m_last_error = other.m_last_error;
            // m_transaction_active removed
        }
        return *this;
    }

    // Move constructor
    SqlDatabase::SqlDatabase(SqlDatabase&& other) noexcept
        : m_driver_type_name(std::move(other.m_driver_type_name)),
          m_connection_name(std::move(other.m_connection_name)),
          m_driver(std::move(other.m_driver)),  // Move shared_ptr
          m_parameters(std::move(other.m_parameters)),
          m_last_error(std::move(other.m_last_error))
    // m_transaction_active removed
    {
    }

    // Move assignment
    SqlDatabase& SqlDatabase::operator=(SqlDatabase&& other) noexcept {
        if (this != &other) {
            m_driver_type_name = std::move(other.m_driver_type_name);
            m_connection_name = std::move(other.m_connection_name);
            m_driver = std::move(other.m_driver);  // Move shared_ptr
            m_parameters = std::move(other.m_parameters);
            m_last_error = std::move(other.m_last_error);
            // m_transaction_active removed
        }
        return *this;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_database_metadata_features.cpp
#include <vector>  // For std::vector return types

#include "sqldriver/i_sql_driver.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_enums.h"  // For Feature, ISqlDriverNs::TableType
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_index.h"
#include "sqldriver/sql_record.h"
#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // --- 元数据访问 ---
    std::vector<std::string> SqlDatabase::tables(ISqlDriverNs::TableType type, const std::string& schemaFilter, const std::string& tableNameFilter) const {
        if (!isOpen() || !m_driver) {  // 增加对 m_driver 的检查
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available.", "SqlDatabase::tables");
            return {};
        }
        auto result = m_driver->tables(type, schemaFilter, tableNameFilter);
        updateLastErrorFromDriver();
        return result;
    }

    std::vector<std::string> SqlDatabase::schemas(const std::string& schemaFilter) const {
        if (!isOpen() || !m_driver) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available.", "SqlDatabase::schemas");
            return {};
        }
        auto result = m_driver->schemas(schemaFilter);
        updateLastErrorFromDriver();
        return result;
    }

    SqlRecord SqlDatabase::record(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_driver) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available.", "SqlDatabase::record");
            return SqlRecord();
        }
        auto result = m_driver->record(tablename, schema);
        updateLastErrorFromDriver();
        return result;
    }

    SqlIndex SqlDatabase::primaryIndex(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_driver) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available.", "SqlDatabase::primaryIndex");
            return SqlIndex();
        }
        auto result = m_driver->primaryIndex(tablename, schema);
        updateLastErrorFromDriver();
        return result;
    }

    std::vector<SqlIndex> SqlDatabase::indexes(const std::string& tablename, const std::string& schema) const {
        if (!isOpen() || !m_driver) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available.", "SqlDatabase::indexes");
            return {};
        }
        auto result = m_driver->indexes(tablename, schema);
        updateLastErrorFromDriver();
        return result;
    }

    // --- 特性支持和版本信息 ---
    bool SqlDatabase::hasFeature(Feature feature) const {
        if (!m_driver) return false;
        return m_driver->hasFeature(feature);
    }

    SqlValue SqlDatabase::nativeHandle() const {
        if (!isOpen() || !m_driver) return SqlValue();
        return m_driver->nativeHandle();
    }

    std::string SqlDatabase::databaseProductVersion() const {
        if (!isOpen() || !m_driver) return "";
        return m_driver->databaseProductVersion();
    }

    std::string SqlDatabase::driverVersion() const {
        if (!m_driver) return "";  // 如果没有驱动，返回空
        return m_driver->driverVersion();
    }

    // --- 序列 ---
    SqlValue SqlDatabase::nextSequenceValue(const std::string& sequenceName, const std::string& schema) {
        if (!isOpen() || !m_driver) {  // 增加对 m_driver 的检查
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open or driver not available for nextSequenceValue.", "SqlDatabase::nextSequenceValue");
            return SqlValue();
        }
        SqlValue val = m_driver->nextSequenceValue(sequenceName, schema);
        updateLastErrorFromDriver();
        return val;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_database_properties.cpp
#include "sqldriver/i_sql_driver.h"
#include "sqldriver/sql_connection_parameters.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // --- 连接属性 ---
    std::string SqlDatabase::driverName() const {
        return m_driver_type_name;
    }

    std::string SqlDatabase::databaseName() const {
        return m_parameters.dbName().value_or("");
    }

    void SqlDatabase::setDatabaseName(const std::string& name) {
        m_parameters.setDbName(name);
        // 如果已连接，某些驱动可能允许更改当前数据库，但这里只更新参数
    }

    std::string SqlDatabase::userName() const {
        return m_parameters.userName().value_or("");
    }

    void SqlDatabase::setUserName(const std::string& name) {
        m_parameters.setUserName(name);
    }

    std::string SqlDatabase::password() const {
        // 通常不直接返回密码，但如果API需要
        return m_parameters.password().value_or("");
    }

    void SqlDatabase::setPassword(const std::string& password) {
        m_parameters.setPassword(password);
    }

    std::string SqlDatabase::hostName() const {
        return m_parameters.hostName().value_or("");
    }

    void SqlDatabase::setHostName(const std::string& host) {
        m_parameters.setHostName(host);
    }

    int SqlDatabase::port() const {
        return m_parameters.port().value_or(-1);
    }

    void SqlDatabase::setPort(int port) {
        m_parameters.setPort(port);
    }

    std::string SqlDatabase::connectOptionsString() const {
        return m_parameters.connectOptions().value_or("");
    }

    void SqlDatabase::setConnectOptionsString(const std::string& options) {
        m_parameters.setConnectOptions(options);
    }

    const ConnectionParameters& SqlDatabase::connectionParameters() const {
        return m_parameters;
    }

    void SqlDatabase::setConnectionParameter(const std::string& key, const SqlValue& value) {
        m_parameters[key] = value;  // 直接使用 map 的 operator[]
    }

    SqlValue SqlDatabase::connectionParameter(const std::string& key) const {
        auto it = m_parameters.find(key);
        if (it != m_parameters.end()) {
            return it->second;
        }
        return SqlValue();  // 返回表示 NULL 的 SqlValue
    }

    SqlError SqlDatabase::lastError() const {
        return m_last_error;
    }

    ISqlDriver* SqlDatabase::driver() const {
        return m_driver.get();
    }

    std::string SqlDatabase::connectionName() const {
        return m_connection_name;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_database_transaction.cpp
#include "sqldriver/i_sql_driver.h"  // For ISqlDriver methods
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_enums.h"  // For TransactionIsolationLevel
#include "sqldriver/sql_error.h"

namespace cpporm_sqldriver {

    // --- Transaction Management ---
    bool SqlDatabase::transaction() {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open for transaction.", "SqlDatabase::transaction");
            return false;
        }
        // ISqlDriver itself might track active transaction, or we query.
        // For simplicity, if driver's beginTransaction succeeds, we assume active.
        // If driver allows querying active state, that's more robust.
        if (m_driver->hasFeature(Feature::Transactions) && m_driver->beginTransaction()) {
            updateLastErrorFromDriver();  // Update error even on success if driver sets warnings
            return true;
        }
        updateLastErrorFromDriver();
        if (m_last_error.category() == ErrorCategory::NoError && m_driver->hasFeature(Feature::Transactions)) {
            // If beginTransaction returned false but no error was set by driver,
            // it might mean transaction was already active or feature not fully supported in context.
            m_last_error = SqlError(ErrorCategory::Transaction, "beginTransaction call returned false without specific driver error.", "SqlDatabase::transaction");
        } else if (!m_driver->hasFeature(Feature::Transactions)) {
            m_last_error = SqlError(ErrorCategory::FeatureNotSupported, "Transactions not supported by driver.", "SqlDatabase::transaction");
        }
        return false;
    }

    bool SqlDatabase::commit() {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open for commit.", "SqlDatabase::commit");
            return false;
        }
        // Query driver for active transaction before attempting commit
        // This requires ISqlDriver to have an isTransactionActive() method.
        // For now, assume commitTransaction will fail if no tx active.
        if (!m_driver->hasFeature(Feature::Transactions)) {
            m_last_error = SqlError(ErrorCategory::FeatureNotSupported, "Transactions not supported by driver.", "SqlDatabase::commit");
            return false;
        }
        bool success = m_driver->commitTransaction();
        updateLastErrorFromDriver();
        return success;
    }

    bool SqlDatabase::rollback() {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open for rollback.", "SqlDatabase::rollback");
            return false;
        }
        if (!m_driver->hasFeature(Feature::Transactions)) {
            m_last_error = SqlError(ErrorCategory::FeatureNotSupported, "Transactions not supported by driver.", "SqlDatabase::rollback");
            return false;
        }
        bool success = m_driver->rollbackTransaction();
        updateLastErrorFromDriver();
        return success;
    }

    bool SqlDatabase::isTransactionActive() const {
        // This method now directly queries the driver if possible.
        // Requires ISqlDriver to have a method like `isTransactionActive() const`.
        // If ISqlDriver doesn't have it, SqlDatabase cannot reliably know without its own tracking.
        // Assuming ISqlDriver provides this:
        // if (m_driver && m_driver->isOpen() && m_driver->hasFeature(Feature::Transactions)) {
        //     return m_driver->isTransactionActive(); // Hypothetical ISqlDriver method
        // }
        // For now, if m_transaction_active was removed, we can't implement this accurately
        // without adding the method to ISqlDriver.
        // A fallback (less accurate): return true if beginTransaction was called and no commit/rollback since.
        // But SqlDatabase no longer tracks m_transaction_active.
        // This method now reflects the underlying C-API state if driver provides it.
        // For MySQL, `mysql_get_server_status(m_mysql_handle) & SERVER_STATUS_IN_TRANS`
        // We need to abstract this into ISqlDriver.
        // For now, this is a placeholder, as ISqlDriver does not have isTransactionActive().
        // In a real scenario, the driver implementation (e.g., MySqlSpecificDriver)
        // would query its native handle. SqlDatabase would call that.
        if (m_driver && m_driver->isOpen() && m_driver->hasFeature(Feature::Transactions)) {
            // Simulate querying the driver (needs actual ISqlDriver method)
            // This is a stub. Actual implementation would be in the specific driver.
            // For example, MySqlSpecificDriver would check MYSQL status.
            // For simplicity here, we can't determine it perfectly.
            // The `is_explicit_transaction_handle_` in Session becomes more important.
        }
        return false;  // Placeholder: cannot determine without ISqlDriver::isTransactionActive()
    }

    bool SqlDatabase::setTransactionIsolationLevel(TransactionIsolationLevel level) {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Connectivity, "Connection not open to set isolation level.", "SqlDatabase::setTransactionIsolationLevel");
            return false;
        }
        bool success = m_driver->setTransactionIsolationLevel(level);
        updateLastErrorFromDriver();
        return success;
    }

    TransactionIsolationLevel SqlDatabase::transactionIsolationLevel() const {
        if (!isOpen() || !m_driver) {
            return TransactionIsolationLevel::Default;
        }
        return m_driver->transactionIsolationLevel();
    }

    bool SqlDatabase::setSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Transaction, "Connection not open or no active transaction for setSavepoint.", "SqlDatabase::setSavepoint");
            return false;
        }
        bool success = m_driver->setSavepoint(name);
        updateLastErrorFromDriver();
        return success;
    }

    bool SqlDatabase::rollbackToSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Transaction, "Connection not open or no active transaction for rollbackToSavepoint.", "SqlDatabase::rollbackToSavepoint");
            return false;
        }
        bool success = m_driver->rollbackToSavepoint(name);
        updateLastErrorFromDriver();
        return success;
    }

    bool SqlDatabase::releaseSavepoint(const std::string& name) {
        if (!isOpen()) {
            m_last_error = SqlError(ErrorCategory::Transaction, "Connection not open or no active transaction for releaseSavepoint.", "SqlDatabase::releaseSavepoint");
            return false;
        }
        bool success = m_driver->releaseSavepoint(name);
        updateLastErrorFromDriver();
        return success;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_driver_manager.cpp
#include "sqldriver/sql_driver_manager.h"

#include <map>
#include <memory>  // For std::shared_ptr and std::unique_ptr (factory can still return unique_ptr)
#include <mutex>
#include <stdexcept>  // For std::runtime_error if needed

#include "sqldriver/i_sql_driver.h"
#include "sqldriver/sql_connection_parameters.h"  // For ConnectionParameters in database() if needed
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"

namespace cpporm_sqldriver {

    // --- Static Data Accessor ---
    SqlDriverManager::ManagerData& SqlDriverManager::data() {
        static ManagerData manager_data;  // C++11 guarantees thread-safe initialization
        return manager_data;
    }

    // --- Connection Management ---
    SqlDatabase SqlDriverManager::addDatabase(const std::string& driverType, const std::string& connectionName) {
        DriverFactory factory_to_call = nullptr;
        {  // Scope for lock
            std::lock_guard<std::mutex> lock(data().managerMutex);
            auto& factories = data().driverFactories;
            auto factory_it = factories.find(driverType);

            if (factory_it == factories.end()) {
                // Driver type not registered, return SqlDatabase that will be invalid
                // SqlDatabase constructor will set an error if driverInstance is null
                return SqlDatabase(driverType, connectionName, nullptr);  // Pass nullptr shared_ptr
            }
            factory_to_call = factory_it->second;  // Get the factory
        }  // Mutex released here

        std::unique_ptr<ISqlDriver> unique_driver_instance = nullptr;  // Factory returns unique_ptr
        if (factory_to_call) {
            try {
                unique_driver_instance = factory_to_call();  // Call factory outside the lock
            } catch (const std::exception& /*e*/) {
                // Factory call threw an exception. driverInstance remains nullptr.
                // Optionally log here: some_logging_system("Driver factory for " + driverType + " threw: " + e.what());
            } catch (...) {
                // Catch all for other potential issues from factory.
            }
        }

        // Convert unique_ptr to shared_ptr for SqlDatabase
        std::shared_ptr<ISqlDriver> shared_driver_instance = std::move(unique_driver_instance);

        if (!shared_driver_instance) {
            // Factory failed to create driver instance or factory_to_call was null after lock release.
            return SqlDatabase(driverType, connectionName, nullptr);  // Pass nullptr shared_ptr
        }

        return SqlDatabase(driverType, connectionName, std::move(shared_driver_instance));
    }

    SqlDatabase SqlDriverManager::database(const std::string& connectionName, bool open) {
        std::string driverTypeToUse;
        DriverFactory factory_to_call = nullptr;

        {  // Scope for lock
            std::lock_guard<std::mutex> lock(data().managerMutex);
            auto& factories = data().driverFactories;

            if (connectionName == defaultConnectionName()) {
                if (!factories.empty()) {
                    driverTypeToUse = factories.begin()->first;
                    factory_to_call = factories.begin()->second;
                } else {
                    // No drivers registered, cannot create default connection
                    return SqlDatabase("NoDriversRegistered", connectionName, nullptr);
                }
            } else {
                // For non-default connection names, if `connectionName` is intended to be a `driverType`.
                auto factory_it = factories.find(connectionName);
                if (factory_it != factories.end()) {
                    driverTypeToUse = factory_it->first;
                    factory_to_call = factory_it->second;
                } else {
                    // Cannot determine driver type for this connectionName.
                    return SqlDatabase("UnknownDriverForConnectionName", connectionName, nullptr);
                }
            }
        }  // Mutex released

        std::unique_ptr<ISqlDriver> unique_driver_instance = nullptr;
        if (factory_to_call) {
            try {
                unique_driver_instance = factory_to_call();
            } catch (...) { /* Factory failed */
            }
        } else {
            // This case means factory_to_call was null after lock release.
            return SqlDatabase(driverTypeToUse.empty() ? "UnknownDriver" : driverTypeToUse, connectionName, nullptr);
        }

        std::shared_ptr<ISqlDriver> shared_driver_instance = std::move(unique_driver_instance);
        SqlDatabase db(driverTypeToUse, connectionName, std::move(shared_driver_instance));

        if (open && db.isValid()) {
            // SqlDatabase::open() will use its internally stored m_parameters.
            // If these are empty, it depends on the driver's default behavior.
            db.open();
        }
        return db;
    }

    void SqlDriverManager::removeDatabase(const std::string& /*connectionName*/) {
        // In the current design where SqlDriverManager doesn't manage active SqlDatabase
        // instances or named configurations (beyond factories by driver type), this method
        // is largely conceptual. If it were to remove a configuration for a 'connectionName',
        // that would require storing such configurations.
        // For now, it's a no-op concerning active connections, as Session owns its SqlDatabase.
        std::lock_guard<std::mutex> lock(data().managerMutex);
        // If 'data().namedConnectionParams' or similar existed, one would erase from it here.
    }

    bool SqlDriverManager::contains(const std::string& connectionName) {
        // This checks if a driver factory exists for the given name (if treated as driverType)
        // or if it's the default name and any driver is registered.
        // It does NOT check if an active SqlDatabase instance with this name exists.
        std::lock_guard<std::mutex> lock(data().managerMutex);
        if (connectionName == defaultConnectionName()) {
            return !data().driverFactories.empty();
        }
        return data().driverFactories.count(connectionName) > 0;
    }

    // --- Driver Information ---
    std::vector<std::string> SqlDriverManager::drivers() {
        std::lock_guard<std::mutex> lock(data().managerMutex);
        std::vector<std::string> driver_names;
        driver_names.reserve(data().driverFactories.size());
        for (const auto& pair : data().driverFactories) {
            driver_names.push_back(pair.first);
        }
        return driver_names;
    }

    bool SqlDriverManager::isDriverAvailable(const std::string& driverType) {
        std::lock_guard<std::mutex> lock(data().managerMutex);
        return data().driverFactories.count(driverType) > 0;
    }

    std::string SqlDriverManager::defaultConnectionName() {
        std::lock_guard<std::mutex> lock(data().managerMutex);  // Ensure consistent access pattern to data()
        return data().defaultConnName;
    }

    // --- Driver Registration ---
    bool SqlDriverManager::registerDriver(const std::string& driverName, DriverFactory factory) {
        if (driverName.empty() || !factory) {
            return false;
        }
        std::lock_guard<std::mutex> lock(data().managerMutex);
        data().driverFactories[driverName] = std::move(factory);
        return true;
    }

    void SqlDriverManager::unregisterDriver(const std::string& driverName) {
        std::lock_guard<std::mutex> lock(data().managerMutex);
        data().driverFactories.erase(driverName);
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_error.cpp
#include "sqldriver/sql_error.h"

#include <string>  // For std::to_string

namespace cpporm_sqldriver {

    SqlError::SqlError() : category_(ErrorCategory::NoError), legacy_type_(ErrorType::NoError), native_error_code_num_(0) {
    }

    SqlError::SqlError(ErrorCategory category, const std::string& databaseText, const std::string& driverText, const std::string& nativeErrorCodeStr, int nativeDbCodeNumeric, const std::string& failedQuery, const std::string& constraintName, const std::optional<int>& errorOffset)
        : category_(category), database_text_(databaseText), driver_text_(driverText), native_error_code_str_(nativeErrorCodeStr), native_error_code_num_(nativeDbCodeNumeric), failed_query_(failedQuery), constraint_name_(constraintName), error_offset_(errorOffset) {
        // Automatically set legacy_type_ based on category_ for basic compatibility
        switch (category_) {
            case ErrorCategory::NoError:
                legacy_type_ = ErrorType::NoError;
                break;
            case ErrorCategory::Connectivity:
                legacy_type_ = ErrorType::ConnectionError;
                break;
            case ErrorCategory::Syntax:
                legacy_type_ = ErrorType::StatementError;
                break;  // Or UnknownError
            case ErrorCategory::Constraint:
                legacy_type_ = ErrorType::ConstraintViolationError;
                break;  // Or StatementError
            case ErrorCategory::Permissions:
                legacy_type_ = ErrorType::ConnectionError;
                break;  // Or StatementError
            case ErrorCategory::DataRelated:
                legacy_type_ = ErrorType::DataError;
                break;
            case ErrorCategory::Resource:
                legacy_type_ = ErrorType::UnknownError;
                break;  // Or StatementError
            case ErrorCategory::Transaction:
                legacy_type_ = ErrorType::TransactionError;
                break;
            case ErrorCategory::DriverInternal:
                legacy_type_ = ErrorType::UnknownError;
                break;
            case ErrorCategory::DatabaseInternal:
                legacy_type_ = ErrorType::UnknownError;
                break;
            case ErrorCategory::OperationCancelled:
                legacy_type_ = ErrorType::UnknownError;
                break;
            case ErrorCategory::FeatureNotSupported:
                legacy_type_ = ErrorType::FeatureNotSupportedError;
                break;
            default:
                legacy_type_ = ErrorType::UnknownError;
                break;
        }
    }

    ErrorCategory SqlError::category() const {
        return category_;
    }

    ErrorType SqlError::type() const {
        // Return the legacy type. Could also dynamically map from category_ if preferred.
        return legacy_type_;
    }

    std::string SqlError::databaseText() const {
        return database_text_;
    }

    std::string SqlError::driverText() const {
        return driver_text_;
    }

    std::string SqlError::text() const {
        // Combine driver and database text for a comprehensive message
        if (!driver_text_.empty() && !database_text_.empty()) {
            if (driver_text_ == database_text_) return driver_text_;
            return driver_text_ + " (Database: " + database_text_ + ")";
        }
        if (!driver_text_.empty()) {
            return driver_text_;
        }
        return database_text_;
    }

    std::string SqlError::nativeErrorCode() const {
        return native_error_code_str_;
    }

    int SqlError::nativeErrorCodeNumeric() const {
        return native_error_code_num_;
    }

    std::string SqlError::failedQuery() const {
        return failed_query_;
    }
    std::string SqlError::constraintName() const {
        return constraint_name_;
    }
    std::optional<int> SqlError::errorOffsetInQuery() const {
        return error_offset_;
    }

    bool SqlError::isValid() const {
        return category_ != ErrorCategory::NoError;
    }

    void SqlError::setCategory(ErrorCategory category) {
        category_ = category;
        // Optionally re-map legacy_type_ here if needed
    }

    void SqlError::setType(ErrorType type) {
        legacy_type_ = type;
        // Optionally, try to map back to a category_ if this is the primary setter
    }

    void SqlError::setDatabaseText(const std::string& text) {
        database_text_ = text;
    }

    void SqlError::setDriverText(const std::string& text) {
        driver_text_ = text;
    }

    void SqlError::setNativeErrorCode(const std::string& code) {
        native_error_code_str_ = code;
    }

    void SqlError::setNativeErrorCodeNumeric(int code) {
        native_error_code_num_ = code;
    }

    void SqlError::setFailedQuery(const std::string& query) {
        failed_query_ = query;
    }
    void SqlError::setConstraintName(const std::string& name) {
        constraint_name_ = name;
    }
    void SqlError::setErrorOffsetInQuery(const std::optional<int>& offset) {
        error_offset_ = offset;
    }

    void SqlError::clear() {
        category_ = ErrorCategory::NoError;
        legacy_type_ = ErrorType::NoError;
        database_text_.clear();
        driver_text_.clear();
        native_error_code_str_.clear();
        native_error_code_num_ = 0;
        failed_query_.clear();
        constraint_name_.clear();
        error_offset_ = std::nullopt;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_field.cpp
#include "sqldriver/sql_field.h"

namespace cpporm_sqldriver {

    // --- Constructors ---
    SqlField::SqlField(const std::string& name, SqlValueType type, const std::string& db_type_name)
        : m_name(name),
          m_value(),  // Default constructs to null SqlValue
          m_type_enum(type),
          m_database_type_name(db_type_name),
          m_driver_type_id(0),  // Default driver type ID
          m_length(-1),         // Unspecified
          m_precision(-1),      // Unspecified
          m_scale(-1),          // Unspecified
          m_required_status(RequiredStatus::Unknown),
          m_is_auto_value(false),
          m_is_read_only(false),
          m_default_value(),  // Default constructs to null SqlValue
          m_is_generated(false),
          m_is_primary_key_part(false),
          m_is_foreign_key_part(false),
          m_is_expression(false)
    // optionals are default constructed to std::nullopt
    {
    }

    SqlField::~SqlField() = default;

    // --- Copy and Move semantics ---
    SqlField::SqlField(const SqlField& other) = default;  // Use default for all members
    SqlField& SqlField::operator=(const SqlField& other) = default;
    SqlField::SqlField(SqlField&& other) noexcept = default;
    SqlField& SqlField::operator=(SqlField&& other) noexcept = default;

    // --- Basic Properties ---
    std::string SqlField::name() const {
        return m_name;
    }
    void SqlField::setName(const std::string& name) {
        m_name = name;
    }

    SqlValue SqlField::value() const {
        return m_value;
    }
    void SqlField::setValue(const SqlValue& value) {
        m_value = value;
    }
    void SqlField::clearValue() {
        m_value.clear();
    }  // Or m_value = SqlValue();
    bool SqlField::isNullInValue() const {
        return m_value.isNull();
    }

    // --- Type Information ---
    SqlValueType SqlField::type() const {
        return m_type_enum;
    }
    void SqlField::setType(SqlValueType type) {
        m_type_enum = type;
    }

    std::string SqlField::databaseTypeName() const {
        return m_database_type_name;
    }
    void SqlField::setDatabaseTypeName(const std::string& name) {
        m_database_type_name = name;
    }

    int SqlField::driverType() const {
        return m_driver_type_id;
    }
    void SqlField::setDriverType(int typeId) {
        m_driver_type_id = typeId;
    }

    // --- Size and Precision ---
    int SqlField::length() const {
        return m_length;
    }
    void SqlField::setLength(int len) {
        m_length = len;
    }

    int SqlField::precision() const {
        return m_precision;
    }
    void SqlField::setPrecision(int prec) {
        m_precision = prec;
    }

    int SqlField::scale() const {
        return m_scale;
    }
    void SqlField::setScale(int s) {
        m_scale = s;
    }

    // --- Constraints and Attributes ---
    RequiredStatus SqlField::requiredStatus() const {
        return m_required_status;
    }
    void SqlField::setRequiredStatus(RequiredStatus status) {
        m_required_status = status;
    }

    bool SqlField::isAutoValue() const {
        return m_is_auto_value;
    }
    void SqlField::setAutoValue(bool autoVal) {
        m_is_auto_value = autoVal;
    }

    bool SqlField::isReadOnly() const {
        return m_is_read_only;
    }
    void SqlField::setReadOnly(bool ro) {
        m_is_read_only = ro;
    }

    SqlValue SqlField::defaultValue() const {
        return m_default_value;
    }
    void SqlField::setDefaultValue(const SqlValue& value) {
        m_default_value = value;
    }

    // --- Status flags ---
    bool SqlField::isValid() const {
        // A field is minimally valid if it has a name. Other checks could be added.
        return !m_name.empty();
    }

    bool SqlField::isGenerated() const {
        return m_is_generated;
    }
    void SqlField::setGenerated(bool generated) {
        m_is_generated = generated;
    }

    // --- Key Information ---
    bool SqlField::isPrimaryKeyPart() const {
        return m_is_primary_key_part;
    }
    void SqlField::setPrimaryKeyPart(bool is_pk) {
        m_is_primary_key_part = is_pk;
    }

    bool SqlField::isForeignKeyPart() const {
        return m_is_foreign_key_part;
    }
    void SqlField::setForeignKeyPart(bool is_fk) {
        m_is_foreign_key_part = is_fk;
    }

    // --- Foreign Key Details ---
    std::optional<std::string> SqlField::referencedTableName() const {
        return m_referenced_table_name;
    }
    void SqlField::setReferencedTableName(const std::optional<std::string>& name) {
        m_referenced_table_name = name;
    }
    std::optional<std::string> SqlField::referencedColumnName() const {
        return m_referenced_column_name;
    }
    void SqlField::setReferencedColumnName(const std::optional<std::string>& name) {
        m_referenced_column_name = name;
    }

    // --- Collation ---
    std::optional<std::string> SqlField::collationName() const {
        return m_collation_name;
    }
    void SqlField::setCollationName(const std::optional<std::string>& name) {
        m_collation_name = name;
    }

    // --- Expression/Alias Information ---
    bool SqlField::isExpression() const {
        return m_is_expression;
    }
    void SqlField::setIsExpression(bool is_expr) {
        m_is_expression = is_expr;
    }
    std::optional<std::string> SqlField::aliasName() const {
        return m_alias_name;
    }
    void SqlField::setAliasName(const std::optional<std::string>& alias) {
        m_alias_name = alias;
    }

    // --- Origin Information ---
    std::optional<std::string> SqlField::baseTableName() const {
        return m_base_table_name;
    }
    void SqlField::setBaseTableName(const std::optional<std::string>& name) {
        m_base_table_name = name;
    }
    std::optional<std::string> SqlField::baseColumnName() const {
        return m_base_column_name;
    }
    void SqlField::setBaseColumnName(const std::optional<std::string>& name) {
        m_base_column_name = name;
    }
    std::optional<std::string> SqlField::baseSchemaName() const {
        return m_base_schema_name;
    }
    void SqlField::setBaseSchemaName(const std::optional<std::string>& name) {
        m_base_schema_name = name;
    }

    // --- Generic metadata ---
    std::any SqlField::metaData() const {
        return m_custom_meta_data;
    }
    void SqlField::setMetaData(const std::any& data) {
        m_custom_meta_data = data;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_index.cpp
#include "sqldriver/sql_index.h"

namespace cpporm_sqldriver {

    SqlIndex::SqlIndex(const std::string& name, const std::string& tableName, const std::string& schemaName)
        : m_name(name),
          m_table_name(tableName),
          m_schema_name(schemaName),
          m_is_unique(false),
          m_is_primary_key(false),
          m_is_functional(false),
          m_type_method("BTREE")  // Common default
    {
    }

    SqlIndex::~SqlIndex() = default;

    // --- Copy and Move semantics ---
    SqlIndex::SqlIndex(const SqlIndex& other) = default;
    SqlIndex& SqlIndex::operator=(const SqlIndex& other) = default;
    SqlIndex::SqlIndex(SqlIndex&& other) noexcept = default;
    SqlIndex& SqlIndex::operator=(SqlIndex&& other) noexcept = default;

    // --- Basic Properties ---
    std::string SqlIndex::name() const {
        return m_name;
    }
    void SqlIndex::setName(const std::string& name) {
        m_name = name;
    }

    std::string SqlIndex::tableName() const {
        return m_table_name;
    }
    void SqlIndex::setTableName(const std::string& name) {
        m_table_name = name;
    }

    std::string SqlIndex::schemaName() const {
        return m_schema_name;
    }
    void SqlIndex::setSchemaName(const std::string& schema) {
        m_schema_name = schema;
    }

    // --- Index Characteristics ---
    bool SqlIndex::isUnique() const {
        return m_is_unique;
    }
    void SqlIndex::setUnique(bool unique) {
        m_is_unique = unique;
    }

    bool SqlIndex::isPrimaryKey() const {
        return m_is_primary_key;
    }
    void SqlIndex::setPrimaryKey(bool pk) {
        m_is_primary_key = pk;
    }

    bool SqlIndex::isFunctional() const {
        return m_is_functional;
    }
    void SqlIndex::setFunctional(bool functional) {
        m_is_functional = functional;
    }

    std::string SqlIndex::typeMethod() const {
        return m_type_method;
    }
    void SqlIndex::setTypeMethod(const std::string& method) {
        m_type_method = method;
    }

    // --- Columns in the Index ---
    void SqlIndex::appendColumn(const IndexColumnDefinition& colDef) {
        m_columns.push_back(colDef);
    }

    void SqlIndex::appendColumn(const std::string& fieldName, IndexSortOrder order, const std::optional<std::string>& expression, IndexNullsPosition nulls, const std::optional<std::string>& opClass) {
        IndexColumnDefinition colDef;
        colDef.fieldName = fieldName;
        colDef.sortOrder = order;
        colDef.expression = expression;
        colDef.nullsPosition = nulls;
        colDef.opClass = opClass;
        m_columns.push_back(colDef);
    }

    int SqlIndex::columnCount() const {
        return static_cast<int>(m_columns.size());
    }

    IndexColumnDefinition SqlIndex::column(int i) const {
        if (i >= 0 && static_cast<size_t>(i) < m_columns.size()) {
            return m_columns[static_cast<size_t>(i)];
        }
        // Consider throwing std::out_of_range or returning a "null" IndexColumnDefinition
        return IndexColumnDefinition{};
    }
    const std::vector<IndexColumnDefinition>& SqlIndex::columns() const {
        return m_columns;
    }

    // --- Advanced Index Properties ---
    std::string SqlIndex::condition() const {
        return m_condition;
    }
    void SqlIndex::setCondition(const std::string& cond) {
        m_condition = cond;
    }

    std::vector<std::string> SqlIndex::includedColumnNames() const {
        return m_included_columns;
    }
    void SqlIndex::addIncludedColumn(const std::string& columnName) {
        m_included_columns.push_back(columnName);
    }
    void SqlIndex::setIncludedColumns(const std::vector<std::string>& columnNames) {
        m_included_columns = columnNames;
    }

    // --- Driver/DB specific options ---
    std::map<std::string, SqlValue> SqlIndex::options() const {
        return m_options;
    }
    void SqlIndex::setOption(const std::string& optionName, const SqlValue& value) {
        m_options[optionName] = value;
    }
    SqlValue SqlIndex::option(const std::string& optionName) const {
        auto it = m_options.find(optionName);
        if (it != m_options.end()) {
            return it->second;
        }
        return SqlValue();  // Null SqlValue if option not found
    }

    void SqlIndex::clear() {
        m_name.clear();
        m_table_name.clear();
        m_schema_name.clear();
        m_is_unique = false;
        m_is_primary_key = false;
        m_is_functional = false;
        m_type_method.clear();  // Or set to default like "BTREE"
        m_columns.clear();
        m_condition.clear();
        m_included_columns.clear();
        m_options.clear();
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_query.cpp
#include "sqldriver/sql_query.h"

#include <stdexcept>  // For potential std::logic_error

#include "sqldriver/i_sql_driver.h"  // For ISqlDriver interaction via SqlDatabase
#include "sqldriver/sql_database.h"  // For SqlDatabase context
#include "sqldriver/sql_result.h"    // For SqlResult interface

namespace cpporm_sqldriver {

    // --- Helper ---
    bool SqlQuery::checkResult(const char* methodName) const {
        if (!m_result) {
            // This state should ideally be caught by m_db check first or result creation failure.
            // If m_result is null here, it's an internal logic error.
            // For robustness, if SqlDatabase::driver() could return null:
            // if (m_db && m_db->driver()) {
            //    // This is tricky, as lastError() is on SqlQuery itself.
            //    // const_cast<SqlQuery*>(this)->m_result_error = SqlError(...)
            // }
            return false;
        }
        return true;
    }

    void SqlQuery::updateSelectStatus() {
        m_is_select_query = false;
        if (m_last_query_text.length() > 6) {
            std::string prefix = m_last_query_text.substr(0, 6);
            for (char& c : prefix) {
                c = static_cast<char>(std::toupper(c));
            }
            if (prefix == "SELECT") {
                m_is_select_query = true;
            }
        }
    }

    // --- Construction and Destruction ---
    SqlQuery::SqlQuery(SqlDatabase& db)
        : m_db(&db),
          m_result(nullptr),
          m_is_active(false),
          m_is_select_query(false),
          m_precision_policy(NumericalPrecisionPolicy::LowPrecision),  // Default
          m_binding_syntax(SqlResultNs::NamedBindingSyntax::Colon) {   // Default
        if (m_db && m_db->driver()) {
            m_result = m_db->driver()->createResult();
        }
        // If m_result is nullptr here, subsequent operations will fail in checkResult
    }

    SqlQuery::SqlQuery(const std::string& query, SqlDatabase* db) : m_db(db), m_result(nullptr), m_last_query_text(query), m_is_active(false), m_is_select_query(false), m_precision_policy(NumericalPrecisionPolicy::LowPrecision), m_binding_syntax(SqlResultNs::NamedBindingSyntax::Colon) {
        if (m_db && m_db->driver()) {
            m_result = m_db->driver()->createResult();
        }
        updateSelectStatus();
    }

    SqlQuery::~SqlQuery() {
        // m_result (unique_ptr) will be automatically destroyed.
        // finish() might be called explicitly or by destructor of SqlResult.
    }

    // --- Move Semantics ---
    SqlQuery::SqlQuery(SqlQuery&& other) noexcept
        : m_db(other.m_db), m_result(std::move(other.m_result)), m_last_query_text(std::move(other.m_last_query_text)), m_is_active(other.m_is_active), m_is_select_query(other.m_is_select_query), m_precision_policy(other.m_precision_policy), m_binding_syntax(other.m_binding_syntax) {
        other.m_db = nullptr;  // Null out moved-from object's db pointer
        other.m_is_active = false;
    }

    SqlQuery& SqlQuery::operator=(SqlQuery&& other) noexcept {
        if (this != &other) {
            m_db = other.m_db;
            m_result = std::move(other.m_result);
            m_last_query_text = std::move(other.m_last_query_text);
            m_is_active = other.m_is_active;
            m_is_select_query = other.m_is_select_query;
            m_precision_policy = other.m_precision_policy;
            m_binding_syntax = other.m_binding_syntax;

            other.m_db = nullptr;
            other.m_is_active = false;
        }
        return *this;
    }

    // --- Preparation and Execution ---
    bool SqlQuery::prepare(const std::string& query, SqlResultNs::ScrollMode scroll, SqlResultNs::ConcurrencyMode concur) {
        if (!checkResult("prepare")) return false;
        m_last_query_text = query;
        updateSelectStatus();
        m_result->setNamedBindingSyntax(m_binding_syntax);                 // Ensure syntax is set before prepare
        bool success = m_result->prepare(query, nullptr, scroll, concur);  // Assuming no type hints for now
        m_is_active = success;
        return success;
    }

    bool SqlQuery::exec() {
        if (!checkResult("exec")) return false;
        if (!m_is_active && m_last_query_text.empty()) {  // Cannot exec if not prepared and no query stored
            // set an error on m_result or return an error via lastError()
            return false;
        }
        if (!m_is_active && !m_last_query_text.empty()) {  // If query text exists but not prepared
            if (!prepare(m_last_query_text)) return false;
        }

        bool success = m_result->exec();
        // m_is_active remains true if exec succeeds, allowing data fetching.
        // It becomes false after finish() or if exec fails catastrophically.
        // For now, exec success implies active.
        m_is_active = success;
        return success;
    }

    bool SqlQuery::exec(const std::string& query) {
        m_last_query_text = query;
        updateSelectStatus();
        // No need to call prepare explicitly, as SqlResult::exec(query) is not standard.
        // We should prepare then exec.
        if (!prepare(query)) {  // Prepare first
            m_is_active = false;
            return false;
        }
        return exec();  // Then execute
    }

    bool SqlQuery::setQueryTimeout(int seconds) {
        if (!checkResult("setQueryTimeout")) return false;
        return m_result->setQueryTimeout(seconds);
    }

    // --- Binding Values ---
    void SqlQuery::bindValue(int pos, const SqlValue& val, ParamType type) {
        if (!checkResult("bindValue")) return;
        // SqlResult expects 0-based typically, but some APIs are 1-based. Assume 0-based for SqlResult interface.
        // SqlQuery API might be 0-based or 1-based. Let's assume 0-based for SqlQuery too for consistency.
        m_result->addPositionalBindValue(val, type);  // Assuming addPositionalBindValue appends in order
                                                      // or setPositionalBindValue(pos, val, type) if exists
    }

    void SqlQuery::bindValue(const std::string& placeholderName, const SqlValue& val, ParamType type) {
        if (!checkResult("bindValue")) return;
        m_result->setNamedBindValue(placeholderName, val, type);
    }

    void SqlQuery::addBindValue(const SqlValue& val, ParamType type) {
        if (!checkResult("addBindValue")) return;
        m_result->addPositionalBindValue(val, type);
    }

    SqlValue SqlQuery::boundValue(int /*pos*/) const {
        if (!checkResult("boundValue")) return SqlValue();
        // This requires SqlResult to have a method like `getPositionalBoundValue(pos)`
        // For now, not directly supported as SqlResult interface doesn't mandate it.
        return SqlValue();  // Placeholder
    }

    SqlValue SqlQuery::boundValue(const std::string& /*placeholderName*/) const {
        if (!checkResult("boundValue")) return SqlValue();
        // Requires SqlResult to have `getNamedBoundValue(name)`
        return SqlValue();  // Placeholder
    }

    void SqlQuery::clearBoundValues() {
        if (!checkResult("clearBoundValues")) return;
        m_result->clearBindValues();
    }

    // --- Navigation ---
    bool SqlQuery::next() {
        if (!checkResult("next") || !m_is_active) return false;
        SqlRecord temp_dummy_record;  // fetchNext in SqlResult needs a buffer
        return m_result->fetchNext(temp_dummy_record);
    }

    bool SqlQuery::previous() {
        if (!checkResult("previous") || !m_is_active) return false;
        SqlRecord temp_dummy_record;
        return m_result->fetchPrevious(temp_dummy_record);
    }

    bool SqlQuery::first() {
        if (!checkResult("first") || !m_is_active) return false;
        SqlRecord temp_dummy_record;
        return m_result->fetchFirst(temp_dummy_record);
    }

    bool SqlQuery::last() {
        if (!checkResult("last") || !m_is_active) return false;
        SqlRecord temp_dummy_record;
        return m_result->fetchLast(temp_dummy_record);
    }

    bool SqlQuery::seek(int index, CursorMovement movement) {
        if (!checkResult("seek") || !m_is_active) return false;
        SqlRecord temp_dummy_record;
        return m_result->fetch(index, temp_dummy_record, movement);
    }

    // --- Data Retrieval ---
    SqlRecord SqlQuery::recordMetadata() const {
        if (!checkResult("recordMetadata")) return SqlRecord();
        return m_result->recordMetadata();
    }

    SqlRecord SqlQuery::currentFetchedRow() const {
        if (!checkResult("currentFetchedRow") || !m_is_active) return SqlRecord();
        return m_result->currentFetchedRow();
    }

    SqlValue SqlQuery::value(int index) const {
        if (!checkResult("value") || !m_is_active) return SqlValue();
        // SqlResult::data(index) is the underlying call
        return m_result->data(index);
    }

    SqlValue SqlQuery::value(const std::string& name) const {
        if (!checkResult("value") || !m_is_active) return SqlValue();
        SqlRecord meta = m_result->recordMetadata();
        int index = meta.indexOf(name);
        if (index != -1) {
            return m_result->data(index);
        }
        return SqlValue();  // Not found
    }

    bool SqlQuery::isNull(int index) const {
        if (!checkResult("isNull") || !m_is_active) return true;  // Treat as null if not valid
        return m_result->isNull(index);
    }

    bool SqlQuery::isNull(const std::string& name) const {
        if (!checkResult("isNull") || !m_is_active) return true;
        SqlRecord meta = m_result->recordMetadata();
        int index = meta.indexOf(name);
        if (index != -1) {
            return m_result->isNull(index);
        }
        return true;  // Not found, treat as null
    }

    SqlField SqlQuery::field(int index) const {
        if (!checkResult("field") || !m_is_active) return SqlField();
        return m_result->field(index);
    }
    SqlField SqlQuery::field(const std::string& name) const {
        if (!checkResult("field") || !m_is_active) return SqlField();
        SqlRecord meta = m_result->recordMetadata();
        int index = meta.indexOf(name);
        if (index != -1) {
            return m_result->field(index);
        }
        return SqlField();
    }

    // --- Information / State ---
    int SqlQuery::at() const {
        if (!checkResult("at") || !m_is_active) return -1;
        return m_result->at();
    }

    int SqlQuery::size() const {
        if (!checkResult("size")) return -1;
        // SqlResult::size() can be mutable if it needs to query or count
        return const_cast<SqlResult*>(m_result.get())->size();
    }

    bool SqlQuery::isActive() const {
        // Active means prepared and potentially executed, but not finished.
        // And underlying result object also says it's active.
        return m_is_active && m_result && m_result->isActive();
    }

    bool SqlQuery::isValid() const {
        // Valid means the result set (if any) can be navigated.
        return m_is_active && m_result && m_result->isValid();
    }

    bool SqlQuery::isSelect() const {
        // Based on heuristic updated during prepare/exec(query)
        return m_is_select_query;
    }

    bool SqlQuery::setForwardOnly(bool forward) {
        if (!checkResult("setForwardOnly")) return false;
        return m_result->setForwardOnly(forward);
    }

    bool SqlQuery::setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) {
        if (!checkResult("setNumericalPrecisionPolicy")) return false;
        bool success = m_result->setNumericalPrecisionPolicy(policy);
        if (success) m_precision_policy = policy;
        return success;
    }
    NumericalPrecisionPolicy SqlQuery::numericalPrecisionPolicy() const {
        return m_precision_policy;
    }

    SqlError SqlQuery::lastError() const {
        if (m_result) {
            return m_result->error();
        }
        if (m_db) {  // If result creation failed, error might be on db
            return m_db->lastError();
        }
        return SqlError(ErrorCategory::DriverInternal, "SqlQuery is not properly initialized.", "SqlQuery::lastError");
    }

    std::string SqlQuery::lastQuery() const {
        return m_last_query_text;
    }

    std::string SqlQuery::executedQuery() const {
        if (!checkResult("executedQuery")) return m_last_query_text;  // Fallback
        return m_result->preparedQueryText();                         // Or lastQuery() if preparedQueryText is only post-placeholder
    }

    // --- Post-Execution Information ---
    long long SqlQuery::numRowsAffected() const {
        if (!checkResult("numRowsAffected")) return -1;  // Or 0
        return m_result->numRowsAffected();
    }

    SqlValue SqlQuery::lastInsertId() const {
        if (!checkResult("lastInsertId")) return SqlValue();
        return m_result->lastInsertId();
    }

    // --- Control ---
    void SqlQuery::finish() {
        if (m_result) {
            m_result->finish();
        }
        m_is_active = false;
    }

    void SqlQuery::clear() {
        if (m_result) {
            m_result->clear();  // SqlResult::clear should also reset binds
        }
        m_last_query_text.clear();
        m_is_active = false;
        m_is_select_query = false;
    }

    // --- Associated objects ---
    SqlDatabase* SqlQuery::database() const {
        return m_db;
    }

    ISqlDriver* SqlQuery::driver() const {
        return m_db ? m_db->driver() : nullptr;
    }

    SqlResult* SqlQuery::result() const {
        return m_result.get();
    }

    // --- Multiple Result Sets ---
    bool SqlQuery::nextResult() {
        if (!checkResult("nextResult")) return false;
        bool success = m_result->nextResult();
        if (success) {
            m_is_active = true;    // New result set might be active
            updateSelectStatus();  // Re-check if new result is from SELECT
        } else {
            m_is_active = false;  // No more results or error
        }
        return success;
    }

    // --- Placeholder syntax ---
    bool SqlQuery::setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) {
        m_binding_syntax = syntax;
        if (m_result) {  // Pass to underlying result object if it's already created
            return m_result->setNamedBindingSyntax(syntax);
        }
        return true;  // Store for when result is created
    }
    SqlResultNs::NamedBindingSyntax SqlQuery::namedBindingSyntax() const {
        return m_binding_syntax;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_record.cpp
#include "sqldriver/sql_record.h"

#include <algorithm>  // For std::find_if
#include <stdexcept>  // For std::out_of_range

namespace cpporm_sqldriver {

    SqlRecord::SqlRecord() = default;
    SqlRecord::~SqlRecord() = default;

    // --- Copy and Move semantics ---
    SqlRecord::SqlRecord(const SqlRecord& other) : m_fields(other.m_fields) {
    }

    SqlRecord& SqlRecord::operator=(const SqlRecord& other) {
        if (this != &other) {
            m_fields = other.m_fields;
        }
        return *this;
    }

    SqlRecord::SqlRecord(SqlRecord&& other) noexcept : m_fields(std::move(other.m_fields)) {
    }

    SqlRecord& SqlRecord::operator=(SqlRecord&& other) noexcept {
        if (this != &other) {
            m_fields = std::move(other.m_fields);
        }
        return *this;
    }

    // --- Status and Count ---
    bool SqlRecord::isEmpty() const {
        return m_fields.empty();
    }

    int SqlRecord::count() const {
        return static_cast<int>(m_fields.size());
    }

    // --- Field access by index ---
    SqlField SqlRecord::field(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::field: index out of bounds");
            return SqlField();  // Return an invalid/empty field
        }
        return m_fields[static_cast<size_t>(index)];
    }

    std::string SqlRecord::fieldName(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::fieldName: index out of bounds");
            return "";
        }
        return m_fields[static_cast<size_t>(index)].name();
    }

    SqlValue SqlRecord::value(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::value: index out of bounds");
            return SqlValue();  // Return null SqlValue
        }
        return m_fields[static_cast<size_t>(index)].value();
    }

    bool SqlRecord::isNull(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::isNull: index out of bounds");
            return true;  // Treat out-of-bounds as null-like for safety
        }
        return m_fields[static_cast<size_t>(index)].isNullInValue();
    }

    void SqlRecord::setValue(int index, const SqlValue& val) {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::setValue: index out of bounds");
            return;
        }
        m_fields[static_cast<size_t>(index)].setValue(val);
    }

    void SqlRecord::setNull(int index) {
        if (index < 0 || static_cast<size_t>(index) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::setNull: index out of bounds");
            return;
        }
        m_fields[static_cast<size_t>(index)].clearValue();  // Or setValue(SqlValue());
    }

    // --- Field access by name ---
    int SqlRecord::indexOf(const std::string& name) const {
        for (size_t i = 0; i < m_fields.size(); ++i) {
            // Case-sensitive comparison. For case-insensitive, convert both to lower/upper.
            if (m_fields[i].name() == name) {
                return static_cast<int>(i);
            }
        }
        return -1;  // Not found
    }

    SqlField SqlRecord::field(const std::string& name) const {
        int idx = indexOf(name);
        if (idx != -1) {
            return m_fields[static_cast<size_t>(idx)];
        }
        return SqlField();  // Return an invalid/empty field
    }

    SqlValue SqlRecord::value(const std::string& name) const {
        int idx = indexOf(name);
        if (idx != -1) {
            return m_fields[static_cast<size_t>(idx)].value();
        }
        return SqlValue();  // Return null SqlValue
    }

    bool SqlRecord::isNull(const std::string& name) const {
        int idx = indexOf(name);
        if (idx != -1) {
            return m_fields[static_cast<size_t>(idx)].isNullInValue();
        }
        return true;  // Not found, treat as null
    }

    void SqlRecord::setValue(const std::string& name, const SqlValue& val) {
        int idx = indexOf(name);
        if (idx != -1) {
            m_fields[static_cast<size_t>(idx)].setValue(val);
        }
        // Else: field not found, could throw or silently ignore
    }

    void SqlRecord::setNull(const std::string& name) {
        int idx = indexOf(name);
        if (idx != -1) {
            m_fields[static_cast<size_t>(idx)].clearValue();  // Or setValue(SqlValue());
        }
        // Else: field not found
    }

    bool SqlRecord::contains(const std::string& name) const {
        return indexOf(name) != -1;
    }

    // --- Modification ---
    void SqlRecord::append(const SqlField& field) {
        m_fields.push_back(field);
    }

    void SqlRecord::insert(int pos, const SqlField& field) {
        if (pos < 0 || static_cast<size_t>(pos) > m_fields.size()) {  // Allow insert at end (pos == size())
            // Or throw std::out_of_range("SqlRecord::insert: position out of bounds");
            if (pos == count()) {  // Append if pos is at the end
                m_fields.push_back(field);
            }
            return;
        }
        m_fields.insert(m_fields.begin() + pos, field);
    }

    void SqlRecord::remove(int pos) {
        if (pos < 0 || static_cast<size_t>(pos) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::remove: position out of bounds");
            return;
        }
        m_fields.erase(m_fields.begin() + pos);
    }

    void SqlRecord::replace(int pos, const SqlField& field) {
        if (pos < 0 || static_cast<size_t>(pos) >= m_fields.size()) {
            // Or throw std::out_of_range("SqlRecord::replace: position out of bounds");
            return;
        }
        m_fields[static_cast<size_t>(pos)] = field;
    }

    void SqlRecord::clear() {
        m_fields.clear();
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_any_interop.cpp
#include <any>
#include <variant>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    std::any SqlValue::toStdAny() const {
        if (isNull()) return std::any{};

        return std::visit(
            [](auto&& arg) -> std::any {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    return std::any{};
                }
                // For types directly storable in std::any and not streams or std::any itself
                else if constexpr (!std::is_same_v<T, InputStreamPtr> &&  // InputStreamPtr is the variant type
                                   !std::is_same_v<T, std::any>) {
                    return arg;
                } else if constexpr (std::is_same_v<T, InputStreamPtr>) {
                    return std::any(arg);  // Store the shared_ptr<istream>
                } else if constexpr (std::is_same_v<T, std::any>) {
                    return arg;
                }
                return std::any{};
            },
            m_value_storage);
    }

    SqlValue SqlValue::fromStdAny(const std::any& val, SqlValueType type_hint) {
        if (!val.has_value()) return SqlValue();

        const auto& typeInfo = val.type();

        if (typeInfo == typeid(std::nullptr_t)) return SqlValue(nullptr);
        if (typeInfo == typeid(bool)) return SqlValue(std::any_cast<bool>(val));
        if (typeInfo == typeid(int8_t)) return SqlValue(std::any_cast<int8_t>(val));
        if (typeInfo == typeid(uint8_t)) return SqlValue(std::any_cast<uint8_t>(val));
        if (typeInfo == typeid(int16_t)) return SqlValue(std::any_cast<int16_t>(val));
        if (typeInfo == typeid(uint16_t)) return SqlValue(std::any_cast<uint16_t>(val));
        if (typeInfo == typeid(int32_t) || typeInfo == typeid(int)) return SqlValue(std::any_cast<int32_t>(val));
        if (typeInfo == typeid(uint32_t) || typeInfo == typeid(unsigned int)) return SqlValue(std::any_cast<uint32_t>(val));
        if (typeInfo == typeid(int64_t) || typeInfo == typeid(long long)) return SqlValue(std::any_cast<int64_t>(val));
        if (typeInfo == typeid(uint64_t) || typeInfo == typeid(unsigned long long)) return SqlValue(std::any_cast<uint64_t>(val));
        if (typeInfo == typeid(float)) return SqlValue(std::any_cast<float>(val));
        if (typeInfo == typeid(double)) return SqlValue(std::any_cast<double>(val));
        if (typeInfo == typeid(long double)) return SqlValue(std::any_cast<long double>(val));
        if (typeInfo == typeid(std::string)) return SqlValue(std::any_cast<std::string>(val), type_hint);
        if (typeInfo == typeid(const char*)) return SqlValue(std::any_cast<const char*>(val), type_hint);
        if (typeInfo == typeid(std::vector<unsigned char>)) return SqlValue(std::any_cast<std::vector<unsigned char>>(val));

        if (typeInfo == typeid(QByteArray)) return SqlValue(std::any_cast<QByteArray>(val));
        if (typeInfo == typeid(QDate)) return SqlValue(std::any_cast<QDate>(val));
        if (typeInfo == typeid(QTime)) return SqlValue(std::any_cast<QTime>(val));
        if (typeInfo == typeid(QDateTime)) return SqlValue(std::any_cast<QDateTime>(val));

        if (typeInfo == typeid(ChronoDate)) return SqlValue(std::any_cast<ChronoDate>(val));
        if (typeInfo == typeid(ChronoTime)) return SqlValue(std::any_cast<ChronoTime>(val));
        if (typeInfo == typeid(ChronoDateTime)) return SqlValue(std::any_cast<ChronoDateTime>(val));

        // 修正：检查 std::any 是否持有 InputStreamPtr
        if (typeInfo == typeid(InputStreamPtr)) {
            // type_hint 必须是 BinaryLargeObject 或 CharacterLargeObject 之一
            if (type_hint == SqlValueType::BinaryLargeObject || type_hint == SqlValueType::CharacterLargeObject) {
                return SqlValue(std::any_cast<InputStreamPtr>(val), type_hint);
            } else {
                // 如果 type_hint 无效，则可能需要默认或抛出错误
                return SqlValue(std::any_cast<InputStreamPtr>(val), SqlValueType::BinaryLargeObject);  // 默认为 BLOB
            }
        }

        SqlValue custom_val;
        custom_val.m_value_storage = val;
        custom_val.m_current_type_enum = (type_hint != SqlValueType::Unknown && type_hint != SqlValueType::Null) ? type_hint : SqlValueType::Custom;
        // 如果 type_hint 本身就是 Custom 或 Unknown，则已经是正确的
        if (custom_val.m_current_type_enum != SqlValueType::Custom && custom_val.m_current_type_enum != SqlValueType::Unknown) {
            // 如果 type_hint 是一个具体的非 Custom 类型，但上面没有匹配到，这说明 std::any 内部类型与 hint 不符
            // 这种情况下，将其标记为 Custom 可能更安全，或者根据策略报错
            // 这里保持了之前的逻辑，即如果 hint 不是 Custom/Unknown，则使用 hint
        } else if (custom_val.m_current_type_enum == SqlValueType::Unknown) {
            custom_val.updateCurrentTypeEnumFromStorage();  // 尝试从 std::any 的内容推断
        }
        return custom_val;
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_chrono_constructors.cpp
#include <chrono>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // 辅助函数声明（如果它们在 helpers 文件中）
    namespace detail {
        bool isValidChronoDate(const SqlValue::ChronoDate& cd);
        bool isValidChronoDateTime(const SqlValue::ChronoDateTime& cdt);
    }  // namespace detail

    SqlValue::SqlValue(const ChronoDate& val) : m_value_storage(val), m_current_type_enum(detail::isValidChronoDate(val) ? SqlValueType::Date : SqlValueType::Null) {
        if (!detail::isValidChronoDate(val)) {
            m_value_storage = std::monostate{};
        }
    }

    SqlValue::SqlValue(const ChronoTime& val) : m_value_storage(val), m_current_type_enum(SqlValueType::Time) {
    }

    SqlValue::SqlValue(const ChronoDateTime& val) : m_value_storage(val), m_current_type_enum(detail::isValidChronoDateTime(val) ? SqlValueType::DateTime : SqlValueType::Null) {
        if (!detail::isValidChronoDateTime(val)) {
            m_value_storage = std::monostate{};
        }
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_core.cpp
#include <QDate>  // For isValid checks in constructor/isValid
#include <QDateTime>
#include <QTime>
#include <any>
#include <cstring>
#include <memory>
#include <string>
#include <variant>
#include <vector>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // --- 核心构造函数 ---
    SqlValue::SqlValue() : m_value_storage(std::monostate{}), m_current_type_enum(SqlValueType::Null), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(std::nullptr_t) : m_value_storage(std::monostate{}), m_current_type_enum(SqlValueType::Null), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(bool val) : m_value_storage(val), m_current_type_enum(SqlValueType::Bool), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(int8_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::Int8), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(uint8_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::UInt8), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(int16_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::Int16), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(uint16_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::UInt16), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(int32_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::Int32), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(uint32_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::UInt32), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(int64_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::Int64), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(uint64_t val) : m_value_storage(val), m_current_type_enum(SqlValueType::UInt64), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(float val) : m_value_storage(val), m_current_type_enum(SqlValueType::Float), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(double val) : m_value_storage(val), m_current_type_enum(SqlValueType::Double), m_lob_size_hint(-1) {
    }
    SqlValue::SqlValue(long double val) : m_value_storage(val), m_current_type_enum(SqlValueType::LongDouble), m_lob_size_hint(-1) {
    }

    SqlValue::SqlValue(const char* val, SqlValueType type_hint) : m_current_type_enum(type_hint), m_lob_size_hint(-1) {
        if (val) {
            if (type_hint == SqlValueType::ByteArray || type_hint == SqlValueType::BinaryLargeObject) {
                m_value_storage = std::vector<unsigned char>(reinterpret_cast<const unsigned char*>(val), reinterpret_cast<const unsigned char*>(val + std::strlen(val)));
                m_current_type_enum = SqlValueType::ByteArray;
            } else {
                m_value_storage = std::string(val);
                // m_current_type_enum 保持用户提供的 type_hint
            }
        } else {
            m_value_storage = std::monostate{};
            m_current_type_enum = SqlValueType::Null;
        }
    }

    SqlValue::SqlValue(const std::string& val, SqlValueType type_hint) : m_current_type_enum(type_hint), m_lob_size_hint(-1) {
        if (type_hint == SqlValueType::ByteArray || type_hint == SqlValueType::BinaryLargeObject) {
            m_value_storage = std::vector<unsigned char>(val.begin(), val.end());
            m_current_type_enum = SqlValueType::ByteArray;
        } else {
            m_value_storage = val;
            // m_current_type_enum 保持用户提供的 type_hint
        }
    }

    SqlValue::SqlValue(const std::vector<unsigned char>& val) : m_value_storage(val), m_current_type_enum(SqlValueType::ByteArray), m_lob_size_hint(-1) {
    }

    // --- 拷贝和移动语义 ---
    SqlValue::SqlValue(const SqlValue& other) : m_value_storage(other.m_value_storage), m_current_type_enum(other.m_current_type_enum), m_driver_type_name_cache(other.m_driver_type_name_cache), m_lob_size_hint(other.m_lob_size_hint) {
    }

    SqlValue& SqlValue::operator=(const SqlValue& other) {
        if (this != &other) {
            m_value_storage = other.m_value_storage;
            m_current_type_enum = other.m_current_type_enum;
            m_driver_type_name_cache = other.m_driver_type_name_cache;
            m_lob_size_hint = other.m_lob_size_hint;
        }
        return *this;
    }

    SqlValue::SqlValue(SqlValue&& other) noexcept : m_value_storage(std::move(other.m_value_storage)), m_current_type_enum(other.m_current_type_enum), m_driver_type_name_cache(std::move(other.m_driver_type_name_cache)), m_lob_size_hint(other.m_lob_size_hint) {
        other.m_current_type_enum = SqlValueType::Null;
        other.m_value_storage = std::monostate{};
        other.m_lob_size_hint = -1;
    }

    SqlValue& SqlValue::operator=(SqlValue&& other) noexcept {
        if (this != &other) {
            m_value_storage = std::move(other.m_value_storage);
            m_current_type_enum = other.m_current_type_enum;
            m_driver_type_name_cache = std::move(other.m_driver_type_name_cache);
            m_lob_size_hint = other.m_lob_size_hint;
            other.m_current_type_enum = SqlValueType::Null;
            other.m_value_storage = std::monostate{};
            other.m_lob_size_hint = -1;
        }
        return *this;
    }

    SqlValue::~SqlValue() = default;

    bool SqlValue::isNull() const {
        return std::holds_alternative<std::monostate>(m_value_storage);
    }

    bool SqlValue::isValid() const {
        if (isNull()) return false;
        bool structurally_valid = true;
        std::visit(
            [&structurally_valid](auto&& arg) {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, QDate>) {
                    if (arg.isNull())
                        structurally_valid = false;
                    else
                        structurally_valid = arg.isValid();
                } else if constexpr (std::is_same_v<T, QTime>) {
                    if (arg.isNull())
                        structurally_valid = false;
                    else
                        structurally_valid = arg.isValid();
                } else if constexpr (std::is_same_v<T, QDateTime>) {
                    if (arg.isNull())
                        structurally_valid = false;
                    else
                        structurally_valid = arg.isValid();
                } else if constexpr (std::is_same_v<T, ChronoDate>) {
                    structurally_valid = arg.ok();
                } else if constexpr (std::is_same_v<T, InputStreamPtr>) {
                    structurally_valid = (arg != nullptr);
                } else if constexpr (std::is_same_v<T, std::any>) {
                    structurally_valid = arg.has_value();
                }
            },
            m_value_storage);
        return structurally_valid;
    }

    SqlValueType SqlValue::type() const {
        return m_current_type_enum;
    }

    void SqlValue::updateCurrentTypeEnumFromStorage() {
        std::visit(
            [this](auto&& arg) {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::monostate>)
                    m_current_type_enum = SqlValueType::Null;
                else if constexpr (std::is_same_v<T, bool>)
                    m_current_type_enum = SqlValueType::Bool;
                else if constexpr (std::is_same_v<T, int8_t>)
                    m_current_type_enum = SqlValueType::Int8;
                else if constexpr (std::is_same_v<T, uint8_t>)
                    m_current_type_enum = SqlValueType::UInt8;
                else if constexpr (std::is_same_v<T, int16_t>)
                    m_current_type_enum = SqlValueType::Int16;
                else if constexpr (std::is_same_v<T, uint16_t>)
                    m_current_type_enum = SqlValueType::UInt16;
                else if constexpr (std::is_same_v<T, int32_t>)
                    m_current_type_enum = SqlValueType::Int32;
                else if constexpr (std::is_same_v<T, uint32_t>)
                    m_current_type_enum = SqlValueType::UInt32;
                else if constexpr (std::is_same_v<T, int64_t>)
                    m_current_type_enum = SqlValueType::Int64;
                else if constexpr (std::is_same_v<T, uint64_t>)
                    m_current_type_enum = SqlValueType::UInt64;
                else if constexpr (std::is_same_v<T, float>)
                    m_current_type_enum = SqlValueType::Float;
                else if constexpr (std::is_same_v<T, double>)
                    m_current_type_enum = SqlValueType::Double;
                else if constexpr (std::is_same_v<T, long double>)
                    m_current_type_enum = SqlValueType::LongDouble;
                else if constexpr (std::is_same_v<T, std::string>) {
                    // 保持 m_current_type_enum 的原样，因为它可能已经是 FixedString, CLOB, Json 等
                    if (m_current_type_enum != SqlValueType::FixedString && m_current_type_enum != SqlValueType::CharacterLargeObject && m_current_type_enum != SqlValueType::Json && m_current_type_enum != SqlValueType::Xml && m_current_type_enum != SqlValueType::Decimal &&
                        m_current_type_enum != SqlValueType::Numeric &&
                        // 也检查Date/Time/DateTime/Timestamp，因为它们可能从字符串构造
                        m_current_type_enum != SqlValueType::Date && m_current_type_enum != SqlValueType::Time && m_current_type_enum != SqlValueType::DateTime && m_current_type_enum != SqlValueType::Timestamp && m_current_type_enum != SqlValueType::Interval) {
                        m_current_type_enum = SqlValueType::String;
                    }
                } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                    if (m_current_type_enum != SqlValueType::BinaryLargeObject) {
                        m_current_type_enum = SqlValueType::ByteArray;
                    }
                } else if constexpr (std::is_same_v<T, InputStreamPtr>) {
                    // m_current_type_enum 应该已在构造时被正确设置为 BinaryLargeObject 或 CharacterLargeObject
                } else if constexpr (std::is_same_v<T, QDate>)
                    m_current_type_enum = SqlValueType::Date;
                else if constexpr (std::is_same_v<T, QTime>)
                    m_current_type_enum = SqlValueType::Time;
                else if constexpr (std::is_same_v<T, QDateTime>) {
                    if (m_current_type_enum != SqlValueType::Timestamp) {
                        m_current_type_enum = SqlValueType::DateTime;
                    }
                } else if constexpr (std::is_same_v<T, ChronoDate>)
                    m_current_type_enum = SqlValueType::Date;
                else if constexpr (std::is_same_v<T, ChronoTime>)
                    m_current_type_enum = SqlValueType::Time;
                else if constexpr (std::is_same_v<T, ChronoDateTime>) {
                    if (m_current_type_enum != SqlValueType::Timestamp) {
                        m_current_type_enum = SqlValueType::DateTime;
                    }
                } else if constexpr (std::is_same_v<T, std::any>)
                    m_current_type_enum = SqlValueType::Custom;
                else
                    m_current_type_enum = SqlValueType::Unknown;
            },
            m_value_storage);
    }

    const char* SqlValue::typeName() const {
        switch (m_current_type_enum) {
            case SqlValueType::Null:
                return "Null";
            case SqlValueType::Bool:
                return "Bool";
            case SqlValueType::Int8:
                return "Int8";
            case SqlValueType::UInt8:
                return "UInt8";
            case SqlValueType::Int16:
                return "Int16";
            case SqlValueType::UInt16:
                return "UInt16";
            case SqlValueType::Int32:
                return "Int32";
            case SqlValueType::UInt32:
                return "UInt32";
            case SqlValueType::Int64:
                return "Int64";
            case SqlValueType::UInt64:
                return "UInt64";
            case SqlValueType::Float:
                return "Float";
            case SqlValueType::Double:
                return "Double";
            case SqlValueType::LongDouble:
                return "LongDouble";
            case SqlValueType::String:
                return "String";
            case SqlValueType::FixedString:
                return "FixedString";
            case SqlValueType::ByteArray:
                return "ByteArray";
            case SqlValueType::BinaryLargeObject:
                return "BLOB";
            case SqlValueType::CharacterLargeObject:
                return "CLOB";
            case SqlValueType::Date:
                return "Date";
            case SqlValueType::Time:
                return "Time";
            case SqlValueType::DateTime:
                return "DateTime";
            case SqlValueType::Timestamp:
                return "Timestamp";
            case SqlValueType::Interval:
                return "Interval";
            case SqlValueType::Decimal:
                return "Decimal";
            case SqlValueType::Numeric:
                return "Numeric";
            case SqlValueType::Json:
                return "Json";
            case SqlValueType::Xml:
                return "Xml";
            case SqlValueType::Array:
                return "Array";
            case SqlValueType::RowId:
                return "RowId";
            case SqlValueType::Custom:
                {
                    if (std::holds_alternative<std::any>(m_value_storage)) {
                        const std::any& a = std::get<std::any>(m_value_storage);
                        if (a.has_value()) return a.type().name();
                        return "Custom (empty std::any)";
                    }
                    return "Custom (invalid state)";
                }
            default:
                return "Unknown";
        }
    }

    std::string SqlValue::driverTypeName() const {
        return m_driver_type_name_cache;
    }
    void SqlValue::setDriverTypeName(const std::string& name) {
        m_driver_type_name_cache = name;
    }
    long long SqlValue::lobSizeHint() const {
        return m_lob_size_hint;
    }

    void SqlValue::clear() {
        m_value_storage = std::monostate{};
        m_current_type_enum = SqlValueType::Null;
        m_driver_type_name_cache.clear();
        m_lob_size_hint = -1;
    }

    bool SqlValue::operator==(const SqlValue& other) const {
        if (m_value_storage.index() != other.m_value_storage.index()) {
            return false;
        }
        if (isNull()) {  // Both are null due to index check above
            return true;
        }

        return std::visit(
            [&other](auto&& lhs_arg) -> bool {
                using LhsT = std::decay_t<decltype(lhs_arg)>;
                // We know other.m_value_storage holds the same alternative type due to index check
                auto const& rhs_arg = std::get<LhsT>(other.m_value_storage);

                if constexpr (std::is_same_v<LhsT, std::monostate>) {
                    return true;  // Both null
                } else if constexpr (std::is_same_v<LhsT, InputStreamPtr>) {
                    return lhs_arg.get() == rhs_arg.get();  // Compare shared_ptr raw pointers
                } else if constexpr (std::is_same_v<LhsT, std::any>) {
                    if (lhs_arg.has_value() && rhs_arg.has_value()) {
                        return lhs_arg.type() == rhs_arg.type();  // Basic type comparison for std::any
                        // Content comparison for std::any is non-trivial and type-dependent
                    }
                    return !lhs_arg.has_value() && !rhs_arg.has_value();
                } else {
                    // For other types that have operator== defined
                    return lhs_arg == rhs_arg;
                }
            },
            m_value_storage);
    }

    bool SqlValue::operator!=(const SqlValue& other) const {
        return !(*this == other);
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_lob_constructors.cpp
#include <istream>
#include <memory>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // LOB 流构造函数
    SqlValue::SqlValue(InputStreamPtr stream_handle, SqlValueType lob_type, long long size)
        : m_value_storage(std::monostate{}),  // 先初始化为 null
          m_current_type_enum(SqlValueType::Null),
          m_lob_size_hint(size) {
        if (stream_handle) {  // 只有当流指针有效时才设置
            if (lob_type == SqlValueType::BinaryLargeObject || lob_type == SqlValueType::CharacterLargeObject) {
                m_value_storage = std::move(stream_handle);
                m_current_type_enum = lob_type;
            } else {
                // 如果 lob_type 无效，则此构造函数不应被调用，或应抛出异常/记录错误
                // 为保持健壮性，如果 stream_handle 有效但 lob_type 无效，则将其视为通用 BLOB
                m_value_storage = std::move(stream_handle);
                m_current_type_enum = SqlValueType::BinaryLargeObject;
                // 或者可以设置错误状态，但这通常在构造函数中不方便
            }
        }
        // 如果 stream_handle 为空，它将保持为 Null 状态
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_qt_constructors.cpp
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    SqlValue::SqlValue(const QByteArray& val) : m_value_storage(std::vector<unsigned char>(reinterpret_cast<const unsigned char*>(val.constData()), reinterpret_cast<const unsigned char*>(val.constData() + val.size()))), m_current_type_enum(SqlValueType::ByteArray) {
    }

    SqlValue::SqlValue(const QDate& val) : m_value_storage(val), m_current_type_enum(val.isValid() ? SqlValueType::Date : SqlValueType::Null) {
        if (!val.isValid()) {
            m_value_storage = std::monostate{};
        }
    }

    SqlValue::SqlValue(const QTime& val) : m_value_storage(val), m_current_type_enum(val.isValid() ? SqlValueType::Time : SqlValueType::Null) {
        if (!val.isValid()) {
            m_value_storage = std::monostate{};
        }
    }

    SqlValue::SqlValue(const QDateTime& val) : m_value_storage(val), m_current_type_enum(val.isValid() ? SqlValueType::DateTime : SqlValueType::Null) {
        if (!val.isValid()) {
            m_value_storage = std::monostate{};
        }
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_qvariant_interop.cpp
#include <QMetaType>
#include <QString>
#include <QTimeZone>
#include <QVariant>
#include <any>
#include <format>  // C++26 (std::format from C++20)

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    QVariant SqlValue::toQVariant() const {
        if (isNull()) return QVariant();

        return std::visit(
            [](auto&& arg) -> QVariant {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    return QVariant();
                } else if constexpr (std::is_same_v<T, bool>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, int8_t>) {
                    return QVariant(static_cast<int>(arg));
                } else if constexpr (std::is_same_v<T, uint8_t>) {
                    return QVariant(static_cast<unsigned int>(arg));
                } else if constexpr (std::is_same_v<T, int16_t>) {
                    return QVariant(static_cast<int>(arg));
                } else if constexpr (std::is_same_v<T, uint16_t>) {
                    return QVariant(static_cast<unsigned int>(arg));
                } else if constexpr (std::is_same_v<T, int32_t>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, uint32_t>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, int64_t>) {
                    return QVariant(static_cast<qlonglong>(arg));
                } else if constexpr (std::is_same_v<T, uint64_t>) {
                    return QVariant(static_cast<qulonglong>(arg));
                } else if constexpr (std::is_same_v<T, float>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, double>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, long double>) {
                    return QVariant(static_cast<double>(arg));
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return QVariant(QString::fromStdString(arg));
                } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                    return QVariant(QByteArray(reinterpret_cast<const char*>(arg.data()), static_cast<int>(arg.size())));
                } else if constexpr (std::is_same_v<T, QDate>) {
                    return QVariant::fromValue(arg);
                } else if constexpr (std::is_same_v<T, QTime>) {
                    return QVariant::fromValue(arg);
                } else if constexpr (std::is_same_v<T, QDateTime>) {
                    return QVariant::fromValue(arg);
                } else if constexpr (std::is_same_v<T, ChronoDate>) {
                    if (arg.ok()) return QVariant::fromValue(QDate(static_cast<int>(arg.year()), static_cast<unsigned>(arg.month()), static_cast<unsigned>(arg.day())));
                } else if constexpr (std::is_same_v<T, ChronoTime>) {
                    auto ct_ms = std::chrono::duration_cast<std::chrono::milliseconds>(arg);
                    qint64 total_ms = ct_ms.count() % (24LL * 3600 * 1000);
                    if (total_ms < 0) total_ms += (24LL * 3600 * 1000);
                    return QVariant::fromValue(QTime::fromMSecsSinceStartOfDay(static_cast<int>(total_ms)));
                } else if constexpr (std::is_same_v<T, ChronoDateTime>) {
                    auto secs = std::chrono::time_point_cast<std::chrono::seconds>(arg).time_since_epoch().count();
                    auto msecs_part = std::chrono::duration_cast<std::chrono::milliseconds>(arg.time_since_epoch() % std::chrono::seconds(1)).count();
                    QDateTime qdt = QDateTime::fromSecsSinceEpoch(secs, QTimeZone::utc());
                    qdt = qdt.addMSecs(msecs_part);
                    return QVariant::fromValue(qdt);
                } else if constexpr (std::is_same_v<T, std::any>) {
                    if (arg.has_value()) return QVariant::fromValue(arg);  // 依赖 Qt 6.2+
                }
                return QVariant();
            },
            m_value_storage);
    }

    SqlValue SqlValue::fromQVariant(const QVariant& qv) {
        if (!qv.isValid() || qv.isNull()) return SqlValue();

        int type_id_int = qv.userType();
        if (type_id_int == QMetaType::UnknownType) {
            type_id_int = qv.typeId();
        }

        switch (static_cast<QMetaType::Type>(type_id_int)) {
            case QMetaType::Bool:
                return SqlValue(qv.toBool());
            case QMetaType::Char:
                return SqlValue(static_cast<int8_t>(qv.toChar().toLatin1()));
            case QMetaType::SChar:
                return SqlValue(qv.value<signed char>());
            case QMetaType::UChar:
                return SqlValue(qv.value<unsigned char>());
            case QMetaType::Short:
                {
                    bool ok = false;
                    int val = qv.toInt(&ok);  // 先转为 int
                    if (ok && val >= std::numeric_limits<short>::min() && val <= std::numeric_limits<short>::max()) {
                        return SqlValue(static_cast<int16_t>(val));
                    }
                    return SqlValue();  // 转换失败或超范围
                }
            case QMetaType::UShort:
                {
                    bool ok = false;
                    unsigned int val = qv.toUInt(&ok);  // 先转为 uint
                    if (ok && val <= std::numeric_limits<unsigned short>::max()) {
                        return SqlValue(static_cast<uint16_t>(val));
                    }
                    return SqlValue();  // 转换失败或超范围
                }
            case QMetaType::Int:
                return SqlValue(qv.toInt());
            case QMetaType::UInt:
                return SqlValue(qv.toUInt());
            case QMetaType::Long:
                return SqlValue(static_cast<int64_t>(qv.toLongLong()));
            case QMetaType::ULong:
                return SqlValue(static_cast<uint64_t>(qv.toULongLong()));
            case QMetaType::LongLong:
                return SqlValue(static_cast<int64_t>(qv.toLongLong()));
            case QMetaType::ULongLong:
                return SqlValue(static_cast<uint64_t>(qv.toULongLong()));
            case QMetaType::Float:
                return SqlValue(qv.toFloat());
            case QMetaType::Double:
                return SqlValue(qv.toDouble());
            case QMetaType::QString:
                return SqlValue(qv.toString().toStdString());
            case QMetaType::QByteArray:
                return SqlValue(qv.toByteArray());
            case QMetaType::QDate:
                return SqlValue(qv.toDate());
            case QMetaType::QTime:
                return SqlValue(qv.toTime());
            case QMetaType::QDateTime:
                return SqlValue(qv.toDateTime());
            // QMetaType::StdAny 不在您提供的 qmetatype.h 的 Type 枚举中
            default:
                // 依赖于 Qt 6.2+ 的 canConvert<std::any> 和 value<std::any>
                if (QMetaType(type_id_int).isValid() && qv.canConvert<std::any>()) {
                    return SqlValue::fromStdAny(qv.value<std::any>());
                }
                break;
        }
        return SqlValue();
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_tobytes.cpp
#include <QByteArray>
#include <string>
#include <variant>
#include <vector>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    std::vector<unsigned char> SqlValue::toStdVectorUChar(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return {};

        if (std::holds_alternative<std::vector<unsigned char>>(m_value_storage)) {
            if (ok) *ok = true;
            return std::get<std::vector<unsigned char>>(m_value_storage);
        }
        // QByteArray 在构造时已转换为 std::vector<unsigned char>
        // 因此不需要 std::holds_alternative<QByteArray>

        if (std::holds_alternative<std::string>(m_value_storage)) {
            // 如果字符串代表十六进制编码的字节，这里需要解析逻辑。
            // 如果字符串本身就是字节序列（例如从某些数据库的 TEXT as BLOB），则直接转换。
            // 当前实现假定后者。
            const std::string& s = std::get<std::string>(m_value_storage);
            if (ok) *ok = true;
            return std::vector<unsigned char>(s.begin(), s.end());
        }
        if (std::holds_alternative<InputStreamPtr>(m_value_storage) && (m_current_type_enum == SqlValueType::BinaryLargeObject || m_current_type_enum == SqlValueType::ByteArray)) {
            // 从流中读取所有字节
            auto stream_ptr = std::get<InputStreamPtr>(m_value_storage);
            if (stream_ptr && stream_ptr->good()) {
                stream_ptr->seekg(0, std::ios::end);
                std::streampos fileSize = stream_ptr->tellg();
                if (fileSize > 0) {
                    std::vector<unsigned char> buffer(static_cast<size_t>(fileSize));
                    stream_ptr->seekg(0, std::ios::beg);
                    stream_ptr->read(reinterpret_cast<char*>(buffer.data()), fileSize);
                    if (stream_ptr->good() || stream_ptr->eof()) {  // 允许 eof
                        if (ok) *ok = true;
                        return buffer;
                    }
                } else if (fileSize == 0) {  // 空流
                    if (ok) *ok = true;
                    return {};
                }
            }
        }
        return {};
    }

    QByteArray SqlValue::toByteArray(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return QByteArray();

        if (std::holds_alternative<std::vector<unsigned char>>(m_value_storage)) {
            const auto& vec = std::get<std::vector<unsigned char>>(m_value_storage);
            if (ok) *ok = true;
            return QByteArray(reinterpret_cast<const char*>(vec.data()), static_cast<int>(vec.size()));
        }
        // QByteArray 在构造时已转换为 std::vector<unsigned char>

        if (std::holds_alternative<std::string>(m_value_storage)) {
            // 如果字符串是文本，转换为UTF-8 QByteArray
            if (m_current_type_enum == SqlValueType::String || m_current_type_enum == SqlValueType::FixedString || m_current_type_enum == SqlValueType::CharacterLargeObject || m_current_type_enum == SqlValueType::Json || m_current_type_enum == SqlValueType::Xml) {
                if (ok) *ok = true;
                return QString::fromStdString(std::get<std::string>(m_value_storage)).toUtf8();
            }
            // 如果字符串意图是字节（例如，之前未被识别为ByteArray的type_hint），则直接转换
            const std::string& s = std::get<std::string>(m_value_storage);
            if (ok) *ok = true;
            return QByteArray(s.data(), static_cast<int>(s.length()));
        }
        if (std::holds_alternative<InputStreamPtr>(m_value_storage) && (m_current_type_enum == SqlValueType::BinaryLargeObject || m_current_type_enum == SqlValueType::ByteArray)) {
            auto stream_ptr = std::get<InputStreamPtr>(m_value_storage);
            if (stream_ptr && stream_ptr->good()) {
                // 尝试读取整个流到 QByteArray
                // 注意：对于非常大的流，这可能会消耗大量内存
                std::stringbuf sbuf;
                (*stream_ptr) >> &sbuf;  // 读取到 stringbuf
                if (stream_ptr->good() || stream_ptr->eof()) {
                    std::string s = sbuf.str();
                    if (ok) *ok = true;
                    return QByteArray(s.data(), static_cast<int>(s.length()));
                }
            }
        }
        return QByteArray();
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_tochrono.cpp
#include <QDate>
#include <QDateTime>
#include <QString>
#include <QTime>
#include <QTimeZone>  // For Qt 6
#include <charconv>
#include <chrono>
#include <cstdio>
#include <variant>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {
    namespace detail {
#ifndef SQLVALUE_HELPERS_DEFINED
#define SQLVALUE_HELPERS_DEFINED
// ...
#endif
    }  // namespace detail

    SqlValue::ChronoDate SqlValue::toChronoDate(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return ChronoDate{};

        if (std::holds_alternative<ChronoDate>(m_value_storage)) {
            const auto& cd = std::get<ChronoDate>(m_value_storage);
            if (cd.ok()) {
                if (ok) *ok = true;
                return cd;
            }
        }
        if (std::holds_alternative<QDate>(m_value_storage)) {
            const QDate& qd = std::get<QDate>(m_value_storage);
            if (qd.isValid()) {
                if (ok) *ok = true;
                return ChronoDate{std::chrono::year(qd.year()), std::chrono::month(static_cast<unsigned>(qd.month())), std::chrono::day(static_cast<unsigned>(qd.day()))};
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            if (s.length() == 10 && s[4] == '-' && s[7] == '-') {
                int y{}, M{}, d{};
                // 使用 sscanf 作为 from_chars 的简单替代，以避免 C++26 对 charconv 的完全依赖（尽管项目标准是26）
                // 如果 from_chars 可靠，则更好。
                if (std::sscanf(s.c_str(), "%d-%d-%d", &y, &M, &d) == 3) {
                    ChronoDate cd_parsed{std::chrono::year(y), std::chrono::month(static_cast<unsigned>(M)), std::chrono::day(static_cast<unsigned>(d))};
                    if (cd_parsed.ok()) {
                        if (ok) *ok = true;
                        return cd_parsed;
                    }
                }
            }
        }
        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                QDate qd = qdt.date();
                if (ok) *ok = true;
                return ChronoDate{std::chrono::year(qd.year()), std::chrono::month(static_cast<unsigned>(qd.month())), std::chrono::day(static_cast<unsigned>(qd.day()))};
            }
        }
        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            const auto& cdt = std::get<ChronoDateTime>(m_value_storage);
            auto dp = std::chrono::floor<std::chrono::days>(cdt);
            std::chrono::year_month_day ymd{dp};
            if (ymd.ok()) {
                if (ok) *ok = true;
                return ymd;
            }
        }
        return ChronoDate{};
    }

    SqlValue::ChronoTime SqlValue::toChronoTime(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return ChronoTime{};

        if (std::holds_alternative<ChronoTime>(m_value_storage)) {
            if (ok) *ok = true;
            return std::get<ChronoTime>(m_value_storage);
        }
        if (std::holds_alternative<QTime>(m_value_storage)) {
            const QTime& qt = std::get<QTime>(m_value_storage);
            if (qt.isValid()) {
                if (ok) *ok = true;
                return std::chrono::hours(qt.hour()) + std::chrono::minutes(qt.minute()) + std::chrono::seconds(qt.second()) + std::chrono::milliseconds(qt.msec());
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            int h{}, m{}, sec{};
            long us = 0;
            if (std::sscanf(s.c_str(), "%d:%d:%d.%6ld", &h, &m, &sec, &us) >= 3 || std::sscanf(s.c_str(), "%d:%d:%d", &h, &m, &sec) == 3) {
                if (s.find('.') == std::string::npos && s.find_last_of(':') != std::string::npos && s.find_last_of(':') > s.find(':')) us = 0;  // 确保无小数部分时 us 为0

                if (h >= 0 && h < 24 && m >= 0 && m < 60 && sec >= 0 && sec < 60 && us >= 0 && us < 1000000) {
                    if (ok) *ok = true;
                    return std::chrono::hours(h) + std::chrono::minutes(m) + std::chrono::seconds(sec) + std::chrono::microseconds(us);
                }
            }
        }
        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                QTime qt = qdt.time();
                if (ok) *ok = true;
                return std::chrono::hours(qt.hour()) + std::chrono::minutes(qt.minute()) + std::chrono::seconds(qt.second()) + std::chrono::milliseconds(qt.msec());
            }
        }
        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            const auto& cdt = std::get<ChronoDateTime>(m_value_storage);
            auto day_point = std::chrono::floor<std::chrono::days>(cdt);
            auto time_in_day = cdt - day_point;
            if (ok) *ok = true;
            return std::chrono::duration_cast<ChronoTime>(time_in_day);
        }
        return ChronoTime{};
    }

    SqlValue::ChronoDateTime SqlValue::toChronoDateTime(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return ChronoDateTime{};

        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            if (ok) *ok = true;
            return std::get<ChronoDateTime>(m_value_storage);
        }
        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                if (ok) *ok = true;
                // 使用 toSecsSinceEpoch，它返回相对于UTC的秒数
                std::chrono::seconds secs(qdt.toSecsSinceEpoch());
                std::chrono::milliseconds msecs_part(qdt.time().msec());
                // QDateTime::offsetFromUtc() 如果是本地时间，则返回与UTC的偏移量（秒）
                // 如果 qdt 本身是UTC，则 offsetFromUtc() 为0.
                // toSecsSinceEpoch 已经考虑了时区（如果是本地时间，会转换成UTC秒数）
                return std::chrono::system_clock::time_point(secs + msecs_part);
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            int y{}, M{}, d{}, h{}, m{}, sec{};
            long us = 0;
            char sep = 0, tz_char_dummy = 0;  // tz_char_dummy 用于捕获可能的 'Z' 或时区指示符，但我们不直接用它来调整
                                              // 因为 system_clock::time_point 通常是 UTC based.
                                              // 如果字符串中没有 'Z' 或时区，它可能被解析为本地时间，
                                              // 然后转换为 time_t (通常是本地)，再转为 system_clock (通常是UTC)。
                                              // 这种转换链条需要小心。
                                              // 一个健壮的解析器会处理时区。
            // ISO 8601-like: YYYY-MM-DD[T| ]HH:MM:SS[.ffffff][Z|+HH:MM|-HH:MM]
            // 简化版，主要处理 YYYY-MM-DD HH:MM:SS[.us]
            int items_read = std::sscanf(s.c_str(), "%d-%d-%d%c%d:%d:%d.%6ld", &y, &M, &d, &sep, &h, &m, &sec, &us);
            if (items_read < 7) {
                us = 0;
                items_read = std::sscanf(s.c_str(), "%d-%d-%d%c%d:%d:%d", &y, &M, &d, &sep, &h, &m, &sec);
            }

            if (items_read >= 7 && (sep == 'T' || sep == ' ')) {
                ChronoDate cd_part{std::chrono::year(y), std::chrono::month(static_cast<unsigned>(M)), std::chrono::day(static_cast<unsigned>(d))};
                if (cd_part.ok() && h >= 0 && h < 24 && m >= 0 && m < 60 && sec >= 0 && sec < 60 && us >= 0 && us < 1000000) {
                    // 将解析的本地时间组件转换为 time_t，然后转换为 system_clock::time_point (通常是UTC)
                    // 这依赖于 mktime 将本地时间转换为 UTC time_t (如果 TZ 环境变量设置正确等)
                    std::tm t{};
                    t.tm_year = y - 1900;
                    t.tm_mon = M - 1;
                    t.tm_mday = d;
                    t.tm_hour = h;
                    t.tm_min = m;
                    t.tm_sec = sec;
                    t.tm_isdst = -1;  // 让 mktime 决定夏令时
                    std::time_t tt = std::mktime(&t);
                    if (tt != -1) {
                        if (ok) *ok = true;
                        return std::chrono::system_clock::from_time_t(tt) + std::chrono::microseconds(us);
                    }
                }
            }
        }
        if (std::holds_alternative<QDate>(m_value_storage)) {
            const QDate& qd = std::get<QDate>(m_value_storage);
            if (qd.isValid()) {
                if (ok) *ok = true;
                // 转换为 UTC 午夜
                QDateTime qdt_utc(qd, QTime(0, 0, 0), QTimeZone::utc());
                return std::chrono::system_clock::from_time_t(qdt_utc.toSecsSinceEpoch());
            }
        }
        if (std::holds_alternative<ChronoDate>(m_value_storage)) {
            const auto& cd = std::get<ChronoDate>(m_value_storage);
            if (cd.ok()) {
                if (ok) *ok = true;
                return std::chrono::sys_days(cd);  // time_point at midnight UTC
            }
        }
        return ChronoDateTime{};
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_todatetime.cpp
#include <QDate>
#include <QDateTime>
#include <QString>
#include <QTime>
#include <QTimeZone>  // For Qt 6
#include <chrono>
#include <cstdio>  // for sscanf in string parsing (alternative to from_chars for simplicity here)
#include <variant>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {
    namespace detail {
#ifndef SQLVALUE_HELPERS_DEFINED
#define SQLVALUE_HELPERS_DEFINED
        // Forward declare or include helpers if they are in a separate file
        bool isValidChronoDate(const SqlValue::ChronoDate& cd);
        bool isValidChronoDateTime(const SqlValue::ChronoDateTime& cdt);
#endif
    }  // namespace detail

    QDate SqlValue::toDate(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return QDate();

        if (std::holds_alternative<QDate>(m_value_storage)) {
            const QDate& qd = std::get<QDate>(m_value_storage);
            if (qd.isValid()) {
                if (ok) *ok = true;
                return qd;
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            QDate d = QDate::fromString(QString::fromStdString(s), Qt::ISODate);
            if (d.isValid()) {
                if (ok) *ok = true;
                return d;
            }
            d = QDate::fromString(QString::fromStdString(s), "yyyy-MM-dd");
            if (d.isValid()) {
                if (ok) *ok = true;
                return d;
            }
        }
        if (std::holds_alternative<ChronoDate>(m_value_storage)) {
            const auto& cd = std::get<ChronoDate>(m_value_storage);
            if (cd.ok()) {
                QDate qd(static_cast<int>(cd.year()), static_cast<int>(static_cast<unsigned>(cd.month())), static_cast<int>(static_cast<unsigned>(cd.day())));
                if (qd.isValid()) {
                    if (ok) *ok = true;
                    return qd;
                }
            }
        }
        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                if (ok) *ok = true;
                return qdt.date();
            }
        }
        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            const auto& cdt = std::get<ChronoDateTime>(m_value_storage);
            std::time_t time_t_val = std::chrono::system_clock::to_time_t(cdt);
            std::tm tm_val{};
#ifdef _WIN32
            if (gmtime_s(&tm_val, &time_t_val) == 0) {  // UTC based
#else
            if (gmtime_r(&time_t_val, &tm_val) != nullptr) {  // UTC based
#endif
                QDate qd(tm_val.tm_year + 1900, tm_val.tm_mon + 1, tm_val.tm_mday);
                if (qd.isValid()) {
                    if (ok) *ok = true;
                    return qd;
                }
            }
        }
        return QDate();
    }

    QTime SqlValue::toTime(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return QTime();

        if (std::holds_alternative<QTime>(m_value_storage)) {
            const QTime& qt = std::get<QTime>(m_value_storage);
            if (qt.isValid()) {
                if (ok) *ok = true;
                return qt;
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            QTime t = QTime::fromString(QString::fromStdString(s), Qt::ISODateWithMs);
            if (!t.isValid()) t = QTime::fromString(QString::fromStdString(s), Qt::ISODate);
            if (!t.isValid()) t = QTime::fromString(QString::fromStdString(s), "HH:mm:ss.zzz");
            if (t.isValid()) {
                if (ok) *ok = true;
                return t;
            }
        }
        if (std::holds_alternative<ChronoTime>(m_value_storage)) {
            auto ct_ns = std::get<ChronoTime>(m_value_storage);
            auto ct_ms = std::chrono::duration_cast<std::chrono::milliseconds>(ct_ns);
            qint64 total_ms = ct_ms.count() % (24LL * 3600 * 1000);
            if (total_ms < 0) total_ms += (24LL * 3600 * 1000);
            QTime qt = QTime::fromMSecsSinceStartOfDay(static_cast<int>(total_ms));
            if (qt.isValid()) {
                if (ok) *ok = true;
                return qt;
            }
        }
        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                if (ok) *ok = true;
                return qdt.time();
            }
        }
        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            const auto& cdt = std::get<ChronoDateTime>(m_value_storage);
            auto time_since_epoch_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(cdt.time_since_epoch());
            auto ns_in_day = time_since_epoch_ns % std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::hours(24));
            if (ns_in_day.count() < 0) ns_in_day += std::chrono::hours(24);
            auto ms_in_day = std::chrono::duration_cast<std::chrono::milliseconds>(ns_in_day).count();
            QTime qt = QTime::fromMSecsSinceStartOfDay(static_cast<int>(ms_in_day));
            if (qt.isValid()) {
                if (ok) *ok = true;
                return qt;
            }
        }
        return QTime();
    }

    QDateTime SqlValue::toDateTime(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return QDateTime();

        if (std::holds_alternative<QDateTime>(m_value_storage)) {
            const QDateTime& qdt = std::get<QDateTime>(m_value_storage);
            if (qdt.isValid()) {
                if (ok) *ok = true;
                return qdt;
            }
        }
        if (std::holds_alternative<std::string>(m_value_storage)) {
            const std::string& s = std::get<std::string>(m_value_storage);
            QDateTime dt = QDateTime::fromString(QString::fromStdString(s), Qt::ISODateWithMs);
            if (!dt.isValid()) dt = QDateTime::fromString(QString::fromStdString(s), Qt::ISODate);
            if (!dt.isValid()) {
                dt = QDateTime::fromString(QString::fromStdString(s), "yyyy-MM-dd HH:mm:ss.zzz");
                if (!dt.isValid()) dt = QDateTime::fromString(QString::fromStdString(s), "yyyy-MM-dd HH:mm:ss");
            }
            if (dt.isValid()) {
                if (ok) *ok = true;
                return dt;
            }
        }
        if (std::holds_alternative<ChronoDateTime>(m_value_storage)) {
            const auto& cdt = std::get<ChronoDateTime>(m_value_storage);
            auto secs_since_epoch = std::chrono::time_point_cast<std::chrono::seconds>(cdt).time_since_epoch().count();
            auto micros_part = std::chrono::duration_cast<std::chrono::microseconds>(cdt.time_since_epoch() % std::chrono::seconds(1)).count();

            QDateTime qdt = QDateTime::fromSecsSinceEpoch(secs_since_epoch, QTimeZone::utc());  // 使用 QTimeZone::utc()
            qdt = qdt.addMSecs(static_cast<qint64>(micros_part / 1000));
            if (qdt.isValid()) {
                if (ok) *ok = true;
                return qdt;
            }
        }
        if (std::holds_alternative<QDate>(m_value_storage)) {
            const QDate& qd = std::get<QDate>(m_value_storage);
            if (qd.isValid()) {
                if (ok) *ok = true;
                return QDateTime(qd, QTime(0, 0, 0), QTimeZone::utc());  // 从 QDate 构造 QDateTime
            }
        }
        if (std::holds_alternative<ChronoDate>(m_value_storage)) {
            const auto& cd = std::get<ChronoDate>(m_value_storage);
            if (cd.ok()) {
                QDate qd(static_cast<int>(cd.year()), static_cast<int>(static_cast<unsigned>(cd.month())), static_cast<int>(static_cast<unsigned>(cd.day())));
                if (qd.isValid()) {
                    if (ok) *ok = true;
                    return QDateTime(qd, QTime(0, 0, 0), QTimeZone::utc());
                }
            }
        }
        return QDateTime();
    }

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_tolob.cpp
#include <sstream>
#include <variant>

#include "sqldriver/sql_value.h"
// QByteArray 的包含已移至 sql_value.h 或其他相关文件

namespace cpporm_sqldriver {

    SqlValue::InputStreamPtr SqlValue::toInputStream(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return nullptr;

        if (std::holds_alternative<InputStreamPtr>(m_value_storage)) {
            // 只有当类型确实是 BLOB 或 CLOB 时才返回，否则可能是意外的流
            if (m_current_type_enum == SqlValueType::BinaryLargeObject || m_current_type_enum == SqlValueType::CharacterLargeObject) {
                if (ok) *ok = true;
                return std::get<InputStreamPtr>(m_value_storage);
            }
        }
        // 从 std::vector<unsigned char> (代表 ByteArray 或内部 BLOB 数据) 创建流
        if (std::holds_alternative<std::vector<unsigned char>>(m_value_storage)) {
            const auto& vec = std::get<std::vector<unsigned char>>(m_value_storage);
            auto ss = std::make_shared<std::stringstream>();  // 使用 stringstream 作为通用的 istream
            // stringstream 需要 char*, 所以进行转换
            ss->write(reinterpret_cast<const char*>(vec.data()), static_cast<std::streamsize>(vec.size()));
            if (ss->good()) {  // 检查流状态
                if (ok) *ok = true;
                return ss;
            }
        }
        // 从 std::string (代表 CLOB 数据或可转换为流的字符串) 创建流
        if (std::holds_alternative<std::string>(m_value_storage)) {
            auto ss = std::make_shared<std::stringstream>();
            *ss << std::get<std::string>(m_value_storage);
            if (ss->good()) {
                if (ok) *ok = true;
                return ss;
            }
        }
        return nullptr;
    }

    // 旧的 BlobInputStream 和 ClobInputStream typedef 已被 InputStreamPtr 取代，
    // 因此 toBlobInputStream 和 toClobInputStream 方法应在 sql_value.h 中移除或调整为调用 toInputStream 并检查类型。
    // 这里假设它们已从头文件中移除，或者如果保留，它们的实现将如下：
    /*
    SqlValue::InputStreamPtr SqlValue::toBlobInputStream(bool* ok) const {
        if (m_current_type_enum == SqlValueType::BinaryLargeObject || m_current_type_enum == SqlValueType::ByteArray) {
            return toInputStream(ok); // 调用通用方法
        }
        if (ok) *ok = false;
        return nullptr;
    }

    SqlValue::InputStreamPtr SqlValue::toClobInputStream(bool* ok) const {
         if (m_current_type_enum == SqlValueType::CharacterLargeObject || m_current_type_enum == SqlValueType::String || m_current_type_enum == SqlValueType::FixedString) {
            return toInputStream(ok); // 调用通用方法
        }
        if (ok) *ok = false;
        return nullptr;
    }
    */

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_tonumeric.cpp
#include <algorithm>  // For std::transform (tolower)
#include <charconv>   // For std::from_chars
#include <limits>     // For std::numeric_limits
#include <string>     // For std::string
#include <variant>    // For std::visit

#include "sqldriver/sql_value.h"

// 辅助函数定义 (如果它们不放在 sql_value_helpers.cpp)
namespace cpporm_sqldriver {
    namespace detail {

        template <typename IntType>
        std::optional<IntType> stringToInteger(const std::string& s, bool* ok);  // 声明 (实现在 helpers 或此处)

        template <typename FloatType>
        std::optional<FloatType> stringToFloat(const std::string& s, bool* ok);  // 声明

// 如果 stringToInteger/Float 的定义不在此处，则需要包含 sql_value_helpers.cpp 或其头文件
// 为了独立编译，这里提供一个最小实现
#ifndef SQLVALUE_HELPERS_DEFINED  // 防止重复定义（如果 helpers 文件也包含它们）
#define SQLVALUE_HELPERS_DEFINED
        template <typename IntType>
        std::optional<IntType> stringToInteger(const std::string& s, bool* ok) {
            if (s.empty()) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            IntType val{};
            size_t first = s.find_first_not_of(" \t\n\r\f\v");
            if (first == std::string::npos) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t last = s.find_last_not_of(" \t\n\r\f\v");
            std::string_view sv_trimmed = std::string_view(s).substr(first, last - first + 1);
            auto [ptr, ec] = std::from_chars(sv_trimmed.data(), sv_trimmed.data() + sv_trimmed.size(), val);
            if (ec == std::errc() && ptr == sv_trimmed.data() + sv_trimmed.size()) {
                if (ok) *ok = true;
                return val;
            }
            if (ok) *ok = false;
            return std::nullopt;
        }

        template <typename FloatType>
        std::optional<FloatType> stringToFloat(const std::string& s, bool* ok) {
            if (s.empty()) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t first = s.find_first_not_of(" \t\n\r\f\v");
            if (first == std::string::npos) {
                if (ok) *ok = false;
                return std::nullopt;
            }
            size_t last = s.find_last_not_of(" \t\n\r\f\v");
            std::string s_trimmed = s.substr(first, last - first + 1);
            try {
                size_t idx = 0;
                FloatType val{};
                if constexpr (std::is_same_v<FloatType, float>)
                    val = std::stof(s_trimmed, &idx);
                else if constexpr (std::is_same_v<FloatType, double>)
                    val = std::stod(s_trimmed, &idx);
                else if constexpr (std::is_same_v<FloatType, long double>)
                    val = std::stold(s_trimmed, &idx);
                if (idx == s_trimmed.length()) {
                    if (ok) *ok = true;
                    return val;
                }
            } catch (...) {
            }
            if (ok) *ok = false;
            return std::nullopt;
        }
#endif  // SQLVALUE_HELPERS_DEFINED
    }  // namespace detail

    bool SqlValue::toBool(bool* ok) const {
        if (ok) *ok = false;
        if (isNull()) return false;

        return std::visit(
            [ok](auto&& arg) -> bool {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, bool>) {
                    if (ok) *ok = true;
                    return arg;
                } else if constexpr (std::is_same_v<T, int8_t> || std::is_same_v<T, uint8_t> || std::is_same_v<T, int16_t> || std::is_same_v<T, uint16_t> || std::is_same_v<T, int32_t> || std::is_same_v<T, uint32_t> || std::is_same_v<T, int64_t> || std::is_same_v<T, uint64_t>) {
                    if (ok) *ok = true;
                    return arg != 0;
                } else if constexpr (std::is_same_v<T, float> || std::is_same_v<T, double> || std::is_same_v<T, long double>) {
                    if (ok) *ok = true;
                    return arg != static_cast<T>(0.0);
                } else if constexpr (std::is_same_v<T, std::string>) {
                    std::string s_lower = arg;
                    std::transform(s_lower.begin(), s_lower.end(), s_lower.begin(), [](unsigned char c) {
                        return static_cast<char>(std::tolower(c));
                    });
                    if (s_lower == "true" || s_lower == "1" || s_lower == "t" || s_lower == "yes" || s_lower == "on") {
                        if (ok) *ok = true;
                        return true;
                    }
                    if (s_lower == "false" || s_lower == "0" || s_lower == "f" || s_lower == "no" || s_lower == "off") {
                        if (ok) *ok = true;
                        return false;
                    }
                }
                return false;
            },
            m_value_storage);
    }

// 使用之前定义的宏，现在它包含了更完整的转换逻辑
#define SQLVALUE_TO_NUMERIC_IMPL_DEF(ReturnType, VariantTypeOrBase, MethodName, DefaultValIfNull)                                                                                                                                            \
    ReturnType SqlValue::MethodName(bool* ok, NumericalPrecisionPolicy policy) const {                                                                                                                                                       \
        if (ok) *ok = false;                                                                                                                                                                                                                 \
        if (isNull()) return DefaultValIfNull;                                                                                                                                                                                               \
        /* 1. 尝试直接获取 (如果内部存储的就是目标类型或其基础类型) */                                                                                                                                                                       \
        if constexpr (std::is_floating_point_v<ReturnType>) { /* 目标是浮点数 */                                                                                                                                                             \
            if (std::holds_alternative<ReturnType>(m_value_storage)) {                                                                                                                                                                       \
                if (ok) *ok = true;                                                                                                                                                                                                          \
                return std::get<ReturnType>(m_value_storage);                                                                                                                                                                                \
            } else if (std::holds_alternative<float>(m_value_storage) && !std::is_same_v<ReturnType, float>) {                                                                                                                               \
                if (ok) *ok = true;                                                                                                                                                                                                          \
                return static_cast<ReturnType>(std::get<float>(m_value_storage));                                                                                                                                                            \
            } else if (std::holds_alternative<double>(m_value_storage) && !std::is_same_v<ReturnType, double>) {                                                                                                                             \
                if (ok) *ok = true;                                                                                                                                                                                                          \
                return static_cast<ReturnType>(std::get<double>(m_value_storage));                                                                                                                                                           \
            } else if (std::holds_alternative<long double>(m_value_storage) && !std::is_same_v<ReturnType, long double>) {                                                                                                                   \
                if (ok) *ok = true;                                                                                                                                                                                                          \
                return static_cast<ReturnType>(std::get<long double>(m_value_storage));                                                                                                                                                      \
            }                                                                                                                                                                                                                                \
        } else if constexpr (std::is_integral_v<ReturnType>) { /* 目标是整数 */                                                                                                                                                              \
            if (std::holds_alternative<ReturnType>(m_value_storage)) {                                                                                                                                                                       \
                if (ok) *ok = true;                                                                                                                                                                                                          \
                return std::get<ReturnType>(m_value_storage);                                                                                                                                                                                \
            }                                                                                                                                                                                                                                \
        }                                                                                                                                                                                                                                    \
        /* 2. 尝试从其他数字类型转换 */                                                                                                                                                                                                      \
        return std::visit(                                                                                                                                                                                                                   \
            [ok, policy](auto&& arg) -> ReturnType {                                                                                                                                                                                         \
                using SrcT = std::decay_t<decltype(arg)>;                                                                                                                                                                                    \
                if constexpr (std::is_arithmetic_v<SrcT> && !std::is_same_v<SrcT, bool>) {                                                                                                                                                   \
                    if constexpr (std::is_floating_point_v<ReturnType>) { /* int to float/double/ldouble, float to double/ldouble, double to ldouble */                                                                                      \
                                                                          /* 检查范围对于整数转浮点数通常不是问题，除非是非常大的整数 */                                                                                                     \
                        if constexpr (std::is_integral_v<SrcT>) {                                                                                                                                                                            \
                            if (static_cast<long double>(arg) >= static_cast<long double>(std::numeric_limits<ReturnType>::lowest()) && static_cast<long double>(arg) <= static_cast<long double>(std::numeric_limits<ReturnType>::max())) { \
                                if (ok) *ok = true;                                                                                                                                                                                          \
                                return static_cast<ReturnType>(arg);                                                                                                                                                                         \
                            }                                                                                                                                                                                                                \
                        } else { /* float to float/double/ldouble */                                                                                                                                                                         \
                            if (ok) *ok = true;                                                                                                                                                                                              \
                            return static_cast<ReturnType>(arg);                                                                                                                                                                             \
                        }                                                                                                                                                                                                                    \
                    } else if constexpr (std::is_integral_v<ReturnType>) {                 /* float/double/ldouble to int, or int to int */                                                                                                  \
                        if constexpr (std::is_floating_point_v<SrcT>) {                    /* float/double to int */                                                                                                                         \
                            if (policy != NumericalPrecisionPolicy::ExactRepresentation) { /* 允许截断 */                                                                                                                                    \
                                if (arg >= static_cast<SrcT>(std::numeric_limits<ReturnType>::lowest()) && arg <= static_cast<SrcT>(std::numeric_limits<ReturnType>::max())) {                                                               \
                                    if (ok) *ok = true;                                                                                                                                                                                      \
                                    return static_cast<ReturnType>(arg);                                                                                                                                                                     \
                                }                                                                                                                                                                                                            \
                            }                                                                                                                                                                                                                \
                        } else { /* int to int */                                                                                                                                                                                            \
                            if (arg >= static_cast<long long>(std::numeric_limits<ReturnType>::min()) && arg <= static_cast<long long>(std::numeric_limits<ReturnType>::max())) {                                                            \
                                if (ok) *ok = true;                                                                                                                                                                                          \
                                return static_cast<ReturnType>(arg);                                                                                                                                                                         \
                            }                                                                                                                                                                                                                \
                        }                                                                                                                                                                                                                    \
                    }                                                                                                                                                                                                                        \
                } else if constexpr (std::is_same_v<SrcT, std::string>) {                                                                                                                                                                    \
                    if (policy != NumericalPrecisionPolicy::ExactRepresentation) {                                                                                                                                                           \
                        if constexpr (std::is_integral_v<ReturnType>) {                                                                                                                                                                      \
                            auto converted = detail::stringToInteger<ReturnType>(arg, ok);                                                                                                                                                   \
                            if (converted) return *converted;                                                                                                                                                                                \
                        } else if constexpr (std::is_floating_point_v<ReturnType>) {                                                                                                                                                         \
                            auto converted = detail::stringToFloat<ReturnType>(arg, ok);                                                                                                                                                     \
                            if (converted) return *converted;                                                                                                                                                                                \
                        }                                                                                                                                                                                                                    \
                    }                                                                                                                                                                                                                        \
                } else if constexpr (std::is_same_v<SrcT, bool> && std::is_arithmetic_v<ReturnType>) {                                                                                                                                       \
                    if (ok) *ok = true;                                                                                                                                                                                                      \
                    return static_cast<ReturnType>(arg ? 1 : 0);                                                                                                                                                                             \
                }                                                                                                                                                                                                                            \
                return DefaultValIfNull;                                                                                                                                                                                                     \
            },                                                                                                                                                                                                                               \
            m_value_storage);                                                                                                                                                                                                                \
    }

    SQLVALUE_TO_NUMERIC_IMPL_DEF(int8_t, int8_t, toInt8, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(uint8_t, uint8_t, toUInt8, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(int16_t, int16_t, toInt16, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(uint16_t, uint16_t, toUInt16, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(int32_t, int32_t, toInt32, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(uint32_t, uint32_t, toUInt32, 0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(int64_t, int64_t, toInt64, 0LL)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(uint64_t, uint64_t, toUInt64, 0ULL)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(float, float, toFloat, 0.0f)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(double, double, toDouble, 0.0)
    SQLVALUE_TO_NUMERIC_IMPL_DEF(long double, long double, toLongDouble, 0.0L)

}  // namespace cpporm_sqldriver// SqlDriver/Source/sql_value_tostring.cpp
#include <QDate>
#include <QDateTime>
#include <QTime>
#include <algorithm>  // For std::transform in boolean string conversion
#include <format>     // C++20/23/26 feature
#include <iomanip>
#include <limits>
#include <sstream>  // 仍然需要 ostringstream 用于浮点数，直到 std::format 对浮点数的支持完美且普遍
#include <string>
#include <variant>
#include <vector>

#include "sqldriver/sql_value.h"

namespace cpporm_sqldriver {
    namespace detail {
        std::string blobToHexString(const std::vector<unsigned char>& blob);  // 声明来自 helpers
    }

    std::string SqlValue::toString(bool* ok, NumericalPrecisionPolicy /*policy*/) const {
        if (ok) *ok = false;
        if (isNull()) {
            if (ok) *ok = true;
            return "";
        }

        return std::visit(
            [ok, this](auto&& arg) -> std::string {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    if (ok) *ok = true;
                    return "";
                } else if constexpr (std::is_same_v<T, bool>) {
                    if (ok) *ok = true;
                    return arg ? "true" : "false";
                } else if constexpr (std::is_integral_v<T>) {
                    if (ok) *ok = true;
                    return std::to_string(arg);
                }  // std::format("{}"...) 也可以
                else if constexpr (std::is_floating_point_v<T>) {
                    // std::format 对浮点数的默认精度可能与 std::ostringstream 不同，
                    // 如果需要特定精度，可能仍需 ostringstream 或显式格式化参数。
                    // C++23/26 的 std::format 对浮点数应该有很好的支持。
                    if (ok) *ok = true;
                    // 使用 std::format，如果默认精度不够，可以指定
                    // return std::format("{}", arg); // 默认精度
                    // 为了最大精度，ostringstream 仍然是一个选择，或者使用更精确的 std::format 参数
                    std::ostringstream oss;
                    oss << std::setprecision(std::numeric_limits<T>::max_digits10) << arg;
                    if (oss.fail()) {
                        return "";
                    }
                    return oss.str();
                } else if constexpr (std::is_same_v<T, std::string>) {
                    if (ok) *ok = true;
                    return arg;
                } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                    if (ok) *ok = true;
                    return detail::blobToHexString(arg);
                } else if constexpr (std::is_same_v<T, QDate>) {
                    if (arg.isValid()) {
                        if (ok) *ok = true;
                        return arg.toString(Qt::ISODate).toStdString();
                    }
                } else if constexpr (std::is_same_v<T, QTime>) {
                    if (arg.isValid()) {
                        if (ok) *ok = true;
                        return arg.toString(Qt::ISODateWithMs).toStdString();
                    }
                } else if constexpr (std::is_same_v<T, QDateTime>) {
                    if (arg.isValid()) {
                        if (ok) *ok = true;
                        return arg.toString(Qt::ISODateWithMs).toStdString();
                    }
                } else if constexpr (std::is_same_v<T, ChronoDate>) {
                    if (arg.ok()) {
                        if (ok) *ok = true;
                        return std::format("{:%Y-%m-%d}", arg);
                    }
                } else if constexpr (std::is_same_v<T, ChronoTime>) {
                    if (ok) *ok = true;
                    // std::format 支持 std::chrono::duration
                    // 例如 "{:%H:%M:%S}" ，但可能需要 hh_mm_ss 适配器或手动格式化子秒
                    auto h = std::chrono::duration_cast<std::chrono::hours>(arg);
                    auto m = std::chrono::duration_cast<std::chrono::minutes>(arg % std::chrono::hours(1));
                    auto s = std::chrono::duration_cast<std::chrono::seconds>(arg % std::chrono::minutes(1));
                    auto us = std::chrono::duration_cast<std::chrono::microseconds>(arg % std::chrono::seconds(1));
                    std::string formatted_time = std::format("{:%T}", std::chrono::hh_mm_ss(arg).to_duration());  // %T is HH:MM:SS
                    if (us.count() != 0) {
                        std::string us_str = std::format("{:06}", us.count());
                        size_t last_digit = us_str.find_last_not_of('0');
                        if (last_digit != std::string::npos) {
                            formatted_time += "." + us_str.substr(0, last_digit + 1);
                        }
                    }
                    return formatted_time;
                } else if constexpr (std::is_same_v<T, ChronoDateTime>) {
                    if (ok) *ok = true;
                    // std::format 支持 system_clock::time_point，通常输出为 UTC ISO 8601
                    // 包含小数秒和 'Z'
                    return std::format("{:%Y-%m-%dT%H:%M:%S}Z", std::chrono::floor<std::chrono::seconds>(arg));  // 简化，去除小数秒以匹配之前的行为
                    // 要包含小数秒:
                    // return std::format("{0:%Y-%m-%dT%H:%M:%S}{1:%S}Z", arg, arg.time_since_epoch() % std::chrono::seconds(1)); // 这比较复杂
                    // 更简单的方法是针对 time_point 使用默认的 std::format，它通常做得很好
                    // return std::format("{}", arg); // C++26 应该对 time_point 有好的默认格式
                } else if constexpr (std::is_same_v<T, InputStreamPtr>) {
                    if (ok) *ok = true;
                    if (this->m_current_type_enum == SqlValueType::BinaryLargeObject) return "[BLOB StreamData]";
                    if (this->m_current_type_enum == SqlValueType::CharacterLargeObject) return "[CLOB StreamData]";
                    return "[InputStreamData]";
                } else if constexpr (std::is_same_v<T, std::any>) {
                    if (arg.type() == typeid(std::string)) {
                        if (ok) *ok = true;
                        return std::any_cast<std::string>(arg);
                    }
                    if (arg.type() == typeid(const char*)) {
                        if (ok) *ok = true;
                        return std::string(std::any_cast<const char*>(arg));
                    }
                    if (ok) *ok = true;
                    return "[CustomAnyData]";
                }
                return "";
            },
            m_value_storage);
    }

}  // namespace cpporm_sqldriverfile(GLOB_RECURSE MYSQL_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(MySqlTransport ${MYSQL_TRANSPORT_SOURCE})

target_include_directories(MySqlTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(MySqlTransport PUBLIC Qt6::Core MysqlProtocol)

# # build example, no condition
# add_subdirectory(Example)
// cpporm_mysql_transport/mysql_transport_charset_handler.h
#pragma once

#include <mysql/mysql.h>

#include <optional>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportCharsetHandler {
      public:
        explicit MySqlTransportCharsetHandler(MySqlTransportConnection* connection_context);

        // Sets charset using mysql_set_character_set() if connected,
        // or mysql_options(MYSQL_SET_CHARSET_NAME) if before connection.
        // The 'is_pre_connect' flag indicates if this is called before mysql_real_connect.
        bool setClientCharset(MYSQL* mysql_handle, const std::string& charset_name, bool is_pre_connect);

        std::optional<std::string> getClientCharset(MYSQL* mysql_handle, bool is_connected) const;

      private:
        friend class MySqlTransportConnection;  // Added friend declaration
        MySqlTransportConnection* m_conn_ctx;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportFieldMeta, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportColumnLister {
      public:
        explicit MySqlTransportColumnLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<MySqlTransportFieldMeta>> getTableColumns(const std::string& table_name, const std::string& db_name_filter = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");

        // Helper to parse the 'Type' string from SHOW COLUMNS output
        // This is a complex function and a key part of this lister.
        bool parseMySQLTypeString(const std::string& type_str, MySqlTransportFieldMeta& field_meta_to_update) const;
    };

}  // namespace cpporm_mysql_transport// Include/cpporm_mysql_transport/mysql_transport_connection.h
#pragma once

#include <mysql/mysql.h>

#include <atomic>
#include <memory>
#include <mutex>
#include <optional>
#include <string>

// Forward declare helper classes if they are only used by unique_ptr in private section
// Otherwise, include their headers directly.
// For PImpl, these are typical forward declarations:
// class MySqlTransportConnectionOptionsSetter;
// class MySqlTransportTransactionManager;
// class MySqlTransportCharsetHandler;
// class MySqlTransportServerInfoProvider;
// However, since they are included in the .cpp and their methods are called,
// it's better to include headers if they are not purely internal details of the PImpl.
// Given the current structure, they seem to be components.

#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"
#include "cpporm_mysql_transport/mysql_transport_connection_options_setter.h"
#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"
#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"
#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportConnectionParams, MySqlNativeValue (via protocol)
#include "mysql_protocol/mysql_type_converter.h"           // For MySqlNativeValue if not fully via types.h

namespace cpporm_mysql_transport {

    class MySqlTransportStatement;  // Forward declaration
    void ensure_mysql_library_initialized();
    void try_mysql_library_end();

    class MySqlTransportConnection {
      public:
        MySqlTransportConnection();
        ~MySqlTransportConnection();

        MySqlTransportConnection(const MySqlTransportConnection&) = delete;
        MySqlTransportConnection& operator=(const MySqlTransportConnection&) = delete;
        MySqlTransportConnection(MySqlTransportConnection&& other) noexcept;
        MySqlTransportConnection& operator=(MySqlTransportConnection&& other) noexcept;

        bool connect(const MySqlTransportConnectionParams& params);
        void disconnect();
        bool isConnected() const;
        bool ping(std::optional<unsigned int> timeout_seconds = std::nullopt);

        std::unique_ptr<MySqlTransportStatement> createStatement(const std::string& query);

        // Transaction methods delegated to m_transaction_manager
        bool beginTransaction();
        bool commit();
        bool rollback();
        bool setTransactionIsolation(TransactionIsolationLevel level);
        std::optional<TransactionIsolationLevel> getTransactionIsolation() const;
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        // Charset methods delegated to m_charset_handler
        bool setClientCharset(const std::string& charset_name);
        std::optional<std::string> getClientCharset() const;

        // Server info methods delegated to m_server_info_provider
        std::string getServerVersionString() const;
        unsigned long getServerVersionNumber() const;
        std::string getHostInfo() const;

        MySqlTransportError getLastError() const;

        // Utility methods
        std::string escapeString(const std::string& unescaped_str, bool treat_backslash_as_meta = true);
        std::string formatNativeValueAsLiteral(const mysql_protocol::MySqlNativeValue& nativeValue) const;
        std::string escapeSqlIdentifier(const std::string& identifier) const;

        MYSQL* getNativeHandle() const {
            return m_mysql_handle;
        }
        const MySqlTransportConnectionParams& getCurrentParams() const {
            return m_current_params;
        }

        // Methods for internal use by components (e.g., TransactionManager, CharsetHandler)
        // These should ideally be less public or managed via friend classes / interfaces.
        // For simplicity, making them public but with an underscore prefix to indicate intended internal use.
        bool _internalExecuteSimpleQuery(const std::string& query, const std::string& context_message);
        void setErrorFromMySqlHandle(MYSQL* handle_to_check_error_on, const std::string& context_message);
        void setErrorManually(MySqlTransportError::Category cat, const std::string& msg, int native_mysql_err = 0, const char* native_sql_state = nullptr, const char* native_mysql_msg = nullptr, unsigned int proto_errc = 0);
        void recordPreConnectOptionError(const std::string& option_error_message);

      private:
        void clearError();  // Clears m_last_error

        MYSQL* m_mysql_handle;
        bool m_is_connected;
        MySqlTransportConnectionParams m_current_params;
        MySqlTransportError m_last_error;
        TransactionIsolationLevel m_current_isolation_level;  // Cached isolation level for getTransactionIsolation

        // Components
        std::unique_ptr<MySqlTransportConnectionOptionsSetter> m_options_setter;
        std::unique_ptr<MySqlTransportTransactionManager> m_transaction_manager;
        std::unique_ptr<MySqlTransportCharsetHandler> m_charset_handler;
        std::unique_ptr<MySqlTransportServerInfoProvider> m_server_info_provider;
    };

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_options_setter.h
#pragma once

#include <mysql/mysql.h>

#include <map>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportConnectionParams, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration for context

    class MySqlTransportConnectionOptionsSetter {
      public:
        explicit MySqlTransportConnectionOptionsSetter(MySqlTransportConnection* connection_context);

        // Applies options from params to the MYSQL handle BEFORE mysql_real_connect
        // Returns true on success, false on failure (error set in connection_context)
        bool applyPreConnectOptions(MYSQL* mysql_handle, const MySqlTransportConnectionParams& params);

      private:
        friend class MySqlTransportConnection;  // Added friend declaration
        MySqlTransportConnection* m_conn_ctx;   // Context to set errors

        // Helper to map SSL mode string to MySQL option value
        unsigned int mapSslModeStringToValue(const std::string& mode_str) const;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportDatabaseLister {
      public:
        explicit MySqlTransportDatabaseLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<std::string>> listDatabases(const std::string& db_name_pattern = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;  // For executing queries and accessing connection utilities
        mutable MySqlTransportError m_last_error;

        void clearError_();  // Suffix to avoid conflict if MySqlTransportMetadata also has one
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportIndexInfo, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportIndexLister {
      public:
        explicit MySqlTransportIndexLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<MySqlTransportIndexInfo>> getTableIndexes(const std::string& table_name, const std::string& db_name_filter = "");
        std::optional<MySqlTransportIndexInfo> getPrimaryIndex(const std::string& table_name, const std::string& db_name_filter = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");
    };

}  // namespace cpporm_mysql_transport#pragma once

#include "cpporm_mysql_transport/mysql_transport_types.h"
// Forward declarations for PImpl or direct inclusion of helper headers
#include <memory>  // For std::unique_ptr
#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_column_lister.h"
#include "cpporm_mysql_transport/mysql_transport_database_lister.h"
#include "cpporm_mysql_transport/mysql_transport_index_lister.h"
#include "cpporm_mysql_transport/mysql_transport_table_lister.h"

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportMetadata {
      public:
        explicit MySqlTransportMetadata(MySqlTransportConnection* conn);
        ~MySqlTransportMetadata();  // Required for unique_ptr to incomplete types if defined in .cpp

        // Movable (if unique_ptrs are handled correctly)
        MySqlTransportMetadata(MySqlTransportMetadata&& other) noexcept;
        MySqlTransportMetadata& operator=(MySqlTransportMetadata&& other) noexcept;
        // Non-copyable
        MySqlTransportMetadata(const MySqlTransportMetadata&) = delete;
        MySqlTransportMetadata& operator=(const MySqlTransportMetadata&) = delete;

        // Delegated methods
        std::optional<std::vector<std::string>> listDatabases(const std::string& db_name_pattern = "");
        std::optional<std::vector<std::string>> listTables(const std::string& db_name = "", const std::string& table_name_pattern = "");
        std::optional<std::vector<std::string>> listViews(const std::string& db_name = "", const std::string& view_name_pattern = "");
        std::optional<std::vector<MySqlTransportFieldMeta>> getTableColumns(const std::string& table_name, const std::string& db_name = "");
        std::optional<std::vector<MySqlTransportIndexInfo>> getTableIndexes(const std::string& table_name, const std::string& db_name = "");
        std::optional<MySqlTransportIndexInfo> getPrimaryIndex(const std::string& table_name, const std::string& db_name = "");

        MySqlTransportError getLastError() const;

      private:
        // MySqlTransportConnection* m_connection_ctx; // No longer needed if all ops are via listers that store it
        mutable MySqlTransportError m_last_error_aggregator;  // Aggregates error from the last lister call

        std::unique_ptr<MySqlTransportDatabaseLister> m_db_lister;
        std::unique_ptr<MySqlTransportTableLister> m_table_lister;
        std::unique_ptr<MySqlTransportColumnLister> m_column_lister;
        std::unique_ptr<MySqlTransportIndexLister> m_index_lister;

        void clearError();                                // Clears m_last_error_aggregator
        void setError(const MySqlTransportError& error);  // Sets m_last_error_aggregator

        // Template helper to call a lister and update aggregated error
        template <typename ListerPtr, typename Method, typename... Args>
        auto callLister(ListerPtr& lister_ptr, Method method, const std::string& error_context, Args&&... args) -> decltype(((*lister_ptr).*method)(std::forward<Args>(args)...));
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <memory>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    class MySqlTransportStatement;

    class MySqlTransportResult {
      public:
        // 构造函数（针对预处理语句 MYSQL_STMT*）
        MySqlTransportResult(MySqlTransportStatement* stmt, MYSQL_RES* meta_res_handle, const MySqlTransportError& initial_error);  // 修改：接收 const MySqlTransportError&
        // 构造函数（针对非预处理语句 MYSQL_RES* from mysql_store_result）
        MySqlTransportResult(MYSQL_RES* stored_res_handle, const MySqlTransportError& initial_error);  // 修改：接收 const MySqlTransportError&
        ~MySqlTransportResult();

        MySqlTransportResult(const MySqlTransportResult&) = delete;
        MySqlTransportResult& operator=(const MySqlTransportResult&) = delete;
        MySqlTransportResult(MySqlTransportResult&& other) noexcept;
        MySqlTransportResult& operator=(MySqlTransportResult&& other) noexcept;

        bool isValid() const;
        MySqlTransportError getError() const;  // 返回副本
        my_ulonglong getRowCount() const;
        unsigned int getFieldCount() const;
        const std::vector<MySqlTransportFieldMeta>& getFieldsMeta() const;
        std::optional<MySqlTransportFieldMeta> getFieldMeta(unsigned int col_idx) const;
        std::optional<MySqlTransportFieldMeta> getFieldMeta(const std::string& col_name) const;
        int getFieldIndex(const std::string& col_name) const;

        bool fetchNextRow();
        std::optional<mysql_protocol::MySqlNativeValue> getValue(unsigned int col_idx);
        std::optional<mysql_protocol::MySqlNativeValue> getValue(const std::string& col_name);
        bool isNull(unsigned int col_idx);
        bool isNull(const std::string& col_name);
        std::vector<mysql_protocol::MySqlNativeValue> getCurrentRowValues();

        MYSQL_RES* getNativeMetadataHandle() const {
            return m_mysql_res_metadata;
        }
        MYSQL_STMT* getNativeStatementHandleForFetch() const {
            return m_mysql_stmt_handle_for_fetch;
        }

      private:
        void populateFieldsMeta();
        void clearCurrentRow();
        void setupOutputBindBuffers();

        MySqlTransportStatement* m_statement;         // Null if from non-prepared MYSQL_RES
        MYSQL_RES* m_mysql_res_metadata;              // Metadata for prepared, or full result for non-prepared
        MYSQL_STMT* m_mysql_stmt_handle_for_fetch;    // Only for prepared statements for fetching
        MySqlTransportError m_error_collector_owned;  // 修改：错误对象为值类型

        std::vector<MySqlTransportFieldMeta> m_fields_meta;
        MYSQL_ROW m_current_sql_row;
        unsigned long* m_current_lengths;
        my_ulonglong m_row_count = 0;
        unsigned int m_field_count = 0;
        long long m_current_row_idx = -1;
        bool m_meta_populated = false;
        bool m_is_valid = false;
        bool m_is_from_prepared_statement = false;
        bool m_stmt_result_was_stored = false;
        bool m_fetched_all_from_stmt = false;

        std::vector<MYSQL_BIND> m_output_bind_buffers;
        std::vector<std::vector<unsigned char>> m_output_data_buffers;
        std::vector<char> m_output_is_null_indicators;
        std::vector<unsigned long> m_output_length_indicators;
        std::vector<char> m_output_error_indicators;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <string>

namespace cpporm_mysql_transport {

    // This class is very simple, could also be static methods or part of Connection directly.
    class MySqlTransportServerInfoProvider {
      public:
        // Constructor might not be needed if all methods are static or take MYSQL*
        MySqlTransportServerInfoProvider() = default;

        std::string getServerVersionString(MYSQL* mysql_handle) const;
        unsigned long getServerVersionNumber(MYSQL* mysql_handle) const;  // e.g., 80023 for 8.0.23
        std::string getHostInfo(MYSQL* mysql_handle, bool is_connected) const;
        // Potentially add more info getters, e.g., thread ID, protocol version
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "mysql_transport_result.h"
#include "mysql_transport_types.h"

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;

    class MySqlTransportStatement {
      public:
        MySqlTransportStatement(MySqlTransportConnection* conn, const std::string& query);
        ~MySqlTransportStatement();

        MySqlTransportStatement(const MySqlTransportStatement&) = delete;
        MySqlTransportStatement& operator=(const MySqlTransportStatement&) = delete;
        MySqlTransportStatement(MySqlTransportStatement&& other) noexcept;
        MySqlTransportStatement& operator=(MySqlTransportStatement&& other) noexcept;

        bool prepare();
        bool isPrepared() const;

        bool bindParam(unsigned int pos_zero_based, const MySqlTransportBindParam& param);
        bool bindParams(const std::vector<MySqlTransportBindParam>& params);

        std::optional<my_ulonglong> execute();                 // For DML
        std::unique_ptr<MySqlTransportResult> executeQuery();  // For SELECT and utility commands like SHOW

        my_ulonglong getAffectedRows() const;
        my_ulonglong getLastInsertId() const;
        unsigned int getWarningCount() const;

        MySqlTransportError getError() const;

        void close();

        MYSQL_STMT* getNativeStatementHandle() const {
            return m_stmt_handle;
        }
        MySqlTransportConnection* getConnection() const {
            return m_connection;
        }
        bool isUtilityCommand() const {
            return m_is_utility_command;
        }

      private:
        void clearError();
        void setError(MySqlTransportError::Category cat, const std::string& msg, unsigned int proto_errc = 0);
        // 更正：明确区分从连接句柄和语句句柄获取错误
        void setErrorFromConnectionHandle(MYSQL* handle_to_check_error_on, const std::string& context);
        void setErrorFromStatementHandle(const std::string& context);
        void setErrorFromProtocol(const mysql_protocol::MySqlProtocolError& proto_err, const std::string& context);

        MySqlTransportConnection* m_connection;
        std::string m_original_query;
        MYSQL_STMT* m_stmt_handle;  // 对于工具类命令，此指针为 nullptr
        bool m_is_prepared;
        bool m_is_utility_command;

        std::vector<MYSQL_BIND> m_bind_buffers;
        std::vector<std::vector<unsigned char>> m_param_data_buffers;
        std::vector<unsigned char> m_param_is_null_indicators;
        std::vector<unsigned long> m_param_length_indicators;

        MySqlTransportError m_last_error;
        my_ulonglong m_affected_rows;
        my_ulonglong m_last_insert_id;
        unsigned int m_warning_count;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportTableLister {
      public:
        explicit MySqlTransportTableLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<std::string>> listTables(const std::string& db_name_filter = "", const std::string& table_name_pattern = "");
        std::optional<std::vector<std::string>> listViews(const std::string& db_name_filter = "", const std::string& view_name_pattern = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");

        // Helper for common logic of SHOW FULL TABLES
        std::optional<std::vector<std::string>> listShowFullTablesFiltered(const std::string& db_name_filter,
                                                                           const std::string& name_pattern,
                                                                           const std::string& target_table_type  // "BASE TABLE" or "VIEW"
        );
    };

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_transaction_manager.h
#pragma once

#include <optional>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For TransactionIsolationLevel, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration for context

    class MySqlTransportTransactionManager {
      public:
        explicit MySqlTransportTransactionManager(MySqlTransportConnection* connection_context);

        bool beginTransaction();
        bool commit();
        bool rollback();
        bool setTransactionIsolation(TransactionIsolationLevel level);
        std::optional<TransactionIsolationLevel> getTransactionIsolation() const;  // May query server
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        // This method is to update the cached isolation level if changed externally or on new connection
        void updateCachedIsolationLevel(TransactionIsolationLevel level);

      private:
        friend class MySqlTransportConnection;               // Added friend declaration
        MySqlTransportConnection* m_conn_ctx;                // Pointer to the parent connection
        TransactionIsolationLevel m_cached_isolation_level;  // Cache to avoid frequent server queries

        // Helper to execute simple queries via the connection context
        bool executeSimpleQueryOnConnection(const std::string& query, const std::string& context_message);
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <algorithm>  // For std::transform in toString example (if any)
#include <chrono>
#include <map>
#include <optional>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    // --- 错误处理 ---
    struct MySqlTransportError {
        enum class Category { NoError, ConnectionError, QueryError, DataError, ResourceError, TransactionError, InternalError, ProtocolError, ApiUsageError };

        Category category = Category::NoError;
        int native_mysql_errno = 0;
        std::string native_mysql_sqlstate;
        std::string native_mysql_error_msg;
        unsigned int protocol_internal_errc = 0;
        std::string message;
        std::string failed_query;

        MySqlTransportError() = default;
        MySqlTransportError(Category cat, std::string msg, int mysql_err = 0, const char* mysql_state = nullptr, const char* mysql_msg = nullptr, unsigned int proto_errc = 0, std::string query = "");
        bool isOk() const {
            return category == Category::NoError;
        }
        std::string toString() const;
    };

    // --- 连接参数 ---
    struct MySqlTransportConnectionParams {
        std::string host = "localhost";
        unsigned int port = 3306;
        std::string user;
        std::string password;
        std::string db_name;
        std::string unix_socket;
        unsigned long client_flag = 0;
        std::optional<unsigned int> connect_timeout_seconds;
        std::optional<unsigned int> read_timeout_seconds;
        std::optional<unsigned int> write_timeout_seconds;
        std::optional<std::string> charset;
        std::map<std::string, std::string> ssl_options;
        std::map<mysql_option, std::string> generic_options;
        std::map<std::string, std::string> init_commands;
    };

    // --- 事务隔离级别 ---
    enum class TransactionIsolationLevel { None, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable };

    // --- 字段元数据 ---
    struct MySqlTransportFieldMeta {
        std::string name;
        std::string original_name;
        std::string table;
        std::string original_table;
        std::string db;
        std::string catalog = "def";
        enum enum_field_types native_type_id = MYSQL_TYPE_NULL;
        uint16_t charsetnr = 0;
        unsigned long length = 0;
        unsigned long max_length = 0;
        unsigned int flags = 0;
        unsigned int decimals = 0;
        mysql_protocol::MySqlNativeValue default_value;

        bool isPrimaryKey() const {
            return flags & PRI_KEY_FLAG;
        }
        bool isNotNull() const {
            return flags & NOT_NULL_FLAG;
        }
        bool isUniqueKey() const {
            return flags & UNIQUE_KEY_FLAG;
        }
        bool isMultipleKey() const {
            return flags & MULTIPLE_KEY_FLAG;
        }
        bool isAutoIncrement() const {
            return flags & AUTO_INCREMENT_FLAG;
        }
        bool isUnsigned() const {
            return flags & UNSIGNED_FLAG;
        }
        bool isZerofill() const {
            return flags & ZEROFILL_FLAG;
        }
        bool isBinary() const {
            return flags & BINARY_FLAG;
        }
        bool isEnum() const {
            return flags & ENUM_FLAG;
        }
        bool isSet() const {
            return flags & SET_FLAG;
        }
        bool isBlob() const {
            return flags & BLOB_FLAG;
        }
        bool isTimestamp() const {
            return flags & TIMESTAMP_FLAG;
        }
        bool isPartOfKey() const {
            return flags & PART_KEY_FLAG;
        }
        bool isGroup() const {
            return flags & GROUP_FLAG;
        }

        bool isGenerallyNumeric() const;
        bool isGenerallyString() const;
        bool isGenerallyDateTime() const;
    };

    // --- 参数绑定类型 ---
    struct MySqlTransportBindParam {
        mysql_protocol::MySqlNativeValue value;

        MySqlTransportBindParam();
        MySqlTransportBindParam(const mysql_protocol::MySqlNativeValue& v);
        MySqlTransportBindParam(mysql_protocol::MySqlNativeValue&& v);
        MySqlTransportBindParam(std::nullptr_t);
        MySqlTransportBindParam(bool val);
        MySqlTransportBindParam(int8_t val);
        MySqlTransportBindParam(uint8_t val);
        MySqlTransportBindParam(int16_t val);
        MySqlTransportBindParam(uint16_t val);
        MySqlTransportBindParam(int32_t val);
        MySqlTransportBindParam(uint32_t val);
        MySqlTransportBindParam(int64_t val);
        MySqlTransportBindParam(uint64_t val);
        MySqlTransportBindParam(float val);
        MySqlTransportBindParam(double val);
        MySqlTransportBindParam(const char* val);
        MySqlTransportBindParam(const std::string& val);
        MySqlTransportBindParam(std::string&& val);
        MySqlTransportBindParam(std::string_view val);
        MySqlTransportBindParam(const std::vector<unsigned char>& val);
        MySqlTransportBindParam(std::vector<unsigned char>&& val);
        MySqlTransportBindParam(const MYSQL_TIME& val);
        MySqlTransportBindParam(const std::chrono::system_clock::time_point& tp);
        MySqlTransportBindParam(const std::chrono::year_month_day& ymd);
        MySqlTransportBindParam(const std::chrono::microseconds& duration);
    };

    // --- 索引信息 (moved from mysql_transport_metadata.h for proper declaration order) ---
    struct MySqlTransportIndexColumn {
        std::string columnName;
        unsigned int sequenceInIndex = 0;
        std::optional<std::string> collation;
        std::optional<long long> cardinality;
        std::optional<unsigned int> subPart;
        bool isNullable = false;
        std::optional<std::string> expression;
    };

    struct MySqlTransportIndexInfo {
        std::string tableName;
        bool isNonUnique = true;
        std::string indexName;
        std::string indexType;
        std::vector<MySqlTransportIndexColumn> columns;
        std::string comment;
        std::string indexComment;
        bool isVisible = true;
    };

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_type_parser.h
#pragma once

#include <string>
// #include "cpporm_mysql_transport/mysql_transport_types.h" // For MySqlTransportFieldMeta
// MySqlTransportFieldMeta is forward declared in the function signature instead

namespace cpporm_mysql_transport {
    // Forward declare MySqlTransportFieldMeta to avoid circular dependency or unnecessary include
    struct MySqlTransportFieldMeta;
    // Declaration of the parsing function
    bool parseMySQLTypeStringInternal(const std::string& type_str_orig, MySqlTransportFieldMeta& field_meta);
}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_result_core.cpp
#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportResult::MySqlTransportResult(MySqlTransportStatement* stmt, MYSQL_RES* meta_res_handle, const MySqlTransportError& initial_error)
        : m_statement(stmt),
          m_mysql_res_metadata(meta_res_handle),
          m_mysql_stmt_handle_for_fetch(stmt ? stmt->getNativeStatementHandle() : nullptr),
          m_error_collector_owned(initial_error),
          m_current_sql_row(nullptr),
          m_current_lengths(nullptr),
          m_meta_populated(false),
          m_is_valid(false),
          m_is_from_prepared_statement(true),
          m_stmt_result_was_stored(false),
          m_fetched_all_from_stmt(false) {
        // 如果 initial_error 已经是一个错误，我们可能不应该继续，或者至少要标记 m_is_valid = false
        if (!initial_error.isOk()) {
            if (m_mysql_res_metadata) {  // 即使有初始错误，也要释放传入的 meta_res_handle
                mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
            }
            m_is_valid = false;
            return;
        }

        if (!m_statement || !m_mysql_stmt_handle_for_fetch) {  // meta_res_handle 可以为 NULL 如果没有字段
            if (m_error_collector_owned.isOk()) {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid statement or stmt_handle for MySqlTransportResult (prepared).");
            }
            if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
            m_mysql_res_metadata = nullptr;
            m_is_valid = false;
            return;
        }
        // 仅当 meta_res_handle 非空时才尝试 store_result (通常 SELECT 会返回元数据)
        // 如果 meta_res_handle 为空，说明查询没有返回列 (例如 DML 或 SELECT 1 WHERE FALSE)
        if (m_mysql_res_metadata) {
            if (mysql_stmt_store_result(m_mysql_stmt_handle_for_fetch) != 0) {
                // 尝试从语句句柄获取错误，因为它与 mysql_stmt_store_result 相关
                if (m_statement) {
                    unsigned int stmt_err_no = mysql_stmt_errno(m_mysql_stmt_handle_for_fetch);
                    if (stmt_err_no != 0) {  // 只有当确实有错误时才覆盖
                        m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, mysql_stmt_error(m_mysql_stmt_handle_for_fetch), static_cast<int>(stmt_err_no), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
                    } else if (m_error_collector_owned.isOk()) {  // 如果语句错误码为0，但操作失败
                        m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_store_result failed but statement reports no error.");
                    }
                } else if (m_error_collector_owned.isOk()) {  // 理论上不应发生，因为 m_statement 必须存在
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_store_result failed (no statement context).");
                }
                mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                m_stmt_result_was_stored = false;
                m_is_valid = false;
                return;
            }
            m_stmt_result_was_stored = true;
            m_row_count = mysql_stmt_num_rows(m_mysql_stmt_handle_for_fetch);
            m_field_count = mysql_num_fields(m_mysql_res_metadata);
        } else {                                                                    // meta_res_handle 为 NULL (例如，没有列的查询)
            m_row_count = mysql_stmt_affected_rows(m_mysql_stmt_handle_for_fetch);  // 对于无结果集的语句，这更有意义
            m_field_count = 0;
            m_stmt_result_was_stored = false;  // 没有结果可存储
        }

        if (m_field_count > 0 && m_mysql_res_metadata) {  // 只有在有字段且元数据存在时才处理字段元数据
            populateFieldsMeta();
            if (!m_error_collector_owned.isOk()) {  // populateFieldsMeta 可能会设置错误
                m_is_valid = false;                 // 确保 m_is_valid 更新
                // 清理，因为 populateFieldsMeta 失败
                if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                if (m_stmt_result_was_stored && m_mysql_stmt_handle_for_fetch) {
                    mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch);
                }
                m_stmt_result_was_stored = false;
                return;
            }
            if (!m_fields_meta.empty()) {
                setupOutputBindBuffers();
                if (!m_error_collector_owned.isOk()) {  // setupOutputBindBuffers 可能会设置错误
                    m_is_valid = false;
                    // 清理
                    if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
                    m_mysql_res_metadata = nullptr;
                    if (m_stmt_result_was_stored && m_mysql_stmt_handle_for_fetch) {
                        mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch);
                    }
                    m_stmt_result_was_stored = false;
                    return;
                }
            } else {                                   // m_fields_meta 为空但 m_field_count > 0，这是个问题
                if (m_error_collector_owned.isOk()) {  // 如果还没有错误
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Field count > 0 but no field metadata populated.");
                }
                m_is_valid = false;
                if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                if (m_stmt_result_was_stored && m_mysql_stmt_handle_for_fetch) {
                    mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch);
                }
                m_stmt_result_was_stored = false;
                return;
            }
        }
        m_is_valid = true;  // 如果所有步骤都成功
    }

    MySqlTransportResult::MySqlTransportResult(MYSQL_RES* stored_res_handle, const MySqlTransportError& initial_error)
        : m_statement(nullptr),
          m_mysql_res_metadata(stored_res_handle),
          m_mysql_stmt_handle_for_fetch(nullptr),
          m_error_collector_owned(initial_error),
          m_current_sql_row(nullptr),
          m_current_lengths(nullptr),
          m_meta_populated(false),
          m_is_valid(false),
          m_is_from_prepared_statement(false),
          m_stmt_result_was_stored(false),
          m_fetched_all_from_stmt(false) {
        if (!initial_error.isOk()) {
            if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
            m_mysql_res_metadata = nullptr;
            m_is_valid = false;
            return;
        }

        if (!m_mysql_res_metadata) {
            if (m_error_collector_owned.isOk()) {  // 仅当没有初始错误时才设置新错误
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Null MYSQL_RES handle passed to MySqlTransportResult constructor (non-prepared).");
            }
            m_is_valid = false;
            return;
        }
        m_row_count = mysql_num_rows(m_mysql_res_metadata);
        m_field_count = mysql_num_fields(m_mysql_res_metadata);

        if (m_field_count > 0) {
            populateFieldsMeta();
            if (!m_error_collector_owned.isOk()) {
                m_is_valid = false;
                if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                return;
            }
            if (m_fields_meta.empty()) {  // 如果 populateFieldsMeta 成功但 m_fields_meta 为空
                if (m_error_collector_owned.isOk()) {
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Field count > 0 but no field metadata populated (non-prepared).");
                }
                m_is_valid = false;
                if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                return;
            }
        }
        m_is_valid = true;
    }

    MySqlTransportResult::~MySqlTransportResult() {
        clearCurrentRow();
        if (m_is_from_prepared_statement && m_mysql_stmt_handle_for_fetch && m_stmt_result_was_stored) {
            mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch);
            m_stmt_result_was_stored = false;
        }
        if (m_mysql_res_metadata) {
            mysql_free_result(m_mysql_res_metadata);
            m_mysql_res_metadata = nullptr;
        }
    }

    MySqlTransportResult::MySqlTransportResult(MySqlTransportResult&& other) noexcept
        : m_statement(other.m_statement),
          m_mysql_res_metadata(other.m_mysql_res_metadata),
          m_mysql_stmt_handle_for_fetch(other.m_mysql_stmt_handle_for_fetch),
          m_error_collector_owned(std::move(other.m_error_collector_owned)),
          m_fields_meta(std::move(other.m_fields_meta)),
          m_current_sql_row(other.m_current_sql_row),
          m_current_lengths(other.m_current_lengths),
          m_row_count(other.m_row_count),
          m_field_count(other.m_field_count),
          m_current_row_idx(other.m_current_row_idx),
          m_meta_populated(other.m_meta_populated),
          m_is_valid(other.m_is_valid),
          m_is_from_prepared_statement(other.m_is_from_prepared_statement),
          m_stmt_result_was_stored(other.m_stmt_result_was_stored),
          m_output_bind_buffers(std::move(other.m_output_bind_buffers)),
          m_output_data_buffers(std::move(other.m_output_data_buffers)),
          m_output_is_null_indicators(std::move(other.m_output_is_null_indicators)),
          m_output_length_indicators(std::move(other.m_output_length_indicators)),
          m_output_error_indicators(std::move(other.m_output_error_indicators)),
          m_fetched_all_from_stmt(other.m_fetched_all_from_stmt) {
        other.m_mysql_res_metadata = nullptr;
        other.m_mysql_stmt_handle_for_fetch = nullptr;
        other.m_current_sql_row = nullptr;
        other.m_is_valid = false;
        other.m_stmt_result_was_stored = false;
    }

    MySqlTransportResult& MySqlTransportResult::operator=(MySqlTransportResult&& other) noexcept {
        if (this != &other) {
            clearCurrentRow();
            if (m_is_from_prepared_statement && m_mysql_stmt_handle_for_fetch && m_stmt_result_was_stored) {
                mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch);
            }
            if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);

            m_statement = other.m_statement;
            m_mysql_res_metadata = other.m_mysql_res_metadata;
            m_mysql_stmt_handle_for_fetch = other.m_mysql_stmt_handle_for_fetch;
            m_error_collector_owned = std::move(other.m_error_collector_owned);
            m_fields_meta = std::move(other.m_fields_meta);
            m_current_sql_row = other.m_current_sql_row;
            m_current_lengths = other.m_current_lengths;
            m_row_count = other.m_row_count;
            m_field_count = other.m_field_count;
            m_current_row_idx = other.m_current_row_idx;
            m_meta_populated = other.m_meta_populated;
            m_is_valid = other.m_is_valid;
            m_is_from_prepared_statement = other.m_is_from_prepared_statement;
            m_stmt_result_was_stored = other.m_stmt_result_was_stored;
            m_output_bind_buffers = std::move(other.m_output_bind_buffers);
            m_output_data_buffers = std::move(other.m_output_data_buffers);
            m_output_is_null_indicators = std::move(other.m_output_is_null_indicators);
            m_output_length_indicators = std::move(other.m_output_length_indicators);
            m_output_error_indicators = std::move(other.m_output_error_indicators);
            m_fetched_all_from_stmt = other.m_fetched_all_from_stmt;

            other.m_mysql_res_metadata = nullptr;
            other.m_mysql_stmt_handle_for_fetch = nullptr;
            other.m_current_sql_row = nullptr;
            other.m_is_valid = false;
            other.m_stmt_result_was_stored = false;
        }
        return *this;
    }

    bool MySqlTransportResult::isValid() const {
        return m_is_valid;
    }
    MySqlTransportError MySqlTransportResult::getError() const {
        return m_error_collector_owned;
    }

    my_ulonglong MySqlTransportResult::getRowCount() const {
        return m_row_count;
    }
    unsigned int MySqlTransportResult::getFieldCount() const {
        return m_field_count;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"

#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For setting errors on the connection context

namespace cpporm_mysql_transport {

    MySqlTransportCharsetHandler::MySqlTransportCharsetHandler(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            // This is a programming error.
            // MySqlTransportConnection should ensure this is constructed with a valid context.
            // If we want to be super robust, this handler could have an 'isValid' state.
        }
    }

    bool MySqlTransportCharsetHandler::setClientCharset(MYSQL* mysql_handle, const std::string& charset_name, bool is_pre_connect) {
        if (!mysql_handle) {
            if (m_conn_ctx) {
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::InternalError, "CharsetHandler: MySQL handle not initialized for setClientCharset operation.");
            }
            return false;
        }
        if (charset_name.empty()) {
            if (m_conn_ctx) {
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "CharsetHandler: Charset name cannot be empty for setClientCharset.");
            }
            return false;
        }

        // The MySqlTransportConnection is responsible for clearing its own error state (m_last_error)
        // before calling this component's method. This component will then use the connection's
        // setErrorFromMySqlHandle or setErrorManually to set the error if its specific operation fails.

        int err_code = 0;
        if (is_pre_connect) {
            // Called before mysql_real_connect, use mysql_options
            err_code = mysql_options(mysql_handle, MYSQL_SET_CHARSET_NAME, charset_name.c_str());
        } else {
            // Called after mysql_real_connect, use mysql_set_character_set
            if (m_conn_ctx && !m_conn_ctx->isConnected()) {  // Sanity check
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::ConnectionError, "CharsetHandler: Attempted to set charset on a non-connected session (post-connect path).");
                return false;
            }
            err_code = mysql_set_character_set(mysql_handle, charset_name.c_str());
        }

        if (err_code != 0) {
            if (m_conn_ctx) {
                // Let the connection set its error state using its handle, providing context.
                m_conn_ctx->setErrorFromMySqlHandle(mysql_handle, "Failed to set client character set to '" + charset_name + "'");
            }
            return false;
        }

        // If successful, MySqlTransportConnection might update its cached m_current_params.charset
        if (m_conn_ctx && !is_pre_connect) {  // Only update if connected and successful
            // MySqlTransportConnection should manage its m_current_params directly after calling this.
        }
        return true;
    }

    std::optional<std::string> MySqlTransportCharsetHandler::getClientCharset(MYSQL* mysql_handle, bool is_connected) const {
        if (!mysql_handle) {
            // Should not be called by MySqlTransportConnection if handle is null.
            if (m_conn_ctx) {
                // This might be an internal logic error if conn_ctx allowed this call.
                // m_conn_ctx->setErrorManually(MySqlTransportError::Category::InternalError, "CharsetHandler: Null handle for getClientCharset.");
            }
            return std::nullopt;
        }

        if (is_connected) {
            const char* charset_c_str = mysql_character_set_name(mysql_handle);
            if (charset_c_str) {
                return std::string(charset_c_str);
            }
            // If mysql_character_set_name returns null, it might indicate an error or unknown state.
            // The MySqlTransportConnection could check its own error status after this call if nullopt is unexpected.
            if (m_conn_ctx && mysql_errno(mysql_handle) != 0) {
                // m_conn_ctx->setErrorFromMySqlHandle(mysql_handle, "Failed to get client character set name.");
                // Best not to modify error state in a const getter. Caller should handle.
            }
        } else {
            // If not connected, the actual charset on the server side isn't established.
            // MySqlTransportConnection might have a cached 'intended' charset from params,
            // but this component (CharsetHandler) only deals with the live MYSQL handle.
        }
        return std::nullopt;  // Indicates charset could not be determined from the live handle in its current state
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_column_lister.cpp
#include "cpporm_mysql_transport/mysql_transport_column_lister.h"

#include <mysql/mysql.h>
#include <mysql/mysql_com.h>

#include <algorithm>
#include <sstream>
#include <string>
#include <vector>  // Required for std::vector

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "cpporm_mysql_transport/mysql_transport_type_parser.h"  // For parseMySQLTypeStringInternal
#include "mysql_protocol/mysql_type_converter.h"                 // For MySqlNativeValue

namespace cpporm_mysql_transport {

    MySqlTransportColumnLister::MySqlTransportColumnLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "ColumnLister: Null connection context provided.");
        }
    }

    void MySqlTransportColumnLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportColumnLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportColumnLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<MySqlTransportFieldMeta>> MySqlTransportColumnLister::getTableColumns(const std::string& table_name, const std::string& db_name_filter_param) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for getTableColumns.");
            return std::nullopt;
        }
        if (table_name.empty()) {
            setError_(MySqlTransportError::Category::ApiUsageError, "Table name cannot be empty for getTableColumns.");
            return std::nullopt;
        }
        clearError_();

        std::string db_to_use = db_name_filter_param;
        if (db_to_use.empty()) {
            db_to_use = m_conn_ctx->getCurrentParams().db_name;
            if (db_to_use.empty()) {
                setError_(MySqlTransportError::Category::ApiUsageError, "Database name not specified for getTableColumns.");
                return std::nullopt;
            }
        }

        std::string fq_table_name = "`" + m_conn_ctx->escapeString(db_to_use, false) + "`.`" + m_conn_ctx->escapeString(table_name, false) + "`";

        std::string query = "SHOW FULL COLUMNS FROM " + fq_table_name;
        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for getTableColumns for " + fq_table_name);
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::vector<MySqlTransportFieldMeta> columns_meta_vec;

        int idx_field = result->getFieldIndex("Field");
        int idx_type = result->getFieldIndex("Type");
        int idx_collation = result->getFieldIndex("Collation");
        int idx_null = result->getFieldIndex("Null");
        int idx_key = result->getFieldIndex("Key");
        int idx_default = result->getFieldIndex("Default");
        int idx_extra = result->getFieldIndex("Extra");
        // int idx_comment = result->getFieldIndex("Comment"); // Was unused

        if (idx_field == -1 || idx_type == -1) {
            setError_(MySqlTransportError::Category::InternalError, "Could not find 'Field' or 'Type' columns in SHOW FULL COLUMNS output.");
            return std::nullopt;
        }

        while (result->fetchNextRow()) {
            MySqlTransportFieldMeta col_meta;

            std::optional<mysql_protocol::MySqlNativeValue> field_native_val_opt = result->getValue(static_cast<unsigned int>(idx_field));
            if (field_native_val_opt) {
                std::optional<std::string> field_str_opt = field_native_val_opt->get_if<std::string>();
                if (field_str_opt) {
                    col_meta.name = *field_str_opt;
                } else {
                    continue;
                }
            } else {
                continue;
            }

            col_meta.original_name = col_meta.name;

            std::optional<mysql_protocol::MySqlNativeValue> type_native_val_opt = result->getValue(static_cast<unsigned int>(idx_type));
            if (type_native_val_opt) {
                std::optional<std::string> type_str_opt = type_native_val_opt->get_if<std::string>();
                if (type_str_opt) {
                    // Call the separated parsing function, ensure namespace resolution
                    if (!cpporm_mysql_transport::parseMySQLTypeStringInternal(*type_str_opt, col_meta)) {
                        // Handle parsing error, maybe log or set a specific error
                        // For now, continue and rely on default field_meta values
                    }
                } else {
                    continue;
                }
            } else {
                continue;
            }

            if (idx_collation != -1) {
                auto coll_native_val_opt = result->getValue(static_cast<unsigned int>(idx_collation));
                if (coll_native_val_opt && !coll_native_val_opt->is_null()) {
                    auto coll_str_opt = coll_native_val_opt->get_if<std::string>();
                    if (coll_str_opt) {
                        // const std::string& collation_name = *coll_str_opt;
                    }
                }
            }

            if (idx_null != -1) {
                auto null_native_val_opt = result->getValue(static_cast<unsigned int>(idx_null));
                if (null_native_val_opt) {
                    auto null_str_opt = null_native_val_opt->get_if<std::string>();
                    if (null_str_opt && *null_str_opt == "NO") {
                        col_meta.flags |= NOT_NULL_FLAG;
                    }
                }
            }

            if (idx_key != -1) {
                auto key_native_val_opt = result->getValue(static_cast<unsigned int>(idx_key));
                if (key_native_val_opt && !key_native_val_opt->is_null()) {
                    auto key_str_opt = key_native_val_opt->get_if<std::string>();
                    if (key_str_opt) {
                        const std::string& key_str = *key_str_opt;
                        if (key_str == "PRI")
                            col_meta.flags |= PRI_KEY_FLAG;
                        else if (key_str == "UNI")
                            col_meta.flags |= UNIQUE_KEY_FLAG;
                        else if (key_str == "MUL")
                            col_meta.flags |= MULTIPLE_KEY_FLAG;
                    }
                }
            }

            if (idx_default != -1) {
                auto def_val_opt = result->getValue(static_cast<unsigned int>(idx_default));
                if (def_val_opt) {
                    col_meta.default_value = std::move(*def_val_opt);
                }
            }

            if (idx_extra != -1) {
                auto extra_native_val_opt = result->getValue(static_cast<unsigned int>(idx_extra));
                if (extra_native_val_opt && !extra_native_val_opt->is_null()) {
                    auto extra_str_opt = extra_native_val_opt->get_if<std::string>();
                    if (extra_str_opt) {
                        const std::string& extra_str = *extra_str_opt;
                        if (extra_str.find("auto_increment") != std::string::npos) {
                            col_meta.flags |= AUTO_INCREMENT_FLAG;
                        }
                    }
                }
            }
            col_meta.table = table_name;
            col_meta.db = db_to_use;

            columns_meta_vec.push_back(col_meta);
        }
        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }
        return columns_meta_vec;
    }

    MySqlTransportError MySqlTransportColumnLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_charset.cpp
#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"
#include "cpporm_mysql_transport/mysql_transport_connection.h"

namespace cpporm_mysql_transport {

    bool MySqlTransportConnection::setClientCharset(const std::string& charset_name) {
        if (!m_charset_handler) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Charset handler not initialized.");
            return false;
        }
        // is_pre_connect is true if not m_is_connected
        bool success = m_charset_handler->setClientCharset(m_mysql_handle, charset_name, !m_is_connected);
        if (success) {
            m_current_params.charset = charset_name;  // Update cached intended charset
        }
        return success;
    }

    std::optional<std::string> MySqlTransportConnection::getClientCharset() const {
        if (!m_charset_handler) {
            return std::nullopt;
        }

        if (m_is_connected && m_mysql_handle) {
            auto live_charset = m_charset_handler->getClientCharset(m_mysql_handle, m_is_connected);
            if (live_charset) {
                // If live_charset is different from m_current_params.charset,
                // it means it was changed externally or by server default.
                // A non-const version could update m_current_params.charset here.
                return live_charset;
            }
        }

        // Fallback to configured/intended charset if not connected or live query failed
        if (m_current_params.charset.has_value() && !m_current_params.charset.value().empty()) {
            return m_current_params.charset.value();
        }
        return std::nullopt;
    }

}  // namespace cpporm_mysql_transport// MySqlTransport/Source/mysql_transport_connection_core.cpp
#include <mysql/mysql.h>

#include <atomic>
#include <mutex>
#include <stdexcept>  // 用于 std::runtime_error

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // 主头文件

// 组件头文件，因为 MySqlTransportConnection 会创建它们
#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"
#include "cpporm_mysql_transport/mysql_transport_connection_options_setter.h"
#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"
#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"

namespace cpporm_mysql_transport {

    // 用于一次性初始化的更简单的全局状态
    static std::atomic<bool> g_mysql_library_actually_initialized_flag(false);
    static std::mutex g_mysql_library_init_call_mutex;  // 保护对 mysql_library_init 的首次调用

    void ensure_mysql_library_initialized() {
        // 快速路径：如果已经初始化，直接返回。
        if (g_mysql_library_actually_initialized_flag.load(std::memory_order_acquire)) {
            return;
        }

        // 慢速路径：可能是首次调用，需要加锁
        std::lock_guard<std::mutex> lock(g_mysql_library_init_call_mutex);
        // 获取锁后再次检查
        if (g_mysql_library_actually_initialized_flag.load(std::memory_order_relaxed)) {
            return;
        }

        if (mysql_library_init(0, nullptr, nullptr)) {
            // 这是致命错误，无法在此处递减 g_mysql_library_init_count。
            throw std::runtime_error("Failed to initialize MySQL C library (call from ensure_mysql_library_initialized)");
        }
        g_mysql_library_actually_initialized_flag.store(true, std::memory_order_release);
    }

    void try_mysql_library_end() {
        // 在新的策略下，这是一个空操作。
        // mysql_library_end() 将不会被调用。
        // 操作系统将在进程退出时进行清理。
    }

    MySqlTransportConnection::MySqlTransportConnection()
        : m_mysql_handle(nullptr),
          m_is_connected(false),
          m_current_isolation_level(TransactionIsolationLevel::None)  // 初始化成员
    {
        ensure_mysql_library_initialized();  // 调用修订后的函数
        m_mysql_handle = mysql_init(nullptr);
        if (!m_mysql_handle) {
            // 直接设置错误或抛出异常，确保 m_last_error 被设置
            m_last_error = MySqlTransportError(MySqlTransportError::Category::ResourceError, "mysql_init() failed in MySqlTransportConnection constructor");
            // 可以考虑抛出 std::runtime_error("mysql_init failed");
        }
        // 初始化 PImpl 成员 (组件)
        m_options_setter = std::make_unique<MySqlTransportConnectionOptionsSetter>(this);
        m_transaction_manager = std::make_unique<MySqlTransportTransactionManager>(this);
        m_charset_handler = std::make_unique<MySqlTransportCharsetHandler>(this);
        m_server_info_provider = std::make_unique<MySqlTransportServerInfoProvider>();
    }

    MySqlTransportConnection::~MySqlTransportConnection() {
        disconnect();  // 确保逻辑断开
        if (m_mysql_handle) {
            mysql_close(m_mysql_handle);
            m_mysql_handle = nullptr;
        }
        try_mysql_library_end();  // 调用修订后的 (现在是空操作的) 函数
    }

    MySqlTransportConnection::MySqlTransportConnection(MySqlTransportConnection&& other) noexcept
        : m_mysql_handle(other.m_mysql_handle),
          m_is_connected(other.m_is_connected),
          m_current_params(std::move(other.m_current_params)),
          m_last_error(std::move(other.m_last_error)),
          m_current_isolation_level(other.m_current_isolation_level),
          m_options_setter(std::move(other.m_options_setter)),
          m_transaction_manager(std::move(other.m_transaction_manager)),
          m_charset_handler(std::move(other.m_charset_handler)),
          m_server_info_provider(std::move(other.m_server_info_provider)) {
        other.m_mysql_handle = nullptr;
        other.m_is_connected = false;

        // 重要：更新被移动的组件中的上下文指针为 'this'
        if (m_options_setter) m_options_setter->m_conn_ctx = this;
        if (m_transaction_manager) m_transaction_manager->m_conn_ctx = this;
        if (m_charset_handler) m_charset_handler->m_conn_ctx = this;
        // m_server_info_provider 不存储 m_conn_ctx
    }

    MySqlTransportConnection& MySqlTransportConnection::operator=(MySqlTransportConnection&& other) noexcept {
        if (this != &other) {
            // 正确清理当前状态
            disconnect();
            if (m_mysql_handle) {
                mysql_close(m_mysql_handle);
            }
            // 此处不需要调用 try_mysql_library_end()，因为库是全局管理的

            // 从 other 移动资源
            m_mysql_handle = other.m_mysql_handle;
            m_is_connected = other.m_is_connected;
            m_current_params = std::move(other.m_current_params);
            m_last_error = std::move(other.m_last_error);
            m_current_isolation_level = other.m_current_isolation_level;
            m_options_setter = std::move(other.m_options_setter);
            m_transaction_manager = std::move(other.m_transaction_manager);
            m_charset_handler = std::move(other.m_charset_handler);
            m_server_info_provider = std::move(other.m_server_info_provider);

            // 重置 other
            other.m_mysql_handle = nullptr;
            other.m_is_connected = false;
            // other 的 unique_ptrs (m_options_setter 等) 现在是 nullptr

            // 更新被移动的组件中的上下文指针为 'this'
            if (m_options_setter) m_options_setter->m_conn_ctx = this;
            if (m_transaction_manager) m_transaction_manager->m_conn_ctx = this;
            if (m_charset_handler) m_charset_handler->m_conn_ctx = this;
        }
        return *this;
    }

    bool MySqlTransportConnection::connect(const MySqlTransportConnectionParams& params) {
        if (m_is_connected) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, "Already connected. Disconnect first.");
            return false;
        }
        if (!m_mysql_handle) {  // 这个检查应该在构造函数的 mysql_init 之后
            setErrorManually(MySqlTransportError::Category::InternalError, "MySQL handle is null before connect (mysql_init failed?).");
            return false;
        }
        if (!m_options_setter) {  // 应该在构造函数中初始化
            setErrorManually(MySqlTransportError::Category::InternalError, "Connection options setter not initialized.");
            return false;
        }

        clearError();
        m_current_params = params;

        if (!m_options_setter->applyPreConnectOptions(m_mysql_handle, params)) {
            // m_options_setter.applyPreConnectOptions 应该已经在这个连接上下文中设置了错误
            if (m_last_error.isOk()) {  // 防御性：如果它没有设置，设置一个通用的
                setErrorFromMySqlHandle(m_mysql_handle, "Failed to apply pre-connect options");
            }
            return false;
        }

        const char* host_ptr = params.host.empty() ? nullptr : params.host.c_str();
        const char* user_ptr = params.user.empty() ? nullptr : params.user.c_str();
        const char* passwd_ptr = params.password.empty() ? nullptr : params.password.c_str();
        const char* db_ptr = params.db_name.empty() ? nullptr : params.db_name.c_str();
        // mysql_real_connect 对 port 0 的处理是使用默认端口
        unsigned int port_val = params.port;
        const char* unix_socket_ptr = params.unix_socket.empty() ? nullptr : params.unix_socket.c_str();

        if (!mysql_real_connect(m_mysql_handle, host_ptr, user_ptr, passwd_ptr, db_ptr, port_val, unix_socket_ptr, params.client_flag)) {
            setErrorFromMySqlHandle(m_mysql_handle, "mysql_real_connect failed");
            return false;
        }

        m_is_connected = true;  // 在需要连接的进一步操作之前设置连接状态

        // 连接后设置字符集（如果已指定）
        if (params.charset.has_value() && !params.charset.value().empty()) {
            if (!setClientCharset(params.charset.value())) {  // 这个方法使用 m_charset_handler
                // 错误会由 setClientCharset 设置
                disconnect();  // 回滚连接尝试
                return false;
            }
        }

        // 执行初始化命令
        for (const auto& pair : params.init_commands) {
            std::string command = pair.first;  // command key 本身可能是命令
            if (!pair.second.empty()) {        // 如果提供了 value，则假定是 key=value 格式的 SET
                command = pair.first + "=" + pair.second;
            }
            if (!_internalExecuteSimpleQuery(command, "Failed to execute init command: " + pair.first)) {
                disconnect();
                return false;
            }
        }

        // 缓存初始隔离级别
        if (m_transaction_manager) {
            auto initial_level_opt = m_transaction_manager->getTransactionIsolation();
            if (initial_level_opt.has_value()) {
                m_current_isolation_level = initial_level_opt.value();
                m_transaction_manager->updateCachedIsolationLevel(initial_level_opt.value());
            } else {
                // 如果获取隔离级别失败，m_last_error 上应该有错误
                // 缓存默认为 None
                m_current_isolation_level = TransactionIsolationLevel::None;
                m_transaction_manager->updateCachedIsolationLevel(TransactionIsolationLevel::None);
            }
        }
        return true;
    }

    void MySqlTransportConnection::disconnect() {
        // 此处不调用 mysql_close。mysql_close 在析构函数中。
        // Disconnect 仅标记逻辑状态并重置缓存。
        m_is_connected = false;
        m_current_isolation_level = TransactionIsolationLevel::None;
        if (m_transaction_manager) {  // 检查 PImpl 成员是否有效
            m_transaction_manager->updateCachedIsolationLevel(TransactionIsolationLevel::None);
        }
        // 注意：如果存在活动事务，它将保留在服务器上，
        // 除非在断开连接前显式回滚。mysql_close 会隐式回滚。
    }

    bool MySqlTransportConnection::isConnected() const {
        return m_is_connected && m_mysql_handle;
    }

    bool MySqlTransportConnection::ping(std::optional<unsigned int> /*timeout_seconds*/) {
        if (!isConnected()) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, "Not connected to server for ping.");
            return false;
        }
        clearError();
        // timeout_seconds 不被 mysql_ping 直接支持。
        // 它使用句柄上设置的连接/读/写超时。
        if (mysql_ping(m_mysql_handle) != 0) {
            setErrorFromMySqlHandle(m_mysql_handle, "mysql_ping failed (connection may be down)");
            m_is_connected = false;  // 假设连接丢失
            return false;
        }
        return true;
    }

    MySqlTransportError MySqlTransportConnection::getLastError() const {
        return m_last_error;
    }

    void MySqlTransportConnection::clearError() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportConnection::setErrorFromMySqlHandle(MYSQL* handle_to_check_error_on, const std::string& context_message) {
        if (handle_to_check_error_on) {
            unsigned int err_no = mysql_errno(handle_to_check_error_on);
            // 仅当 err_no 非零时才设置错误，或者如果 context_message很重要且之前没有错误。
            if (err_no != 0) {
                const char* sqlstate = mysql_sqlstate(handle_to_check_error_on);
                const char* errmsg = mysql_error(handle_to_check_error_on);
                std::string full_msg = context_message;
                if (errmsg && errmsg[0] != '\0') {
                    if (!full_msg.empty()) full_msg += ": ";
                    full_msg += errmsg;
                }
                // 如果可能，根据 err_no 或 sqlstate 确定类别
                MySqlTransportError::Category cat = MySqlTransportError::Category::QueryError;                               // 查询/语句错误的默认类别
                if (err_no >= CR_MIN_ERROR && err_no <= CR_MAX_ERROR) cat = MySqlTransportError::Category::ConnectionError;  // 客户端错误通常是连接错误
                // 如果需要，添加更精细的类别映射

                m_last_error = MySqlTransportError(cat, full_msg, static_cast<int>(err_no), sqlstate, errmsg);
            } else if (!context_message.empty() && m_last_error.isOk()) {
                // 如果 mysql_errno 为0，但我们有上下文消息且之前没有错误，
                // 这可能表示内部逻辑问题或非MySQL错误条件。
                m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context_message);
            }
        } else {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context_message.empty() ? "MySQL handle is null" : context_message + ": MySQL handle is null");
        }
    }

    void MySqlTransportConnection::setErrorManually(MySqlTransportError::Category cat, const std::string& msg, int native_mysql_err, const char* native_sql_state, const char* native_mysql_msg, unsigned int proto_errc) {
        m_last_error = MySqlTransportError(cat, msg, native_mysql_err, native_sql_state, native_mysql_msg, proto_errc);
    }

    void MySqlTransportConnection::recordPreConnectOptionError(const std::string& option_error_message) {
        // 此方法通常由 MySqlTransportConnectionOptionsSetter 在 mysql_options() 失败时调用。
        // mysql_options() 不设置 mysql_errno()。
        // 因此，我们创建一个没有特定MySQL代码的错误，只有消息。
        m_last_error = MySqlTransportError(MySqlTransportError::Category::ConnectionError, "Pre-connect option failure: " + option_error_message);
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_options_setter.cpp
#include "cpporm_mysql_transport/mysql_transport_connection_options_setter.h"

#include <mysql/mysql.h>

#include <algorithm>  // For std::transform
#include <vector>     // For potential temporary buffers if needed

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // To call setErrorFromMySQL directly on context

namespace cpporm_mysql_transport {

    MySqlTransportConnectionOptionsSetter::MySqlTransportConnectionOptionsSetter(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            // This is a programming error, options setter cannot function without context.
            // No direct way to report error from constructor if m_conn_ctx itself is for error reporting.
            // Assume valid context.
        }
    }

    unsigned int MySqlTransportConnectionOptionsSetter::mapSslModeStringToValue(const std::string& mode_str) const {
        std::string upper_mode = mode_str;
        std::transform(upper_mode.begin(), upper_mode.end(), upper_mode.begin(), [](unsigned char c) {
            return static_cast<char>(std::toupper(c));
        });

        if (upper_mode == "DISABLED") return SSL_MODE_DISABLED;
        if (upper_mode == "PREFERRED") return SSL_MODE_PREFERRED;
        if (upper_mode == "REQUIRED") return SSL_MODE_REQUIRED;
        if (upper_mode == "VERIFY_CA") return SSL_MODE_VERIFY_CA;
        if (upper_mode == "VERIFY_IDENTITY") return SSL_MODE_VERIFY_IDENTITY;

        return SSL_MODE_PREFERRED;  // Default if unknown
    }

    bool MySqlTransportConnectionOptionsSetter::applyPreConnectOptions(MYSQL* mysql_handle, const MySqlTransportConnectionParams& params) {
        if (!mysql_handle || !m_conn_ctx) {
            if (m_conn_ctx) {
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::InternalError, "OptionsSetter: Null MySQL handle or connection context.");
            }
            return false;
        }

        auto set_mysql_opt_ptr = [&](mysql_option option, const void* arg, const std::string& opt_name) -> bool {
            if (mysql_options(mysql_handle, option, arg) != 0) {
                m_conn_ctx->recordPreConnectOptionError("Failed to set " + opt_name);
                return false;
            }
            return true;
        };
        auto set_mysql_opt_uint = [&](mysql_option option, unsigned int arg, const std::string& opt_name) -> bool {
            if (mysql_options(mysql_handle, option, &arg) != 0) {  // Pass address of uint
                m_conn_ctx->recordPreConnectOptionError("Failed to set " + opt_name);
                return false;
            }
            return true;
        };
        auto set_mysql_opt_bool_as_char = [&](mysql_option option, bool val, const std::string& opt_name) -> bool {
            char char_val = val ? 1 : 0;
            if (mysql_options(mysql_handle, option, &char_val) != 0) {
                m_conn_ctx->recordPreConnectOptionError("Failed to set " + opt_name);
                return false;
            }
            return true;
        };

        if (params.connect_timeout_seconds.has_value()) {
            if (!set_mysql_opt_uint(MYSQL_OPT_CONNECT_TIMEOUT, params.connect_timeout_seconds.value(), "MYSQL_OPT_CONNECT_TIMEOUT")) return false;
        }
        if (params.read_timeout_seconds.has_value()) {
            if (!set_mysql_opt_uint(MYSQL_OPT_READ_TIMEOUT, params.read_timeout_seconds.value(), "MYSQL_OPT_READ_TIMEOUT")) return false;
        }
        if (params.write_timeout_seconds.has_value()) {
            if (!set_mysql_opt_uint(MYSQL_OPT_WRITE_TIMEOUT, params.write_timeout_seconds.value(), "MYSQL_OPT_WRITE_TIMEOUT")) return false;
        }

        auto ssl_mode_it = params.ssl_options.find("ssl_mode");
        if (ssl_mode_it != params.ssl_options.end()) {
            unsigned int ssl_mode_val = mapSslModeStringToValue(ssl_mode_it->second);
            // MYSQL_OPT_SSL_MODE expects unsigned int* as arg
            if (!set_mysql_opt_uint(MYSQL_OPT_SSL_MODE, ssl_mode_val, "MYSQL_OPT_SSL_MODE")) return false;
        }

        for (const auto& pair : params.ssl_options) {
            if (pair.first == "ssl_key") {
                if (!set_mysql_opt_ptr(MYSQL_OPT_SSL_KEY, pair.second.c_str(), "MYSQL_OPT_SSL_KEY")) return false;
            } else if (pair.first == "ssl_cert") {
                if (!set_mysql_opt_ptr(MYSQL_OPT_SSL_CERT, pair.second.c_str(), "MYSQL_OPT_SSL_CERT")) return false;
            } else if (pair.first == "ssl_ca") {
                if (!set_mysql_opt_ptr(MYSQL_OPT_SSL_CA, pair.second.c_str(), "MYSQL_OPT_SSL_CA")) return false;
            } else if (pair.first == "ssl_capath") {
                if (!set_mysql_opt_ptr(MYSQL_OPT_SSL_CAPATH, pair.second.c_str(), "MYSQL_OPT_SSL_CAPATH")) return false;
            } else if (pair.first == "ssl_cipher") {
                if (!set_mysql_opt_ptr(MYSQL_OPT_SSL_CIPHER, pair.second.c_str(), "MYSQL_OPT_SSL_CIPHER")) return false;
            } else if (pair.first == "ssl_mode") {
                continue;
            } else {
                // Log unknown SSL option or ignore
            }
        }

        for (const auto& pair : params.generic_options) {
            mysql_option opt_enum = pair.first;
            const std::string& opt_val_str = pair.second;

            if (opt_enum == MYSQL_INIT_COMMAND || opt_enum == MYSQL_SET_CHARSET_NAME || opt_enum == MYSQL_SET_CHARSET_DIR || opt_enum == MYSQL_PLUGIN_DIR ||  // Corrected from MYSQL_OPT_PLUGIN_DIR
                opt_enum == MYSQL_DEFAULT_AUTH || opt_enum == MYSQL_SERVER_PUBLIC_KEY ||                                                                      // Corrected from MYSQL_OPT_SERVER_PUBLIC_KEY
#if MYSQL_VERSION_ID >= 50607
                opt_enum == MYSQL_OPT_CONNECT_ATTR_RESET ||  // This option is fine
#endif
                false  // Add other const char* options here
            ) {
                if (!set_mysql_opt_ptr(opt_enum, opt_val_str.c_str(), "Generic char* option " + std::to_string(opt_enum))) return false;
            } else if (opt_enum == MYSQL_OPT_RECONNECT || opt_enum == MYSQL_ENABLE_CLEARTEXT_PLUGIN || opt_enum == MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS || opt_enum == MYSQL_OPT_COMPRESS || opt_enum == MYSQL_OPT_LOCAL_INFILE) {
                bool val = (opt_val_str == "1" || opt_val_str == "true" || opt_val_str == "TRUE" || opt_val_str == "ON");
                if (!set_mysql_opt_bool_as_char(opt_enum, val, "Generic bool(char) option " + std::to_string(opt_enum))) return false;
            } else if (opt_enum == MYSQL_OPT_PROTOCOL || opt_enum == MYSQL_OPT_MAX_ALLOWED_PACKET || opt_enum == MYSQL_OPT_NET_BUFFER_LENGTH
                       // MYSQL_OPT_CONNECT_TIMEOUT, READ_TIMEOUT, WRITE_TIMEOUT are handled above
            ) {
                try {
                    unsigned int val_uint = std::stoul(opt_val_str);
                    if (!set_mysql_opt_uint(opt_enum, val_uint, "Generic uint option " + std::to_string(opt_enum))) return false;
                } catch (const std::exception&) {
                    m_conn_ctx->recordPreConnectOptionError("Invalid integer value '" + opt_val_str + "' for option " + std::to_string(opt_enum));
                    return false;
                }
            } else {
                if (!set_mysql_opt_ptr(opt_enum, opt_val_str.c_str(), "Generic unknown-type (assumed char*) option " + std::to_string(opt_enum))) return false;
            }
        }

        if (params.charset.has_value() && !params.charset.value().empty()) {
            bool charset_already_set_via_generic = params.generic_options.count(MYSQL_SET_CHARSET_NAME);
            if (!charset_already_set_via_generic) {
                if (!set_mysql_opt_ptr(MYSQL_SET_CHARSET_NAME, params.charset.value().c_str(), "MYSQL_SET_CHARSET_NAME")) return false;
            }
        }

        return true;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_serverinfo.cpp
#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"

namespace cpporm_mysql_transport {

    std::string MySqlTransportConnection::getServerVersionString() const {
        if (!m_server_info_provider || !m_mysql_handle) {
            // Cannot set error in const method
            return "Not available";
        }
        return m_server_info_provider->getServerVersionString(m_mysql_handle);
    }

    unsigned long MySqlTransportConnection::getServerVersionNumber() const {
        if (!m_server_info_provider || !m_mysql_handle) {
            return 0;
        }
        return m_server_info_provider->getServerVersionNumber(m_mysql_handle);
    }

    std::string MySqlTransportConnection::getHostInfo() const {
        if (!m_server_info_provider || !m_mysql_handle) {
            return "Not available";
        }
        return m_server_info_provider->getHostInfo(m_mysql_handle, m_is_connected);
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_statement.cpp
#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"  // Definition of MySqlTransportStatement

namespace cpporm_mysql_transport {

    std::unique_ptr<MySqlTransportStatement> MySqlTransportConnection::createStatement(const std::string& query) {
        // Connection validity (m_mysql_handle != nullptr) is checked by MySqlTransportStatement constructor
        return std::make_unique<MySqlTransportStatement>(this, query);
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_connection_transaction.cpp
#include "cpporm_mysql_transport/mysql_transport_connection.h"
// MySqlTransportTransactionManager is already included via mysql_transport_connection.h -> .cpp (core)
// or directly if needed for types:
#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"

namespace cpporm_mysql_transport {

    bool MySqlTransportConnection::beginTransaction() {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->beginTransaction();
    }

    bool MySqlTransportConnection::commit() {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->commit();
    }

    bool MySqlTransportConnection::rollback() {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->rollback();
    }

    bool MySqlTransportConnection::setTransactionIsolation(TransactionIsolationLevel level) {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        bool success = m_transaction_manager->setTransactionIsolation(level);
        if (success) {
            m_current_isolation_level = level;
        }
        return success;
    }

    std::optional<TransactionIsolationLevel> MySqlTransportConnection::getTransactionIsolation() const {
        if (!m_transaction_manager) {
            // Cannot set error in const method without mutable m_last_error
            return std::nullopt;
        }
        if (!isConnected() && m_current_isolation_level == TransactionIsolationLevel::None) {
            return std::nullopt;
        }
        if (m_current_isolation_level != TransactionIsolationLevel::None) {
            return m_current_isolation_level;
        }

        // If connected and cache is None, query the server.
        // The component m_transaction_manager might cache it or query live.
        // This const getter itself won't update m_current_isolation_level unless it's mutable.
        return m_transaction_manager->getTransactionIsolation();
    }

    bool MySqlTransportConnection::setSavepoint(const std::string& name) {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->setSavepoint(name);
    }

    bool MySqlTransportConnection::rollbackToSavepoint(const std::string& name) {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->rollbackToSavepoint(name);
    }

    bool MySqlTransportConnection::releaseSavepoint(const std::string& name) {
        if (!m_transaction_manager) {
            setErrorManually(MySqlTransportError::Category::InternalError, "Transaction manager not initialized.");
            return false;
        }
        return m_transaction_manager->releaseSavepoint(name);
    }

}  // namespace cpporm_mysql_transport// Transport/MySqlTransport/Source/mysql_transport_connection_utility.cpp
#include <mysql/mysql.h>

#include <iomanip>
#include <limits>  // Required for std::numeric_limits
#include <sstream>
#include <stdexcept>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    std::string MySqlTransportConnection::escapeString(const std::string& unescaped_str, bool /*treat_backslash_as_meta*/) {
        if (!m_mysql_handle) {
            setErrorManually(MySqlTransportError::Category::InternalError, "MySQL handle not available for escapeString.");
            // 对于常量方法中需要转义的场景，这会是个问题。
            // 如果 formatNativeValueAsLiteral (const) 需要调用此非 const 方法，需要重新考虑。
            // 暂时，我们假设 formatNativeValueAsLiteral 能够通过 const_cast 调用，或者有其他机制。
            // 或者，如果只是用于非 const 场景，则此实现OK。
            return unescaped_str;  // 返回未转义的字符串或抛出异常
        }
        // 清除此特定操作的错误状态不是这里的职责，应由调用者管理。

        std::vector<char> to_buffer(unescaped_str.length() * 2 + 1);
        unsigned long to_length = mysql_real_escape_string(m_mysql_handle, to_buffer.data(), unescaped_str.c_str(), unescaped_str.length());
        return std::string(to_buffer.data(), to_length);
    }

    std::string MySqlTransportConnection::escapeSqlIdentifier(const std::string& identifier) const {
        if (identifier.empty()) {
            return "``";
        }
        std::string escaped_id;
        escaped_id.reserve(identifier.length() + 2 + (identifier.length() / 4));
        escaped_id += '`';
        for (char c : identifier) {
            if (c == '`') {
                escaped_id += "``";
            } else {
                escaped_id += c;
            }
        }
        escaped_id += '`';
        return escaped_id;
    }

    std::string MySqlTransportConnection::formatNativeValueAsLiteral(const mysql_protocol::MySqlNativeValue& nativeValue) const {
        if (nativeValue.is_null()) {
            return "NULL";
        }

        MYSQL* current_handle_for_escaping = const_cast<MYSQL*>(m_mysql_handle);  // Potentially unsafe if m_mysql_handle state is changed by escape

        if (!current_handle_for_escaping && (std::holds_alternative<std::string>(nativeValue.data) || std::holds_alternative<std::vector<unsigned char>>(nativeValue.data))) {
            if (std::holds_alternative<std::string>(nativeValue.data)) {
                // 基本的、不安全的转义，仅用于演示或无连接句柄时的最后手段
                std::string s = std::get<std::string>(nativeValue.data);
                std::string escaped_s;
                escaped_s.push_back('\'');
                for (char ch : s) {
                    if (ch == '\'')
                        escaped_s.append("''");
                    else if (ch == '\\')
                        escaped_s.append("\\\\");
                    else
                        escaped_s.push_back(ch);
                }
                escaped_s.push_back('\'');
                return escaped_s + " /* NO_HANDLE_BASIC_ESCAPE */";
            }
            return "NULL /* FORMATTING_ERROR_NO_HANDLE_FOR_BLOB */";
        }

        if (std::holds_alternative<bool>(nativeValue.data)) {
            return std::get<bool>(nativeValue.data) ? "TRUE" : "FALSE";
        } else if (std::holds_alternative<int8_t>(nativeValue.data)) {
            return std::to_string(std::get<int8_t>(nativeValue.data));
        } else if (std::holds_alternative<uint8_t>(nativeValue.data)) {
            return std::to_string(std::get<uint8_t>(nativeValue.data));
        } else if (std::holds_alternative<int16_t>(nativeValue.data)) {
            return std::to_string(std::get<int16_t>(nativeValue.data));
        } else if (std::holds_alternative<uint16_t>(nativeValue.data)) {
            return std::to_string(std::get<uint16_t>(nativeValue.data));
        } else if (std::holds_alternative<int32_t>(nativeValue.data)) {
            return std::to_string(std::get<int32_t>(nativeValue.data));
        } else if (std::holds_alternative<uint32_t>(nativeValue.data)) {
            return std::to_string(std::get<uint32_t>(nativeValue.data));
        } else if (std::holds_alternative<int64_t>(nativeValue.data)) {
            return std::to_string(std::get<int64_t>(nativeValue.data));
        } else if (std::holds_alternative<uint64_t>(nativeValue.data)) {
            return std::to_string(std::get<uint64_t>(nativeValue.data));
        } else if (std::holds_alternative<float>(nativeValue.data)) {
            std::ostringstream oss;
            oss << std::fixed << std::setprecision(std::numeric_limits<float>::max_digits10) << std::get<float>(nativeValue.data);
            return oss.str();
        } else if (std::holds_alternative<double>(nativeValue.data)) {
            std::ostringstream oss;
            oss << std::fixed << std::setprecision(std::numeric_limits<double>::max_digits10) << std::get<double>(nativeValue.data);
            return oss.str();
        } else if (std::holds_alternative<std::string>(nativeValue.data)) {
            const std::string& str_val = std::get<std::string>(nativeValue.data);
            std::vector<char> to_buffer(str_val.length() * 2 + 1);
            unsigned long to_length = mysql_real_escape_string(current_handle_for_escaping, to_buffer.data(), str_val.c_str(), str_val.length());
            return "'" + std::string(to_buffer.data(), to_length) + "'";
        } else if (std::holds_alternative<std::vector<unsigned char>>(nativeValue.data)) {
            const std::vector<unsigned char>& blob_val = std::get<std::vector<unsigned char>>(nativeValue.data);
            if (blob_val.empty()) {
                return "X''";
            }
            std::ostringstream oss;
            oss << "X'";
            for (unsigned char byte : blob_val) {
                oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
            }
            oss << "'";
            return oss.str();
        } else if (std::holds_alternative<MYSQL_TIME>(nativeValue.data)) {
            const MYSQL_TIME& mt = std::get<MYSQL_TIME>(nativeValue.data);
            std::ostringstream oss;
            oss << "'";
            bool date_part_exists = (mt.year != 0 || mt.month != 0 || mt.day != 0);
            bool time_part_exists = (mt.hour != 0 || mt.minute != 0 || mt.second != 0 || mt.second_part != 0);

            if (mt.time_type == MYSQL_TIMESTAMP_DATE || (mt.time_type == MYSQL_TIMESTAMP_DATETIME && date_part_exists) || (mt.time_type == MYSQL_TIMESTAMP_NONE && date_part_exists && !time_part_exists)) {
                oss << std::setfill('0') << std::setw(4) << mt.year << "-" << std::setw(2) << mt.month << "-" << std::setw(2) << mt.day;
            } else if (mt.time_type == MYSQL_TIMESTAMP_DATETIME && date_part_exists && time_part_exists) {  // Full DATETIME
                oss << std::setfill('0') << std::setw(4) << mt.year << "-" << std::setw(2) << mt.month << "-" << std::setw(2) << mt.day;
            }

            if (mt.time_type == MYSQL_TIMESTAMP_TIME || (mt.time_type == MYSQL_TIMESTAMP_DATETIME && time_part_exists) || (mt.time_type == MYSQL_TIMESTAMP_NONE && !date_part_exists && time_part_exists)) {
                if (date_part_exists && time_part_exists && mt.time_type == MYSQL_TIMESTAMP_DATETIME) {  // Space for DATETIME
                    oss << " ";
                }
                oss << std::setfill('0') << std::setw(2) << mt.hour << ":" << std::setw(2) << mt.minute << ":" << std::setw(2) << mt.second;
                if (mt.second_part > 0) {
                    std::string sec_part_str = std::to_string(mt.second_part);
                    // Pad to 6 digits for microseconds if it's less, truncate if more.
                    if (sec_part_str.length() < 6) {
                        sec_part_str = std::string(6 - sec_part_str.length(), '0') + sec_part_str;
                    } else if (sec_part_str.length() > 6) {
                        sec_part_str = sec_part_str.substr(0, 6);
                    }
                    // Remove trailing zeros from fractional part
                    size_t last_digit = sec_part_str.find_last_not_of('0');
                    if (last_digit != std::string::npos) {
                        oss << "." << sec_part_str.substr(0, last_digit + 1);
                    }  // else if all zeros, don't append ".000000"
                }
            } else if (mt.time_type == MYSQL_TIMESTAMP_DATETIME && date_part_exists && !time_part_exists) {
                // Date part was written, but no time part for a DATETIME type (e.g. 'YYYY-MM-DD 00:00:00')
                // This case is covered by the first date_part_exists block for DATETIME if time is all zero.
                // If time_type is DATETIME, we generally expect time. If mt.hour etc are 0, they will be formatted as 00.
            }

            oss << "'";
            std::string formatted_literal = oss.str();
            // Handle cases like just time 'HH:MM:SS' or just date 'YYYY-MM-DD'
            // If oss is just "'", it means no part was formatted, which is an error or unhandled MYSQL_TIME state
            if (formatted_literal == "''" && !(date_part_exists || time_part_exists)) {  // If truly empty time struct and nothing written
                if (mt.time_type == MYSQL_TIMESTAMP_ERROR) return "NULL /* MYSQL_TIME ERROR */";
                return "NULL /* INVALID OR UNHANDLED MYSQL_TIME */";
            }
            // If only date or only time was written and it's not ''
            if (formatted_literal.length() > 2) {  // Something was written beyond "''"
                return formatted_literal;
            }
            return "NULL /* INVALID OR UNHANDLED MYSQL_TIME */";  // Fallback
        }

        return "NULL /* UNSUPPORTED NATIVE TYPE FOR LITERAL */";
    }

    bool MySqlTransportConnection::_internalExecuteSimpleQuery(const std::string& query, const std::string& context_message) {
        if (!isConnected()) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, context_message.empty() ? "Not connected to server." : context_message + ": Not connected.");
            return false;
        }
        clearError();
        if (mysql_real_query(m_mysql_handle, query.c_str(), query.length()) != 0) {
            setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Query failed" : context_message);
            return false;
        }

        int status;
        do {
            MYSQL_RES* result = mysql_store_result(m_mysql_handle);
            if (result) {
                mysql_free_result(result);
            } else {
                if (mysql_field_count(m_mysql_handle) == 0) {
                    // No result set, which is OK for DML, SET, etc.
                } else {
                    setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Failed to retrieve result after query" : context_message + ": Failed to retrieve result");
                    return false;
                }
            }
            status = mysql_next_result(m_mysql_handle);  // Advances to the next result (if any)
            if (status > 0) {                            // Error
                setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Error processing multiple results" : context_message + ": Error processing results");
                return false;
            }
        } while (status == 0);  // Loop if status is 0 (more results processed successfully)

        // After loop, status is -1 (no more results) or >0 (error, already handled).
        // If status is -1, it means all results were processed successfully or there were no more results.
        // One final check for errors that might not be caught by mysql_next_result status.
        if (status == -1 && mysql_errno(m_mysql_handle) != 0) {
            setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Error after processing all results" : context_message + ": Error after processing all results");
            return false;
        }
        return true;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_database_lister.cpp
#include "cpporm_mysql_transport/mysql_transport_database_lister.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "mysql_protocol/mysql_type_converter.h"  // For MySqlNativeValue

namespace cpporm_mysql_transport {

    MySqlTransportDatabaseLister::MySqlTransportDatabaseLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "DatabaseLister: Null connection context provided.");
        }
    }

    void MySqlTransportDatabaseLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportDatabaseLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportDatabaseLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<std::string>> MySqlTransportDatabaseLister::listDatabases(const std::string& db_name_pattern) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for listDatabases.");
            return std::nullopt;
        }
        clearError_();

        std::string query = "SHOW DATABASES";
        if (!db_name_pattern.empty()) {
            query += " LIKE '" + m_conn_ctx->escapeString(db_name_pattern, false) + "'";
        }

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for listDatabases");
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::vector<std::string> databases;
        while (result->fetchNextRow()) {
            std::optional<mysql_protocol::MySqlNativeValue> db_name_native_val_opt = result->getValue(0);
            if (db_name_native_val_opt) {  // Check if optional<MySqlNativeValue> has a value
                const mysql_protocol::MySqlNativeValue& native_value = *db_name_native_val_opt;
                std::optional<std::string> db_name_str_opt = native_value.get_if<std::string>();
                if (db_name_str_opt) {  // Check if optional<string> has a value
                    databases.push_back(*db_name_str_opt);
                }
            }
        }
        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }
        return databases;
    }

    MySqlTransportError MySqlTransportDatabaseLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_index_lister.cpp
#include "cpporm_mysql_transport/mysql_transport_index_lister.h"

#include <mysql/mysql.h>

#include <algorithm>
#include <map>
#include <vector>  // Required for std::vector

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    MySqlTransportIndexLister::MySqlTransportIndexLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "IndexLister: Null connection context provided.");
        }
    }

    void MySqlTransportIndexLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportIndexLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportIndexLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) {
                    combined_msg += ": ";
                }
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty() && context.find("Failed to create statement") != std::string::npos) {
                m_last_error.category = MySqlTransportError::Category::QueryError;
            } else if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<MySqlTransportIndexInfo>> MySqlTransportIndexLister::getTableIndexes(const std::string& table_name, const std::string& db_name_filter_param) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for getTableIndexes.");
            return std::nullopt;
        }
        if (table_name.empty()) {
            setError_(MySqlTransportError::Category::ApiUsageError, "Table name cannot be empty for getTableIndexes.");
            return std::nullopt;
        }
        clearError_();

        std::string db_to_use = db_name_filter_param;
        if (db_to_use.empty()) {
            db_to_use = m_conn_ctx->getCurrentParams().db_name;
            if (db_to_use.empty()) {
                setError_(MySqlTransportError::Category::ApiUsageError, "Database name not specified and not set in connection for getTableIndexes.");
                return std::nullopt;
            }
        }
        std::string fq_table_name = "`" + m_conn_ctx->escapeString(db_to_use, false) + "`.`" + m_conn_ctx->escapeString(table_name, false) + "`";
        std::string query = "SHOW INDEX FROM " + fq_table_name;

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt || (stmt->getNativeStatementHandle() == nullptr && !stmt->getError().isOk())) {
            setErrorFromConnection_("Failed to create statement for getTableIndexes for " + fq_table_name);
            if (stmt && !stmt->getError().isOk()) {
                m_last_error = stmt->getError();
            }
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::map<std::string, MySqlTransportIndexInfo> index_map;

        int idx_table = result->getFieldIndex("Table");
        int idx_non_unique = result->getFieldIndex("Non_unique");
        int idx_key_name = result->getFieldIndex("Key_name");
        int idx_seq_in_index = result->getFieldIndex("Seq_in_index");
        int idx_column_name = result->getFieldIndex("Column_name");
        int idx_collation = result->getFieldIndex("Collation");
        int idx_cardinality = result->getFieldIndex("Cardinality");
        int idx_sub_part = result->getFieldIndex("Sub_part");
        int idx_null = result->getFieldIndex("Null");
        int idx_index_type = result->getFieldIndex("Index_type");
        int idx_comment = result->getFieldIndex("Comment");
        int idx_index_comment = result->getFieldIndex("Index_comment");
        int idx_visible = result->getFieldIndex("Visible");
        int idx_expression = result->getFieldIndex("Expression");

        if (idx_key_name == -1 || idx_column_name == -1 || idx_seq_in_index == -1 || idx_table == -1 || idx_non_unique == -1 || idx_index_type == -1) {
            setError_(MySqlTransportError::Category::InternalError, "Could not find one or more required columns in SHOW INDEX output.");
            return std::nullopt;
        }

        while (result->fetchNextRow()) {
            std::string key_name_str_val;
            if (auto key_name_native_opt = result->getValue(static_cast<unsigned int>(idx_key_name))) {
                if (auto key_name_str_opt = key_name_native_opt->get_if<std::string>()) {
                    key_name_str_val = *key_name_str_opt;
                } else {
                    continue;
                }
            } else {
                continue;
            }

            auto it = index_map.find(key_name_str_val);
            if (it == index_map.end()) {
                MySqlTransportIndexInfo index_info;

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_table))) {
                    if (auto s_opt = val_opt->get_if<std::string>()) {
                        index_info.tableName = *s_opt;
                    }
                }

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_non_unique))) {
                    bool nu_val_set = false;
                    if (auto pval_u64_opt = val_opt->get_if<uint64_t>()) {
                        index_info.isNonUnique = (*pval_u64_opt == 1);
                        nu_val_set = true;
                    } else if (auto pval_i64_opt = val_opt->get_if<int64_t>()) {
                        index_info.isNonUnique = (*pval_i64_opt == 1);
                        nu_val_set = true;
                    } else if (auto pval_u32_opt = val_opt->get_if<uint32_t>()) {
                        index_info.isNonUnique = (*pval_u32_opt == 1);
                        nu_val_set = true;
                    } else if (auto pval_i32_opt = val_opt->get_if<int32_t>()) {
                        index_info.isNonUnique = (*pval_i32_opt == 1);
                        nu_val_set = true;
                    }
                    if (!nu_val_set) {
                        index_info.isNonUnique = true;
                    }
                }
                index_info.indexName = key_name_str_val;

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_index_type))) {
                    if (auto s_opt = val_opt->get_if<std::string>()) {
                        index_info.indexType = *s_opt;
                    }
                }

                if (idx_comment != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_comment))) {
                        if (!val_opt->is_null()) {
                            if (auto s_opt = val_opt->get_if<std::string>()) {
                                index_info.comment = *s_opt;
                            }
                        }
                    }
                }
                if (idx_index_comment != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_index_comment))) {
                        if (!val_opt->is_null()) {
                            if (auto s_opt = val_opt->get_if<std::string>()) {
                                index_info.indexComment = *s_opt;
                            }
                        }
                    }
                }
                if (idx_visible != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_visible))) {
                        if (!val_opt->is_null()) {
                            if (auto s_opt = val_opt->get_if<std::string>()) {
                                index_info.isVisible = (*s_opt == "YES" || *s_opt == "1");
                            }
                        } else {
                            index_info.isVisible = true;
                        }
                    } else {
                        index_info.isVisible = true;
                    }
                } else {
                    index_info.isVisible = true;
                }
                it = index_map.insert({key_name_str_val, index_info}).first;
            }

            MySqlTransportIndexColumn col_def;
            if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_column_name))) {
                if (auto s_opt = val_opt->get_if<std::string>()) {
                    col_def.columnName = *s_opt;
                } else {
                    continue;
                }
            } else {
                continue;
            }

            if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_seq_in_index))) {
                if (auto pval_u64_opt = val_opt->get_if<uint64_t>()) {
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_u64_opt);
                } else if (auto pval_i64_opt = val_opt->get_if<int64_t>()) {
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_i64_opt);
                } else if (auto pval_u32_opt = val_opt->get_if<uint32_t>()) {
                    col_def.sequenceInIndex = *pval_u32_opt;
                } else if (auto pval_i32_opt = val_opt->get_if<int32_t>()) {
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_i32_opt);
                }
            }

            if (idx_collation != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_collation))) {
                    if (!val_opt->is_null()) {
                        if (auto s_opt = val_opt->get_if<std::string>()) {
                            col_def.collation = *s_opt;
                        }
                    }
                }
            }
            if (idx_cardinality != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_cardinality))) {
                    if (!val_opt->is_null()) {
                        if (auto pval_u64_opt = val_opt->get_if<uint64_t>()) {
                            col_def.cardinality = static_cast<long long>(*pval_u64_opt);
                        } else if (auto pval_i64_opt = val_opt->get_if<int64_t>()) {
                            col_def.cardinality = *pval_i64_opt;
                        } else if (auto pval_u32_opt = val_opt->get_if<uint32_t>()) {
                            col_def.cardinality = static_cast<long long>(*pval_u32_opt);
                        } else if (auto pval_i32_opt = val_opt->get_if<int32_t>()) {
                            col_def.cardinality = *pval_i32_opt;
                        }
                    }
                }
            }
            if (idx_sub_part != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_sub_part))) {
                    if (!val_opt->is_null()) {
                        if (auto pval_u64_opt = val_opt->get_if<uint64_t>()) {
                            col_def.subPart = static_cast<unsigned int>(*pval_u64_opt);
                        } else if (auto pval_i64_opt = val_opt->get_if<int64_t>()) {
                            col_def.subPart = static_cast<unsigned int>(*pval_i64_opt);
                        } else if (auto pval_u32_opt = val_opt->get_if<uint32_t>()) {
                            col_def.subPart = *pval_u32_opt;
                        } else if (auto pval_i32_opt = val_opt->get_if<int32_t>()) {
                            col_def.subPart = static_cast<unsigned int>(*pval_i32_opt);
                        }
                    }
                }
            }

            if (idx_null != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_null))) {
                    if (!val_opt->is_null()) {
                        if (auto s_opt = val_opt->get_if<std::string>()) {
                            col_def.isNullable = (*s_opt == "YES");
                        }
                    } else {
                        col_def.isNullable = false;
                    }
                } else {
                    col_def.isNullable = false;
                }
            } else {
                col_def.isNullable = false;  // Default if "Null" column is not present.
            }

            if (idx_expression != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_expression))) {
                    if (!val_opt->is_null()) {
                        if (auto s_opt = val_opt->get_if<std::string>()) {
                            col_def.expression = *s_opt;
                        }
                    }
                }
            }
            it->second.columns.push_back(col_def);
        }

        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }

        std::vector<MySqlTransportIndexInfo> indexes_vec;
        indexes_vec.reserve(index_map.size());
        for (auto& pair_kv : index_map) {
            std::sort(pair_kv.second.columns.begin(), pair_kv.second.columns.end(), [](const MySqlTransportIndexColumn& a, const MySqlTransportIndexColumn& b) {
                return a.sequenceInIndex < b.sequenceInIndex;
            });
            indexes_vec.push_back(std::move(pair_kv.second));
        }
        return indexes_vec;
    }

    std::optional<MySqlTransportIndexInfo> MySqlTransportIndexLister::getPrimaryIndex(const std::string& table_name, const std::string& db_name_filter) {
        auto indexes_opt = getTableIndexes(table_name, db_name_filter);
        if (indexes_opt) {
            for (const auto& index : indexes_opt.value()) {
                if (index.indexName == "PRIMARY") {
                    return index;
                }
            }
        }
        return std::nullopt;
    }

    MySqlTransportError MySqlTransportIndexLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_metadata.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // Listers might need it

// Listers are included via mysql_transport_metadata.h

namespace cpporm_mysql_transport {

    MySqlTransportMetadata::MySqlTransportMetadata(MySqlTransportConnection* conn) {
        if (!conn) {
            // This is a critical programming error.
            // Set an error that can be retrieved by getLastError(), or throw.
            m_last_error_aggregator = MySqlTransportError(MySqlTransportError::Category::InternalError, "MySqlTransportMetadata: Null connection context provided during construction.");
            // Listers will not be initialized. Calls to them will fail.
            return;
        }
        m_db_lister = std::make_unique<MySqlTransportDatabaseLister>(conn);
        m_table_lister = std::make_unique<MySqlTransportTableLister>(conn);
        m_column_lister = std::make_unique<MySqlTransportColumnLister>(conn);
        m_index_lister = std::make_unique<MySqlTransportIndexLister>(conn);
    }

    MySqlTransportMetadata::~MySqlTransportMetadata() = default;  // For std::unique_ptr to incomplete types

    // Move constructor
    MySqlTransportMetadata::MySqlTransportMetadata(MySqlTransportMetadata&& other) noexcept
        : m_last_error_aggregator(std::move(other.m_last_error_aggregator)), m_db_lister(std::move(other.m_db_lister)), m_table_lister(std::move(other.m_table_lister)), m_column_lister(std::move(other.m_column_lister)), m_index_lister(std::move(other.m_index_lister)) {
        // After moving unique_ptrs, 'other' lister pointers are null.
        // The listers themselves, if they store MySqlTransportConnection*, still point to the original connection.
        // This is generally fine if the MySqlTransportConnection outlives this MySqlTransportMetadata object,
        // or if the connection context in listers is updated (but they are simple pointers).
        // The new MySqlTransportMetadata object now owns the listers.
    }

    // Move assignment
    MySqlTransportMetadata& MySqlTransportMetadata::operator=(MySqlTransportMetadata&& other) noexcept {
        if (this != &other) {
            m_last_error_aggregator = std::move(other.m_last_error_aggregator);
            m_db_lister = std::move(other.m_db_lister);
            m_table_lister = std::move(other.m_table_lister);
            m_column_lister = std::move(other.m_column_lister);
            m_index_lister = std::move(other.m_index_lister);
        }
        return *this;
    }

    void MySqlTransportMetadata::clearError() {
        m_last_error_aggregator = MySqlTransportError();
    }

    void MySqlTransportMetadata::setError(const MySqlTransportError& error) {
        m_last_error_aggregator = error;
    }

    // Template helper implementation
    template <typename ListerPtr, typename Method, typename... Args>
    auto MySqlTransportMetadata::callLister(ListerPtr& lister_ptr, Method method, const std::string& error_context, Args&&... args) -> decltype(((*lister_ptr).*method)(std::forward<Args>(args)...)) {
        clearError();  // Clear aggregator before call
        using ReturnType = decltype(((*lister_ptr).*method)(std::forward<Args>(args)...));

        if (!lister_ptr) {
            setError(MySqlTransportError(MySqlTransportError::Category::InternalError, error_context + ": Lister component not initialized."));
            if constexpr (std::is_same_v<ReturnType, void>)
                return;
            else
                return ReturnType{};  // Return default-constructed optional or empty vector
        }

        ReturnType result = ((*lister_ptr).*method)(std::forward<Args>(args)...);
        m_last_error_aggregator = lister_ptr->getLastError();  // Get specific error from the lister

        // If lister operation failed (indicated by !result for optionals, or error set),
        // and lister itself didn't set a good error message, enhance it.
        bool result_indicates_failure = false;
        if constexpr (std::is_same_v<decltype(result), std::optional<typename ReturnType::value_type>>) {  // Check if ReturnType is std::optional
            if (!result.has_value()) result_indicates_failure = true;
        }
        // Add similar checks if result is vector and empty could mean failure in some contexts.

        if (result_indicates_failure && m_last_error_aggregator.isOk()) {
            setError(MySqlTransportError(MySqlTransportError::Category::InternalError, error_context + ": Operation failed but lister reported no specific error."));
        } else if (!m_last_error_aggregator.isOk() && m_last_error_aggregator.message.find(error_context) == std::string::npos) {
            // Prepend context to lister's error message if not already there
            m_last_error_aggregator.message = error_context + ": " + m_last_error_aggregator.message;
        }
        return result;
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listDatabases(const std::string& db_name_pattern) {
        return callLister(m_db_lister, &MySqlTransportDatabaseLister::listDatabases, "ListDatabases", db_name_pattern);
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listTables(const std::string& db_name, const std::string& table_name_pattern) {
        return callLister(m_table_lister, &MySqlTransportTableLister::listTables, "ListTables", db_name, table_name_pattern);
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listViews(const std::string& db_name, const std::string& view_name_pattern) {
        return callLister(m_table_lister, &MySqlTransportTableLister::listViews, "ListViews", db_name, view_name_pattern);
    }

    std::optional<std::vector<MySqlTransportFieldMeta>> MySqlTransportMetadata::getTableColumns(const std::string& table_name, const std::string& db_name) {
        return callLister(m_column_lister, &MySqlTransportColumnLister::getTableColumns, "GetTableColumns", table_name, db_name);
    }

    std::optional<std::vector<MySqlTransportIndexInfo>> MySqlTransportMetadata::getTableIndexes(const std::string& table_name, const std::string& db_name) {
        return callLister(m_index_lister, &MySqlTransportIndexLister::getTableIndexes, "GetTableIndexes", table_name, db_name);
    }

    std::optional<MySqlTransportIndexInfo> MySqlTransportMetadata::getPrimaryIndex(const std::string& table_name, const std::string& db_name) {
        return callLister(m_index_lister, &MySqlTransportIndexLister::getPrimaryIndex, "GetPrimaryIndex", table_name, db_name);
    }

    MySqlTransportError MySqlTransportMetadata::getLastError() const {
        return m_last_error_aggregator;
    }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    void MySqlTransportResult::clearCurrentRow() {
        if (!m_is_from_prepared_statement) {
            m_current_sql_row = nullptr;
            m_current_lengths = nullptr;
        }
        // For prepared statements, data is in m_output_data_buffers. These are reused.
        // m_current_row_idx is reset/incremented by fetchNextRow.
    }

    bool MySqlTransportResult::fetchNextRow() {
        if (!m_is_valid) return false;
        clearCurrentRow();  // Clear previous row data first

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch || m_fetched_all_from_stmt) {
                return false;
            }

            int fetch_rc = mysql_stmt_fetch(m_mysql_stmt_handle_for_fetch);
            if (fetch_rc == 0) {  // Success
                m_current_row_idx++;
                return true;
            } else if (fetch_rc == MYSQL_NO_DATA) {  // No more rows
                m_fetched_all_from_stmt = true;
                m_current_row_idx = -1;
                return false;
            } else if (fetch_rc == MYSQL_DATA_TRUNCATED) {  // Data truncated
                // Set error on m_error_collector_owned
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::DataError, "Data truncated during fetch.", mysql_stmt_errno(m_mysql_stmt_handle_for_fetch), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
                m_current_row_idx++;  // Row is still fetched despite truncation
                return true;
            } else {                // Error
                if (m_statement) {  // If statement context available, try to get its error
                    m_error_collector_owned = m_statement->getError();
                    // If statement's error is still OK, then set a specific fetch error
                    if (m_error_collector_owned.isOk()) {
                        m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_fetch failed.", mysql_stmt_errno(m_mysql_stmt_handle_for_fetch), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
                    }
                } else if (m_mysql_stmt_handle_for_fetch) {  // No statement context, but have stmt handle
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_fetch failed.", mysql_stmt_errno(m_mysql_stmt_handle_for_fetch), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
                } else {  // Fallback
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_fetch failed (no statement context or handle).");
                }
                m_current_row_idx = -1;
                return false;
            }
        } else {  // From non-prepared (MYSQL_RES)
            if (!m_mysql_res_metadata) return false;
            m_current_sql_row = mysql_fetch_row(m_mysql_res_metadata);
            if (m_current_sql_row) {
                m_current_lengths = mysql_fetch_lengths(m_mysql_res_metadata);
                m_current_row_idx++;
                return true;
            } else {
                m_current_row_idx = -1;
                // Check if it's a real error or just end of data
                if (m_mysql_res_metadata->handle && mysql_errno(m_mysql_res_metadata->handle) != 0) {
                    m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_fetch_row failed.", mysql_errno(m_mysql_res_metadata->handle), mysql_sqlstate(m_mysql_res_metadata->handle), mysql_error(m_mysql_res_metadata->handle));
                } else if (m_mysql_res_metadata->handle && mysql_errno(m_mysql_res_metadata->handle) == 0 && mysql_eof(m_mysql_res_metadata)) {
                    // Normal EOF, m_error_collector_owned should remain OK
                } else {
                    // If m_error_collector_owned is already set (e.g., from a previous issue), don't overwrite.
                    // If it's currently OK, then this is unexpected.
                    if (m_error_collector_owned.isOk()) {
                        m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "Unknown error during mysql_fetch_row or no more rows.");
                    }
                }
                return false;
            }
        }
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_result_meta.cpp
#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_result.h"

namespace cpporm_mysql_transport {

    void MySqlTransportResult::populateFieldsMeta() {
        if (m_meta_populated || !m_mysql_res_metadata || m_field_count == 0) {
            if (!m_mysql_res_metadata && m_field_count > 0 && m_is_valid) {  // m_is_valid might be true from constructor
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "MYSQL_RES metadata handle is null in populateFieldsMeta when fields expected.");
                m_is_valid = false;  // Explicitly mark as invalid
            }
            return;
        }

        m_fields_meta.clear();
        m_fields_meta.resize(m_field_count);
        MYSQL_FIELD* fields_raw = mysql_fetch_fields(m_mysql_res_metadata);
        if (!fields_raw) {
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "mysql_fetch_fields returned null.");
            m_field_count = 0;  // Reset field count as meta is unavailable
            m_is_valid = false;
            return;
        }

        for (unsigned int i = 0; i < m_field_count; ++i) {
            m_fields_meta[i].name = fields_raw[i].name ? fields_raw[i].name : "";
            m_fields_meta[i].original_name = fields_raw[i].org_name ? fields_raw[i].org_name : "";
            m_fields_meta[i].table = fields_raw[i].table ? fields_raw[i].table : "";
            m_fields_meta[i].original_table = fields_raw[i].org_table ? fields_raw[i].org_table : "";
            m_fields_meta[i].db = fields_raw[i].db ? fields_raw[i].db : "";
            m_fields_meta[i].catalog = fields_raw[i].catalog ? fields_raw[i].catalog : "def";
            m_fields_meta[i].native_type_id = fields_raw[i].type;
            m_fields_meta[i].charsetnr = fields_raw[i].charsetnr;
            m_fields_meta[i].length = fields_raw[i].length;
            m_fields_meta[i].max_length = fields_raw[i].max_length;
            m_fields_meta[i].flags = fields_raw[i].flags;
            m_fields_meta[i].decimals = fields_raw[i].decimals;
            // default_value parsing would require knowing the type and converting from string,
            // or if `fields_raw[i].def` was directly usable (it is const char*).
            // For now, default_value is left as default (null) MySqlNativeValue.
        }
        m_meta_populated = true;
        // Do not set m_is_valid = true here, constructor manages overall validity.
        // If we reached here without errors, it contributes to validity.
    }

    const std::vector<MySqlTransportFieldMeta>& MySqlTransportResult::getFieldsMeta() const {
        return m_fields_meta;
    }

    std::optional<MySqlTransportFieldMeta> MySqlTransportResult::getFieldMeta(unsigned int col_idx) const {
        if (!m_is_valid || col_idx >= m_field_count) {
            return std::nullopt;
        }
        if (m_fields_meta.size() <= col_idx) return std::nullopt;
        return m_fields_meta[col_idx];
    }

    std::optional<MySqlTransportFieldMeta> MySqlTransportResult::getFieldMeta(const std::string& col_name) const {
        if (!m_is_valid) return std::nullopt;
        int idx = getFieldIndex(col_name);
        if (idx == -1) return std::nullopt;
        return m_fields_meta[static_cast<size_t>(idx)];
    }

    int MySqlTransportResult::getFieldIndex(const std::string& col_name) const {
        if (!m_is_valid || !m_meta_populated) return -1;
        for (size_t i = 0; i < m_fields_meta.size(); ++i) {
            if (m_fields_meta[i].name == col_name || (!m_fields_meta[i].original_name.empty() && m_fields_meta[i].original_name == col_name)) {
                return static_cast<int>(i);
            }
        }
        return -1;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_result_prepared_bind.cpp
#include <mysql/mysql.h>

#include <cstring>  // For std::memset

#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"  // For m_statement (used for getError)

namespace cpporm_mysql_transport {

    void MySqlTransportResult::setupOutputBindBuffers() {
        if (!m_is_from_prepared_statement || m_field_count == 0 || !m_mysql_stmt_handle_for_fetch) return;
        if (m_fields_meta.size() != m_field_count) {
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Field metadata count mismatch in setupOutputBindBuffers.");
            m_is_valid = false;
            return;
        }

        m_output_bind_buffers.assign(m_field_count, MYSQL_BIND{});
        m_output_data_buffers.resize(m_field_count);

        m_output_is_null_indicators.assign(m_field_count, (char)0);
        m_output_length_indicators.assign(m_field_count, 0UL);
        m_output_error_indicators.assign(m_field_count, (char)0);

        for (unsigned int i = 0; i < m_field_count; ++i) {
            MYSQL_BIND& bind = m_output_bind_buffers[i];
            const MySqlTransportFieldMeta& meta = m_fields_meta[i];

            std::memset(&bind, 0, sizeof(MYSQL_BIND));

            bind.buffer_type = meta.native_type_id;
            unsigned long buffer_sz = 0;
            buffer_sz = meta.length;

            switch (meta.native_type_id) {
                case MYSQL_TYPE_TINY:
                    if (buffer_sz < sizeof(int8_t)) buffer_sz = sizeof(int8_t);
                    break;
                case MYSQL_TYPE_SHORT:
                    if (buffer_sz < sizeof(int16_t)) buffer_sz = sizeof(int16_t);
                    break;
                case MYSQL_TYPE_INT24:
                case MYSQL_TYPE_LONG:
                    if (buffer_sz < sizeof(int32_t)) buffer_sz = sizeof(int32_t);
                    break;
                case MYSQL_TYPE_LONGLONG:
                    if (buffer_sz < sizeof(int64_t)) buffer_sz = sizeof(int64_t);
                    break;
                case MYSQL_TYPE_FLOAT:
                    if (buffer_sz < sizeof(float)) buffer_sz = sizeof(float);
                    break;
                case MYSQL_TYPE_DOUBLE:
                    if (buffer_sz < sizeof(double)) buffer_sz = sizeof(double);
                    break;
                case MYSQL_TYPE_BIT:
                    buffer_sz = (meta.length + 7) / 8;
                    if (buffer_sz == 0) buffer_sz = 1;
                    break;
                case MYSQL_TYPE_DATE:
                case MYSQL_TYPE_TIME:
                case MYSQL_TYPE_DATETIME:
                case MYSQL_TYPE_TIMESTAMP:
                case MYSQL_TYPE_YEAR:
                    buffer_sz = sizeof(MYSQL_TIME);
                    break;
                case MYSQL_TYPE_DECIMAL:
                case MYSQL_TYPE_NEWDECIMAL:
                    if (buffer_sz == 0)
                        buffer_sz = 66;
                    else if (buffer_sz < 66)
                        buffer_sz = 66;
                    break;
                case MYSQL_TYPE_STRING:
                case MYSQL_TYPE_VAR_STRING:
                case MYSQL_TYPE_VARCHAR:
                case MYSQL_TYPE_BLOB:
                case MYSQL_TYPE_TINY_BLOB:
                case MYSQL_TYPE_MEDIUM_BLOB:
                case MYSQL_TYPE_LONG_BLOB:
                case MYSQL_TYPE_JSON:
                case MYSQL_TYPE_ENUM:
                case MYSQL_TYPE_SET:
                case MYSQL_TYPE_GEOMETRY:
                    if (buffer_sz == 0)
                        buffer_sz = (meta.max_length > 0) ? meta.max_length : 256;
                    else if (meta.max_length > 0 && buffer_sz < meta.max_length)
                        buffer_sz = meta.max_length;
                    if (buffer_sz == 0) buffer_sz = 256;
                    break;
                default:
                    if (buffer_sz == 0) buffer_sz = 256;
                    break;
            }
            if (buffer_sz == 0) buffer_sz = 1;

            m_output_data_buffers[i].assign(buffer_sz, (unsigned char)0);
            bind.buffer = m_output_data_buffers[i].data();
            bind.buffer_length = buffer_sz;
            bind.length = &m_output_length_indicators[i];
            bind.is_null = reinterpret_cast<bool*>(&m_output_is_null_indicators[i]);
            bind.error = reinterpret_cast<bool*>(&m_output_error_indicators[i]);
            bind.is_unsigned = (meta.flags & UNSIGNED_FLAG);
        }

        if (mysql_stmt_bind_result(m_mysql_stmt_handle_for_fetch, m_output_bind_buffers.data()) != 0) {
            if (m_statement)
                m_error_collector_owned = m_statement->getError();
            else if (m_mysql_stmt_handle_for_fetch)
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_bind_result failed.", mysql_stmt_errno(m_mysql_stmt_handle_for_fetch), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
            else
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_bind_result failed (no statement context).");
            m_is_valid = false;
        }
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_result_value_access.cpp
#include <mysql/mysql.h>  // For MYSQL_FIELD

#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "mysql_protocol/mysql_type_converter.h"  // For MySqlNativeValue and conversion functions

namespace cpporm_mysql_transport {

    std::optional<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getValue(unsigned int col_idx) {
        if (!m_is_valid || col_idx >= m_field_count) {
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid column index for getValue.");
            return std::nullopt;
        }
        if (m_fields_meta.size() <= col_idx) {
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Field metadata inconsistent with field count in getValue.");
            return std::nullopt;
        }
        if (m_current_row_idx == -1) {  // No valid row fetched (either before first fetch, after last, or after an error)
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "No current valid row to get value from.");
            return std::nullopt;
        }

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch) {  // m_fetched_all_from_stmt implies no current row too
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid state for prepared statement getValue (no handle or past end).");
                return std::nullopt;
            }
            if (m_output_is_null_indicators.size() <= col_idx || m_output_bind_buffers.size() <= col_idx) {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Output bind/indicator buffers out of sync for prepared statement getValue.");
                return std::nullopt;
            }

            if (m_output_is_null_indicators[col_idx] != 0) {
                mysql_protocol::MySqlNativeValue nv;
                nv.original_mysql_type = m_fields_meta[col_idx].native_type_id;
                nv.original_mysql_flags = m_fields_meta[col_idx].flags;
                nv.original_charsetnr = m_fields_meta[col_idx].charsetnr;
                return nv;
            }

            auto expected_nv = mysql_protocol::mySqlBoundResultToNativeValue(&m_output_bind_buffers[col_idx], m_fields_meta[col_idx].flags, m_fields_meta[col_idx].charsetnr);
            if (expected_nv) {
                return expected_nv.value();
            } else {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ProtocolError, "Failed to convert bound result to NativeValue: " + expected_nv.error().error_message, 0, nullptr, nullptr, expected_nv.error().error_code);
                return std::nullopt;
            }

        } else {  // From non-prepared (MYSQL_RES)
            if (!m_current_sql_row) {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "No current row fetched for non-prepared statement getValue.");
                return std::nullopt;
            }
            if (m_current_sql_row[col_idx] == nullptr) {
                mysql_protocol::MySqlNativeValue nv;
                nv.original_mysql_type = m_fields_meta[col_idx].native_type_id;
                nv.original_mysql_flags = m_fields_meta[col_idx].flags;
                nv.original_charsetnr = m_fields_meta[col_idx].charsetnr;
                return nv;
            }

            MYSQL_FIELD* field_info = mysql_fetch_field_direct(m_mysql_res_metadata, col_idx);
            if (!field_info) {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Failed to fetch field info for getValue.");
                return std::nullopt;
            }
            if (!m_current_lengths) {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::InternalError, "Row lengths not available for non-prepared getValue.");
                return std::nullopt;
            }

            auto expected_nv = mysql_protocol::mySqlRowFieldToNativeValue(m_current_sql_row[col_idx], m_current_lengths[col_idx], field_info);
            if (expected_nv) {
                return expected_nv.value();
            } else {
                m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ProtocolError, "Failed to convert row field to NativeValue: " + expected_nv.error().error_message, 0, nullptr, nullptr, expected_nv.error().error_code);
                return std::nullopt;
            }
        }
    }

    std::optional<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getValue(const std::string& col_name) {
        int idx = getFieldIndex(col_name);
        if (idx == -1) {
            m_error_collector_owned = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid column name for getValue: " + col_name);
            return std::nullopt;
        }
        return getValue(static_cast<unsigned int>(idx));
    }

    bool MySqlTransportResult::isNull(unsigned int col_idx) {
        if (!m_is_valid || col_idx >= m_field_count || m_current_row_idx == -1) {
            return true;
        }

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch) return true;
            if (m_output_is_null_indicators.size() <= col_idx) return true;
            return m_output_is_null_indicators[col_idx] != 0;
        } else {
            if (!m_current_sql_row) return true;
            return m_current_sql_row[col_idx] == nullptr;
        }
    }

    bool MySqlTransportResult::isNull(const std::string& col_name) {
        int idx = getFieldIndex(col_name);
        if (idx == -1) return true;
        return isNull(static_cast<unsigned int>(idx));
    }

    std::vector<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getCurrentRowValues() {
        std::vector<mysql_protocol::MySqlNativeValue> row_values;
        if (!m_is_valid || m_field_count == 0 || m_current_row_idx == -1) {
            return row_values;
        }
        row_values.reserve(m_field_count);
        for (unsigned int i = 0; i < m_field_count; ++i) {
            auto val_opt = getValue(i);
            if (val_opt) {
                row_values.push_back(std::move(*val_opt));
            } else {
                // Error already set by getValue, push a default NULL value
                mysql_protocol::MySqlNativeValue null_val;
                if (m_fields_meta.size() > i) {
                    null_val.original_mysql_type = m_fields_meta[i].native_type_id;
                    null_val.original_mysql_flags = m_fields_meta[i].flags;
                    null_val.original_charsetnr = m_fields_meta[i].charsetnr;
                } else {
                    null_val.original_mysql_type = MYSQL_TYPE_NULL;
                }
                row_values.push_back(std::move(null_val));
            }
        }
        return row_values;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"

#include <mysql/mysql.h>  // Ensure MYSQL type is fully defined

namespace cpporm_mysql_transport {

    // No constructor needed if methods are simple wrappers or connection context isn't stored.

    std::string MySqlTransportServerInfoProvider::getServerVersionString(MYSQL* mysql_handle) const {
        if (mysql_handle) {
            const char* server_info = mysql_get_server_info(mysql_handle);
            if (server_info) {
                return std::string(server_info);
            }
        }
        // Return empty or a specific "N/A" string if handle is null or info is null.
        // Throwing an exception might be too aggressive for a simple info getter.
        return "";
    }

    unsigned long MySqlTransportServerInfoProvider::getServerVersionNumber(MYSQL* mysql_handle) const {
        if (mysql_handle) {
            return mysql_get_server_version(mysql_handle);
        }
        return 0;  // 0 can indicate an error or that the handle is invalid.
    }

    std::string MySqlTransportServerInfoProvider::getHostInfo(MYSQL* mysql_handle, bool is_connected) const {
        // mysql_get_host_info() typically requires an active connection to return meaningful data.
        if (mysql_handle && is_connected) {
            const char* host_info = mysql_get_host_info(mysql_handle);
            if (host_info) {
                return std::string(host_info);
            }
        }
        return "";
    }

    // Potential additions:
    // unsigned long MySqlTransportServerInfoProvider::getThreadId(MYSQL* mysql_handle, bool is_connected) const {
    //     if (mysql_handle && is_connected) {
    //         return mysql_thread_id(mysql_handle);
    //     }
    //     return 0; // Or some error indicator
    // }
    //
    // unsigned int MySqlTransportServerInfoProvider::getProtocolVersion(MYSQL* mysql_handle) const {
    //     if (mysql_handle) {
    //         return mysql_get_proto_info(mysql_handle);
    //     }
    //     return 0;
    // }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include <cstring>  // For std::memset

#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    bool MySqlTransportStatement::bindParam(unsigned int pos_zero_based, const MySqlTransportBindParam& param) {
        // 更正：首先检查是否是工具类命令
        if (m_is_utility_command) {
            setError(MySqlTransportError::Category::ApiUsageError, "Cannot bind parameters to a utility command (e.g., SHOW, DESCRIBE).");
            return false;
        }

        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for bindParam.");
            return false;
        }
        if (!m_is_prepared) {
            if (!prepare()) {
                return false;
            }
        }
        if (pos_zero_based >= m_bind_buffers.size()) {
            setError(MySqlTransportError::Category::ApiUsageError, "Bind position out of range.");
            return false;
        }

        clearError();

        // 重置特定的绑定缓冲区条目
        std::memset(&m_bind_buffers[pos_zero_based], 0, sizeof(MYSQL_BIND));

        auto& bind_struct = m_bind_buffers[pos_zero_based];
        auto& data_buffer = m_param_data_buffers[pos_zero_based];
        auto& is_null_indicator = m_param_is_null_indicators[pos_zero_based];
        auto& length_indicator = m_param_length_indicators[pos_zero_based];

        const auto& native_value = param.value;

        if (native_value.is_null()) {
            auto result = mysql_protocol::setupMySqlBindForNull(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), MYSQL_TYPE_NULL);
            if (!result) {
                setErrorFromProtocol(result.error(), "Failed to setup bind for NULL");
                return false;
            }
            // 对于 setupMySqlBindForNull, buffer 和其他指针成员由函数设置
            return true;
        }

        std::expected<void, mysql_protocol::MySqlProtocolError> result;

        if (std::holds_alternative<bool>(native_value.data)) {
            // 对于基本类型，数据直接存在成员中，buffer指向该成员
            data_buffer.resize(sizeof(bool));
            *reinterpret_cast<bool*>(data_buffer.data()) = std::get<bool>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), std::get<bool>(native_value.data));
        } else if (std::holds_alternative<int8_t>(native_value.data)) {
            data_buffer.resize(sizeof(int8_t));
            *reinterpret_cast<int8_t*>(data_buffer.data()) = std::get<int8_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), native_value.original_mysql_flags & UNSIGNED_FLAG, *reinterpret_cast<int8_t*>(data_buffer.data()));
        } else if (std::holds_alternative<uint8_t>(native_value.data)) {
            data_buffer.resize(sizeof(uint8_t));
            *reinterpret_cast<uint8_t*>(data_buffer.data()) = std::get<uint8_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), true, *reinterpret_cast<int8_t*>(data_buffer.data()));
        } else if (std::holds_alternative<int16_t>(native_value.data)) {
            data_buffer.resize(sizeof(int16_t));
            *reinterpret_cast<int16_t*>(data_buffer.data()) = std::get<int16_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), native_value.original_mysql_flags & UNSIGNED_FLAG, *reinterpret_cast<int16_t*>(data_buffer.data()));
        } else if (std::holds_alternative<uint16_t>(native_value.data)) {
            data_buffer.resize(sizeof(uint16_t));
            *reinterpret_cast<uint16_t*>(data_buffer.data()) = std::get<uint16_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), true, *reinterpret_cast<int16_t*>(data_buffer.data()));
        } else if (std::holds_alternative<int32_t>(native_value.data)) {
            data_buffer.resize(sizeof(int32_t));
            *reinterpret_cast<int32_t*>(data_buffer.data()) = std::get<int32_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), native_value.original_mysql_flags & UNSIGNED_FLAG, *reinterpret_cast<int32_t*>(data_buffer.data()));
        } else if (std::holds_alternative<uint32_t>(native_value.data)) {
            data_buffer.resize(sizeof(uint32_t));
            *reinterpret_cast<uint32_t*>(data_buffer.data()) = std::get<uint32_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), true, *reinterpret_cast<int32_t*>(data_buffer.data()));
        } else if (std::holds_alternative<int64_t>(native_value.data)) {
            data_buffer.resize(sizeof(int64_t));
            *reinterpret_cast<int64_t*>(data_buffer.data()) = std::get<int64_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), native_value.original_mysql_flags & UNSIGNED_FLAG, *reinterpret_cast<int64_t*>(data_buffer.data()));
        } else if (std::holds_alternative<uint64_t>(native_value.data)) {
            data_buffer.resize(sizeof(uint64_t));
            *reinterpret_cast<uint64_t*>(data_buffer.data()) = std::get<uint64_t>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), true, *reinterpret_cast<int64_t*>(data_buffer.data()));
        } else if (std::holds_alternative<float>(native_value.data)) {
            data_buffer.resize(sizeof(float));
            *reinterpret_cast<float*>(data_buffer.data()) = std::get<float>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), *reinterpret_cast<float*>(data_buffer.data()));
        } else if (std::holds_alternative<double>(native_value.data)) {
            data_buffer.resize(sizeof(double));
            *reinterpret_cast<double*>(data_buffer.data()) = std::get<double>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInput(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), *reinterpret_cast<double*>(data_buffer.data()));
        } else if (std::holds_alternative<std::string>(native_value.data)) {
            const auto& str = std::get<std::string>(native_value.data);
            data_buffer.assign(str.begin(), str.end());
            result = mysql_protocol::setupMySqlBindForInputString(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), &length_indicator, native_value.original_mysql_type, reinterpret_cast<char*>(data_buffer.data()), data_buffer.size());
        } else if (std::holds_alternative<std::vector<unsigned char>>(native_value.data)) {
            data_buffer = std::get<std::vector<unsigned char>>(native_value.data);
            result = mysql_protocol::setupMySqlBindForInputBlob(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), &length_indicator, native_value.original_mysql_type, data_buffer.data(), data_buffer.size());
        } else if (std::holds_alternative<MYSQL_TIME>(native_value.data)) {
            data_buffer.resize(sizeof(MYSQL_TIME));
            std::memcpy(data_buffer.data(), &std::get<MYSQL_TIME>(native_value.data), sizeof(MYSQL_TIME));
            result = mysql_protocol::setupMySqlBindForInputTime(bind_struct, reinterpret_cast<bool*>(&is_null_indicator), native_value.original_mysql_type, reinterpret_cast<MYSQL_TIME*>(data_buffer.data()));
        } else {
            result = std::unexpected(mysql_protocol::MySqlProtocolError(mysql_protocol::InternalErrc::CONVERSION_UNSUPPORTED_TYPE, "Unsupported type for binding in MySqlTransportStatement"));
        }

        if (!result) {
            setErrorFromProtocol(result.error(), "Failed to setup bind for input parameter at pos " + std::to_string(pos_zero_based));
            return false;
        }

        // setupMySqlBind* 函数已经设置了 bind_struct.buffer 指向 data_buffer.data()
        // 因此这里不需要再显式设置

        return true;
    }

    bool MySqlTransportStatement::bindParams(const std::vector<MySqlTransportBindParam>& params) {
        // 更正：这是修复 SHOW/DESCRIBE 命令问题的关键
        if (m_is_utility_command) {
            if (!params.empty()) {
                setError(MySqlTransportError::Category::ApiUsageError, "Cannot bind parameters to a utility command (e.g., SHOW, DESCRIBE).");
                return false;
            }
            return true;  // 对工具类命令“绑定”零个参数是合法的
        }

        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for bindParams.");
            return false;
        }

        if (!m_is_prepared) {
            if (!prepare()) {
                return false;
            }
        }

        if (params.size() != m_bind_buffers.size()) {
            setError(MySqlTransportError::Category::ApiUsageError, "Parameter count mismatch. Expected " + std::to_string(m_bind_buffers.size()) + ", got " + std::to_string(params.size()) + ".");
            return false;
        }

        for (size_t i = 0; i < params.size(); ++i) {
            if (!bindParam(static_cast<unsigned int>(i), params[i])) {
                // bindParam 已经设置了错误
                return false;
            }
        }

        if (mysql_stmt_bind_param(m_stmt_handle, m_bind_buffers.data()) != 0) {
            setErrorFromStatementHandle("mysql_stmt_bind_param failed");
            return false;
        }

        return true;
    }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include <algorithm>  // For std::transform
#include <string>

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportStatement::MySqlTransportStatement(MySqlTransportConnection* conn, const std::string& query) : m_connection(conn), m_original_query(query), m_stmt_handle(nullptr), m_is_prepared(false), m_is_utility_command(false), m_affected_rows(0), m_last_insert_id(0), m_warning_count(0) {
        if (!m_connection || !m_connection->getNativeHandle()) {
            setError(MySqlTransportError::Category::ApiUsageError, "Invalid or uninitialized connection provided to statement.");
            return;
        }

        std::string upper_query;
        upper_query.resize(m_original_query.size());
        std::transform(m_original_query.begin(), m_original_query.end(), upper_query.begin(), [](unsigned char c) {
            return static_cast<char>(std::toupper(c));
        });

        if (upper_query.rfind("SHOW ", 0) == 0 || upper_query.rfind("DESC ", 0) == 0 || upper_query.rfind("DESCRIBE ", 0) == 0 || upper_query.rfind("EXPLAIN ", 0) == 0) {
            m_is_utility_command = true;
        } else {
            m_is_utility_command = false;
            m_stmt_handle = mysql_stmt_init(m_connection->getNativeHandle());
            if (!m_stmt_handle) {
                setErrorFromConnectionHandle(m_connection->getNativeHandle(), "mysql_stmt_init failed");
            }
        }
    }

    MySqlTransportStatement::~MySqlTransportStatement() {
        close();
    }

    MySqlTransportStatement::MySqlTransportStatement(MySqlTransportStatement&& other) noexcept
        : m_connection(other.m_connection),
          m_original_query(std::move(other.m_original_query)),
          m_stmt_handle(other.m_stmt_handle),
          m_is_prepared(other.m_is_prepared),
          m_is_utility_command(other.m_is_utility_command),
          m_bind_buffers(std::move(other.m_bind_buffers)),
          m_param_data_buffers(std::move(other.m_param_data_buffers)),
          m_param_is_null_indicators(std::move(other.m_param_is_null_indicators)),
          m_param_length_indicators(std::move(other.m_param_length_indicators)),
          m_last_error(std::move(other.m_last_error)),
          m_affected_rows(other.m_affected_rows),
          m_last_insert_id(other.m_last_insert_id),
          m_warning_count(other.m_warning_count) {
        other.m_stmt_handle = nullptr;
        other.m_is_prepared = false;
    }

    MySqlTransportStatement& MySqlTransportStatement::operator=(MySqlTransportStatement&& other) noexcept {
        if (this != &other) {
            close();

            m_connection = other.m_connection;
            m_original_query = std::move(other.m_original_query);
            m_stmt_handle = other.m_stmt_handle;
            m_is_prepared = other.m_is_prepared;
            m_is_utility_command = other.m_is_utility_command;
            m_bind_buffers = std::move(other.m_bind_buffers);
            m_param_data_buffers = std::move(other.m_param_data_buffers);
            m_param_is_null_indicators = std::move(other.m_param_is_null_indicators);
            m_param_length_indicators = std::move(other.m_param_length_indicators);
            m_last_error = std::move(other.m_last_error);
            m_affected_rows = other.m_affected_rows;
            m_last_insert_id = other.m_last_insert_id;
            m_warning_count = other.m_warning_count;

            other.m_stmt_handle = nullptr;
            other.m_is_prepared = false;
        }
        return *this;
    }

    void MySqlTransportStatement::close() {
        if (m_stmt_handle) {
            mysql_stmt_close(m_stmt_handle);
            m_stmt_handle = nullptr;
        }
        m_is_prepared = false;
        m_bind_buffers.clear();
        m_param_data_buffers.clear();
        m_param_is_null_indicators.clear();
        m_param_length_indicators.clear();
        clearError();
    }

    bool MySqlTransportStatement::isPrepared() const {
        return m_is_prepared;
    }

    void MySqlTransportStatement::clearError() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportStatement::setError(MySqlTransportError::Category cat, const std::string& msg, unsigned int proto_errc) {
        m_last_error = MySqlTransportError(cat, msg, 0, nullptr, nullptr, proto_errc, m_original_query);
    }

    void MySqlTransportStatement::setErrorFromConnectionHandle(MYSQL* handle_to_check_error_on, const std::string& context) {
        if (!handle_to_check_error_on) {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context + ": MySQL connection handle is null.", 0, nullptr, nullptr, 0, m_original_query);
            return;
        }
        unsigned int err_no = mysql_errno(handle_to_check_error_on);
        if (err_no != 0) {
            const char* sql_state = mysql_sqlstate(handle_to_check_error_on);
            const char* err_msg_c = mysql_error(handle_to_check_error_on);
            std::string full_msg = context + ": " + (err_msg_c ? err_msg_c : "Unknown MySQL error");
            m_last_error = MySqlTransportError(MySqlTransportError::Category::QueryError, full_msg, static_cast<int>(err_no), sql_state, err_msg_c, 0, m_original_query);
        } else if (!context.empty() && m_last_error.isOk()) {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context, 0, nullptr, nullptr, 0, m_original_query);
        }
    }

    void MySqlTransportStatement::setErrorFromStatementHandle(const std::string& context) {
        if (!m_stmt_handle) {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context + ": MySQL statement handle is null.", 0, nullptr, nullptr, 0, m_original_query);
            return;
        }
        unsigned int err_no = mysql_stmt_errno(m_stmt_handle);
        if (err_no != 0) {
            const char* sql_state = mysql_stmt_sqlstate(m_stmt_handle);
            const char* err_msg_c = mysql_stmt_error(m_stmt_handle);
            std::string full_msg = context + ": " + (err_msg_c ? err_msg_c : "Unknown MySQL statement error");
            m_last_error = MySqlTransportError(MySqlTransportError::Category::QueryError, full_msg, static_cast<int>(err_no), sql_state, err_msg_c, 0, m_original_query);
        } else if (!context.empty() && m_last_error.isOk()) {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context, 0, nullptr, nullptr, 0, m_original_query);
        }
    }

    void MySqlTransportStatement::setErrorFromProtocol(const mysql_protocol::MySqlProtocolError& proto_err, const std::string& context) {
        m_last_error = MySqlTransportError(MySqlTransportError::Category::ProtocolError, context + ": " + proto_err.error_message, 0, proto_err.sql_state, nullptr, proto_err.error_code, m_original_query);
    }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    std::optional<my_ulonglong> MySqlTransportStatement::execute() {
        if (m_is_utility_command) {
            setError(MySqlTransportError::Category::ApiUsageError, "Utility commands (like SHOW) should be run via executeQuery, not execute.");
            return std::nullopt;
        }

        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for execute.");
            return std::nullopt;
        }
        if (!m_is_prepared) {
            if (!prepare()) {
                return std::nullopt;
            }
        }
        clearError();
        m_affected_rows = 0;
        m_last_insert_id = 0;
        m_warning_count = 0;

        if (mysql_stmt_execute(m_stmt_handle) != 0) {
            setErrorFromStatementHandle("mysql_stmt_execute failed");
            return std::nullopt;
        }

        m_affected_rows = mysql_stmt_affected_rows(m_stmt_handle);
        m_last_insert_id = mysql_stmt_insert_id(m_stmt_handle);

        // 更正：使用 mysql_warning_count 并从连接句柄获取
        if (m_connection && m_connection->getNativeHandle()) {
            m_warning_count = mysql_warning_count(m_connection->getNativeHandle());
        }

        int status;
        do {
            MYSQL_RES* meta = mysql_stmt_result_metadata(m_stmt_handle);
            if (meta) {
                mysql_free_result(meta);
            } else {
                if (mysql_stmt_errno(m_stmt_handle) != 0) {
                    // 通常这里的错误会被 mysql_stmt_execute 捕获，这里可以忽略或记录日志
                }
            }
            status = mysql_stmt_next_result(m_stmt_handle);
            if (status > 0) {  // error
                setErrorFromStatementHandle("Error in mysql_stmt_next_result after DML");
                return std::nullopt;
            }
        } while (status == 0);

        if (status == -1) {
            if (mysql_stmt_errno(m_stmt_handle) != 0) {
                setErrorFromStatementHandle("Error after processing all results in DML execute");
                return std::nullopt;
            }
        }

        return m_affected_rows;
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_statement_info.cpp
#include "cpporm_mysql_transport/mysql_transport_statement.h"
// No other specific includes needed for these simple getters

namespace cpporm_mysql_transport {

    my_ulonglong MySqlTransportStatement::getAffectedRows() const {
        return m_affected_rows;
    }

    my_ulonglong MySqlTransportStatement::getLastInsertId() const {
        return m_last_insert_id;
    }

    unsigned int MySqlTransportStatement::getWarningCount() const {
        // This returns the warning count from the *connection* after the last statement execution.
        // Not specific to the statement if mysql_stmt_warning_count is unavailable.
        return m_warning_count;
    }

    MySqlTransportError MySqlTransportStatement::getError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    bool MySqlTransportStatement::prepare() {
        if (m_is_utility_command) {
            m_is_prepared = true;
            return true;
        }

        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle is not initialized for prepare (non-utility command).");
            return false;
        }
        if (m_is_prepared) {
            return true;
        }

        clearError();

        if (mysql_stmt_prepare(m_stmt_handle, m_original_query.c_str(), m_original_query.length()) != 0) {
            setErrorFromStatementHandle("mysql_stmt_prepare failed");
            m_is_prepared = false;
            return false;
        }

        m_is_prepared = true;
        unsigned long param_count_long = mysql_stmt_param_count(m_stmt_handle);
        if (param_count_long > 0) {
            unsigned int param_count = static_cast<unsigned int>(param_count_long);
            m_bind_buffers.assign(param_count, MYSQL_BIND{});
            m_param_data_buffers.assign(param_count, std::vector<unsigned char>());
            m_param_is_null_indicators.assign(param_count, (unsigned char)0);
            m_param_length_indicators.assign(param_count, 0UL);
        } else {
            m_bind_buffers.clear();
            m_param_data_buffers.clear();
            m_param_is_null_indicators.clear();
            m_param_length_indicators.clear();
        }
        return true;
    }

}  // namespace cpporm_mysql_transport#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    std::unique_ptr<MySqlTransportResult> MySqlTransportStatement::executeQuery() {
        if (!m_connection || !m_connection->getNativeHandle()) {
            setError(MySqlTransportError::Category::ApiUsageError, "Connection or native handle not available for executeQuery.");
            return nullptr;
        }

        clearError();
        m_affected_rows = 0;
        m_last_insert_id = 0;
        m_warning_count = 0;

        MYSQL_RES* res_handle = nullptr;

        if (m_is_utility_command) {
            if (mysql_real_query(m_connection->getNativeHandle(), m_original_query.c_str(), m_original_query.length()) != 0) {
                setErrorFromConnectionHandle(m_connection->getNativeHandle(), "mysql_real_query failed for utility command: " + m_original_query);
                return nullptr;
            }
            res_handle = mysql_store_result(m_connection->getNativeHandle());
            if (!res_handle && mysql_errno(m_connection->getNativeHandle()) != 0) {
                setErrorFromConnectionHandle(m_connection->getNativeHandle(), "mysql_store_result failed for utility command: " + m_original_query);
                return nullptr;
            }
            m_affected_rows = mysql_affected_rows(m_connection->getNativeHandle());
            m_last_insert_id = mysql_insert_id(m_connection->getNativeHandle());

        } else {
            if (!m_stmt_handle) {
                setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for executeQuery (prepared path).");
                return nullptr;
            }
            if (!m_is_prepared) {
                if (!prepare()) {
                    return nullptr;
                }
            }

            while (mysql_stmt_next_result(m_stmt_handle) == 0);

            if (mysql_stmt_execute(m_stmt_handle) != 0) {
                setErrorFromStatementHandle("mysql_stmt_execute failed in executeQuery");
                return nullptr;
            }

            res_handle = mysql_stmt_result_metadata(m_stmt_handle);
            if (!res_handle) {
                if (mysql_stmt_errno(m_stmt_handle) != 0) {
                    setErrorFromStatementHandle("mysql_stmt_result_metadata failed");
                    return nullptr;
                } else if (mysql_stmt_field_count(m_stmt_handle) == 0) {
                    // 合法情况
                } else {
                    setError(MySqlTransportError::Category::QueryError, "Failed to get result metadata (prepared), but fields were expected.");
                    return nullptr;
                }
            }
            m_affected_rows = mysql_stmt_affected_rows(m_stmt_handle);
            m_last_insert_id = mysql_stmt_insert_id(m_stmt_handle);
        }

        if (m_connection && m_connection->getNativeHandle()) {
            m_warning_count = mysql_warning_count(m_connection->getNativeHandle());
        }

        if (m_is_utility_command) {
            return std::make_unique<MySqlTransportResult>(res_handle, m_last_error);
        } else {
            return std::make_unique<MySqlTransportResult>(this, res_handle, m_last_error);
        }
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_table_lister.cpp
#include "cpporm_mysql_transport/mysql_transport_table_lister.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"
#include "mysql_protocol/mysql_type_converter.h"  // For MySqlNativeValue

namespace cpporm_mysql_transport {

    MySqlTransportTableLister::MySqlTransportTableLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "TableLister: Null connection context provided.");
        }
    }

    void MySqlTransportTableLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportTableLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportTableLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listShowFullTablesFiltered(const std::string& db_name_filter, const std::string& name_pattern, const std::string& target_table_type) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for listing " + target_table_type + "s.");
            return std::nullopt;
        }
        clearError_();

        std::string current_db_for_query = db_name_filter;
        if (current_db_for_query.empty()) {
            current_db_for_query = m_conn_ctx->getCurrentParams().db_name;
        }

        std::string query;
        bool use_like_in_query = false;

        if (target_table_type.empty() && !name_pattern.empty()) {
            query = "SHOW TABLES";
            if (!current_db_for_query.empty()) {
                query += " FROM `" + m_conn_ctx->escapeString(current_db_for_query, false) + "`";
            }
            query += " LIKE '" + m_conn_ctx->escapeString(name_pattern, false) + "'";
            use_like_in_query = true;
        } else {
            query = "SHOW FULL TABLES";
            if (!current_db_for_query.empty()) {
                query += " FROM `" + m_conn_ctx->escapeString(current_db_for_query, false) + "`";
            }
            if (!target_table_type.empty()) {
                query += " WHERE `Table_type` = '" + m_conn_ctx->escapeString(target_table_type, false) + "'";
            }
        }

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for listing " + target_table_type);
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::vector<std::string> names;
        unsigned int name_col_idx = 0;
        unsigned int type_col_idx = (query.find("SHOW FULL TABLES") != std::string::npos) ? 1 : static_cast<unsigned int>(-1);

        while (result->fetchNextRow()) {
            std::optional<mysql_protocol::MySqlNativeValue> name_native_val_opt = result->getValue(name_col_idx);
            if (name_native_val_opt) {
                const auto& native_val = *name_native_val_opt;
                std::optional<std::string> name_str_opt = native_val.get_if<std::string>();
                if (name_str_opt) {
                    const std::string& current_name = *name_str_opt;

                    bool type_match = target_table_type.empty();
                    if (!type_match && type_col_idx != static_cast<unsigned int>(-1)) {
                        std::optional<mysql_protocol::MySqlNativeValue> type_native_val_opt = result->getValue(type_col_idx);
                        if (type_native_val_opt) {
                            std::optional<std::string> type_str_opt = type_native_val_opt->get_if<std::string>();
                            if (type_str_opt && *type_str_opt == target_table_type) {
                                type_match = true;
                            }
                        }
                    }

                    bool name_pattern_match = name_pattern.empty();
                    if (!name_pattern_match) {
                        if (use_like_in_query) {  // LIKE was used in query
                            name_pattern_match = true;
                        } else {  // Client side filtering for name_pattern
                            // TODO: Implement proper SQL LIKE pattern matching for client-side.
                            // For now, a simple exact match or substring if wildcards are not SQL standard.
                            // This is a placeholder for a more robust LIKE comparison.
                            if (name_pattern.find('%') == std::string::npos && name_pattern.find('_') == std::string::npos) {
                                if (current_name == name_pattern) name_pattern_match = true;
                            } else {
                                // Simplified: assume if pattern exists and not used in query, we need a real LIKE.
                                // For this example, we'll just say it matches if not empty.
                                // In a real scenario, use a regex or fnmatch equivalent.
                                name_pattern_match = (current_name.find(name_pattern.substr(0, name_pattern.find('%'))) != std::string::npos);  // Very basic
                            }
                        }
                    }

                    if (type_match && name_pattern_match) {
                        names.push_back(current_name);
                    }
                }
            }
        }
        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }
        return names;
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listTables(const std::string& db_name_filter, const std::string& table_name_pattern) {
        return listShowFullTablesFiltered(db_name_filter, table_name_pattern, "BASE TABLE");
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listViews(const std::string& db_name_filter, const std::string& view_name_pattern) {
        return listShowFullTablesFiltered(db_name_filter, view_name_pattern, "VIEW");
    }

    MySqlTransportError MySqlTransportTableLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"

#include <vector>  // For parsing result of isolation level query

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For executeSimpleQuery, getLastError, etc.
#include "cpporm_mysql_transport/mysql_transport_result.h"      // For getTransactionIsolation querying server
#include "cpporm_mysql_transport/mysql_transport_statement.h"   // For getTransactionIsolation querying server

namespace cpporm_mysql_transport {

    MySqlTransportTransactionManager::MySqlTransportTransactionManager(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context), m_cached_isolation_level(TransactionIsolationLevel::None) {
        if (!m_conn_ctx) {
            // Programming error
            // throw std::invalid_argument("MySqlTransportTransactionManager: connection_context cannot be null.");
        }
    }

    bool MySqlTransportTransactionManager::executeSimpleQueryOnConnection(const std::string& query, const std::string& context_message) {
        if (!m_conn_ctx) return false;  // Should not happen if constructed properly
        // Delegate to a public method on MySqlTransportConnection that executes a simple query
        // and sets its own error state.
        // MySqlTransportConnection must have a method like:
        // bool _internalExecuteSimpleQuery(const std::string& query, const std::string& context_message);
        return m_conn_ctx->_internalExecuteSimpleQuery(query, context_message);
    }

    bool MySqlTransportTransactionManager::beginTransaction() {
        return executeSimpleQueryOnConnection("START TRANSACTION", "Failed to start transaction");
    }

    bool MySqlTransportTransactionManager::commit() {
        return executeSimpleQueryOnConnection("COMMIT", "Failed to commit transaction");
    }

    bool MySqlTransportTransactionManager::rollback() {
        return executeSimpleQueryOnConnection("ROLLBACK", "Failed to rollback transaction");
    }

    bool MySqlTransportTransactionManager::setTransactionIsolation(TransactionIsolationLevel level) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ConnectionError, "Not connected to set transaction isolation.");
            return false;
        }
        std::string sql;
        switch (level) {
            case TransactionIsolationLevel::ReadUncommitted:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED";
                break;
            case TransactionIsolationLevel::ReadCommitted:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED";
                break;
            case TransactionIsolationLevel::RepeatableRead:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ";
                break;
            case TransactionIsolationLevel::Serializable:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE";
                break;
            case TransactionIsolationLevel::None:
                if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Cannot set isolation level to 'None'.");
                return false;
        }

        if (executeSimpleQueryOnConnection(sql, "Failed to set transaction isolation level")) {
            m_cached_isolation_level = level;
            return true;
        }
        return false;
    }

    std::optional<TransactionIsolationLevel> MySqlTransportTransactionManager::getTransactionIsolation() const {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            // Don't set error in const method, caller should check connection status
            return std::nullopt;
        }
        // Return cached if available and valid (not None, unless None is what was explicitly set somehow)
        if (m_cached_isolation_level != TransactionIsolationLevel::None) {
            return m_cached_isolation_level;
        }

        // Query from server: SELECT @@SESSION.transaction_isolation; (or @@SESSION.tx_isolation for older MySQL)
        std::string query_str = "SELECT @@SESSION.transaction_isolation";
        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query_str);
        if (!stmt) {
            // Error already set by createStatement or connection
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            // Error already set by executeQuery or result processing
            return std::nullopt;
        }

        if (result->fetchNextRow()) {
            auto val_opt = result->getValue(0);
            if (val_opt && val_opt.value().get_if<std::string>()) {
                std::string level_str = *val_opt.value().get_if<std::string>();
                // MySQL returns levels like "REPEATABLE-READ", "READ-COMMITTED", etc.
                std::transform(level_str.begin(), level_str.end(), level_str.begin(), [](unsigned char c) {
                    return std::toupper(c);
                });

                if (level_str == "READ-UNCOMMITTED") return TransactionIsolationLevel::ReadUncommitted;
                if (level_str == "READ-COMMITTED") return TransactionIsolationLevel::ReadCommitted;
                if (level_str == "REPEATABLE-READ") return TransactionIsolationLevel::RepeatableRead;
                if (level_str == "SERIALIZABLE") return TransactionIsolationLevel::Serializable;
            }
        }
        // If query fails or result is unexpected, return nullopt. Error should be on connection/statement.
        return std::nullopt;
    }

    void MySqlTransportTransactionManager::updateCachedIsolationLevel(TransactionIsolationLevel level) {
        m_cached_isolation_level = level;
    }

    bool MySqlTransportTransactionManager::setSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name.");
            return false;
        }
        return executeSimpleQueryOnConnection("SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to set savepoint " + name);
    }

    bool MySqlTransportTransactionManager::rollbackToSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name for rollback.");
            return false;
        }
        return executeSimpleQueryOnConnection("ROLLBACK TO SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to rollback to savepoint " + name);
    }

    bool MySqlTransportTransactionManager::releaseSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name for release.");
            return false;
        }
        return executeSimpleQueryOnConnection("RELEASE SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to release savepoint " + name);
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_types.cpp
#include "cpporm_mysql_transport/mysql_transport_types.h"

#include <mysql/mysql.h>
#include <mysql/mysql_time.h>  // For MYSQL_TIMESTAMP_TYPE enum values, included via mysql.h

#include <algorithm>
#include <stdexcept>
#include <string>
#include <vector>

#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    // --- MySqlTransportError ---
    MySqlTransportError::MySqlTransportError(Category cat, std::string msg, int mysql_err, const char* mysql_state, const char* mysql_msg_str, unsigned int proto_errc, std::string query)
        : category(cat), native_mysql_errno(mysql_err), protocol_internal_errc(proto_errc), message(std::move(msg)), failed_query(std::move(query)) {
        if (mysql_state) native_mysql_sqlstate = mysql_state;
        if (mysql_msg_str) native_mysql_error_msg = mysql_msg_str;
    }

    std::string MySqlTransportError::toString() const {
        std::string full_msg = "MySqlTransportError: [Category: ";
        switch (category) {
            case Category::NoError:
                full_msg += "NoError";
                break;
            case Category::ConnectionError:
                full_msg += "ConnectionError";
                break;
            case Category::QueryError:
                full_msg += "QueryError";
                break;
            case Category::DataError:
                full_msg += "DataError";
                break;
            case Category::ResourceError:
                full_msg += "ResourceError";
                break;
            case Category::TransactionError:
                full_msg += "TransactionError";
                break;
            case Category::InternalError:
                full_msg += "InternalError";
                break;
            case Category::ProtocolError:
                full_msg += "ProtocolError";
                break;
            case Category::ApiUsageError:
                full_msg += "ApiUsageError";
                break;
            default:
                full_msg += "Unknown (" + std::to_string(static_cast<int>(category)) + ")";
                break;
        }
        full_msg += "] Message: " + message;
        if (native_mysql_errno != 0) {
            full_msg += " | MySQL Errno: " + std::to_string(native_mysql_errno);
        }
        if (!native_mysql_sqlstate.empty()) {
            full_msg += " | MySQL SQLSTATE: " + native_mysql_sqlstate;
        }
        if (!native_mysql_error_msg.empty() && native_mysql_error_msg != message) {
            full_msg += " | MySQL Error Msg: " + native_mysql_error_msg;
        }
        if (protocol_internal_errc != 0) {
            full_msg += " | Protocol InternalErrc: " + std::to_string(protocol_internal_errc);
        }
        if (!failed_query.empty()) {
            full_msg += " | Failed Query: " + failed_query;
        }
        return full_msg;
    }

    // --- MySqlTransportFieldMeta ---
    bool MySqlTransportFieldMeta::isGenerallyNumeric() const {
        switch (native_type_id) {
            case MYSQL_TYPE_DECIMAL:
            case MYSQL_TYPE_NEWDECIMAL:
            case MYSQL_TYPE_TINY:
            case MYSQL_TYPE_SHORT:
            case MYSQL_TYPE_LONG:
            case MYSQL_TYPE_FLOAT:
            case MYSQL_TYPE_DOUBLE:
            case MYSQL_TYPE_LONGLONG:
            case MYSQL_TYPE_INT24:
            case MYSQL_TYPE_BIT:
            case MYSQL_TYPE_YEAR:
                return true;
            default:
                return false;
        }
    }

    bool MySqlTransportFieldMeta::isGenerallyString() const {
        switch (native_type_id) {
            case MYSQL_TYPE_VARCHAR:
            case MYSQL_TYPE_VAR_STRING:
            case MYSQL_TYPE_STRING:
            case MYSQL_TYPE_TINY_BLOB:
            case MYSQL_TYPE_MEDIUM_BLOB:
            case MYSQL_TYPE_LONG_BLOB:
            case MYSQL_TYPE_BLOB:
            case MYSQL_TYPE_JSON:
            case MYSQL_TYPE_ENUM:
            case MYSQL_TYPE_SET:
            case MYSQL_TYPE_GEOMETRY:
                return true;
            default:
                return false;
        }
    }

    bool MySqlTransportFieldMeta::isGenerallyDateTime() const {
        switch (native_type_id) {
            case MYSQL_TYPE_TIMESTAMP:
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_TIME:
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_NEWDATE:
            case MYSQL_TYPE_YEAR:
                return true;
            default:
                return false;
        }
    }

    // --- MySqlTransportBindParam Constructors ---
    MySqlTransportBindParam::MySqlTransportBindParam() {
        value.data = std::monostate{};
        value.original_mysql_type = MYSQL_TYPE_NULL;
    }

    MySqlTransportBindParam::MySqlTransportBindParam(const mysql_protocol::MySqlNativeValue& v) : value(v) {
    }
    MySqlTransportBindParam::MySqlTransportBindParam(mysql_protocol::MySqlNativeValue&& v) : value(std::move(v)) {
    }

    MySqlTransportBindParam::MySqlTransportBindParam(std::nullptr_t) {
        value.data = std::monostate{};
        value.original_mysql_type = MYSQL_TYPE_NULL;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(bool val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int8_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint8_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int16_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_SHORT;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint16_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_SHORT;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int32_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint32_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONG;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int64_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONGLONG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint64_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONGLONG;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(float val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_FLOAT;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(double val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_DOUBLE;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const char* cval) {
        if (cval) {
            value.data = std::string(cval);
            value.original_mysql_type = MYSQL_TYPE_STRING;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::string& val_str) {
        value.data = val_str;
        value.original_mysql_type = MYSQL_TYPE_STRING;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::string&& val_str) {
        value.data = std::move(val_str);
        value.original_mysql_type = MYSQL_TYPE_STRING;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::string_view val_sv) {
        value.data = std::string(val_sv);
        value.original_mysql_type = MYSQL_TYPE_STRING;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::vector<unsigned char>& val_blob) {
        value.data = val_blob;
        value.original_mysql_type = MYSQL_TYPE_BLOB;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::vector<unsigned char>&& val_blob) {
        value.data = std::move(val_blob);
        value.original_mysql_type = MYSQL_TYPE_BLOB;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const MYSQL_TIME& val_time) {
        value.data = val_time;
        // MYSQL_TIMESTAMP_YEAR is not in the provided mysql_time.h
        // A MYSQL_TIME struct representing a YEAR type would have time_type = MYSQL_TIMESTAMP_DATE
        // and month=0, day=0 (or month=1, day=1, depending on how it's set for YEAR).
        // For binding, we'd likely bind it as MYSQL_TYPE_YEAR if it's just an integer year,
        // or MYSQL_TYPE_DATE if it's a full MYSQL_TIME struct.
        // Since this constructor takes MYSQL_TIME, we'll map based on its time_type.
        switch (val_time.time_type) {
            case MYSQL_TIMESTAMP_DATE:
                value.original_mysql_type = MYSQL_TYPE_DATE;
                // If val_time.month == 0 && val_time.day == 0, it might represent a YEAR,
                // but its native C API type would still be MYSQL_TIMESTAMP_DATE.
                // For binding, if the target column is YEAR, then MYSQL_TYPE_YEAR might be better.
                // However, this constructor doesn't know the target column type.
                break;
            case MYSQL_TIMESTAMP_DATETIME:
            case MYSQL_TIMESTAMP_DATETIME_TZ:
                value.original_mysql_type = MYSQL_TYPE_DATETIME;
                break;
            case MYSQL_TIMESTAMP_TIME:
                value.original_mysql_type = MYSQL_TYPE_TIME;
                break;
            // No MYSQL_TIMESTAMP_YEAR case
            case MYSQL_TIMESTAMP_NONE:
            case MYSQL_TIMESTAMP_ERROR:
            default:
                if (val_time.time_type == MYSQL_TIMESTAMP_ERROR || (val_time.time_type == MYSQL_TIMESTAMP_NONE && val_time.year == 0 && val_time.month == 0 && val_time.day == 0 && val_time.hour == 0 && val_time.minute == 0 && val_time.second == 0 && val_time.second_part == 0)) {
                    value.data = std::monostate{};
                    value.original_mysql_type = MYSQL_TYPE_NULL;
                } else {
                    // For MYSQL_TIMESTAMP_NONE with some data, or unknown time_type,
                    // DATETIME is a general fallback if it has date and time parts.
                    // If only date parts, DATE; if only time, TIME.
                    // This is a simplification; a more robust mapping might be needed.
                    if (val_time.hour == 0 && val_time.minute == 0 && val_time.second == 0 && val_time.second_part == 0) {
                        value.original_mysql_type = MYSQL_TYPE_DATE;  // If only date components are significant
                    } else if (val_time.year == 0 && val_time.month == 0 && val_time.day == 0) {
                        value.original_mysql_type = MYSQL_TYPE_TIME;  // If only time components are significant
                    } else {
                        value.original_mysql_type = MYSQL_TYPE_DATETIME;
                    }
                }
                break;
        }
    }

    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::system_clock::time_point& tp) {
        auto expected_mysql_time = mysql_protocol::systemClockTimePointToMySqlTime(tp, MYSQL_TYPE_DATETIME);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_DATETIME;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::year_month_day& ymd) {
        auto expected_mysql_time = mysql_protocol::yearMonthDayToMySqlDate(ymd);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_DATE;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::microseconds& duration) {
        auto expected_mysql_time = mysql_protocol::durationToMySqlTime(duration);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_TIME;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }

}  // namespace cpporm_mysql_transport// cpporm_mysql_transport/mysql_transport_type_parser.cpp
#include "cpporm_mysql_transport/mysql_transport_type_parser.h"  // Header for the function itself

#include <mysql/mysql.h>      // For flags like UNSIGNED_FLAG etc.
#include <mysql/mysql_com.h>  // For MYSQL_TYPE_ enums

#include <algorithm>  // For std::transform, std::remove_if
#include <cctype>     // For ::isspace, ::tolower
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportFieldMeta

// Helper from the previous version of mysql_transport_column_lister.cpp
// (or a similar helper defined here or in a common utility file)
static std::string removeSubstringCaseInsensitive_parser_local(std::string mainStr, const std::string& subStr) {
    std::string resultStr;
    std::string mainLower = mainStr;
    std::string subLower = subStr;
    std::transform(mainLower.begin(), mainLower.end(), mainLower.begin(), [](unsigned char c) {
        return static_cast<char>(std::tolower(c));
    });
    std::transform(subLower.begin(), subLower.end(), subLower.begin(), [](unsigned char c) {
        return static_cast<char>(std::tolower(c));
    });

    size_t current_pos = 0;
    size_t found_pos = mainLower.find(subLower, current_pos);
    while (found_pos != std::string::npos) {
        resultStr += mainStr.substr(current_pos, found_pos - current_pos);
        current_pos = found_pos + subStr.length();
        found_pos = mainLower.find(subLower, current_pos);
    }
    resultStr += mainStr.substr(current_pos);
    return resultStr;
}

namespace cpporm_mysql_transport {

    bool parseMySQLTypeStringInternal(const std::string& type_str_orig, MySqlTransportFieldMeta& field_meta) {
        if (type_str_orig.empty()) return false;

        std::string working_type_str = type_str_orig;

        std::string lower_check_str = working_type_str;
        std::transform(lower_check_str.begin(), lower_check_str.end(), lower_check_str.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });

        if (lower_check_str.find("unsigned") != std::string::npos) {
            field_meta.flags |= UNSIGNED_FLAG;
            working_type_str = removeSubstringCaseInsensitive_parser_local(working_type_str, "unsigned");
        }

        // Re-lower after removing "unsigned" as "unsigned" itself might affect paren parsing if not careful
        lower_check_str = working_type_str;
        std::transform(lower_check_str.begin(), lower_check_str.end(), lower_check_str.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });

        if (lower_check_str.find("zerofill") != std::string::npos) {
            field_meta.flags |= ZEROFILL_FLAG;
            working_type_str = removeSubstringCaseInsensitive_parser_local(working_type_str, "zerofill");
        }

        // Trim whitespace from the potentially modified working_type_str
        working_type_str.erase(0, working_type_str.find_first_not_of(" \t\n\r\f\v"));
        working_type_str.erase(working_type_str.find_last_not_of(" \t\n\r\f\v") + 1);

        // Re-lower the trimmed string for base type name extraction
        std::string base_type_name_part_lower = working_type_str;
        std::transform(base_type_name_part_lower.begin(), base_type_name_part_lower.end(), base_type_name_part_lower.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });

        size_t paren_open = base_type_name_part_lower.find('(');
        if (paren_open != std::string::npos) {
            size_t paren_close = base_type_name_part_lower.rfind(')');
            if (paren_close != std::string::npos && paren_close > paren_open) {
                std::string params_str = base_type_name_part_lower.substr(paren_open + 1, paren_close - (paren_open + 1));
                // Extract the base type name without parameters and trailing spaces
                base_type_name_part_lower = base_type_name_part_lower.substr(0, paren_open);
                base_type_name_part_lower.erase(base_type_name_part_lower.find_last_not_of(" \t\n\r\f\v") + 1);

                if (base_type_name_part_lower == "tinyint" || base_type_name_part_lower == "smallint" || base_type_name_part_lower == "mediumint" || base_type_name_part_lower == "int" || base_type_name_part_lower == "bigint" || base_type_name_part_lower == "bit") {
                    try {
                        field_meta.length = std::stoul(params_str);
                    } catch (...) { /* ignore parsing errors for length */
                    }
                } else if (base_type_name_part_lower == "char" || base_type_name_part_lower == "varchar" || base_type_name_part_lower == "binary" || base_type_name_part_lower == "varbinary") {
                    try {
                        field_meta.length = std::stoul(params_str);
                    } catch (...) { /* ignore */
                    }
                } else if (base_type_name_part_lower == "float" || base_type_name_part_lower == "double" || base_type_name_part_lower == "real" || base_type_name_part_lower == "decimal" || base_type_name_part_lower == "numeric" || base_type_name_part_lower == "dec") {
                    size_t comma_pos = params_str.find(',');
                    if (comma_pos != std::string::npos) {
                        try {
                            field_meta.length = std::stoul(params_str.substr(0, comma_pos));  // Precision for decimal
                        } catch (...) {                                                       /*ignore*/
                        }
                        try {
                            field_meta.decimals = static_cast<unsigned int>(std::stoul(params_str.substr(comma_pos + 1)));  // Scale for decimal
                        } catch (...) {                                                                                     /*ignore*/
                        }
                    } else {  // Only precision specified for float/double, or M for decimal
                        try {
                            if (base_type_name_part_lower == "decimal" || base_type_name_part_lower == "numeric" || base_type_name_part_lower == "dec") {
                                field_meta.length = std::stoul(params_str);  // M for DECIMAL(M)
                                field_meta.decimals = 0;                     // Default scale 0
                            } else {                                         // float(P) or double(P) - P is bits for storage, not display length. MySQL does not use P for float/double in that way.
                                                                             // For float/double, (M,D) can be specified but M is total digits, D is decimals.
                                                                             // If only one number, it is usually ignored or sets display width for integers with zerofill.
                                                                             // So, just parsing length might be misleading for float/double.
                                                                             // Typically, SHOW COLUMNS returns float/double without (M,D) unless defined with it.
                                                                             // Let's assume if single param for float/double, it's total digits (length).
                                field_meta.length = std::stoul(params_str);
                            }
                        } catch (...) { /*ignore*/
                        }
                    }
                }
                // For ENUM and SET, params_str contains the list of values.
                // Example: ENUM('a','b','c') or SET('x','y','z')
                // field_meta.length could be set to number of options, or max string length of an option.
                // MySqlTransportFieldMeta does not have a dedicated place for enum/set values.
                // This parsing part is complex and depends on how you want to represent it.
                // For native_type_id, just map the base type.
            }
            // If no parentheses, base_type_name_part_lower is already the cleaned base type.
        }

        if (base_type_name_part_lower == "tinyint")
            field_meta.native_type_id = MYSQL_TYPE_TINY;
        else if (base_type_name_part_lower == "smallint")
            field_meta.native_type_id = MYSQL_TYPE_SHORT;
        else if (base_type_name_part_lower == "mediumint")
            field_meta.native_type_id = MYSQL_TYPE_INT24;
        else if (base_type_name_part_lower == "int" || base_type_name_part_lower == "integer")
            field_meta.native_type_id = MYSQL_TYPE_LONG;
        else if (base_type_name_part_lower == "bigint")
            field_meta.native_type_id = MYSQL_TYPE_LONGLONG;
        else if (base_type_name_part_lower == "float")
            field_meta.native_type_id = MYSQL_TYPE_FLOAT;
        else if (base_type_name_part_lower == "double" || base_type_name_part_lower == "real")
            field_meta.native_type_id = MYSQL_TYPE_DOUBLE;
        else if (base_type_name_part_lower == "decimal" || base_type_name_part_lower == "numeric" || base_type_name_part_lower == "dec")
            field_meta.native_type_id = MYSQL_TYPE_NEWDECIMAL;
        else if (base_type_name_part_lower == "date")
            field_meta.native_type_id = MYSQL_TYPE_DATE;
        else if (base_type_name_part_lower == "datetime")
            field_meta.native_type_id = MYSQL_TYPE_DATETIME;
        else if (base_type_name_part_lower == "timestamp")
            field_meta.native_type_id = MYSQL_TYPE_TIMESTAMP;
        else if (base_type_name_part_lower == "time")
            field_meta.native_type_id = MYSQL_TYPE_TIME;
        else if (base_type_name_part_lower == "year")
            field_meta.native_type_id = MYSQL_TYPE_YEAR;
        else if (base_type_name_part_lower == "char") {
            field_meta.native_type_id = MYSQL_TYPE_STRING;
            if (field_meta.length == 0) field_meta.length = 1;
        }  // Default CHAR(1) if no length
        else if (base_type_name_part_lower == "varchar")
            field_meta.native_type_id = MYSQL_TYPE_VAR_STRING;
        else if (base_type_name_part_lower == "tinytext") {
            field_meta.native_type_id = MYSQL_TYPE_TINY_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type_name_part_lower == "text") {
            field_meta.native_type_id = MYSQL_TYPE_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type_name_part_lower == "mediumtext") {
            field_meta.native_type_id = MYSQL_TYPE_MEDIUM_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type_name_part_lower == "longtext") {
            field_meta.native_type_id = MYSQL_TYPE_LONG_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type_name_part_lower == "tinyblob") {
            field_meta.native_type_id = MYSQL_TYPE_TINY_BLOB;
            field_meta.flags |= BLOB_FLAG | BINARY_FLAG;
        } else if (base_type_name_part_lower == "blob") {
            field_meta.native_type_id = MYSQL_TYPE_BLOB;
            field_meta.flags |= BLOB_FLAG | BINARY_FLAG;
        } else if (base_type_name_part_lower == "mediumblob") {
            field_meta.native_type_id = MYSQL_TYPE_MEDIUM_BLOB;
            field_meta.flags |= BLOB_FLAG | BINARY_FLAG;
        } else if (base_type_name_part_lower == "longblob") {
            field_meta.native_type_id = MYSQL_TYPE_LONG_BLOB;
            field_meta.flags |= BLOB_FLAG | BINARY_FLAG;
        } else if (base_type_name_part_lower == "binary") {
            field_meta.native_type_id = MYSQL_TYPE_STRING;
            field_meta.flags |= BINARY_FLAG;
            if (field_meta.length == 0) field_meta.length = 1;
        } else if (base_type_name_part_lower == "varbinary") {
            field_meta.native_type_id = MYSQL_TYPE_VAR_STRING;
            field_meta.flags |= BINARY_FLAG;
        } else if (base_type_name_part_lower == "enum") {
            field_meta.native_type_id = MYSQL_TYPE_ENUM;
            field_meta.flags |= ENUM_FLAG;
        } else if (base_type_name_part_lower == "set") {
            field_meta.native_type_id = MYSQL_TYPE_SET;
            field_meta.flags |= SET_FLAG;
        } else if (base_type_name_part_lower == "bit")
            field_meta.native_type_id = MYSQL_TYPE_BIT;
        else if (base_type_name_part_lower == "json")
            field_meta.native_type_id = MYSQL_TYPE_JSON;
        else if (base_type_name_part_lower == "geometry" || base_type_name_part_lower == "point" || base_type_name_part_lower == "linestring" || base_type_name_part_lower == "polygon" || base_type_name_part_lower == "multipoint" || base_type_name_part_lower == "multilinestring" ||
                 base_type_name_part_lower == "multipolygon" || base_type_name_part_lower == "geometrycollection")
            field_meta.native_type_id = MYSQL_TYPE_GEOMETRY;
        else {                                              // Default for unknown types
            field_meta.native_type_id = MYSQL_TYPE_STRING;  // Or MYSQL_TYPE_UNKNOWN, but STRING is safer for SHOW COLUMNS
        }

        return true;
    }

}  // namespace cpporm_mysql_transportfile(GLOB_RECURSE CPPORM_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(CppOrm ${CPPORM_SOURCES})
target_include_directories(CppOrm PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/Include)
target_link_libraries(CppOrm PUBLIC Qt6::Core DataBaseDriver)

add_subdirectory(Example)add_executable(CppOrmMySqlExample main_cpporm_mysql_example.cpp user_model.h)

# 链接 Qt Core (用于 QDebug 等)
target_link_libraries(CppOrmMySqlExample PRIVATE Qt6::Core)

# 链接 CppOrm 库
# 假设 CppOrm 库的目标名是 "CppOrm" (在 CppOrm/CMakeLists.txt 中定义)
target_link_libraries(CppOrmMySqlExample PRIVATE CppOrm)// Example/main_cpporm_mysql_example.cpp
#include <QCoreApplication>
#include <QDebug>
#include <iostream>
#include <memory>
#include <vector>

#include "cpporm/db_manager.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "sqldriver/mysql/mysql_specific_driver.h"
#include "user_model.h"

cpporm::DbConfig getMySqlConfig() {
    cpporm::DbConfig config;
    config.driver_type = "MYSQL";
    config.host_name = "127.0.0.1";
    config.port = 3306;
    config.database_name = "test_cppgorm_examples";
    config.user_name = "user";
    config.password = "123456789adj";
    config.client_charset = "utf8mb4";
    return config;
}

void runCrudOperations(cpporm::Session& session) {
    qDebug() << "\n--- Running CRUD Operations ---";

    qDebug() << "\n1. Creating users...";
    User user1;
    user1.name = "Alice Wonderland";
    user1.age = 30;
    user1.email = "alice.wonderland@example.com";

    User user2;
    user2.name = "Bob The Builder";
    user2.age = 45;
    user2.email = "bob.builder@example.com";

    auto create_res1 = session.Create(user1);
    if (create_res1) {
        qDebug() << "Created user1, ID:" << user1.id;
        user1.print();
    } else {
        qCritical() << "Failed to create user1:" << QString::fromStdString(create_res1.error().toString());
        return;
    }

    auto create_res2 = session.Create(user2);
    if (create_res2) {
        qDebug() << "Created user2, ID:" << user2.id;
        user2.print();
    } else {
        qCritical() << "Failed to create user2:" << QString::fromStdString(create_res2.error().toString());
    }

    User user3_dup_email;
    user3_dup_email.name = "Charlie Chaplin";
    user3_dup_email.age = 50;
    user3_dup_email.email = "alice.wonderland@example.com";
    auto create_res3 = session.Create(user3_dup_email);
    if (create_res3) {
        qWarning() << "Unexpected: Created user3 with duplicate email. ID:" << user3_dup_email.id;
    } else {
        qInfo() << "Correctly failed to create user3 with duplicate email:" << QString::fromStdString(create_res3.error().toString());
        if (create_res3.error().code == cpporm::ErrorCode::QueryExecutionError || create_res3.error().message.find("Duplicate entry") != std::string::npos || create_res3.error().message.find("UNIQUE constraint failed") != std::string::npos || create_res3.error().native_db_error_code == 1062) {
            qInfo() << "Error indicates constraint violation as expected.";
        }
    }

    qDebug() << "\n2. Reading user with ID:" << user1.id;
    User foundUser1;
    cpporm::Error err = session.First(&foundUser1, user1.id);
    if (!err) {
        qDebug() << "Found user by ID:";
        foundUser1.print();
    } else {
        qCritical() << "Failed to find user by ID " << user1.id << ":" << QString::fromStdString(err.toString());
    }

    qDebug() << "\nReading user with name 'Bob The Builder':";
    User foundUserBob;
    err = session.Model<User>().Where("name = ?", {cpporm::QueryValue(std::string("Bob The Builder"))}).First(&foundUserBob);
    if (!err) {
        qDebug() << "Found user by name:";
        foundUserBob.print();
    } else {
        qWarning() << "Failed to find user by name 'Bob The Builder':" << QString::fromStdString(err.toString());
    }

    qDebug() << "\n3. Updating Alice's age...";
    if (foundUser1.id > 0) {
        foundUser1.age = 31;
        auto save_res = session.Save(foundUser1);
        if (save_res) {
            qDebug() << "Alice updated. Affected rows/status:" << save_res.value();
            User updatedAlice;
            if (!session.First(&updatedAlice, foundUser1.id)) {
                qDebug() << "Alice after update:";
                updatedAlice.print();
            } else {
                qWarning() << "Failed to re-fetch Alice after update.";
            }
        } else {
            qCritical() << "Failed to update Alice:" << QString::fromStdString(save_res.error().toString());
        }
    }

    qDebug() << "\nUpdating age for users older than 40...";
    auto update_res = session.Model<User>().Where("age > ?", {40}).Updates({{"age", cpporm::QueryValue(55)}});
    if (update_res) {
        qDebug() << "Mass update completed. Rows affected:" << update_res.value();
    } else {
        qWarning() << "Mass update failed:" << QString::fromStdString(update_res.error().toString());
    }

    qDebug() << "\n4. Finding all users...";
    std::vector<User> allUsers;
    err = session.Find(&allUsers);
    if (!err) {
        qDebug() << "Found" << allUsers.size() << "users:";
        for (const auto& user : allUsers) {
            user.print();
        }
    } else {
        qCritical() << "Failed to find all users:" << QString::fromStdString(err.toString());
    }

    qDebug() << "\nFinding users with age 55 (using unique_ptr)...";
    std::vector<std::unique_ptr<User>> usersAge55;
    err = session.Model<User>().Where("age = ?", {55}).Find(&usersAge55);
    if (!err) {
        qDebug() << "Found" << usersAge55.size() << "users with age 55:";
        for (const auto& user_ptr : usersAge55) {
            if (user_ptr) user_ptr->print();
        }
    } else {
        qWarning() << "Failed to find users with age 55:" << QString::fromStdString(err.toString());
    }

    qDebug() << "\n5. Deleting Bob (original ID: " << user2.id << ", current model may be different after updates)...";
    User bobForDelete;
    cpporm::Error findBobErr = session.Model<User>().Where("email = ?", {cpporm::QueryValue(std::string("bob.builder@example.com"))}).First(&bobForDelete);

    if (!findBobErr && bobForDelete.id > 0) {
        qDebug() << "Found Bob for deletion, ID: " << bobForDelete.id;
        auto delete_res = session.Delete(bobForDelete);
        if (delete_res) {
            qDebug() << "Bob deleted. Rows affected:" << delete_res.value();
        } else {
            qCritical() << "Failed to delete Bob:" << QString::fromStdString(delete_res.error().toString());
        }
        User deletedBobCheck;
        err = session.First(&deletedBobCheck, bobForDelete.id);
        if (err && err.code == cpporm::ErrorCode::RecordNotFound) {
            qInfo() << "Bob (ID: " << bobForDelete.id << ") correctly not found after deletion.";
        } else if (!err) {
            qWarning() << "Unexpected: Bob (ID: " << bobForDelete.id << ") found after attempting deletion.";
        } else {
            qWarning() << "Error checking for Bob after deletion:" << QString::fromStdString(err.toString());
        }
    } else {
        qWarning() << "Could not find Bob by email for deletion. Original ID was" << user2.id << ". Error:" << QString::fromStdString(findBobErr.toString());
    }

    qDebug() << "\n6. Counting remaining users...";
    auto count_res = session.Model<User>().Count();
    if (count_res) {
        qDebug() << "Number of users remaining:" << count_res.value();
    } else {
        qWarning() << "Failed to count users:" << QString::fromStdString(count_res.error().toString());
    }
}

void runTransactionExample(cpporm::Session& main_session) {
    qDebug() << "\n--- Running Transaction Example ---";

    auto tx_session_expected = main_session.Begin();
    if (!tx_session_expected) {
        qCritical() << "Failed to begin transaction:" << QString::fromStdString(tx_session_expected.error().toString());
        return;
    }
    std::unique_ptr<cpporm::Session> tx_session = std::move(tx_session_expected.value());
    qDebug() << "Transaction started on a new Session wrapper (original session still usable).";

    User user_tx1;
    user_tx1.name = "Tx User One";
    user_tx1.age = 70;
    user_tx1.email = "tx.user.one@example.com";

    auto create_tx1_res = tx_session->Create(user_tx1);
    if (!create_tx1_res) {
        qCritical() << "Failed to create user in transaction:" << QString::fromStdString(create_tx1_res.error().toString());
        cpporm::Error rollback_err = tx_session->Rollback();
        if (rollback_err) {
            qWarning() << "Failed to rollback transaction after error:" << QString::fromStdString(rollback_err.toString());
        } else {
            qDebug() << "Transaction rolled back due to error.";
        }
        return;
    }
    qDebug() << "Created user_tx1 (ID:" << user_tx1.id << ") inside transaction.";

    bool simulate_error = true;
    cpporm::Error tx_op_err;

    if (simulate_error) {
        qDebug() << "Simulating an error, rolling back transaction...";
        tx_op_err = tx_session->Rollback();
        if (tx_op_err) {
            qCritical() << "Failed to rollback transaction:" << QString::fromStdString(tx_op_err.toString());
        } else {
            qDebug() << "Transaction rolled back successfully.";
        }
    } else {
        qDebug() << "Committing transaction...";
        tx_op_err = tx_session->Commit();
        if (tx_op_err) {
            qCritical() << "Failed to commit transaction:" << QString::fromStdString(tx_op_err.toString());
        } else {
            qDebug() << "Transaction committed successfully.";
        }
    }

    // Now, main_session should still be usable as it shares the ISqlDriver.
    User check_tx_user;
    cpporm::Error err_tx_check = main_session.Model<User>().Where("id = ?", {user_tx1.id}).First(&check_tx_user);
    if (simulate_error) {
        if (err_tx_check && err_tx_check.code == cpporm::ErrorCode::RecordNotFound) {
            qInfo() << "User_tx1 (ID:" << user_tx1.id << ") correctly not found after rollback (checked with original session).";
        } else if (!err_tx_check) {
            qWarning() << "Unexpected: User_tx1 (ID:" << user_tx1.id << ") found after rollback (checked with original session)!";
            check_tx_user.print();
        } else {
            qWarning() << "Error checking for user_tx1 after rollback (with original session):" << QString::fromStdString(err_tx_check.toString());
        }
    } else {
        if (!err_tx_check) {
            qInfo() << "User_tx1 (ID:" << user_tx1.id << ") found after commit, as expected (checked with original session).";
            check_tx_user.print();
        } else {
            qWarning() << "User_tx1 (ID:" << user_tx1.id << ") not found after commit or other error (checked with original session):" << QString::fromStdString(err_tx_check.toString());
        }
    }
}

int main(int argc, char* argv[]) {
    QCoreApplication app(argc, argv);

    cpporm_sqldriver::MySqlDriver_Initialize();
    qDebug() << "CppOrm MySQL Example Starting...";
    cpporm::finalize_all_model_meta();
    qDebug() << "Model metadata finalized.";

    cpporm::DbConfig db_config = getMySqlConfig();

    auto db_expected = cpporm::DbManager::openDatabase(db_config);
    if (!db_expected) {
        qCritical() << "Failed to open database:" << QString::fromStdString(db_expected.error().toString());
        return -1;
    }
    cpporm::Session session(std::move(db_expected.value()));

    if (!session.getDbHandle().isOpen()) {
        qCritical() << "Session could not use the database connection (it's not open). Last DB error in session handle:" << QString::fromStdString(session.getDbHandle().lastError().text());
        return -1;
    }
    qDebug() << "Database connection" << QString::fromStdString(session.getConnectionName()) << "opened and session created successfully.";

    qDebug() << "\n--- Running AutoMigration for User model ---";
    cpporm::Error migrate_err = session.AutoMigrate(User::getModelMeta());
    if (migrate_err) {
        qWarning() << "AutoMigration for User model failed:" << QString::fromStdString(migrate_err.toString());
    } else {
        qDebug() << "AutoMigration for User model completed.";
    }

    runCrudOperations(session);
    runTransactionExample(session);  // Original session should remain usable

    if (session.getDbHandle().isOpen()) {
        qDebug() << "\n--- Cleaning up ---";
        auto cleanup_res = session.Model<User>().Where("1=1").Delete();
        if (cleanup_res) {
            qDebug() << "Cleaned up users table. Rows affected:" << cleanup_res.value();
        } else {
            qWarning() << "Failed to clean up users table:" << QString::fromStdString(cleanup_res.error().toString());
        }
    } else {
        qCritical() << "Main session db_handle is no longer open after transaction example. Cleanup cannot proceed.";
        // This indicates a problem if the shared_ptr logic didn't work as expected,
        // or if a transaction error caused the underlying connection to close.
    }

    qDebug() << "Database connection" << QString::fromStdString(session.getConnectionName()) << " will be closed when session goes out of scope.";
    qDebug() << "CppOrm MySQL Example Finished.";

    return 0;
}// Base/CppOrm/Include/user_model.h
#pragma once

#include <QDateTime>
#include <QDebug>  // For print() method

#include "cpporm/model_base.h"
#include "cpporm/model_definition_macros.h"

class User : public cpporm::Model<User> {
  cpporm_DEFINE_MODEL_CLASS_NAME(User)

      public :
      // Switched id to BIGINT AUTO_INCREMENT which is common for MySQL.
      // If your DB needs SERIAL or other, adjust getSqlTypeForCppType accordingly or use explicit DB type hint.
      cpporm_AUTO_INCREMENT_PRIMARY_KEY(long long, id, "id")

      // Changed TEXT to VARCHAR(255) for name and email to allow indexing without prefix length on MySQL
      cpporm_FIELD_TYPE(std::string, name, "name", "VARCHAR(255)") cpporm_FIELD_TYPE(int, age, "age", "INT") cpporm_FIELD_TYPE(std::string, email, "email", "VARCHAR(255)")

          cpporm_TIMESTAMPS(QDateTime)
      // cpporm_SOFT_DELETE(QDateTime)

      User() = default;

    void print() const {
        qDebug() << "User - ID:" << id << "Name:" << QString::fromStdString(name) << "Age:" << age << "Email:" << QString::fromStdString(email) << "Created At:" << created_at.toString(Qt::ISODateWithMs)  // Use ISODateWithMs for more precision if needed
                 << "Updated At:" << updated_at.toString(Qt::ISODateWithMs);
    }

    cpporm_MODEL_BEGIN(User, "users") cpporm_UNIQUE_INDEX("uix_users_email", "email") cpporm_INDEX("idx_users_name_age", "name", "age") cpporm_MODEL_END()
};// cpporm/session.h
#ifndef cpporm_SESSION_H
#define cpporm_SESSION_H

// 核心 Session 类定义（非模板成员，模板成员声明）
#include "cpporm/session_core.h"

// 简单模板化 CRUD 便捷函数的实现
#include "cpporm/session_crud_ops.h"

// CreateBatch 模板函数的实现
#include "cpporm/session_batch_ops.h"

// 如果将来有其他可分离的模板操作组，可以继续添加：
// #include "cpporm/session_preload_ops.h"
// #include "cpporm/session_advanced_query_ops.h"

#endif // cpporm_SESSION_H#ifndef cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H
#define cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H

#include "cpporm/builder_parts/query_builder_conditions_mixin.h" // << 需要 wrap_for_query_value
#include "cpporm/builder_parts/query_builder_state.h"
#include <algorithm>
#include <initializer_list>
#include <set>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

namespace cpporm {

template <typename Derived> class QueryBuilderClausesMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

private:
  // 内部辅助函数：重置（清空）选择字段列表
  void reset_select_fields() { _state().select_fields_.clear(); }

  // 当添加具体的选择项时，如果当前仅有默认的 "*" 选择，则清除它
  void clear_default_select_if_adding_specifics() {
    if (_state().select_fields_.size() == 1 &&
        std::holds_alternative<std::string>(_state().select_fields_[0]) &&
        std::get<std::string>(_state().select_fields_[0]) == "*") {
      _state().select_fields_.clear();
    }
  }

  // 如果选择字段列表为空，则恢复为默认的 "*"
  void restore_default_select_if_empty() {
    if (_state().select_fields_.empty()) {
      _state().select_fields_.push_back(std::string("*"));
    }
  }

  // 内部辅助函数：添加一个选择字段变体到列表（不清除现有）
  // 主要用于公共 Select 方法内部，或者 AddSelect 方法
  void add_select_field_variant(SelectField field_variant) {
    bool found = false;
    if (std::holds_alternative<std::string>(field_variant)) {
      const std::string &field_str_to_add =
          std::get<std::string>(field_variant);
      if (field_str_to_add.empty())
        return;
      // DISTINCT 关键字不应通过 Select 添加，而是通过 Distinct() 方法
      // std::string temp_check_str = field_str_to_add;
      // std::transform(temp_check_str.begin(), temp_check_str.end(),
      //                temp_check_str.begin(), ::tolower);
      // if (temp_check_str == "distinct" && _state().apply_distinct_) {
      //   return; // Distinct() 方法已处理
      // }

      for (const auto &existing_field : _state().select_fields_) {
        if (std::holds_alternative<std::string>(existing_field) &&
            std::get<std::string>(existing_field) == field_str_to_add) {
          found = true; // 简单字符串去重
          break;
        }
      }
    } else if (std::holds_alternative<NamedSubqueryField>(field_variant)) {
      // 子查询通常不基于字符串内容去重，它们的别名可能不同
    }

    if (!found) {
      _state().select_fields_.push_back(std::move(field_variant));
    }
  }

  std::string trim_field_string(const std::string &field_str_with_spaces) {
    size_t first = field_str_with_spaces.find_first_not_of(" \t\n\r\f\v");
    if (std::string::npos == first)
      return "";
    size_t last = field_str_with_spaces.find_last_not_of(" \t\n\r\f\v");
    return field_str_with_spaces.substr(first, (last - first + 1));
  }

public:
  // Select 方法：这些方法应该 *替换* 当前的选择列表
  Derived &Select(const std::string &fields_string) {
    reset_select_fields(); // 清除所有之前的选择项
    std::string temp_field_str;
    std::stringstream ss(fields_string);
    while (std::getline(ss, temp_field_str, ',')) {
      std::string trimmed_field = trim_field_string(temp_field_str);
      if (!trimmed_field.empty()) {
        add_select_field_variant(trimmed_field); // 添加新的选择项
      }
    }
    restore_default_select_if_empty(); // 如果最终列表为空，恢复为 "*"
    return static_cast<Derived &>(*this);
  }

  Derived &Select(const std::vector<std::string> &fields_list) {
    reset_select_fields(); // 清除所有之前的选择项
    if (!fields_list.empty()) {
      for (const auto &field_str : fields_list) {
        std::string trimmed_field = trim_field_string(field_str);
        if (!trimmed_field.empty()) {
          add_select_field_variant(trimmed_field);
        }
      }
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  Derived &Select(std::initializer_list<std::string_view> fields_il) {
    reset_select_fields(); // 清除所有之前的选择项
    if (fields_il.size() > 0) {
      for (std::string_view sv : fields_il) {
        std::string trimmed_field = trim_field_string(std::string(sv));
        if (!trimmed_field.empty()) {
          add_select_field_variant(trimmed_field);
        }
      }
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  template <
      typename... Args,
      std::enable_if_t<
          std::conjunction_v<std::is_convertible<Args, std::string_view>...>,
          int> = 0>
  Derived &Select(std::string_view first_field, Args &&...rest_fields) {
    reset_select_fields(); // 清除所有之前的选择项
    std::string trimmed_first = trim_field_string(std::string(first_field));
    if (!trimmed_first.empty()) {
      add_select_field_variant(trimmed_first);
    }
    if constexpr (sizeof...(Args) > 0) {
      (
          (void)[&] {
            std::string trimmed_rest =
                trim_field_string(std::string(std::forward<Args>(rest_fields)));
            if (!trimmed_rest.empty()) {
              add_select_field_variant(trimmed_rest);
            }
          }(),
          ...);
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  // AddSelect 方法：这些方法 *追加* 到当前的选择列表
  Derived &AddSelect(const std::string &field_or_expr_string) {
    clear_default_select_if_adding_specifics(); // 如果当前仅为 "*", 则清除
    std::string trimmed_field = trim_field_string(field_or_expr_string);
    if (!trimmed_field.empty()) {
      add_select_field_variant(trimmed_field);
    }
    // restore_default_select_if_empty(); // AddSelect 不应该在添加后恢复为 "*",
    // 除非列表在清除 "*" 后仍为空
    if (_state().select_fields_.empty() &&
        field_or_expr_string
            .empty()) { // 仅当添加了一个空字符串且原先是*时才恢复
      restore_default_select_if_empty();
    } else if (_state().select_fields_.empty() &&
               !field_or_expr_string.empty()) {
      // 如果添加了有效字段后列表仍为空（理论上不应该，除非
      // add_select_field_variant 有bug），
      // 或者就是想添加一个有效的，那么不应该恢复为 *
    } else if (_state()
                   .select_fields_
                   .empty()) { // 最终如果还是空的（比如只添加了空字符串）
      restore_default_select_if_empty();
    }

    return static_cast<Derived &>(*this);
  }

  Derived &AddSelect(const NamedSubqueryField &subquery_field) {
    clear_default_select_if_adding_specifics();
    add_select_field_variant(subquery_field);
    // restore_default_select_if_empty(); // 同上，AddSelect 不应轻易恢复为 "*"
    if (_state().select_fields_.empty()) {
      restore_default_select_if_empty();
    }
    return static_cast<Derived &>(*this);
  }
  Derived &AddSelect(
      NamedSubqueryField &&subquery_field) { // Rvalue overload for efficiency
    clear_default_select_if_adding_specifics();
    add_select_field_variant(std::move(subquery_field));
    if (_state().select_fields_.empty()) {
      restore_default_select_if_empty();
    }
    return static_cast<Derived &>(*this);
  }

  Derived &Distinct(bool apply = true) {
    _state().apply_distinct_ = apply;
    return static_cast<Derived &>(*this);
  }

  Derived &Order(const std::string &order_string) {
    _state().order_clause_ = order_string;
    return static_cast<Derived &>(*this);
  }

  Derived &Limit(int limit_val_param) {
    _state().limit_val_ = limit_val_param;
    return static_cast<Derived &>(*this);
  }

  Derived &Offset(int offset_val_param) {
    _state().offset_val_ = offset_val_param;
    return static_cast<Derived &>(*this);
  }

  Derived &Group(const std::string &group_string) {
    _state().group_clause_ = group_string;
    return static_cast<Derived &>(*this);
  }

  // --- Having 方法 ---
  Derived &Having(const std::string &query_str,
                  const std::vector<QueryValue> &args) {
    _state().having_condition_ = std::make_unique<Condition>(query_str, args);
    return static_cast<Derived &>(*this);
  }

  Derived &Having(const std::string &query_str) {
    _state().having_condition_ =
        std::make_unique<Condition>(query_str, std::vector<QueryValue>{});
    return static_cast<Derived &>(*this);
  }

  Derived &Having(const std::string &query_str,
                  std::initializer_list<QueryValue> il) {
    _state().having_condition_ = std::make_unique<Condition>(query_str, il);
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value,
                int> = 0>
  Derived &Having(const std::string &query_str, T &&val1,
                  TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(wrap_for_query_value(std::forward<T>(val1)));
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back(
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().having_condition_ =
        std::make_unique<Condition>(query_str, std::move(collected_args));
    return static_cast<Derived &>(*this);
  }
  // --- 结束 Having 方法 ---

  const std::string &getOrderClause_mixin() const {
    return _state().order_clause_;
  }
  int getLimitVal_mixin() const { return _state().limit_val_; }
  int getOffsetVal_mixin() const { return _state().offset_val_; }
  const std::string &getGroupClause_mixin() const {
    return _state().group_clause_;
  }
  const Condition *getHavingCondition_mixin() const {
    return _state().having_condition_ ? &(*_state().having_condition_)
                                      : nullptr;
  }
  bool isDistinctApplied_mixin() const { return _state().apply_distinct_; }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H#ifndef cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H
#define cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/error.h"
#include <expected>

#include <initializer_list>
#include <iterator>
#include <map>
#include <string>
#include <type_traits>
#include <vector>

#ifdef QT_CORE_LIB
#include <QDebug>
#endif

// Forward declare QueryBuilder for wrap_for_query_value and quoteSqlIdentifier
namespace cpporm {
class QueryBuilder;
}

namespace cpporm {

namespace detail {
template <typename T> struct is_std_initializer_list : std::false_type {};
template <typename E>
struct is_std_initializer_list<std::initializer_list<E>> : std::true_type {};
} // namespace detail

// Modified wrap_for_query_value
template <typename Arg>
QueryValue wrap_for_query_value(Arg &&arg) { // Explicitly return QueryValue
  using DecayedArg = std::decay_t<Arg>;
  if constexpr (std::is_same_v<DecayedArg, const char *> ||
                (std::is_array_v<DecayedArg> &&
                 std::is_same_v<std::remove_extent_t<DecayedArg>,
                                const char>)) {
    return std::string(std::forward<Arg>(arg));
  } else if constexpr (std::is_same_v<DecayedArg, SubqueryExpression>) {
    return std::forward<Arg>(arg);
  } else if constexpr (std::is_base_of_v<QueryBuilder, DecayedArg> ||
                       std::is_same_v<DecayedArg, QueryBuilder>) {
    // If 'arg' is a QueryBuilder (or derived from it), convert it to
    // SubqueryExpression. This requires QueryBuilder::AsSubquery() to be
    // accessible. We need to include "cpporm/query_builder_core.h" for
    // QueryBuilder::AsSubquery, or ensure QueryBuilder is fully defined. This
    // creates a dependency cycle risk if QueryBuilderCore includes this file.
    // A common pattern is to have QueryBuilder::AsSubquery() defined where
    // QueryBuilder is complete. For now, assume 'arg.AsSubquery()' is callable.
    auto sub_expr_expected = arg.AsSubquery();
    if (sub_expr_expected.has_value()) {
      return sub_expr_expected.value();
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "wrap_for_query_value: Failed to convert QueryBuilder to "
                    "SubqueryExpression: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Returning nullptr for QueryValue.";
#endif
      return nullptr;
    }
  } else if constexpr (std::is_constructible_v<QueryValue, DecayedArg>) {
    return QueryValue(
        std::forward<Arg>(arg)); // Explicit construction for QueryValue
  } else {
    // Default forwarding for types directly convertible to one of QueryValue's
    // alternatives If this also fails, it will be a variant construction error.
    return std::forward<Arg>(arg);
  }
}

template <typename Derived> class QueryBuilderConditionsMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  // --- WHERE methods ---
  Derived &Where(const std::string &query_string) {
    _state().where_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 const std::vector<QueryValue> &args) {
    _state().where_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 std::vector<QueryValue> &&args) {
    _state().where_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 std::initializer_list<QueryValue> il) {
    _state().where_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().where_conditions_.insert(_state().where_conditions_.end(),
                                      std::make_move_iterator(mc.begin()),
                                      std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }

  Derived &
  Where(const std::string &query_string,
        const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().where_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Where(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Where(const std::string &query_string, T &&val1,
                 TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed to push_back
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed to push_back
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().where_conditions_.emplace_back(query_string,
                                            std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- OR methods --- (Similar structure to Where)
  Derived &Or(const std::string &query_string) {
    _state().or_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string,
              const std::vector<QueryValue> &args) {
    _state().or_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string, std::vector<QueryValue> &&args) {
    _state().or_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string,
              std::initializer_list<QueryValue> il) {
    _state().or_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().or_conditions_.insert(_state().or_conditions_.end(),
                                   std::make_move_iterator(mc.begin()),
                                   std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }
  Derived &
  Or(const std::string &query_string,
     const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().or_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Or(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Or(const std::string &query_string, T &&val1, TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().or_conditions_.emplace_back(query_string,
                                         std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- NOT methods --- (Similar structure to Where)
  Derived &Not(const std::string &query_string) {
    _state().not_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               const std::vector<QueryValue> &args) {
    _state().not_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               std::vector<QueryValue> &&args) {
    _state().not_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               std::initializer_list<QueryValue> il) {
    _state().not_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().not_conditions_.insert(_state().not_conditions_.end(),
                                    std::make_move_iterator(mc.begin()),
                                    std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }
  Derived &
  Not(const std::string &query_string,
      const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().not_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Not(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Not(const std::string &query_string, T &&val1,
               TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().not_conditions_.emplace_back(query_string,
                                          std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- IN methods ---
  // Takes a vector of QueryValue directly
  Derived &In(const std::string &column_name,
              const std::vector<QueryValue> &values) {
    if (values.empty()) {
      // For an empty IN list, "1 = 0" ensures no rows are matched.
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }

    std::string placeholders;
    placeholders.reserve(values.size() * 3); // Approximate size for "?, ?, ?"
    for (size_t i = 0; i < values.size(); ++i) {
      placeholders += (i == 0 ? "?" : ", ?");
    }

    // QueryBuilder::quoteSqlIdentifier is a public static method
    // This creates a circular dependency if QueryBuilder needs this header.
    // For now, assuming QueryBuilder is defined before this, or
    // quoteSqlIdentifier is moved/forwarded. Let's assume
    // `static_cast<Derived*>(this)->quoteSqlIdentifier()` exists or a global
    // one. For simplicity, we will call a static method assumed to be
    // available.
    // **This means QueryBuilder must be fully defined before this header, or a
    // static helper for quoting must be in a common place.** The easiest is
    // that QueryBuilder.h includes this.
    std::string quoted_column =
        static_cast<Derived *>(this)->quoteSqlIdentifier(
            column_name); // Calling through Derived
    _state().where_conditions_.emplace_back(
        quoted_column + " IN (" + placeholders + ")", values);
    return static_cast<Derived &>(*this);
  }

  Derived &In(const std::string &column_name,
              std::vector<QueryValue> &&values) {
    if (values.empty()) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::string placeholders;
    placeholders.reserve(values.size() * 3);
    for (size_t i = 0; i < values.size(); ++i) {
      placeholders += (i == 0 ? "?" : ", ?");
    }
    std::string quoted_column =
        static_cast<Derived *>(this)->quoteSqlIdentifier(column_name);
    _state().where_conditions_.emplace_back(
        quoted_column + " IN (" + placeholders + ")", std::move(values));
    return static_cast<Derived &>(*this);
  }

  // Templated version for convenience, taking a vector of arbitrary types
  template <typename T>
  Derived &In(const std::string &column_name, const std::vector<T> &values) {
    if (values.empty()) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::vector<QueryValue> qv_values;
    qv_values.reserve(values.size());
    for (const auto &val : values) {
      qv_values.push_back(
          wrap_for_query_value(val)); // Use existing wrap_for_query_value
    }
    return In(column_name,
              std::move(qv_values)); // Delegate to QueryValue vector overload
  }

  // Overload for initializer_list<QueryValue>
  Derived &In(const std::string &column_name,
              std::initializer_list<QueryValue> il) {
    // Create a vector from the initializer_list to reuse the vector overload
    return In(column_name, std::vector<QueryValue>(il.begin(), il.end()));
  }

  // Templated version for initializer_list<T> where T is not QueryValue
  template <
      typename T,
      std::enable_if_t<!std::is_same_v<std::decay_t<T>, QueryValue> &&
                           !std::is_same_v<std::decay_t<T>, SubqueryExpression>,
                       int> = 0>
  Derived &In(const std::string &column_name, std::initializer_list<T> il) {
    if (il.size() == 0) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::vector<QueryValue> qv_values;
    qv_values.reserve(il.size());
    for (const T &val : il) {
      qv_values.push_back(wrap_for_query_value(val));
    }
    return In(column_name, std::move(qv_values)); // Delegate
  }

  const std::vector<Condition> &getWhereConditions_mixin() const {
    return _state().where_conditions_;
  }
  const std::vector<Condition> &getOrConditions_mixin() const {
    return _state().or_conditions_;
  }
  const std::vector<Condition> &getNotConditions_mixin() const {
    return _state().not_conditions_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H#ifndef cpporm_QUERY_BUILDER_JOINS_MIXIN_H
#define cpporm_QUERY_BUILDER_JOINS_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState, JoinClause
#include <QDebug>    // For qWarning (optional, for join parsing warning)
#include <algorithm> // For std::transform
#include <string>
#include <vector>

namespace cpporm {

template <typename Derived> class QueryBuilderJoinsMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  Derived &Joins(const std::string &join_str) {
    std::string upper_join = join_str;
    // Ensure cpporm namespace for toupper or use ::toupper
    std::transform(upper_join.begin(), upper_join.end(), upper_join.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    if (upper_join.rfind("LEFT JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("LEFT", "", join_str);
    } else if (upper_join.rfind("RIGHT JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("RIGHT", "", join_str);
    } else if (upper_join.rfind("INNER JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("INNER", "", join_str);
    } else if (upper_join.rfind("FULL JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("FULL", "", join_str);
    } else if (upper_join.rfind("JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back(
          "INNER", "", join_str); // Default JOIN is usually INNER
    } else {
// qWarning() is a Qt function, ensure QDebug is included if used.
// For a library, consider a more generic logging/warning mechanism or none
// here.
#if defined(QT_CORE_LIB) // Only use qWarning if Qt is available
      qWarning() << "cpporm QueryBuilder::JoinsMixin: Could not determine "
                    "explicit join type from '"
                 << join_str.c_str() << "'. Storing as raw fragment.";
#endif
      _state().join_clauses_.emplace_back(
          "", "", join_str); // Empty type, just the raw string
    }
    return static_cast<Derived &>(*this);
  }

  Derived &InnerJoin(const std::string &table,
                     const std::string &on_condition) {
    _state().join_clauses_.emplace_back("INNER", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  Derived &LeftJoin(const std::string &table, const std::string &on_condition) {
    _state().join_clauses_.emplace_back("LEFT", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  Derived &RightJoin(const std::string &table,
                     const std::string &on_condition) {
    _state().join_clauses_.emplace_back("RIGHT", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  // Accessor
  const std::vector<JoinClause> &getJoinClauses_mixin() const {
    return _state().join_clauses_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_JOINS_MIXIN_H#ifndef cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H
#define cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState, PreloadRequest
#include <string>
#include <vector> // For state_.preload_requests_

namespace cpporm {

template <typename Derived> class QueryBuilderPreloadMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  // Simple Preload by association C++ field name.
  // GORM also supports Preload("Orders.OrderItems") for nested preloading,
  // and Preload("Orders", func(db *gorm.DB) *gorm.DB { ... }) for conditional
  // preloading. We'll start with the basic form.
  Derived &Preload(const std::string &association_cpp_field_name) {
    // TODO: Add support for dot-separated nested preload paths if needed.
    // For now, assume association_cpp_field_name is a direct association of the
    // current model.
    _state().preload_requests_.emplace_back(association_cpp_field_name);
    return static_cast<Derived &>(*this);
  }

  // Accessor for preload requests (mainly for Session to use)
  const std::vector<PreloadRequest> &getPreloadRequests_mixin() const {
    return _state().preload_requests_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H#ifndef cpporm_QUERY_BUILDER_SCOPES_MIXIN_H
#define cpporm_QUERY_BUILDER_SCOPES_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState

namespace cpporm {

template <typename Derived> class QueryBuilderScopesMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  Derived &Unscoped() {
    _state().apply_soft_delete_scope_ = false;
    // Potentially disable other default scopes here if they are added
    return static_cast<Derived &>(*this);
  }

  bool isSoftDeleteScopeActive_mixin() const {
    return _state().apply_soft_delete_scope_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_SCOPES_MIXIN_H#ifndef cpporm_QUERY_BUILDER_STATE_H
#define cpporm_QUERY_BUILDER_STATE_H

#include "cpporm/model_base.h"
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QString>
#include <QTime>
#include <QVariant>

#include <map>
#include <memory>
#include <set>
#include <string>
#include <variant>
#include <vector>

namespace cpporm {

// 用于子查询绑定的 QueryValue 变体 (不包含 SubqueryExpression 自身以避免递归)
using QueryValueVariantForSubquery =
    std::variant<std::nullptr_t, int, long long, double, std::string, bool,
                 QDateTime, QDate, QTime, QByteArray>;

// 表示子查询表达式的结构体
struct SubqueryExpression {
  std::string sql_string;                             // 子查询的 SQL 语句
  std::vector<QueryValueVariantForSubquery> bindings; // 子查询的绑定参数

  // 构造函数
  SubqueryExpression(std::string s,
                     std::vector<QueryValueVariantForSubquery> b = {})
      : sql_string(std::move(s)), bindings(std::move(b)) {}

  // 默认的拷贝和移动语义
  SubqueryExpression(const SubqueryExpression &) = default;
  SubqueryExpression &operator=(const SubqueryExpression &) = default;
  SubqueryExpression(SubqueryExpression &&) = default;
  SubqueryExpression &operator=(SubqueryExpression &&) = default;
};

// 表示查询中参数值的类型 (std::variant 允许多种类型)
// 新增: 将 SubqueryExpression 作为 QueryValue 的一个可能类型
using QueryValue =
    std::variant<std::nullptr_t, int, long long, double, std::string, bool,
                 QDateTime, QDate, QTime, QByteArray, SubqueryExpression>;

// 表示查询条件的结构体 (例如 WHERE, HAVING 中的条件)
struct Condition {
  std::string query_string;     // 条件的 SQL 片段 (例如 "age > ?")
  std::vector<QueryValue> args; // 条件的绑定参数

  // 构造函数
  Condition(std::string qs, std::vector<QueryValue> a = {})
      : query_string(std::move(qs)), args(std::move(a)) {}
};

// 表示 JOIN 子句的结构体
struct JoinClause {
  std::string join_type;     // JOIN 类型 (例如 "INNER", "LEFT")
  std::string table_to_join; // 要连接的表名
  std::string on_condition;  // JOIN 的 ON 条件

  // 构造函数
  JoinClause(std::string type, std::string table, std::string on)
      : join_type(std::move(type)), table_to_join(std::move(table)),
        on_condition(std::move(on)) {}
};

// 表示预加载请求的结构体
struct PreloadRequest {
  std::string association_cpp_field_name; // 要预加载的关联字段的 C++ 名称

  // 构造函数
  explicit PreloadRequest(std::string name)
      : association_cpp_field_name(std::move(name)) {}
};

// 定义 ON CONFLICT (或 ON DUPLICATE KEY UPDATE) 子句的状态
struct OnConflictClause {
  enum class Action {
    DoNothing, // 例如 PostgreSQL 的 DO NOTHING 或 MySQL 的 INSERT IGNORE
    UpdateAllExcluded, // 更新所有非主键列为新插入的值 (MySQL: VALUES(col))
    UpdateSpecific     // 更新指定的列
  };

  Action action = Action::DoNothing; // 默认操作
  std::vector<std::string>
      conflict_target_columns_db_names; // 冲突目标列 (主要用于 PostgreSQL)
  std::map<std::string, QueryValue>
      update_assignments; // 指定更新时的列名和值映射

  // 构造函数
  OnConflictClause(Action act = Action::DoNothing) : action(act) {}
  // 默认的拷贝和移动语义
  OnConflictClause(const OnConflictClause &other) = default;
  OnConflictClause(OnConflictClause &&other) noexcept = default;
  OnConflictClause &operator=(const OnConflictClause &other) = default;
  OnConflictClause &operator=(OnConflictClause &&other) noexcept = default;
};

// 表示一个 Common Table Expression (CTE) 的状态
struct CTEState {
  std::string name;         // CTE 的名称
  SubqueryExpression query; // CTE 的定义查询 (使用 SubqueryExpression 结构)
  bool recursive = false;   // CTE 是否是递归的

  CTEState(std::string n, SubqueryExpression q, bool rec = false)
      : name(std::move(n)), query(std::move(q)), recursive(rec) {}

  // 默认的拷贝和移动语义
  CTEState(const CTEState &other) = default;
  CTEState(CTEState &&other) noexcept = default;
  CTEState &operator=(const CTEState &other) = default;
  CTEState &operator=(CTEState &&other) noexcept = default;
};

// --- New structures for enhanced subquery support ---
struct SubquerySource {
  SubqueryExpression subquery;
  std::string alias;

  SubquerySource(SubqueryExpression sq, std::string a)
      : subquery(std::move(sq)), alias(std::move(a)) {}
  // Default copy/move
  SubquerySource(const SubquerySource &) = default;
  SubquerySource &operator=(const SubquerySource &) = default;
  SubquerySource(SubquerySource &&) = default;
  SubquerySource &operator=(SubquerySource &&) = default;
};

// Represents the source for a FROM clause (either a table name or a subquery
// with an alias)
using FromClauseSource =
    std::variant<std::string /* table_name */, SubquerySource>;

struct NamedSubqueryField {
  SubqueryExpression subquery;
  std::string alias;

  NamedSubqueryField(SubqueryExpression sq, std::string a)
      : subquery(std::move(sq)), alias(std::move(a)) {}
  // Default copy/move
  NamedSubqueryField(const NamedSubqueryField &) = default;
  NamedSubqueryField &operator=(const NamedSubqueryField &) = default;
  NamedSubqueryField(NamedSubqueryField &&) = default;
  NamedSubqueryField &operator=(NamedSubqueryField &&) = default;
};

// Represents a field in the SELECT list (either a string or a named subquery)
using SelectField = std::variant<std::string /* field_name_or_expression */,
                                 NamedSubqueryField>;
// --- End of new structures ---

// QueryBuilder 的内部状态结构体, 存储所有查询构建部分
struct QueryBuilderState {
  const ModelMeta *model_meta_ = nullptr; // 指向当前操作模型的元数据
  FromClauseSource from_clause_source_{
      std::string("")}; // Default to empty table name string

  // 条件子句
  std::vector<Condition> where_conditions_; // WHERE 条件列表
  std::vector<Condition> or_conditions_;    // OR 条件列表
  std::vector<Condition> not_conditions_; // NOT 条件列表 (通常包装一组AND条件)

  // SELECT 子句相关
  std::vector<SelectField> select_fields_{
      std::string("*")};        // 要选择的字段列表 (默认 "*")
  bool apply_distinct_ = false; // 新增: 是否在 SELECT 后应用 DISTINCT

  std::string order_clause_;                    // ORDER BY 子句
  int limit_val_ = -1;                          // LIMIT 值 (-1 表示无限制)
  int offset_val_ = -1;                         // OFFSET 值 (-1 表示无偏移)
  std::string group_clause_;                    // GROUP BY 子句
  std::unique_ptr<Condition> having_condition_; // HAVING 条件

  // JOIN 子句
  std::vector<JoinClause> join_clauses_; // JOIN 子句列表

  // 预加载
  std::vector<PreloadRequest> preload_requests_; // 预加载请求列表

  // 作用域控制
  bool apply_soft_delete_scope_ = true; // 是否应用软删除作用域 (默认是)

  // OnConflict 子句
  std::unique_ptr<OnConflictClause> on_conflict_clause_; // ON CONFLICT 子句状态

  // Common Table Expressions (CTEs)
  std::vector<CTEState> ctes_; // WITH 子句列表

  // 默认构造函数
  QueryBuilderState() = default;

  // 拷贝构造函数 (深拷贝)
  QueryBuilderState(const QueryBuilderState &other)
      : model_meta_(other.model_meta_),
        from_clause_source_(other.from_clause_source_),
        where_conditions_(other.where_conditions_),
        or_conditions_(other.or_conditions_),
        not_conditions_(other.not_conditions_),
        select_fields_(other.select_fields_),
        apply_distinct_(other.apply_distinct_), // 拷贝 apply_distinct_
        order_clause_(other.order_clause_), limit_val_(other.limit_val_),
        offset_val_(other.offset_val_), group_clause_(other.group_clause_),
        join_clauses_(other.join_clauses_),
        preload_requests_(other.preload_requests_),
        apply_soft_delete_scope_(other.apply_soft_delete_scope_),
        ctes_(other.ctes_) {
    if (other.having_condition_) {
      having_condition_ = std::make_unique<Condition>(*other.having_condition_);
    }
    if (other.on_conflict_clause_) {
      on_conflict_clause_ =
          std::make_unique<OnConflictClause>(*other.on_conflict_clause_);
    }
  }

  // 移动构造函数
  QueryBuilderState(QueryBuilderState &&other) noexcept
      : model_meta_(other.model_meta_),
        from_clause_source_(std::move(other.from_clause_source_)),
        where_conditions_(std::move(other.where_conditions_)),
        or_conditions_(std::move(other.or_conditions_)),
        not_conditions_(std::move(other.not_conditions_)),
        select_fields_(std::move(other.select_fields_)),
        apply_distinct_(other.apply_distinct_), // 移动 apply_distinct_
        order_clause_(std::move(other.order_clause_)),
        limit_val_(other.limit_val_), offset_val_(other.offset_val_),
        group_clause_(std::move(other.group_clause_)),
        having_condition_(std::move(other.having_condition_)),
        join_clauses_(std::move(other.join_clauses_)),
        preload_requests_(std::move(other.preload_requests_)),
        apply_soft_delete_scope_(other.apply_soft_delete_scope_),
        on_conflict_clause_(std::move(other.on_conflict_clause_)),
        ctes_(std::move(other.ctes_)) {
    other.model_meta_ = nullptr;
    other.limit_val_ = -1;
    other.offset_val_ = -1;
    other.apply_distinct_ = false; // 重置源对象的 apply_distinct_
  }

  // 拷贝赋值运算符
  QueryBuilderState &operator=(const QueryBuilderState &other) {
    if (this == &other)
      return *this;

    model_meta_ = other.model_meta_;
    from_clause_source_ = other.from_clause_source_;
    where_conditions_ = other.where_conditions_;
    or_conditions_ = other.or_conditions_;
    not_conditions_ = other.not_conditions_;
    select_fields_ = other.select_fields_;
    apply_distinct_ = other.apply_distinct_; // 赋值 apply_distinct_
    order_clause_ = other.order_clause_;
    limit_val_ = other.limit_val_;
    offset_val_ = other.offset_val_;
    group_clause_ = other.group_clause_;
    if (other.having_condition_) {
      having_condition_ = std::make_unique<Condition>(*other.having_condition_);
    } else {
      having_condition_.reset();
    }
    join_clauses_ = other.join_clauses_;
    preload_requests_ = other.preload_requests_;
    apply_soft_delete_scope_ = other.apply_soft_delete_scope_;
    if (other.on_conflict_clause_) {
      on_conflict_clause_ =
          std::make_unique<OnConflictClause>(*other.on_conflict_clause_);
    } else {
      on_conflict_clause_.reset();
    }
    ctes_ = other.ctes_;
    return *this;
  }

  // 移动赋值运算符
  QueryBuilderState &operator=(QueryBuilderState &&other) noexcept {
    if (this == &other)
      return *this;

    model_meta_ = other.model_meta_;
    from_clause_source_ = std::move(other.from_clause_source_);
    where_conditions_ = std::move(other.where_conditions_);
    or_conditions_ = std::move(other.or_conditions_);
    not_conditions_ = std::move(other.not_conditions_);
    select_fields_ = std::move(other.select_fields_);
    apply_distinct_ = other.apply_distinct_; // 移动 apply_distinct_
    order_clause_ = std::move(other.order_clause_);
    limit_val_ = other.limit_val_;
    offset_val_ = other.offset_val_;
    group_clause_ = std::move(other.group_clause_);
    having_condition_ = std::move(other.having_condition_);
    join_clauses_ = std::move(other.join_clauses_);
    preload_requests_ = std::move(other.preload_requests_);
    apply_soft_delete_scope_ = other.apply_soft_delete_scope_;
    on_conflict_clause_ = std::move(other.on_conflict_clause_);
    ctes_ = std::move(other.ctes_);

    other.model_meta_ = nullptr;
    other.from_clause_source_ = std::string("");
    other.limit_val_ = -1;
    other.offset_val_ = -1;
    other.apply_distinct_ = false; // 重置源对象的 apply_distinct_
    return *this;
  }
};

std::vector<Condition>
mapToConditions(const std::map<std::string, QueryValue> &condition_map);

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_STATE_H// cpporm/db_manager.h
#ifndef cpporm_DB_MANAGER_H
#define cpporm_DB_MANAGER_H

#include <expected>
#include <memory>
#include <string>

#include "cpporm/error.h"
#include "sqldriver/sql_connection_parameters.h"
#include "sqldriver/sql_database.h"  // Now returns SqlDatabase directly
#include "sqldriver/sql_driver_manager.h"

namespace cpporm {

    struct DbConfig {
        std::string driver_type;
        std::string host_name = "127.0.0.1";
        int port = -1;
        std::string database_name;
        std::string user_name;
        std::string password;
        std::string connect_options;
        std::string client_charset;
        std::string connection_name;  // Optional: if SqlDatabase is to be named for later retrieval (not used by Session directly if Session owns the handle)

        static std::string generateUniqueConnectionName() {
            static long long counter = 0;
            // Using a more descriptive prefix for SqlDatabase connection names if they are still used by DriverManager for anything
            return "cpporm_sqldb_conn_" + std::to_string(++counter);
        }

        cpporm_sqldriver::ConnectionParameters toDriverParameters() const {
            cpporm_sqldriver::ConnectionParameters params;
            // driver_type is used by SqlDriverManager to get the factory, not a parameter for SqlDatabase::open
            params.setHostName(host_name);
            if (port > 0) {
                params.setPort(port);
            }
            params.setDbName(database_name);
            params.setUserName(user_name);
            params.setPassword(password);
            if (!connect_options.empty()) {
                params.setConnectOptions(connect_options);
            }
            // client_charset is handled separately after open if needed
            return params;
        }
    };

    class DbManager {
      public:
        DbManager() = delete;

        // Changed return type: directly returns the SqlDatabase object (or an error)
        static std::expected<cpporm_sqldriver::SqlDatabase, Error> openDatabase(const DbConfig &config);

        // The following methods become problematic if SqlDriverManager doesn't manage active SqlDatabase instances by name.
        // Session will now own its SqlDatabase handle.
        // These might need to be removed or re-thought if global access to specific connections by name is truly needed.
        // For now, I'll comment them out as Session will get its handle from openDatabase.
        /*
        static cpporm_sqldriver::SqlDatabase getDatabase(const std::string &connection_name_str = cpporm_sqldriver::SqlDriverManager::defaultConnectionName());
        static void closeDatabase(const std::string &connection_name_str);
        static bool isConnectionValid(const std::string &connection_name_str);
        */
    };

}  // namespace cpporm

#endif  // cpporm_DB_MANAGER_H#ifndef cpporm_ERROR_H
#define cpporm_ERROR_H

#include <string>
#include <system_error> // For std::error_code, std::errc (potential future use)

namespace cpporm {

// 错误码枚举
enum class ErrorCode {
  Ok = 0,
  // 连接相关错误
  ConnectionFailed,
  ConnectionAlreadyOpen,
  ConnectionNotOpen,
  ConnectionInvalid,
  DriverNotFound,
  // 配置错误
  InvalidConfiguration,
  // SQL 执行错误
  QueryExecutionError,
  StatementPreparationError,
  TransactionError,
  // ORM 层面错误
  RecordNotFound,
  MappingError,
  UnsupportedFeature,
  // 其他
  InternalError,
  UnknownError,
};

// Error 结构体，用于封装错误信息
struct Error {
  ErrorCode code = ErrorCode::Ok;
  std::string message;
  int native_db_error_code = 0; // 可选的数据库原生错误码
  std::string sql_state;        // 可选的 SQLSTATE

  // 构造函数
  Error() = default;
  Error(ErrorCode c, std::string msg = "", int native_code = 0,
        std::string state = "")
      : code(c), message(std::move(msg)), native_db_error_code(native_code),
        sql_state(std::move(state)) {}

  // 检查是否为成功状态
  bool isOk() const { return code == ErrorCode::Ok; }

  // 允许在布尔上下文中使用 (if (error))
  explicit operator bool() const {
    return !isOk(); // true if there is an error
  }

  // 获取错误描述
  std::string toString() const {
    std::string err_str =
        "Error Code: " + std::to_string(static_cast<int>(code));
    if (!message.empty()) {
      err_str += ", Message: " + message;
    }
    if (native_db_error_code != 0) {
      err_str += ", DB Error: " + std::to_string(native_db_error_code);
    }
    if (!sql_state.empty()) {
      err_str += ", SQLState: " + sql_state;
    }
    return err_str;
  }
};

// 一个辅助函数，用于快速创建 Ok 状态的 Error
inline Error make_ok() { return Error(ErrorCode::Ok); }

} // namespace cpporm

#endif // cpporm_ERROR_H#ifndef cpporm_I_QUERY_EXECUTOR_H
#define cpporm_I_QUERY_EXECUTOR_H

#include "cpporm/error.h"
// 直接包含 query_builder_state.h 来获取 QueryValue 和 OnConflictClause 的定义
#include <QString>  // QVariantList 依赖 QString, QVariant 仍用于 QueryBuilder 的接口层
#include <QVariant>
#include <QVariantList>
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <vector>

#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/model_base.h"    // ModelBase, ModelMeta (ModelBase 也会包含 query_builder_state.h)
#include "sqldriver/sql_value.h"  // 使用 SqlValue 替代 QVariant 作为原生DB交互类型

namespace cpporm {

    class QueryBuilder;  // 前向声明 QueryBuilder

    // QueryValue 和 OnConflictClause 现在通过包含 query_builder_state.h
    // 来确保其定义可见

    class IQueryExecutor {
      public:
        virtual ~IQueryExecutor() = default;

        virtual Error FirstImpl(const QueryBuilder &qb, ModelBase &result_model) = 0;

        virtual Error FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) = 0;

        // CreateImpl 返回的是 SqlValue，它比 QVariant 更接近底层驱动的值类型
        virtual std::expected<cpporm_sqldriver::SqlValue, Error> CreateImpl(const QueryBuilder &qb, ModelBase &model, const OnConflictClause *conflict_options_override) = 0;

        virtual std::expected<long long, Error> UpdatesImpl(const QueryBuilder &qb, const std::map<std::string, QueryValue> &updates) = 0;

        virtual std::expected<long long, Error> DeleteImpl(const QueryBuilder &qb) = 0;

        virtual std::expected<long long, Error> SaveImpl(const QueryBuilder &qb, ModelBase &model) = 0;

        virtual std::expected<int64_t, Error> CountImpl(const QueryBuilder &qb) = 0;
    };

}  // namespace cpporm
#endif  // cpporm_I_QUERY_EXECUTOR_H#ifndef cpporm_MODEL_H
#define cpporm_MODEL_H

#include <string>
#include <vector>
#include <any> // For generic field values, or consider std::variant
#include <map>

// Forward declaration if DB operations are directly tied to model methods
// namespace cpporm { class Database; }

namespace cpporm {

// Forward declaration for Session/DB context if models don't own a DB pointer directly
class Session; // Or class DB; (representing an active DB session/transaction context)


// A very basic concept for a model field attribute (e.g., primary key, nullable, etc.)
// This will be expanded significantly.
enum class FieldAttribute {
    None,
    PrimaryKey,
    AutoIncrement,
    NotNull,
    Unique
    // etc.
};

struct FieldDefinition {
    std::string name;
    std::string type_name; // e.g., "INT", "VARCHAR(255)" - for schema generation or reflection
    // std::type_index cpp_type; // For type checking
    std::vector<FieldAttribute> attributes;
    // Potentially default value, etc.
};


// Base class for all ORM models
class Model {
public:
    virtual ~Model() = default;

    // Method to get the table name for the model
    // GORM uses struct tags or conventions; C++ needs a different approach.
    // Pure virtual makes subclasses implement it.
    [[nodiscard]] virtual std::string getTableName() const = 0;

    // Method to get primary key field name(s)
    // For simplicity, starting with a single string, could be a vector for composite keys.
    [[nodiscard]] virtual std::string getPrimaryKeyName() const { return "id"; } // Default

    // Placeholder for getting/setting field values by name
    // This is a complex area: type safety, reflection-like capabilities.
    // virtual std::any getField(const std::string& fieldName) const = 0;
    // virtual void setField(const std::string& fieldName, const std::any& value) = 0;

    // Placeholder for schema definition, could be static or virtual
    // static virtual std::vector<FieldDefinition> defineSchema() = 0; // Static virtual not allowed
    // This needs a pattern like CRTP or a registration mechanism.
    // For now, each model might just "know" its fields.

protected:
    // Models might not directly hold a DB connection pointer.
    // Operations would typically go through a `Session` or `DB` object
    // to which the model instance is passed.
    // e.g., session.Save(myUserInstance);
    //
    // If GORM-style chainable methods directly on model instances are desired (user.DB.Where(...)),
    // then a (possibly non-owning) pointer/reference to the DB context is needed.
    // This is a design choice with trade-offs.

    // Example: if models were to manage their own state persistence directly
    // cpporm::Database* db_ = nullptr; // Non-owning, set by a session or context

    // For now, let's keep models as Plain Old Data Objects (PODs) as much as possible,
    // with persistence logic handled by other classes (Repository, Session, QueryBuilder).

    // Primary key value (example, assuming 'id' and type int64_t)
    // This will be made generic later.
    // int64_t id_ = 0;
};

} // namespace cpporm

#endif // cpporm_MODEL_H// cpporm/model_base.h
#ifndef cpporm_MODEL_BASE_H
#define cpporm_MODEL_BASE_H

#include "cpporm/error.h"
#include <QDebug>
#include <algorithm>
#include <any>
#include <cstdint>
#include <functional>
#include <map>
#include <memory> // For std::shared_ptr
#include <mutex>
#include <string>
#include <typeindex>
#include <vector>

#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>

namespace cpporm {

// Forward declarations
class Session;
class QueryBuilder;
class ModelBase;
struct ModelMeta;
struct FieldMeta;
struct AssociationMeta;
struct IndexDefinition;

// --- Index Definition ---
struct IndexDefinition {
  std::string index_name;
  std::vector<std::string> db_column_names;
  bool is_unique = false;
  std::string type_str;
  std::string condition_str;
};

// --- Association Related Enums and Structs ---
enum class AssociationType { None, HasOne, BelongsTo, HasMany, ManyToMany };

// Type-erased provider for target model's type_index
using TargetTypeIndexProvider = std::function<std::type_index()>;

struct AssociationMeta {
  std::string cpp_field_name;
  AssociationType type = AssociationType::None;

  // Store the provider function instead of the type_index directly at
  // registration
  TargetTypeIndexProvider target_type_index_provider;
  std::type_index target_model_type; // To be filled during finalization

  std::string foreign_key_db_name;
  std::string primary_key_db_name_on_current_model;
  std::string target_model_pk_db_name;

  std::function<void(
      void * /* model_instance */,
      std::vector<std::shared_ptr<ModelBase>> & /* associated_models */)>
      data_setter_vector;

  std::function<void(void * /* model_instance */,
                     std::shared_ptr<ModelBase> /* associated_model */)>
      data_setter_single;

  AssociationMeta(
      std::string fieldName, AssociationType assocType,
      TargetTypeIndexProvider targetTypeProvider, // Changed parameter
      std::string fkDbName, std::string currentModelRefKeyDbName = "",
      std::string targetModelReferencedKeyDbName = "",
      std::function<void(void *, std::vector<std::shared_ptr<ModelBase>> &)>
          vec_setter = nullptr,
      std::function<void(void *, std::shared_ptr<ModelBase>)> single_setter =
          nullptr)
      : cpp_field_name(std::move(fieldName)), type(assocType),
        target_type_index_provider(std::move(targetTypeProvider)),
        target_model_type(typeid(void)), // Initialize to a dummy value
        foreign_key_db_name(std::move(fkDbName)),
        primary_key_db_name_on_current_model(
            std::move(currentModelRefKeyDbName)),
        target_model_pk_db_name(std::move(targetModelReferencedKeyDbName)),
        data_setter_vector(std::move(vec_setter)),
        data_setter_single(std::move(single_setter)) {}
};

// --- Field Flags ---
enum class FieldFlag : uint32_t {
  None = 0,
  PrimaryKey = 1 << 0,
  AutoIncrement = 1 << 1,
  NotNull = 1 << 2,
  Unique = 1 << 3,
  HasDefault = 1 << 4,
  Indexed = 1 << 5,
  CreatedAt = 1 << 6,
  UpdatedAt = 1 << 7,
  DeletedAt = 1 << 8,
  Association = 1 << 9
};

inline FieldFlag operator|(FieldFlag a, FieldFlag b) {
  return static_cast<FieldFlag>(static_cast<uint32_t>(a) |
                                static_cast<uint32_t>(b));
}
inline FieldFlag operator&(FieldFlag a, FieldFlag b) {
  return static_cast<FieldFlag>(static_cast<uint32_t>(a) &
                                static_cast<uint32_t>(b));
}
inline FieldFlag &operator|=(FieldFlag &a, FieldFlag b) {
  a = a | b;
  return a;
}
inline bool has_flag(FieldFlag flags, FieldFlag flag_to_check) {
  return (static_cast<uint32_t>(flags) &
          static_cast<uint32_t>(flag_to_check)) != 0;
}

// --- Field Metadata ---
struct FieldMeta {
  std::string db_name;
  std::string cpp_name;
  std::type_index cpp_type;
  std::string db_type_hint;
  FieldFlag flags = FieldFlag::None;
  std::any default_value;

  std::function<std::any(const void *)> getter;
  std::function<void(void *, const std::any &)> setter;

  FieldMeta(std::string dbName, std::string cppName, std::type_index cppType,
            std::string dbTypeHint = "", FieldFlag fieldFlags = FieldFlag::None,
            std::function<std::any(const void *)> g = nullptr,
            std::function<void(void *, const std::any &)> s = nullptr)
      : db_name(std::move(dbName)), cpp_name(std::move(cppName)),
        cpp_type(cppType), db_type_hint(std::move(dbTypeHint)),
        flags(fieldFlags), getter(std::move(g)), setter(std::move(s)) {}
};

// --- ModelBase Definition ---
class ModelBase {
public:
  virtual ~ModelBase() = default;

  [[nodiscard]] virtual const ModelMeta &_getOwnModelMeta() const = 0;
  [[nodiscard]] virtual std::string _getTableName() const = 0;
  [[nodiscard]] virtual std::map<std::string, std::any> _getPrimaryKeys() const;

  bool _is_persisted = false;

  std::any getFieldValue(const std::string &cpp_field_name) const;
  Error setFieldValue(const std::string &cpp_field_name, const std::any &value);

  virtual Error beforeCreate(Session & /*session*/) { return make_ok(); }
  virtual Error afterCreate(Session & /*session*/) { return make_ok(); }
  virtual Error beforeUpdate(Session & /*session*/) { return make_ok(); }
  virtual Error afterUpdate(Session & /*session*/) { return make_ok(); }
  virtual Error beforeSave(Session & /*session*/) { return make_ok(); }
  virtual Error afterSave(Session & /*session*/) { return make_ok(); }
  virtual Error beforeDelete(Session & /*session*/) { return make_ok(); }
  virtual Error afterDelete(Session & /*session*/) { return make_ok(); }
  virtual Error afterFind(Session & /*session*/) { return make_ok(); }
};

// --- ModelMeta Definition ---
struct ModelMeta {
  std::string table_name;
  std::vector<FieldMeta> fields;
  std::vector<AssociationMeta> associations;
  std::vector<std::string> primary_keys_db_names;
  std::vector<IndexDefinition> indexes;
  bool _is_finalized = false;

  const FieldMeta *findFieldByDbName(const std::string &name) const {
    for (const auto &f : fields)
      if (f.db_name == name && !f.db_name.empty())
        return &f;
    return nullptr;
  }
  const FieldMeta *findFieldByCppName(const std::string &name) const {
    for (const auto &f : fields)
      if (f.cpp_name == name)
        return &f;
    return nullptr;
  }
  const AssociationMeta *
  findAssociationByCppName(const std::string &cpp_assoc_field_name) const {
    for (const auto &assoc : associations)
      if (assoc.cpp_field_name == cpp_assoc_field_name)
        return &assoc;
    return nullptr;
  }
  const FieldMeta *getPrimaryField(size_t idx = 0) const {
    if (primary_keys_db_names.empty() || idx >= primary_keys_db_names.size())
      return nullptr;
    return findFieldByDbName(primary_keys_db_names[idx]);
  }
  std::vector<const FieldMeta *> getPrimaryKeyFields() const {
    std::vector<const FieldMeta *> pks;
    pks.reserve(primary_keys_db_names.size());
    for (const auto &pk_name : primary_keys_db_names) {
      if (auto *f = findFieldByDbName(pk_name))
        pks.push_back(f);
    }
    return pks;
  }
  const FieldMeta *findFieldWithFlag(FieldFlag flag_to_find) const {
    auto it = std::find_if(fields.begin(), fields.end(),
                           [flag_to_find](const FieldMeta &fm) {
                             return has_flag(fm.flags, flag_to_find);
                           });
    return (it == fields.end()) ? nullptr : &(*it);
  }
};

inline std::any
ModelBase::getFieldValue(const std::string &cpp_field_name) const {
  const ModelMeta &meta = this->_getOwnModelMeta();
  const FieldMeta *field = meta.findFieldByCppName(cpp_field_name);
  if (!field) {
    const AssociationMeta *assoc =
        meta.findAssociationByCppName(cpp_field_name);
    if (assoc) {
      qWarning()
          << "cpporm ModelBase::getFieldValue: Attempted to get association "
             "collection or object '"
          << cpp_field_name.c_str()
          << "' via generic getter. Access the member directly after Preload.";
      return std::any{};
    }
    qWarning() << "cpporm ModelBase::getFieldValue: Field or Association "
                  "placeholder '"
               << cpp_field_name.c_str() << "' not found in meta for table "
               << QString::fromStdString(meta.table_name);
    return std::any{};
  }
  if (!field->getter) {
    qWarning() << "cpporm ModelBase::getFieldValue: Getter not found or "
                  "not finalized for field '"
               << cpp_field_name.c_str() << "' in table "
               << QString::fromStdString(meta.table_name);
    return std::any{};
  }
  return field->getter(this);
}

inline Error ModelBase::setFieldValue(const std::string &cpp_field_name,
                                      const std::any &value) {
  const ModelMeta &meta = this->_getOwnModelMeta();
  const FieldMeta *field = meta.findFieldByCppName(cpp_field_name);
  if (!field) {
    const AssociationMeta *assoc =
        meta.findAssociationByCppName(cpp_field_name);
    if (assoc) {
      qWarning() << "cpporm ModelBase::setFieldValue: Attempted to set "
                    "association collection or object '"
                 << cpp_field_name.c_str()
                 << "' via generic setter. This is usually handled by Preload "
                    "setters or direct member assignment if applicable.";
      return Error(ErrorCode::MappingError,
                   "Cannot set association via generic setFieldValue.");
    }
    qWarning() << "cpporm ModelBase::setFieldValue: Field or Association "
                  "placeholder '"
               << cpp_field_name.c_str() << "' not found in meta for table "
               << QString::fromStdString(meta.table_name);
    return Error(ErrorCode::MappingError, "Field or Association placeholder " +
                                              cpp_field_name + " not found.");
  }
  if (!field->setter) {
    qWarning() << "cpporm ModelBase::setFieldValue: Setter not found or "
                  "not finalized for field '"
               << cpp_field_name.c_str() << "' in table "
               << QString::fromStdString(meta.table_name);
    return Error(ErrorCode::MappingError,
                 "Setter for " + cpp_field_name + " not found/finalized.");
  }
  try {
    field->setter(this, value);
  } catch (const std::bad_any_cast &e) {
    qWarning() << "cpporm ModelBase::setFieldValue: Bad_any_cast for field '"
               << cpp_field_name.c_str()
               << "' (table: " << QString::fromStdString(meta.table_name)
               << ", expected C++ type: " << field->cpp_type.name()
               << ", value provided type: "
               << (value.has_value() ? value.type().name() : "empty_any")
               << "): " << e.what();
    return Error(ErrorCode::MappingError,
                 "Type mismatch for field " + cpp_field_name + ": " + e.what());
  } catch (const std::exception &e) {
    qWarning()
        << "cpporm ModelBase::setFieldValue: Exception while setting field '"
        << cpp_field_name.c_str()
        << "' (table: " << QString::fromStdString(meta.table_name)
        << "): " << e.what();
    return Error(ErrorCode::MappingError,
                 "Setter failed for field " + cpp_field_name + ": " + e.what());
  }
  return make_ok();
}

inline std::map<std::string, std::any> ModelBase::_getPrimaryKeys() const {
  std::map<std::string, std::any> pks;
  const auto &meta = this->_getOwnModelMeta();
  for (const auto &pk_db_name : meta.primary_keys_db_names) {
    const FieldMeta *fm = meta.findFieldByDbName(pk_db_name);
    if (fm && fm->getter) {
      try {
        pks[pk_db_name] = fm->getter(this);
      } catch (const std::exception &e) {
        qWarning()
            << "cpporm ModelBase::_getPrimaryKeys: Getter failed for PK field "
            << pk_db_name.c_str() << " on table "
            << QString::fromStdString(meta.table_name) << ": " << e.what();
      }
    } else {
      qWarning()
          << "cpporm ModelBase::_getPrimaryKeys: Primary key field meta or "
             "getter not found for DB name: "
          << pk_db_name.c_str() << " on table "
          << QString::fromStdString(meta.table_name);
    }
  }
  return pks;
}

namespace internal {
using ModelFactory = std::function<std::unique_ptr<ModelBase>()>;
std::map<std::type_index, ModelFactory> &getGlobalModelFactoryRegistry();
std::mutex &getGlobalModelFactoryRegistryMutex();

template <typename T> void registerModelFactory() {
  std::lock_guard<std::mutex> lock(getGlobalModelFactoryRegistryMutex());
  getGlobalModelFactoryRegistry()[typeid(T)] = []() {
    return std::make_unique<T>();
  };
}

using VoidFunc = std::function<void()>;
std::vector<VoidFunc> &getGlobalModelFinalizerFunctions();
std::mutex &getGlobalModelFinalizersRegistryMutex();

template <typename ModelClass> void registerModelClassForFinalization() {
  std::lock_guard<std::mutex> lock(getGlobalModelFinalizersRegistryMutex());
  getGlobalModelFinalizerFunctions().push_back(
      []() { ModelClass::_finalizeModelMeta(); });
}

} // namespace internal

void finalize_all_model_meta();

using FieldMetaProvider = std::function<FieldMeta()>;
// Renamed from AssociationMetaConfigurator to be more specific
// This provider now returns a partially filled AssociationMeta (without
// target_model_type) and the TargetTypeIndexProvider separately.
using PendingAssociationProvider = std::function<AssociationMeta()>;

using IndexDefinitionProvider = std::function<IndexDefinition()>;

template <typename Derived> class Model : public ModelBase {
public:
  inline static ModelMeta _shared_meta_instance;
  inline static std::vector<FieldMetaProvider> *_pending_field_meta_providers =
      nullptr;
  // Changed type for pending associations
  inline static std::vector<PendingAssociationProvider>
      *_pending_association_providers = nullptr;
  inline static std::vector<IndexDefinitionProvider>
      *_pending_index_definition_providers = nullptr;
  inline static std::mutex _meta_init_mutex;

  // New static function to get type_index of Derived
  static std::type_index _get_static_type_index() { return typeid(Derived); }

  static void _initSharedMetaTableName(const char *tableNameFromMacro) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (Model<Derived>::_shared_meta_instance.table_name.empty() &&
        tableNameFromMacro && *tableNameFromMacro) {
      Model<Derived>::_shared_meta_instance.table_name = tableNameFromMacro;
      cpporm::internal::registerModelFactory<Derived>();
    }
  }

  static void _addPendingFieldMetaProvider(FieldMetaProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_field_meta_providers)
      Model<Derived>::_pending_field_meta_providers =
          new std::vector<FieldMetaProvider>();
    Model<Derived>::_pending_field_meta_providers->push_back(
        std::move(provider));
  }

  static void
  _addPendingAssociationProvider(PendingAssociationProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_association_providers) {
      Model<Derived>::_pending_association_providers =
          new std::vector<PendingAssociationProvider>();
    }
    Model<Derived>::_pending_association_providers->push_back(
        std::move(provider));
  }

  static void
  _addPendingIndexDefinitionProvider(IndexDefinitionProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_index_definition_providers)
      Model<Derived>::_pending_index_definition_providers =
          new std::vector<IndexDefinitionProvider>();
    Model<Derived>::_pending_index_definition_providers->push_back(
        std::move(provider));
  }

  static void _finalizeModelMeta() {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    ModelMeta &s_meta = Model<Derived>::_shared_meta_instance;
    if (s_meta._is_finalized)
      return;

    if (Model<Derived>::_pending_field_meta_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_field_meta_providers)
        if (provider_func) {
          auto field_meta_obj = provider_func();
          bool already_exists = false;
          for (const auto &existing_field_meta : s_meta.fields)
            if (existing_field_meta.cpp_name == field_meta_obj.cpp_name)
              already_exists = true;
          if (!already_exists) {
            s_meta.fields.push_back(std::move(field_meta_obj));
            const auto &added_field_meta = s_meta.fields.back();
            if (has_flag(added_field_meta.flags, FieldFlag::PrimaryKey)) {
              bool pk_already_listed = false;
              for (const auto &pk_name_str : s_meta.primary_keys_db_names)
                if (pk_name_str == added_field_meta.db_name)
                  pk_already_listed = true;
              if (!pk_already_listed && !added_field_meta.db_name.empty())
                s_meta.primary_keys_db_names.push_back(
                    added_field_meta.db_name);
            }
          }
        }
      delete Model<Derived>::_pending_field_meta_providers;
      Model<Derived>::_pending_field_meta_providers = nullptr;
    }

    // Process pending associations
    if (Model<Derived>::_pending_association_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_association_providers) {
        if (provider_func) {
          AssociationMeta assoc_meta_obj = provider_func();
          // Now, resolve the target_model_type using the provider function
          if (assoc_meta_obj.target_type_index_provider) {
            assoc_meta_obj.target_model_type =
                assoc_meta_obj.target_type_index_provider();
          } else {
            qWarning() << "cpporm Model::finalizeModelMeta: Association"
                       << QString::fromStdString(assoc_meta_obj.cpp_field_name)
                       << "in model"
                       << QString::fromStdString(s_meta.table_name)
                       << "is missing a target type index provider.";
          }

          bool already_exists = false;
          for (const auto &existing_assoc_meta : s_meta.associations) {
            if (existing_assoc_meta.cpp_field_name ==
                assoc_meta_obj.cpp_field_name) {
              already_exists = true;
              break;
            }
          }
          if (!already_exists) {
            s_meta.associations.push_back(std::move(assoc_meta_obj));
          }
        }
      }
      delete Model<Derived>::_pending_association_providers;
      Model<Derived>::_pending_association_providers = nullptr;
    }

    if (Model<Derived>::_pending_index_definition_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_index_definition_providers)
        if (provider_func)
          s_meta.indexes.push_back(provider_func());
      delete Model<Derived>::_pending_index_definition_providers;
      Model<Derived>::_pending_index_definition_providers = nullptr;
    }
    s_meta._is_finalized = true;
  }

  static const ModelMeta &getModelMeta() {
    if (!Model<Derived>::_shared_meta_instance._is_finalized) {
      Model<Derived>::_finalizeModelMeta();
    }
    return Model<Derived>::_shared_meta_instance;
  }

  [[nodiscard]] const ModelMeta &_getOwnModelMeta() const final {
    return Model<Derived>::getModelMeta();
  }
  [[nodiscard]] std::string _getTableName() const final {
    return Model<Derived>::getModelMeta().table_name;
  }

  static std::unique_ptr<ModelBase> createInstance() {
    return std::make_unique<Derived>();
  }

  template <typename FieldType, FieldType Derived::*MemberPtr>
  static std::any _cpporm_generated_getter(const void *obj_ptr) {
    return static_cast<const Derived *>(obj_ptr)->*MemberPtr;
  }

  template <typename FieldType, FieldType Derived::*MemberPtr>
  static void _cpporm_generated_setter(void *obj_ptr, const std::any &value) {
    try {
      if (value.has_value()) {
        (static_cast<Derived *>(obj_ptr)->*MemberPtr) =
            std::any_cast<FieldType>(value);
      } else {
        (static_cast<Derived *>(obj_ptr)->*MemberPtr) = FieldType{};
      }
    } catch (const std::bad_any_cast &e) {
      qWarning() << "cpporm Model::generated_setter: Bad_any_cast for type "
                 << typeid(FieldType).name() << " from value of type "
                 << (value.has_value() ? value.type().name() : "empty_any")
                 << ". Details: " << e.what();
      throw;
    } catch (const std::exception &e) {
      qWarning() << "cpporm Model::generated_setter: Exception for type "
                 << typeid(FieldType).name() << ": " << e.what();
      throw;
    }
  }

  template <typename AssociatedModel,
            std::vector<std::shared_ptr<AssociatedModel>> Derived::*MemberPtr>
  static void _cpporm_generated_association_vector_setter(
      void *obj_ptr, std::vector<std::shared_ptr<ModelBase>>
                         &associated_models_base_sptr_vec) {
    Derived *model_instance = static_cast<Derived *>(obj_ptr);
    std::vector<std::shared_ptr<AssociatedModel>> &target_vector =
        model_instance->*MemberPtr;

    target_vector.clear();
    target_vector.reserve(associated_models_base_sptr_vec.size());

    for (auto &base_model_sptr : associated_models_base_sptr_vec) {
      if (!base_model_sptr)
        continue;

      std::shared_ptr<AssociatedModel> derived_sptr =
          std::dynamic_pointer_cast<AssociatedModel>(base_model_sptr);

      if (derived_sptr) {
        target_vector.push_back(derived_sptr);
      } else {
        qWarning() << "cpporm: Type mismatch in "
                      "_cpporm_generated_association_vector_setter. Expected "
                   << typeid(AssociatedModel).name()
                   << " but got different type "
                   << typeid(*base_model_sptr.get()).name()
                   << ". Object not added to target vector.";
      }
    }
  }

  template <typename AssociatedModel,
            std::shared_ptr<AssociatedModel> Derived::*MemberPtr>
  static void _cpporm_generated_association_single_setter(
      void *obj_ptr, std::shared_ptr<ModelBase> associated_model_base_sptr) {
    Derived *model_instance = static_cast<Derived *>(obj_ptr);

    if (!associated_model_base_sptr) {
      (model_instance->*MemberPtr) = nullptr;
      return;
    }

    std::shared_ptr<AssociatedModel> derived_sptr =
        std::dynamic_pointer_cast<AssociatedModel>(associated_model_base_sptr);

    if (derived_sptr) {
      (model_instance->*MemberPtr) = derived_sptr;
    } else {
      qWarning() << "cpporm: Type mismatch in "
                    "_cpporm_generated_association_single_setter. Expected "
                 << typeid(AssociatedModel).name() << " but got different type "
                 << typeid(*associated_model_base_sptr.get()).name()
                 << ". Object not set.";
      (model_instance->*MemberPtr) = nullptr;
    }
  }
};

#if __cplusplus < 201703L
template <typename Derived> ModelMeta Model<Derived>::_shared_meta_instance;
template <typename Derived>
std::vector<FieldMetaProvider> *Model<Derived>::_pending_field_meta_providers;
template <typename Derived>
std::vector<PendingAssociationProvider>
    *Model<Derived>::_pending_association_providers;
template <typename Derived>
std::vector<IndexDefinitionProvider>
    *Model<Derived>::_pending_index_definition_providers;
template <typename Derived> std::mutex Model<Derived>::_meta_init_mutex;
#endif

} // namespace cpporm
#endif // cpporm_MODEL_BASE_H// cpporm/model_definition_macros.h
#ifndef cpporm_MODEL_DEFINITION_MACROS_H
#define cpporm_MODEL_DEFINITION_MACROS_H

#include "cpporm/model_base.h"
#include <any>
#include <initializer_list>
#include <map>
#include <memory> // For std::shared_ptr
#include <sstream>
#include <string>
#include <typeindex>
#include <vector>

// --- Helper Macros ---
#define cpporm_STRINGIFY_DETAIL(x) #x
#define cpporm_STRINGIFY(x) cpporm_STRINGIFY_DETAIL(x)
#define cpporm_CONCAT_DETAIL(x, y) x##y
#define cpporm_CONCAT(x, y) cpporm_CONCAT_DETAIL(x, y)

namespace cpporm {
template <typename BaseFlagType, typename... Flags>
constexpr BaseFlagType combine_flags_recursive(BaseFlagType base,
                                               Flags... flags) {
  if constexpr (sizeof...(flags) == 0) {
    return base;
  } else {
    return (base | ... | flags);
  }
}
namespace internal {
template <size_t N_one_based, typename... Args>
std::string get_optional_arg_str(const char *default_val_if_absent_or_empty,
                                 Args... args) {
  if constexpr (N_one_based > 0 && N_one_based <= sizeof...(Args)) {
    const char *arg_array[] = {args...};
    const char *selected_arg = arg_array[N_one_based - 1];
    if (selected_arg && selected_arg[0] != '\0') {
      return selected_arg;
    }
  }
  return default_val_if_absent_or_empty ? default_val_if_absent_or_empty : "";
}
} // namespace internal
inline std::vector<std::string>
_cpporm_make_string_vector(std::initializer_list<const char *> list) {
  std::vector<std::string> vec;
  vec.reserve(list.size());
  for (const char *s : list) {
    if (s && *s) {
      vec.emplace_back(s);
    }
  }
  return vec;
}
} // namespace cpporm

#define cpporm_DEFINE_MODEL_CLASS_NAME(ClassName)                             \
  using _cppormThisModelClass = ClassName;                                    \
  friend class cpporm::Model<ClassName>;

#define cpporm_MODEL_BEGIN(CurrentClassName, TableNameStr)                    \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_cpporm_tbl_init_, __COUNTER__) =   \
      (cpporm::Model<CurrentClassName>::_initSharedMetaTableName(             \
           TableNameStr),                                                      \
       true);                                                                  \
  inline static const bool cpporm_CONCAT(_cpporm_mfinal_reg_, __COUNTER__) = \
      (cpporm::internal::registerModelClassForFinalization<                   \
           CurrentClassName>(),                                                \
       true);                                                                  \
                                                                               \
public:

#undef cpporm_FIELD
#define cpporm_FIELD(CppType, CppName, DbNameStr, ...)                        \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_f_prov_reg_, CppName) =             \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType), "",   \
                 cpporm::combine_flags_recursive(cpporm::FieldFlag::None,    \
                                                  ##__VA_ARGS__),              \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_FIELD_TYPE(CppType, CppName, DbNameStr, DbTypeHintStr, ...)    \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_ft_prov_reg_, CppName) =            \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType),       \
                 DbTypeHintStr,                                                \
                 cpporm::combine_flags_recursive(cpporm::FieldFlag::None,    \
                                                  ##__VA_ARGS__),              \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#undef cpporm_ASSOCIATION_FIELD
#define cpporm_ASSOCIATION_FIELD(ContainerCppType, CppName)                   \
public:                                                                        \
  ContainerCppType CppName{};                                                  \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_f_prov_reg_, CppName) =       \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             return cpporm::FieldMeta(                                        \
                 "", cpporm_STRINGIFY(CppName), typeid(ContainerCppType), "", \
                 cpporm::FieldFlag::Association, nullptr, nullptr);           \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

// Association macros now pass a TargetTypeIndexProvider
#define cpporm_HAS_MANY(CppFieldName, AssocModelParamName, FKOnAssoc, ...)    \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_hm_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_vec =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_vector_setter<    \
                         AssocModelParamName,                                  \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string current_model_ref_key =                               \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             /* Create the provider function for target_model_type */          \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<AssocModelParamName>::_get_static_type_index; \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::HasMany, target_type_provider,      \
                 FKOnAssoc, current_model_ref_key, "", d_setter_vec, nullptr); \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_HAS_ONE(CppFieldName, AssocModelParamName, FKOnAssoc, ...)     \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_ho_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_sgl =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_single_setter<    \
                         AssocModelParamName,                                  \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string current_model_ref_key =                               \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<AssocModelParamName>::_get_static_type_index; \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::HasOne, target_type_provider,       \
                 FKOnAssoc, current_model_ref_key, "", nullptr, d_setter_sgl); \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_BELONGS_TO(CppFieldName, TargetModelParamName, FKOnCurrent,    \
                           ...)                                                \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_bt_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_sgl =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_single_setter<    \
                         TargetModelParamName,                                 \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string target_model_ref_key =                                \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<                                              \
                     TargetModelParamName>::_get_static_type_index;            \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::BelongsTo, target_type_provider,    \
                 FKOnCurrent, FKOnCurrent, target_model_ref_key, nullptr,      \
                 d_setter_sgl);                                                \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_INDEX_INTERNAL(IsUniqueParam, IndexNameOrFirstColParam, ...)   \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_idx_def_prov_reg_, __COUNTER__) =   \
      (cpporm::Model<_cppormThisModelClass>::                                \
           _addPendingIndexDefinitionProvider(                                 \
               []() -> cpporm::IndexDefinition {                              \
                 cpporm::IndexDefinition def;                                 \
                 def.is_unique = IsUniqueParam;                                \
                 const char *first_arg = IndexNameOrFirstColParam;             \
                 std::initializer_list<const char *> other_cols_il = {         \
                     __VA_ARGS__};                                             \
                 std::vector<std::string> other_cols_vec =                     \
                     cpporm::_cpporm_make_string_vector(other_cols_il);      \
                 if (!other_cols_vec.empty()) {                                \
                   if (first_arg && *first_arg)                                \
                     def.index_name = first_arg;                               \
                   def.db_column_names = other_cols_vec;                       \
                 } else if (first_arg && *first_arg) {                         \
                   std::string temp_s(first_arg);                              \
                   std::stringstream ss_cols(temp_s);                          \
                   std::string segment;                                        \
                   bool looks_like_single_col_name_not_index_name =            \
                       (temp_s.find(',') == std::string::npos &&               \
                        temp_s.find(' ') == std::string::npos &&               \
                        temp_s.rfind("idx_", 0) != 0 &&                        \
                        temp_s.rfind("uix_", 0) != 0);                         \
                   std::vector<std::string> parsed_cols;                       \
                   while (std::getline(ss_cols, segment, ',')) {               \
                     size_t f = segment.find_first_not_of(" \t");              \
                     if (f != std::string::npos) {                             \
                       size_t l = segment.find_last_not_of(" \t");             \
                       parsed_cols.push_back(segment.substr(f, (l - f + 1)));  \
                     }                                                         \
                   }                                                           \
                   if (parsed_cols.size() > 1 ||                               \
                       looks_like_single_col_name_not_index_name) {            \
                     def.db_column_names = parsed_cols;                        \
                   } else {                                                    \
                     def.index_name = temp_s;                                  \
                     if (def.db_column_names.empty()) {                        \
                     }                                                         \
                   }                                                           \
                 }                                                             \
                 if (def.db_column_names.empty() && !def.index_name.empty()) { \
                 } else if (def.db_column_names.empty() &&                     \
                            def.index_name.empty()) {                          \
                 }                                                             \
                 return def;                                                   \
               }),                                                             \
       true);                                                                  \
                                                                               \
public:

#define cpporm_INDEX(IndexNameOrFirstCol, ...)                                \
  cpporm_INDEX_INTERNAL(false, IndexNameOrFirstCol, ##__VA_ARGS__)
#define cpporm_UNIQUE_INDEX(IndexNameOrFirstCol, ...)                         \
  cpporm_INDEX_INTERNAL(true, IndexNameOrFirstCol, ##__VA_ARGS__)

#undef cpporm_PRIMARY_KEY
#define cpporm_PRIMARY_KEY(CppType, CppName, DbNameStr, ...)                  \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_pk_prov_reg_, CppName) =            \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType), "",   \
                 cpporm::combine_flags_recursive(                             \
                     cpporm::FieldFlag::PrimaryKey, ##__VA_ARGS__),           \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_AUTO_INCREMENT_PRIMARY_KEY(CppType, CppName, DbNameStr)        \
  cpporm_PRIMARY_KEY(CppType, CppName, DbNameStr,                             \
                      cpporm::FieldFlag::AutoIncrement)

#define cpporm_TIMESTAMPS(TimestampCppType)                                   \
  cpporm_FIELD_TYPE(TimestampCppType, created_at, "created_at", "DATETIME",   \
                     cpporm::FieldFlag::CreatedAt)                            \
  cpporm_FIELD_TYPE(TimestampCppType, updated_at, "updated_at", "DATETIME",   \
                     cpporm::FieldFlag::UpdatedAt)

#define cpporm_SOFT_DELETE(TimestampCppType)                                  \
  cpporm_FIELD_TYPE(TimestampCppType, deleted_at, "deleted_at", "DATETIME",   \
                     cpporm::FieldFlag::DeletedAt,                            \
                     cpporm::FieldFlag::HasDefault)

#define cpporm_MODEL_END()

#endif // cpporm_MODEL_DEFINITION_MACROS_H// cpporm/query_builder.h
#ifndef cpporm_QUERY_BUILDER_H
#define cpporm_QUERY_BUILDER_H

// Core QueryBuilder class definition (non-template members, mixins, state)
#include "cpporm/query_builder_core.h"

// Template member implementations for QueryBuilder (e.g., First<T>, Find<T>)
#include "cpporm/query_builder_execution.h"

// query_builder_setters.h is currently minimal as setters are part of
// QueryBuilder class #include "cpporm/query_builder_setters.h"

// query_builder_fwd.h is for forward declarations, not typically included by
// the main header itself, but by files that need to forward declare
// QueryBuilder.

#endif // cpporm_QUERY_BUILDER_H#ifndef cpporm_QUERY_BUILDER_CORE_H
#define cpporm_QUERY_BUILDER_CORE_H

#include <QDateTime>  // QVariantList 依赖
#include <QMetaType>  // QVariantList 依赖
#include <QString>    // QVariantList 依赖
#include <QVariant>
#include <QVariantList>
#include <algorithm>  // For std::transform, std::tolower (needed for string_contains_ci)
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

#include "cpporm/builder_parts/query_builder_clauses_mixin.h"
#include "cpporm/builder_parts/query_builder_conditions_mixin.h"
#include "cpporm/builder_parts/query_builder_joins_mixin.h"
#include "cpporm/builder_parts/query_builder_preload_mixin.h"
#include "cpporm/builder_parts/query_builder_scopes_mixin.h"
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder_fwd.h"
#include "sqldriver/sql_value.h"  // For CreateImpl return type

namespace cpporm {

    // --- Helper for case-insensitive string find (inline definition) ---
    // Placed within the namespace but outside the class, available to QueryBuilder implementation files.
    inline bool string_contains_ci(const std::string &text, const std::string &pattern) {
        if (pattern.empty()) return true;  // Empty pattern is always "found"
        if (text.empty()) return false;    // Pattern is not empty, but text is

        // Create lowercase copies for comparison
        std::string text_lower = text;
        std::string pattern_lower = pattern;
        // Ensure correct overload of std::tolower is used by casting char to unsigned char first
        std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });
        std::transform(pattern_lower.begin(), pattern_lower.end(), pattern_lower.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });

        return text_lower.find(pattern_lower) != std::string::npos;
    }

    class OnConflictUpdateSetter {
      public:
        explicit OnConflictUpdateSetter(OnConflictClause &clause_ref);
        OnConflictUpdateSetter &Set(const std::string &db_column_name, const QueryValue &value);
        OnConflictUpdateSetter &Set(const std::map<std::string, QueryValue> &assignments);

      private:
        OnConflictClause &clause_;
    };

    class QueryBuilder : public QueryBuilderConditionsMixin<QueryBuilder>, public QueryBuilderClausesMixin<QueryBuilder>, public QueryBuilderJoinsMixin<QueryBuilder>, public QueryBuilderScopesMixin<QueryBuilder>, public QueryBuilderPreloadMixin<QueryBuilder> {
      public:
        using QueryBuilderConditionsMixin<QueryBuilder>::Where;
        using QueryBuilderConditionsMixin<QueryBuilder>::Or;
        using QueryBuilderConditionsMixin<QueryBuilder>::Not;
        using QueryBuilderConditionsMixin<QueryBuilder>::In;

        // 构造函数和析构函数
        // connection_name 现在是 std::string
        explicit QueryBuilder(IQueryExecutor *executor, std::string connection_name, const ModelMeta *model_meta = nullptr);
        QueryBuilder(const QueryBuilder &other);
        QueryBuilder &operator=(const QueryBuilder &other);
        QueryBuilder(QueryBuilder &&other) noexcept;
        QueryBuilder &operator=(QueryBuilder &&other) noexcept;
        ~QueryBuilder();

        // 核心 Model/Table/From 设置器
        QueryBuilder &Model(const ModelBase *model_instance_hint);
        QueryBuilder &Model(const ModelMeta &meta);
        template <typename T>
        QueryBuilder &Model() {
            static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
            return this->Model(T::getModelMeta());
        }
        QueryBuilder &Table(std::string table_name);

        QueryBuilder &From(const QueryBuilder &subquery_builder, const std::string &alias);
        QueryBuilder &From(const SubqueryExpression &subquery_expr, const std::string &alias);
        QueryBuilder &From(std::string source_name_or_cte_alias);

        // Specific Setters
        QueryBuilder &OnConflictUpdateAllExcluded();
        QueryBuilder &OnConflictDoNothing();
        QueryBuilder &OnConflictUpdateSpecific(std::function<void(OnConflictUpdateSetter &)> updater_fn);

        QueryBuilder &With(const std::string &cte_name, const QueryBuilder &cte_query_builder, bool recursive = false);
        QueryBuilder &WithRaw(const std::string &cte_name, const std::string &raw_sql, const std::vector<QueryValue> &bindings = {}, bool recursive = false);

        QueryBuilder &SelectSubquery(const QueryBuilder &subquery_builder, const std::string &alias);
        QueryBuilder &SelectSubquery(const SubqueryExpression &subquery_expr, const std::string &alias);

        // QueryBuilder specific Where/Or/Not overloads
        QueryBuilder &Where(const QueryBuilder &sub_qb_condition);
        QueryBuilder &Or(const QueryBuilder &sub_qb_condition);
        QueryBuilder &Not(const QueryBuilder &sub_qb_condition);

        QueryBuilder &Where(const std::expected<SubqueryExpression, Error> &sub_expr_expected);
        QueryBuilder &Or(const std::expected<SubqueryExpression, Error> &sub_expr_expected);
        QueryBuilder &Not(const std::expected<SubqueryExpression, Error> &sub_expr_expected);

        // SQL 构建和转换方法
        std::pair<QString, QVariantList> buildSelectSQL(bool for_subquery_generation = false) const;
        std::pair<QString, QVariantList> buildInsertSQLSuffix(const std::vector<std::string> &inserted_columns_db_names_for_values_clause) const;
        std::pair<QString, QVariantList> buildUpdateSQL(const std::map<std::string, QueryValue> &updates) const;
        std::pair<QString, QVariantList> buildDeleteSQL() const;
        std::expected<SubqueryExpression, Error> AsSubquery() const;
        std::pair<std::string, std::vector<QueryValue>> buildConditionClauseGroup() const;

        // 状态访问器
        const ModelMeta *getModelMeta() const {
            return state_.model_meta_;
        }
        QString getFromSourceName() const;
        const FromClauseSource &getFromClauseSource() const {
            return state_.from_clause_source_;
        }
        const std::string &getConnectionName() const {
            return connection_name_;
        }
        IQueryExecutor *getExecutor() const {
            return executor_;
        }

        const std::vector<Condition> &getWhereConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getWhereConditions_mixin();
        }
        const std::vector<Condition> &getOrConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getOrConditions_mixin();
        }
        const std::vector<Condition> &getNotConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getNotConditions_mixin();
        }
        const std::vector<CTEState> &getCTEs() const {
            return state_.ctes_;
        }
        const std::vector<SelectField> &getSelectFields() const {
            return state_.select_fields_;
        }
        const std::string &getOrderClause() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getOrderClause_mixin();
        }
        int getLimitVal() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getLimitVal_mixin();
        }
        int getOffsetVal() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getOffsetVal_mixin();
        }
        const std::string &getGroupClause() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getGroupClause_mixin();
        }
        const Condition *getHavingCondition() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getHavingCondition_mixin();
        }
        const std::vector<JoinClause> &getJoinClauses() const {
            return QueryBuilderJoinsMixin<QueryBuilder>::getJoinClauses_mixin();
        }
        bool isSoftDeleteScopeActive() const {
            return QueryBuilderScopesMixin<QueryBuilder>::isSoftDeleteScopeActive_mixin();
        }
        const std::vector<PreloadRequest> &getPreloadRequests() const {
            return QueryBuilderPreloadMixin<QueryBuilder>::getPreloadRequests_mixin();
        }
        const OnConflictClause *getOnConflictClause() const {
            return state_.on_conflict_clause_.get();
        }

        // 公共静态方法
        static QVariant toQVariant(const QueryValue &qv, QVariantList &subquery_bindings_accumulator);
        static QueryValue qvariantToQueryValue(const QVariant &qv);
        static std::string quoteSqlIdentifier(const std::string &identifier);

        // 内部状态访问
        QueryBuilderState &getState_() {
            return state_;
        }
        const QueryBuilderState &getState_() const {
            return state_;
        }

        // 调试方法
        QString toSqlDebug() const;

        // 模板化执行方法 (声明)
        template <typename T>
        Error First(T *result_model);
        template <typename T>
        Error First(T *result_model, const QueryValue &primary_key_value);
        template <typename T>
        Error First(T *result_model, const std::vector<QueryValue> &primary_key_values);
        template <typename T>
        Error First(T *result_model, const std::map<std::string, QueryValue> &conditions);

        template <typename T>
        Error Find(std::vector<T> *results_vector);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        // Create 返回类型与 IQueryExecutor::CreateImpl 保持一致
        template <typename TModel>
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(TModel &model);

        template <typename TModel>
        std::expected<long long, Error> Save(TModel &model);

        // 非模板化执行方法 (声明)
        Error First(ModelBase &result_model);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory);
        // Create 返回类型与 IQueryExecutor::CreateImpl 保持一致
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(ModelBase &model, const OnConflictClause *conflict_options_override = nullptr);
        std::expected<long long, Error> Updates(const std::map<std::string, QueryValue> &updates);
        std::expected<long long, Error> Delete();
        std::expected<long long, Error> Save(ModelBase &model);
        std::expected<int64_t, Error> Count();

      private:
        friend class QueryBuilderConditionsMixin<QueryBuilder>;
        friend class QueryBuilderClausesMixin<QueryBuilder>;
        friend class QueryBuilderJoinsMixin<QueryBuilder>;
        friend class QueryBuilderScopesMixin<QueryBuilder>;
        friend class QueryBuilderPreloadMixin<QueryBuilder>;

        IQueryExecutor *executor_;
        std::string connection_name_;
        QueryBuilderState state_;

        void build_condition_logic_internal(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator, bool &first_overall_condition_written, const std::string &prepended_scope_sql = "") const;
        void build_ctes_sql_prefix(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator) const;

        static bool build_one_condition_block_internal_static_helper(std::ostringstream &to_stream, QVariantList &bindings_acc, const std::vector<Condition> &conditions_group, const std::string &op_within_group, bool is_not_group);
    };

    inline OnConflictUpdateSetter::OnConflictUpdateSetter(OnConflictClause &clause_ref) : clause_(clause_ref) {
        clause_.action = OnConflictClause::Action::UpdateSpecific;
    }

    inline OnConflictUpdateSetter &OnConflictUpdateSetter::Set(const std::string &db_column_name, const QueryValue &value) {
        clause_.update_assignments[db_column_name] = value;
        return *this;
    }

    inline OnConflictUpdateSetter &OnConflictUpdateSetter::Set(const std::map<std::string, QueryValue> &assignments) {
        for (const auto &pair : assignments) {
            clause_.update_assignments[pair.first] = pair.second;
        }
        return *this;
    }

}  // namespace cpporm

#endif  // cpporm_QUERY_BUILDER_CORE_H// cpporm/query_builder_execution.h
#ifndef cpporm_QUERY_BUILDER_EXECUTION_H
#define cpporm_QUERY_BUILDER_EXECUTION_H

#include "cpporm/query_builder_core.h"
#include "sqldriver/sql_value.h"  // For SqlValue type

// Other necessary includes are transitively included via query_builder_core.h

namespace cpporm {

    // --- Templated Execution Method Implementations ---

    template <typename T>
    inline Error QueryBuilder::First(T *result_model) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for First operation.");
        if (!result_model) return Error(ErrorCode::InternalError, "Result model pointer is null for QueryBuilder::First.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }
        return executor_->FirstImpl(*this, *static_cast<ModelBase *>(result_model));
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const QueryValue &primary_key_value) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        const ModelMeta *meta = this->state_.model_meta_;
        if (!meta || meta->primary_keys_db_names.empty()) return Error(ErrorCode::MappingError, "Model has no primary key defined for First by PK.");
        if (meta->primary_keys_db_names.size() > 1)
            return Error(ErrorCode::InvalidConfiguration,
                         "Model has composite PKs. Use vector<QueryValue> or map "
                         "overload for First by PK.");
        this->Where(quoteSqlIdentifier(meta->primary_keys_db_names[0]) + " = ?", {primary_key_value});
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const std::vector<QueryValue> &primary_key_values) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        const ModelMeta *meta = this->state_.model_meta_;
        if (!meta || meta->primary_keys_db_names.empty()) return Error(ErrorCode::MappingError, "Model has no primary keys defined for First by PKs.");
        if (meta->primary_keys_db_names.size() != primary_key_values.size()) return Error(ErrorCode::InvalidConfiguration, "Number of PK values does not match PK columns for First by PKs.");
        std::map<std::string, QueryValue> conditions;
        for (size_t i = 0; i < meta->primary_keys_db_names.size(); ++i) {
            conditions[meta->primary_keys_db_names[i]] = primary_key_values[i];
        }
        this->Where(conditions);
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        this->Where(conditions);
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for Find operation.");
        if (!results_vector) return Error(ErrorCode::InternalError, "Results vector pointer is null for QueryBuilder::Find.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }

        std::vector<std::unique_ptr<ModelBase>> base_results;
        auto factory = []() -> std::unique_ptr<ModelBase> {
            return std::make_unique<T>();
        };
        Error err = executor_->FindImpl(*this, base_results, factory);
        if (err) {
            return err;
        }

        results_vector->clear();
        results_vector->reserve(base_results.size());
        for (auto &base_ptr : base_results) {
            if (base_ptr) {
                T *typed_ptr = static_cast<T *>(base_ptr.release());
                results_vector->push_back(std::move(*typed_ptr));
                delete typed_ptr;
            }
        }
        return make_ok();
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        this->Model<T>();
        this->Where(conditions);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        this->Model<T>();
        this->Where(query_string, args);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for Find operation.");
        if (!results_vector) return Error(ErrorCode::InternalError, "Results vector pointer is null for QueryBuilder::Find.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }

        std::vector<std::unique_ptr<ModelBase>> base_results;
        auto factory = []() -> std::unique_ptr<ModelBase> {
            return std::make_unique<T>();
        };
        Error err = executor_->FindImpl(*this, base_results, factory);
        if (err) {
            return err;
        }

        results_vector->clear();
        results_vector->reserve(base_results.size());
        for (auto &base_ptr : base_results) {
            results_vector->emplace_back(static_cast<T *>(base_ptr.release()));
        }
        return make_ok();
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        this->Model<T>();
        this->Where(conditions);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        this->Model<T>();
        this->Where(query_string, args);
        return this->Find(results_vector);
    }

    template <typename TModel>
    inline std::expected<cpporm_sqldriver::SqlValue, Error> QueryBuilder::Create(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        // 调用非模板 Create，它现在返回 std::expected<SqlValue, Error>
        return this->Create(static_cast<ModelBase &>(model), nullptr);
    }

    template <typename TModel>
    inline std::expected<long long, Error> QueryBuilder::Save(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        return this->Save(static_cast<ModelBase &>(model));
    }

}  // namespace cpporm

#endif  // cpporm_QUERY_BUILDER_EXECUTION_H// cpporm/query_builder_fwd.h
#ifndef cpporm_QUERY_BUILDER_FWD_H
#define cpporm_QUERY_BUILDER_FWD_H

namespace cpporm {
class QueryBuilder;
class OnConflictUpdateSetter; // 也前向声明
struct OnConflictClause;      // 如果 setter 会用到
struct SubqueryExpression;    // 如果 setter 会用到
// struct QueryValue;            // 如果 setter 会用到
} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_FWD_H// cpporm/query_builder_setters.h
#ifndef cpporm_QUERY_BUILDER_SETTERS_H
#define cpporm_QUERY_BUILDER_SETTERS_H

// This file is intended for QueryBuilder setter method declarations if they
// were separated from the main QueryBuilder class definition, or for related
// free functions. Currently, setter methods like OnConflict..., With...,
// SelectSubquery... are declared directly within the QueryBuilder class in
// query_builder_core.h, and their non-template implementations are in
// query_builder_core.cpp.

// #include "cpporm/query_builder_fwd.h" // For forward declarations if needed
// #include "cpporm/builder_parts/query_builder_state.h" // For types like
// OnConflictClause

namespace cpporm {

// Declarations for OnConflictUpdateSetter are in query_builder_core.h as it's
// tightly coupled.

// If there were free functions related to QueryBuilder state manipulation or
// specific setters, they could be declared here. For now, this file remains
// mostly a placeholder.

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_SETTERS_H// cpporm/query_builder_execution.h
#ifndef cpporm_QUERY_BUILDER_EXECUTION_H
#define cpporm_QUERY_BUILDER_EXECUTION_H

#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"   // 执行方法依赖 IQueryExecutor
#include "cpporm/model_base.h"         // For ModelBase constraint
#include "cpporm/query_builder_core.h" // 需要 QueryBuilder 类的完整定义

#include <QVariant> // For Create result
#include <expected>
#include <functional> // For factory function
#include <map>        // For map conditions
#include <memory>     // For std::unique_ptr
#include <string>
#include <type_traits> // For std::is_base_of
#include <vector>

namespace cpporm {

// --- QueryBuilder Execution Method Implementations ---
// 这些是模板方法，它们的实现通常放在头文件中。
// 注意：这些实现已从旧的 query_builder.h 移至此处。

template <typename T> inline Error QueryBuilder::First(T *result_model) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for First operation.");
  if (!result_model)
    return Error(ErrorCode::InternalError,
                 "Result model pointer is null for QueryBuilder::First.");

  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  return executor_->FirstImpl(*this, *static_cast<ModelBase *>(result_model));
}

template <typename T>
inline Error QueryBuilder::First(T *result_model,
                                 const QueryValue &primary_key_value) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  const ModelMeta *meta = this->state_.model_meta_;
  if (!meta || meta->primary_keys_db_names.empty())
    return Error(ErrorCode::MappingError, "Model has no primary key defined.");
  if (meta->primary_keys_db_names.size() > 1)
    return Error(ErrorCode::InvalidConfiguration,
                 "Model has composite PKs. Use vector<QueryValue> overload.");
  this->Where(meta->primary_keys_db_names[0] + " = ?", {primary_key_value});

  return this->First(result_model);
}

template <typename T>
inline Error
QueryBuilder::First(T *result_model,
                    const std::vector<QueryValue> &primary_key_values) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  const ModelMeta *meta = this->state_.model_meta_;
  if (!meta || meta->primary_keys_db_names.empty())
    return Error(ErrorCode::MappingError, "Model has no primary keys defined.");
  if (meta->primary_keys_db_names.size() != primary_key_values.size())
    return Error(ErrorCode::InvalidConfiguration,
                 "Number of PK values does not match PK columns.");
  std::map<std::string, QueryValue> conditions;
  for (size_t i = 0; i < meta->primary_keys_db_names.size(); ++i) {
    conditions[meta->primary_keys_db_names[i]] = primary_key_values[i];
  }
  this->Where(conditions);
  return this->First(result_model);
}

template <typename T>
inline Error
QueryBuilder::First(T *result_model,
                    const std::map<std::string, QueryValue> &conditions) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  this->Where(conditions);
  return this->First(result_model);
}

// Non-template First(ModelBase&) is in query_builder_core.cpp

template <typename T>
inline Error QueryBuilder::Find(std::vector<T> *results_vector) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for Find operation.");
  if (!results_vector)
    return Error(ErrorCode::InternalError,
                 "Results vector pointer is null for QueryBuilder::Find.");
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  std::vector<std::unique_ptr<ModelBase>> base_results;
  auto factory = []() -> std::unique_ptr<ModelBase> {
    return std::make_unique<T>();
  };
  Error err = executor_->FindImpl(*this, base_results, factory);
  if (err) {
    return err;
  }

  results_vector->clear();
  results_vector->reserve(base_results.size());
  for (auto &base_ptr : base_results) {
    if (base_ptr) {
      T *typed_ptr = static_cast<T *>(base_ptr.release());
      results_vector->push_back(std::move(*typed_ptr));
      delete typed_ptr;
    }
  }
  return make_ok();
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<T> *results_vector,
                   const std::map<std::string, QueryValue> &conditions) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(conditions);
  return this->Find(results_vector);
}

template <typename T>
inline Error QueryBuilder::Find(std::vector<T> *results_vector,
                                const std::string &query_string,
                                const std::vector<QueryValue> &args) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(query_string, args);
  return this->Find(results_vector);
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for Find operation.");
  if (!results_vector)
    return Error(ErrorCode::InternalError,
                 "Results vector pointer is null for QueryBuilder::Find.");
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  std::vector<std::unique_ptr<ModelBase>> base_results;
  auto factory = []() -> std::unique_ptr<ModelBase> {
    return std::make_unique<T>();
  };
  Error err = executor_->FindImpl(*this, base_results, factory);
  if (err) {
    return err;
  }

  results_vector->clear();
  results_vector->reserve(base_results.size());
  for (auto &base_ptr : base_results) {
    results_vector->emplace_back(static_cast<T *>(base_ptr.release()));
  }
  return make_ok();
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector,
                   const std::map<std::string, QueryValue> &conditions) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(conditions);
  return this->Find(results_vector);
}

template <typename T>
inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector,
                                const std::string &query_string,
                                const std::vector<QueryValue> &args) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(query_string, args);
  return this->Find(results_vector);
}

// Non-template Find(std::vector<std::unique_ptr<ModelBase>>&, factory) is in
// query_builder_core.cpp

template <typename TModel>
inline std::expected<QVariant, Error> QueryBuilder::Create(TModel &model) {
  static_assert(std::is_base_of<ModelBase, TModel>::value,
                "TModel must be a descendant of cpporm::ModelBase");
  return this->Create(static_cast<ModelBase &>(model), nullptr);
}

// Non-template Create(ModelBase&, const OnConflictClause*) is in
// query_builder_core.cpp

// Non-template Updates(map) is in query_builder_core.cpp
// Non-template Delete() is in query_builder_core.cpp

template <typename TModel>
inline std::expected<long long, Error> QueryBuilder::Save(TModel &model) {
  static_assert(std::is_base_of<ModelBase, TModel>::value,
                "TModel must be a descendant of cpporm::ModelBase");
  return this->Save(static_cast<ModelBase &>(model));
}

// Non-template Save(ModelBase&) is in query_builder_core.cpp
// Non-template Count() is in query_builder_core.cpp

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_EXECUTION_H// cpporm/session_batch_ops.h
#ifndef cpporm_SESSION_BATCH_OPS_H
#define cpporm_SESSION_BATCH_OPS_H

#include <algorithm>  // For std::min
#include <expected>
#include <functional>
#include <memory>
#include <optional>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/model_base.h"    // For ModelType constraints
#include "cpporm/session_core.h"  // Needs Session definition

// QueryBuilder is included via session_core.h -> query_builder.h

namespace cpporm {

    // --- Implementations for Templated CreateBatch methods ---
    // 这些实现看起来应该能与 CreateBatchProviderInternal 配合，
    // 因为后者处理底层的 ModelBase*。主要的关注点是返回类型和错误处理。
    // 返回类型 `std::expected<std::vector<std::shared_ptr<ModelType>>, Error>` 保持不变。
    // 错误处理依赖于 CreateBatchProviderInternal 返回的 Error 对象。

    // Vector of raw pointers version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(const std::vector<ModelType *> &models_raw_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_raw_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        base_models_for_internal_provider.reserve(models_raw_input.size());
        std::vector<ModelType *> original_input_ptrs_filtered;
        original_input_ptrs_filtered.reserve(models_raw_input.size());

        for (ModelType *typed_ptr : models_raw_input) {
            if (typed_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(typed_ptr));
                original_input_ptrs_filtered.push_back(typed_ptr);
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;  // 表示没有更多数据或当前块为空
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (ModelBase *base_ptr : successfully_processed_and_backfilled_models_collector) {
            ModelType *typed_ptr = static_cast<ModelType *>(base_ptr);
            bool found_in_original = false;
            for (ModelType *original_typed_ptr : original_input_ptrs_filtered) {
                if (typed_ptr == original_typed_ptr) {
                    found_in_original = true;
                    break;
                }
            }
            if (found_in_original) {
                final_result_sptrs.emplace_back(typed_ptr, [](ModelType *) { /* no-op deleter */ });
            }
        }
        return final_result_sptrs;
    }

    // Vector of unique_ptr version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(std::vector<std::unique_ptr<ModelType>> &models_unique_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_unique_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        std::vector<ModelType *> unique_ptr_original_raw_ptrs;
        base_models_for_internal_provider.reserve(models_unique_input.size());
        unique_ptr_original_raw_ptrs.reserve(models_unique_input.size());

        for (const auto &u_ptr : models_unique_input) {
            if (u_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(u_ptr.get()));
                unique_ptr_original_raw_ptrs.push_back(u_ptr.get());
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (auto &u_ptr : models_unique_input) {
            if (u_ptr) {
                bool found_and_persisted = false;
                for (ModelBase *processed_base_ptr : successfully_processed_and_backfilled_models_collector) {
                    if (static_cast<ModelBase *>(u_ptr.get()) == processed_base_ptr) {
                        found_and_persisted = true;
                        break;
                    }
                }
                if (found_and_persisted) {
                    final_result_sptrs.push_back(std::move(u_ptr));
                }
            }
        }
        models_unique_input.erase(std::remove(models_unique_input.begin(), models_unique_input.end(), nullptr), models_unique_input.end());
        return final_result_sptrs;
    }

    // Vector of shared_ptr version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(const std::vector<std::shared_ptr<ModelType>> &models_shared_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_shared_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        base_models_for_internal_provider.reserve(models_shared_input.size());
        for (const auto &s_ptr : models_shared_input) {
            if (s_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(s_ptr.get()));
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (const auto &original_s_ptr : models_shared_input) {
            if (original_s_ptr) {
                bool found_and_persisted = false;
                for (ModelBase *processed_base_ptr : successfully_processed_and_backfilled_models_collector) {
                    if (static_cast<ModelBase *>(original_s_ptr.get()) == processed_base_ptr) {
                        found_and_persisted = true;
                        break;
                    }
                }
                if (found_and_persisted) {
                    final_result_sptrs.push_back(original_s_ptr);
                }
            }
        }
        return final_result_sptrs;
    }

    // Provider-based CreateBatch implementation
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(std::function<std::optional<std::vector<ModelType *>>()> data_batch_provider_typed, const OnConflictClause *conflict_options_override, size_t) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");

        if (!data_batch_provider_typed) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateBatch (provider): data_batch_provider_typed is null."));
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> all_successfully_created_models_sptr;
        Error overall_error_from_all_batches = make_ok();

        auto data_batch_provider_base_adapted = [provider_typed = std::move(data_batch_provider_typed)]() mutable -> std::optional<std::vector<ModelBase *>> {
            auto typed_batch_opt = provider_typed();
            if (!typed_batch_opt.has_value()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> base_batch;
            base_batch.reserve(typed_batch_opt.value().size());
            for (ModelType *typed_ptr : typed_batch_opt.value()) {
                if (typed_ptr) {
                    base_batch.push_back(static_cast<ModelBase *>(typed_ptr));
                }
            }
            return base_batch;
        };

        std::vector<ModelBase *> collected_processed_base_models_with_ids;

        auto internal_completion_callback_for_provider = [&overall_error_from_all_batches, &collected_processed_base_models_with_ids](const std::vector<ModelBase *> &processed_batch_models_from_internal_call, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_from_internal_call) {
                    if (bm && bm->_is_persisted) {
                        collected_processed_base_models_with_ids.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, data_batch_provider_base_adapted, internal_completion_callback_for_provider, conflict_options_override);

        if (provider_loop_error) {
            return std::unexpected(provider_loop_error);
        }
        if (overall_error_from_all_batches) {
            return std::unexpected(overall_error_from_all_batches);
        }

        all_successfully_created_models_sptr.reserve(collected_processed_base_models_with_ids.size());
        for (ModelBase *base_ptr : collected_processed_base_models_with_ids) {
            ModelType *typed_ptr = static_cast<ModelType *>(base_ptr);
            all_successfully_created_models_sptr.emplace_back(typed_ptr);
        }

        return all_successfully_created_models_sptr;
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_BATCH_OPS_H// Base/CppOrm/Include/cpporm/session_core.h
#ifndef cpporm_SESSION_CORE_H
#define cpporm_SESSION_CORE_H

#include <QString>
#include <QVariant>
#include <QVariantList>
#include <any>
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session_fwd.h"
#include "cpporm/session_types.h"
#include "sqldriver/sql_database.h"  // For cpporm_sqldriver::SqlDatabase
// SqlDriverManager is not directly needed by Session if it receives an SqlDatabase handle
// #include "sqldriver/sql_driver_manager.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {
        class FriendAccess;
    }
}  // namespace cpporm

namespace cpporm {

    class Session : public IQueryExecutor {
      public:
        // Removed: explicit Session(const std::string &connection_name);
        // Constructor now takes an rvalue reference to an SqlDatabase object
        explicit Session(cpporm_sqldriver::SqlDatabase &&db_handle_rval);

        Session(const Session &) = delete;
        Session &operator=(const Session &) = delete;
        Session(Session &&other) noexcept;
        Session &operator=(Session &&other) noexcept;
        ~Session();

        QueryBuilder Model(const ModelBase *model_instance_hint);
        QueryBuilder Model(const ModelMeta &meta);
        template <typename T>
        QueryBuilder Model() {
            static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
            // Pass this->connection_name_ (which is now derived from db_handle_)
            return QueryBuilder(this, this->connection_name_, &(T::getModelMeta()));
        }
        QueryBuilder Table(const std::string &table_name);
        QueryBuilder MakeQueryBuilder();

        Session &OnConflictUpdateAllExcluded();
        Session &OnConflictDoNothing();
        Session &OnConflictUpdateSpecific(std::function<void(SessionOnConflictUpdateSetter &)> updater_fn);

        Error FirstImpl(const QueryBuilder &qb, ModelBase &result_model) override;
        Error FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) override;
        std::expected<cpporm_sqldriver::SqlValue, Error> CreateImpl(const QueryBuilder &qb, ModelBase &model, const OnConflictClause *conflict_options_override) override;
        std::expected<long long, Error> UpdatesImpl(const QueryBuilder &qb, const std::map<std::string, QueryValue> &updates) override;
        std::expected<long long, Error> DeleteImpl(const QueryBuilder &qb) override;
        std::expected<long long, Error> SaveImpl(const QueryBuilder &qb, ModelBase &model) override;
        std::expected<int64_t, Error> CountImpl(const QueryBuilder &qb) override;

        std::expected<cpporm_sqldriver::SqlValue, Error> Create(ModelBase &model, const OnConflictClause *conflict_options_override = nullptr);

        template <typename TModel>
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(TModel &model);

        Error First(ModelBase &result_model);
        Error First(ModelBase &result_model, const QueryValue &primary_key_value);
        Error First(ModelBase &result_model, const std::vector<QueryValue> &primary_key_values);
        Error First(ModelBase &result_model, const std::map<std::string, QueryValue> &conditions);

        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory, const std::map<std::string, QueryValue> &conditions);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error First(T *result_model, QueryBuilder qb);
        template <typename T>
        Error First(T *result_model);
        template <typename T>
        Error First(T *result_model, const QueryValue &primary_key_value);
        template <typename T>
        Error First(T *result_model, const std::vector<QueryValue> &primary_key_values);
        template <typename T>
        Error First(T *result_model, const std::map<std::string, QueryValue> &conditions);

        template <typename T>
        Error Find(std::vector<T> *results_vector, QueryBuilder qb);
        template <typename T>
        Error Find(std::vector<T> *results_vector);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, QueryBuilder qb);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(const std::vector<ModelType *> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(std::vector<std::unique_ptr<ModelType>> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(const std::vector<std::shared_ptr<ModelType>> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(std::function<std::optional<std::vector<ModelType *>>()> data_batch_provider_typed, const OnConflictClause *conflict_options_override = nullptr, size_t internal_db_batch_processing_size_hint = 100);

        std::expected<size_t, Error> CreateBatchWithMeta(const ModelMeta &meta, const std::vector<ModelBase *> &models, size_t internal_batch_processing_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        Error CreateBatchProviderInternal(QueryBuilder qb_prototype,
                                          std::function<std::optional<std::vector<ModelBase *>>()> data_batch_provider_base,
                                          std::function<void(const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error)> per_db_batch_completion_callback,
                                          const OnConflictClause *conflict_options_override);

        std::expected<long long, Error> Save(ModelBase &model);
        template <typename TModel>
        std::expected<long long, Error> Save(TModel &model);

        std::expected<long long, Error> Updates(QueryBuilder qb, const std::map<std::string, QueryValue> &updates);
        std::expected<long long, Error> Delete(QueryBuilder qb);

        std::expected<long long, Error> Updates(const ModelMeta &meta, const std::map<std::string, QueryValue> &updates, const std::map<std::string, QueryValue> &conditions);
        std::expected<long long, Error> Updates(const ModelBase &model_condition, const std::map<std::string, QueryValue> &updates);

        std::expected<long long, Error> Delete(const ModelBase &model_condition);
        std::expected<long long, Error> Delete(const ModelMeta &meta, const std::map<std::string, QueryValue> &conditions);

        std::expected<long long, Error> DeleteBatch(const ModelMeta &meta, const std::vector<std::map<std::string, QueryValue>> &primary_keys_list, size_t batch_delete_size = 100);

        std::expected<long long, Error> ExecRaw(const QString &sql, const QVariantList &args = {});

        Error AutoMigrate(const ModelMeta &meta);
        Error AutoMigrate(const std::vector<const ModelMeta *> &metas);

        std::expected<std::unique_ptr<Session>, Error> Begin();
        Error Commit();
        Error Rollback();
        bool IsTransaction() const;

        const std::string &getConnectionName() const;
        cpporm_sqldriver::SqlDatabase &getDbHandle();
        const cpporm_sqldriver::SqlDatabase &getDbHandle() const;

        const cpporm::OnConflictClause *getTempOnConflictClause() const;
        void clearTempOnConflictClause();

        static std::string getSqlTypeForCppType(const FieldMeta &field_meta, const QString &driverName_std);
        static void qvariantToAny(const QVariant &qv, const std::type_index &target_cpp_type, std::any &out_any, bool &out_conversion_ok);
        static QueryValue anyToQueryValueForSessionConvenience(const std::any &val);

        static cpporm_sqldriver::SqlValue queryValueToSqlValue(const QueryValue &qv);
        static QueryValue sqlValueToQueryValue(const cpporm_sqldriver::SqlValue &sv);

        static std::pair<cpporm_sqldriver::SqlQuery, Error> execute_query_internal(cpporm_sqldriver::SqlDatabase &db_conn_ref, const std::string &sql, const std::vector<cpporm_sqldriver::SqlValue> &bound_params);

      private:
        friend class internal_batch_helpers::FriendAccess;  // Grant access for batch helpers

        Error mapRowToModel(cpporm_sqldriver::SqlQuery &query, ModelBase &model, const ModelMeta &meta);
        internal::SessionModelDataForWrite extractModelData(const ModelBase &model_instance, const ModelMeta &meta, bool for_update = false, bool include_timestamps_even_if_null = false);

        void autoSetTimestamps(ModelBase &model_instance, const ModelMeta &meta, bool is_create_op);

        Error processPreloadsInternal(const QueryBuilder &qb, std::vector<ModelBase *> &models_raw_ptr);
        Error processPreloads(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &loaded_models);
        Error executePreloadForAssociation(const AssociationMeta &assoc_meta, const ModelMeta &parent_model_meta, std::vector<ModelBase *> &parent_models_raw_ptr, const std::string &remaining_nested_preload_path = "");

        std::string connection_name_;              // Still useful for QueryBuilder, derived from db_handle_
        cpporm_sqldriver::SqlDatabase db_handle_;  // Session now OWNS the database handle
        bool is_explicit_transaction_handle_;      // True if this Session object represents an explicit transaction
        std::unique_ptr<OnConflictClause> temp_on_conflict_clause_;
    };

}  // namespace cpporm

#endif  // cpporm_SESSION_CORE_H// cpporm/session_crud_ops.h
#ifndef cpporm_SESSION_CRUD_OPS_H
#define cpporm_SESSION_CRUD_OPS_H

#include "cpporm/session_core.h"  // 包含 Session 核心定义和 QueryBuilder
#include "sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    // --- 实现简单的模板化便捷 CRUD 方法 ---

    template <typename TModel>  // 返回 SqlValue
    inline std::expected<cpporm_sqldriver::SqlValue, Error> Session::Create(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        // 调用 Session 的非模板 Create 方法，该方法已更新为返回 SqlValue
        return this->Create(static_cast<ModelBase &>(model), nullptr);
    }

    template <typename T>
    inline Error Session::First(T *result_model, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        // QueryBuilder::First 已经过修改以与 IQueryExecutor 的新接口配合
        return qb.First(result_model);
    }

    template <typename T>
    inline Error Session::First(T *result_model) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const QueryValue &primary_key_value) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model, primary_key_value);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const std::vector<QueryValue> &primary_key_values) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model, primary_key_values);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).First(result_model);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return qb.Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(query_string, args).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return qb.Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(query_string, args).Find(results_vector);
    }

    template <typename TModel>
    inline std::expected<long long, Error> Session::Save(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        return this->Save(static_cast<ModelBase &>(model));
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_CRUD_OPS_H// cpporm/session_fwd.h
#ifndef cpporm_SESSION_FWD_H
#define cpporm_SESSION_FWD_H

#include <memory> // For std::unique_ptr if used in forward declared params/returns

namespace cpporm {

class Session; // Forward declaration
class QueryBuilder;
struct OnConflictClause; // Forward declaration if needed by SessionCore setters
                         // but defined elsewhere (e.g., query_builder_state.h)

// If SessionOnConflictUpdateSetter is tightly coupled and only used by Session,
// its forward declaration or full definition might go here or in session_core.h
// For now, let's assume it's defined before session_core.h needs its full type.

} // namespace cpporm

#endif // cpporm_SESSION_FWD_H// Base/CppOrm/Include/cpporm/session_migrate_priv.h
#ifndef cpporm_SESSION_MIGRATE_PRIV_H
#define cpporm_SESSION_MIGRATE_PRIV_H

#include <QString>
#include <map>
#include <string>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/model_base.h"  // For ModelMeta
// Removed algorithm and cctype, will be in the .cpp file with definition

namespace cpporm_sqldriver {
    class SqlDatabase;
    class SqlQuery;
}  // namespace cpporm_sqldriver

namespace cpporm {

    class Session;

    namespace internal {

        struct DbColumnInfo {
            std::string name;
            std::string type;
            std::string normalized_type;
            bool is_nullable = true;
            std::string default_value;
            std::string character_set_name;
            std::string collation_name;
            std::string column_key;  // e.g., "PRI", "UNI", "MUL"
            std::string extra;       // e.g., "auto_increment"
        };

        struct DbIndexInfo {
            std::string index_name;
            std::vector<std::string> column_names;
            bool is_unique = false;
            bool is_primary_key = false;
            std::string type_method;
        };

        // Declaration of normalizeDbType
        std::string normalizeDbType(const std::string &db_type_raw, const QString &driverNameUpperQ);

        // Declarations for functions in migrate_table_ops.cpp, migrate_column_ops.cpp, migrate_index_ops.cpp
        Error migrateCreateTable(Session &session, const ModelMeta &meta, const QString &driverNameUpper);
        std::map<std::string, DbColumnInfo> getTableColumnsInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper);
        Error migrateModifyColumns(Session &session, const ModelMeta &meta, const QString &driverNameUpper);
        std::map<std::string, DbIndexInfo> getTableIndexesInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper);
        Error migrateManageIndexes(Session &session, const ModelMeta &meta, const QString &driverNameUpper);
        bool areIndexDefinitionsEquivalent(const DbIndexInfo &db_idx, const IndexDefinition &model_idx_def, const QString &driverNameUpper);

        // Helper for executing DDL - already public static on Session, but good to have a consistent way if needed privately
        std::pair<cpporm_sqldriver::SqlQuery, Error> execute_ddl_query(cpporm_sqldriver::SqlDatabase &db, const std::string &ddl_sql_std);

    }  // namespace internal
}  // namespace cpporm

#endif  // cpporm_SESSION_MIGRATE_PRIV_H// Base/CppOrm/Include/cpporm/session_priv_batch_helpers.h
#ifndef cpporm_SESSION_PRIV_BATCH_HELPERS_H
#define cpporm_SESSION_PRIV_BATCH_HELPERS_H

#include <QString>
#include <QStringList>
#include <QVariantList>
#include <optional>
#include <string>
#include <typeindex>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/session_fwd.h"
#include "cpporm/session_types.h"
#include "sqldriver/sql_query.h"
// Forward declare types from cpporm_sqldriver that are used in signatures
namespace cpporm_sqldriver {
    class SqlQuery;
    class SqlValue;
    class SqlDatabase;
}  // namespace cpporm_sqldriver

namespace cpporm {

    class ModelBase;
    struct ModelMeta;
    struct FieldMeta;
    struct OnConflictClause;
    class QueryBuilder;

    namespace internal_batch_helpers {

        class FriendAccess {
          public:
            static internal::SessionModelDataForWrite callExtractModelData(Session &s, const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null);

            // Unified parameter names with definition
            static std::pair<cpporm_sqldriver::SqlQuery, Error> callExecuteQueryInternal(cpporm_sqldriver::SqlDatabase &db_conn_ref, const std::string &sql, const std::vector<cpporm_sqldriver::SqlValue> &bound_params);

            static void callAutoSetTimestamps(Session &s, ModelBase &model_instance, const ModelMeta &meta, bool is_create_op);
        };

        struct BatchSqlParts {
            QString sql_insert_base;
            QStringList row_placeholders;
            std::vector<cpporm_sqldriver::SqlValue> all_values_flattened;
            QString sql_on_conflict_suffix;
            QVariantList conflict_suffix_bindings;
            std::string final_sql_statement;
            std::vector<cpporm_sqldriver::SqlValue> final_bindings;
            bool can_proceed = false;
        };

        struct ExecutionResult {
            std::optional<cpporm_sqldriver::SqlQuery> query_object_opt;
            long long rows_affected = -1;
            Error db_error = make_ok();
            std::vector<ModelBase *> models_potentially_persisted;

            ExecutionResult() = default;
            ExecutionResult(ExecutionResult &&) = default;
            ExecutionResult &operator=(ExecutionResult &&) = default;
            ExecutionResult(const ExecutionResult &) = delete;
            ExecutionResult &operator=(const ExecutionResult &) = delete;
        };

        std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(Session &session, const std::vector<ModelBase *> &models_in_provider_chunk, const ModelMeta &meta, const std::vector<std::string> &batch_ordered_db_field_names_cache, BatchSqlParts &out_sql_parts);

        Error buildFullBatchSqlStatement(const Session &session, const QueryBuilder &qb_prototype, const ModelMeta &meta, const std::vector<std::string> &batch_ordered_db_field_names_cache, const OnConflictClause *active_conflict_clause, BatchSqlParts &in_out_sql_parts);

        ExecutionResult executeBatchSql(Session &session, const std::string &sql_to_execute_std, const std::vector<cpporm_sqldriver::SqlValue> &bindings_sqlvalue, const std::vector<ModelBase *> &models_in_db_op, const OnConflictClause *active_conflict_clause);

        std::vector<ModelBase *> backfillIdsFromReturning(cpporm_sqldriver::SqlQuery &executed_query, const ModelMeta &meta, const std::vector<ModelBase *> &models_to_backfill_from, const std::string &pk_cpp_name_str, const std::type_index &pk_cpp_type);

        std::vector<ModelBase *> backfillIdsFromLastInsertId(cpporm_sqldriver::SqlQuery &executed_query,
                                                             const Session &session,
                                                             const ModelMeta &meta,
                                                             const std::vector<ModelBase *> &models_to_backfill_from,
                                                             long long total_rows_affected_by_query,
                                                             const std::string &pk_cpp_name_str,
                                                             const std::type_index &pk_cpp_type,
                                                             const OnConflictClause *active_conflict_clause);

        void callAfterCreateHooks(Session &session, const std::vector<ModelBase *> &successfully_persisted_and_backfilled_models, Error &in_out_first_error_encountered);

    }  // namespace internal_batch_helpers
}  // namespace cpporm

#endif// cpporm/session_priv_batch_helpers_fwd.h
#ifndef cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H
#define cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H

#include <QString>
#include <QVariant>
#include <string>
#include <utility> // For std::pair
#include <vector>
// 前向声明核心类型，避免循环依赖
namespace cpporm {
class Session;
class ModelBase;
struct ModelMeta;
struct Error; // 假设 Error 定义在 error.h 中，并且被广泛包含
struct OnConflictClause;

namespace internal_batch_helpers {
struct BatchSqlParts;   // 在 session_priv_batch_helpers.h 中定义
struct ExecutionResult; // 在 session_priv_batch_helpers.h 中定义

// 声明将成为 Session 友元的函数
std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(
    Session &session, const std::vector<ModelBase *> &models_in_provider_chunk,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache,
    BatchSqlParts &out_sql_parts);

ExecutionResult executeBatchSql(Session &session, const QString &sql_to_execute,
                                const QVariantList &bindings,
                                const std::vector<ModelBase *> &models_in_db_op,
                                const OnConflictClause *active_conflict_clause);

// 其他在 internal_batch_helpers 中定义但在 session_core.h 中不需要友元的函数，
// 则不需要在此处前向声明。
} // namespace internal_batch_helpers
} // namespace cpporm

#endif // cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H#ifndef cpporm_SESSION_TYPES_H
#define cpporm_SESSION_TYPES_H

#include <QString>   // QVariant 依赖 QString
#include <QVariant>  // QueryValue 仍然可以持有 QVariant 支持的类型
#include <map>
#include <string>
#include <typeindex>

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause, QueryValue
#include "sqldriver/sql_value.h"                       // 使用 SqlValue

namespace cpporm {

    class SessionOnConflictUpdateSetter {
      public:
        explicit SessionOnConflictUpdateSetter(OnConflictClause &clause_ref);
        SessionOnConflictUpdateSetter &Set(const std::string &db_column_name, const QueryValue &value);
        SessionOnConflictUpdateSetter &Set(const std::map<std::string, QueryValue> &assignments);

      private:
        OnConflictClause &clause_to_build_;
    };

    // Session 内部用于数据提取的结构体
    namespace internal {
        struct SessionModelDataForWrite {
            // fields_to_write 将从 QVariant 改为 SqlValue
            std::map<std::string, cpporm_sqldriver::SqlValue> fields_to_write;
            // primary_key_fields 也改为 SqlValue
            std::map<std::string, cpporm_sqldriver::SqlValue> primary_key_fields;
            bool has_auto_increment_pk = false;
            std::string auto_increment_pk_name_db;      // 已经是 std::string
            std::string pk_cpp_name_for_autoincrement;  // 已经是 std::string
            std::type_index pk_cpp_type_for_autoincrement = typeid(void);
        };
    }  // namespace internal

    inline SessionOnConflictUpdateSetter::SessionOnConflictUpdateSetter(OnConflictClause &clause_ref) : clause_to_build_(clause_ref) {
        clause_to_build_.action = OnConflictClause::Action::UpdateSpecific;
    }

    inline SessionOnConflictUpdateSetter &SessionOnConflictUpdateSetter::Set(const std::string &db_column_name, const QueryValue &value) {
        clause_to_build_.update_assignments[db_column_name] = value;
        return *this;
    }

    inline SessionOnConflictUpdateSetter &SessionOnConflictUpdateSetter::Set(const std::map<std::string, QueryValue> &assignments) {
        for (const auto &pair : assignments) {
            clause_to_build_.update_assignments[pair.first] = pair.second;
        }
        return *this;
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_TYPES_H// cpporm/builder_parts/query_builder_conditions_qb_overloads.cpp
#include <QDebug>   // For qWarning
#include <QString>  // For getFromSourceName return type

#include "cpporm/builder_parts/query_builder_state.h"  // For SubqueryExpression, Error, QueryValue
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and QueryBuilderConditionsMixin

namespace cpporm {

    // --- Implementations for QueryBuilder's own Where/Or/Not overloads ---
    // These handle QueryBuilder instances as conditions.

    QueryBuilder &QueryBuilder::Where(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;

        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            // Check if both are simple table names or both are same model implied tables
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() &&                       // Current QB uses this table name directly
                std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {  // Sub QB uses this table name directly
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ &&                           // Same model
                       std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&                     // Current QB implies model table
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()  // Sub QB implies model table
            ) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            // Merge conditions directly
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Where(sub_cond_sql, sub_cond_args);
            }
            // If the sub-condition disables soft delete, propagate that
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            // Use EXISTS (subquery)
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Where(const QueryBuilder& sub_qb): Failed "
                              "to convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Where("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Or(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;
        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() && std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) &&
                std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ && std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Or(sub_cond_sql, sub_cond_args);
            }
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Or(const QueryBuilder& sub_qb): Failed to "
                              "convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Or("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Not(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;
        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() && std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) &&
                std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ && std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Not(sub_cond_sql, sub_cond_args);
            }
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Not(const QueryBuilder& sub_qb): Failed to "
                              "convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Not("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    // Overloads for std::expected<SubqueryExpression, Error>
    QueryBuilder &QueryBuilder::Where(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Where("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Where(expected<Subquery>): Subquery "
                          "generation failed: "
                       << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Or(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Or("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Or(expected<Subquery>): Subquery generation failed: " << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Not(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Not("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Not(expected<Subquery>): Subquery generation failed: " << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_core.cpp
#include "cpporm/query_builder_core.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h" // For Session::anyToQueryValueForSessionConvenience

#include <QDebug>
#include <QMetaType>
#include <sstream>
#include <variant>

namespace cpporm {

// Non-template member function definitions for QueryBuilder have been moved to:
// - query_builder_lifecycle.cpp (constructors, destructor, assignments)
// - query_builder_setters_core.cpp (Model, Table, From, With, OnConflict,
// SelectSubquery, QB-specific Where/Or/Not)
// - query_builder_execution_non_template.cpp (First(ModelBase&), Find, Create,
// Updates, Delete, Save, Count)
// - query_builder_utils.cpp (getFromSourceName, AsSubquery, static
// quoteSqlIdentifier, static toQVariant, toSqlDebug)
// - query_builder_helpers.cpp (internal SQL build helpers)

// This file (query_builder_core.cpp) is now primarily for any potential future
// non-template, non-static QueryBuilder methods that don't fit into the above
// categories, or if some specific core logic needed a central, non-header
// definition point. Currently, based on the linker errors, it seems all
// problematic definitions were duplicated from their intended separate files.

} // namespace cpporm// cpporm/builder_parts/query_builder_cte_select_subquery.cpp
#include <QDebug>   // For qWarning
#include <variant>  // For std::visit in WithRaw

#include "cpporm/builder_parts/query_builder_state.h"  // For SubqueryExpression, QueryValue, CTEState, NamedSubqueryField
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and QueryBuilderClausesMixin

namespace cpporm {

    QueryBuilder &QueryBuilder::SelectSubquery(const QueryBuilder &subquery_builder, const std::string &alias) {
        auto sub_expr_expected = subquery_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::SelectSubquery(QueryBuilder): Failed "
                          "to create subquery expression: "
                       << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        // AddSelect is part of QueryBuilderClausesMixin
        this->AddSelect(NamedSubqueryField{std::move(sub_expr_expected.value()), alias});
        return *this;
    }

    QueryBuilder &QueryBuilder::SelectSubquery(const SubqueryExpression &subquery_expr, const std::string &alias) {
        this->AddSelect(NamedSubqueryField{subquery_expr, alias});
        return *this;
    }

    QueryBuilder &QueryBuilder::With(const std::string &cte_name, const QueryBuilder &cte_query_builder, bool recursive) {
        auto sub_expr_expected = cte_query_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::With: Failed to create subquery for CTE '" << QString::fromStdString(cte_name) << "': " << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        state_.ctes_.emplace_back(cte_name, std::move(sub_expr_expected.value()), recursive);
        return *this;
    }

    QueryBuilder &QueryBuilder::WithRaw(const std::string &cte_name, const std::string &raw_sql, const std::vector<QueryValue> &bindings, bool recursive) {
        std::vector<QueryValueVariantForSubquery> native_bindings;
        native_bindings.reserve(bindings.size());
        for (const auto &qv_arg : bindings) {
            std::visit(
                [&native_bindings](auto &&arg_val) {
                    using ArgT = std::decay_t<decltype(arg_val)>;
                    if constexpr (std::is_same_v<ArgT, SubqueryExpression>) {
                        qWarning() << "cpporm QueryBuilder::WithRaw: SubqueryExpression as a "
                                      "binding for raw CTE is complex. Only its bindings are "
                                      "used.";
                        for (const auto &sub_binding : arg_val.bindings) {
                            native_bindings.push_back(sub_binding);
                        }
                    } else if constexpr (std::is_same_v<ArgT, std::nullptr_t> || std::is_same_v<ArgT, int> || std::is_same_v<ArgT, long long> || std::is_same_v<ArgT, double> || std::is_same_v<ArgT, std::string> || std::is_same_v<ArgT, bool> || std::is_same_v<ArgT, QDateTime> ||
                                         std::is_same_v<ArgT, QDate> || std::is_same_v<ArgT, QTime> || std::is_same_v<ArgT, QByteArray>) {
                        native_bindings.push_back(arg_val);
                    } else {
                        qWarning() << "QueryBuilder::WithRaw: Skipping unsupported "
                                      "QueryValue variant type '"
                                   << typeid(ArgT).name() << "' for raw CTE binding.";
                    }
                },
                qv_arg);
        }
        state_.ctes_.emplace_back(cte_name, SubqueryExpression(raw_sql, std::move(native_bindings)), recursive);
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_execution_non_template.cpp
#include "cpporm/i_query_executor.h"    // For IQueryExecutor
#include "cpporm/query_builder_core.h"  // For QueryBuilder definition
#include "cpporm/session.h"             // For Session::anyToQueryValueForSessionConvenience (still valid)
#include "sqldriver/sql_value.h"        // For SqlValue in Create return type

// QDebug, QMetaType, sstream, variant are included via query_builder_core.h or session.h

namespace cpporm {

    Error QueryBuilder::First(ModelBase &result_model) {
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

        const ModelMeta &meta = result_model._getOwnModelMeta();
        if (this->state_.model_meta_ != &meta) {
            this->Model(meta);
        }

        std::map<std::string, QueryValue> pk_conditions;
        bool all_pks_set_in_model = true;
        if (meta.primary_keys_db_names.empty()) {
            all_pks_set_in_model = false;
        } else {
            for (const std::string &pk_db_name : meta.primary_keys_db_names) {
                const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
                if (!pk_field) {
                    all_pks_set_in_model = false;
                    break;
                }
                std::any pk_val_any = result_model.getFieldValue(pk_field->cpp_name);
                if (!pk_val_any.has_value()) {
                    all_pks_set_in_model = false;
                    break;
                }
                // Session::anyToQueryValueForSessionConvenience is still valid for converting model field to QueryValue
                QueryValue qv = Session::anyToQueryValueForSessionConvenience(pk_val_any);

                bool use_this_pk_value = false;
                if (std::holds_alternative<int>(qv) && std::get<int>(qv) != 0)
                    use_this_pk_value = true;
                else if (std::holds_alternative<long long>(qv) && std::get<long long>(qv) != 0)
                    use_this_pk_value = true;
                else if (std::holds_alternative<std::string>(qv) && !std::get<std::string>(qv).empty())
                    use_this_pk_value = true;
                // Add other QueryValue types if they can be PKs and have non-default "empty" states

                if (use_this_pk_value) {
                    pk_conditions[pk_db_name] = qv;
                } else {
                    all_pks_set_in_model = false;
                    break;
                }
            }
        }

        if (all_pks_set_in_model && !pk_conditions.empty()) {
            this->Where(pk_conditions);
        } else {
            if (!meta.primary_keys_db_names.empty() && this->state_.order_clause_.empty()) {
                std::string order_by_pk_clause;
                for (size_t i = 0; i < meta.primary_keys_db_names.size(); ++i) {
                    order_by_pk_clause += quoteSqlIdentifier(  // Uses static QB::quoteSqlIdentifier
                        meta.primary_keys_db_names[i]);
                    if (i < meta.primary_keys_db_names.size() - 1) order_by_pk_clause += ", ";
                }
                if (!order_by_pk_clause.empty()) {
                    this->Order(order_by_pk_clause);  // Calls mixin's Order
                }
            }
        }
        return executor_->FirstImpl(*this, result_model);
    }

    Error QueryBuilder::Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

        if (!this->state_.model_meta_ && element_type_factory) {
            auto temp_instance = element_type_factory();
            if (temp_instance) {
                this->Model(temp_instance->_getOwnModelMeta());
            } else {
                return Error(ErrorCode::InternalError, "Model factory returned nullptr for Find.");
            }
        } else if (!this->state_.model_meta_ && !element_type_factory) {
            return Error(ErrorCode::InvalidConfiguration, "Find requires ModelMeta or an element factory.");
        }

        return executor_->FindImpl(*this, results_vector, element_type_factory);
    }

    // Create 返回 std::expected<SqlValue, Error>
    std::expected<cpporm_sqldriver::SqlValue, Error> QueryBuilder::Create(ModelBase &model, const OnConflictClause *conflict_options_override) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &model._getOwnModelMeta()) {
            this->Model(model._getOwnModelMeta());
        }
        const OnConflictClause *final_conflict_options = conflict_options_override;
        if (!final_conflict_options && this->state_.on_conflict_clause_) {
            final_conflict_options = this->state_.on_conflict_clause_.get();
        }
        return executor_->CreateImpl(*this, model, final_conflict_options);
    }

    std::expected<long long, Error> QueryBuilder::Updates(const std::map<std::string, QueryValue> &updates) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 &&  // index 0 is std::string for table name
                                          std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Updates requires a Model or Table to be set."));
        }
        return executor_->UpdatesImpl(*this, updates);
    }

    std::expected<long long, Error> QueryBuilder::Delete() {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 && std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Delete requires a Model or Table to be set."));
        }
        return executor_->DeleteImpl(*this);
    }

    std::expected<long long, Error> QueryBuilder::Save(ModelBase &model) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &model._getOwnModelMeta()) {
            this->Model(model._getOwnModelMeta());
        }
        return executor_->SaveImpl(*this, model);
    }

    std::expected<int64_t, Error> QueryBuilder::Count() {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 && std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Count requires a Model or Table to be set."));
        }
        return executor_->CountImpl(*this);
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_helpers.cpp
#include <QDebug>
#include <QMetaType>  // For QMetaType::UnknownType
#include <QVariant>
#include <sstream>
#include <variant>  // For std::visit

#include "cpporm/model_base.h"     // For ModelMeta related logic
#include "cpporm/query_builder.h"  // For QueryBuilder class and its members like quoteSqlIdentifier, toQVariant

namespace cpporm {

    void QueryBuilder::build_ctes_sql_prefix(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator) const {
        if (state_.ctes_.empty()) {
            return;
        }
        sql_stream << "WITH ";
        bool has_recursive_cte = false;
        for (const auto &cte_state : state_.ctes_) {
            if (cte_state.recursive) {
                has_recursive_cte = true;
                break;
            }
        }
        if (has_recursive_cte) {
            sql_stream << "RECURSIVE ";
        }
        for (size_t i = 0; i < state_.ctes_.size(); ++i) {
            const auto &cte = state_.ctes_[i];
            sql_stream << quoteSqlIdentifier(cte.name) << " AS (";
            sql_stream << cte.query.sql_string;
            sql_stream << ")";
            for (const auto &binding_variant : cte.query.bindings) {
                std::visit(
                    [&bound_params_accumulator](auto &&arg_val) {
                        using ArgT = std::decay_t<decltype(arg_val)>;
                        if constexpr (std::is_same_v<ArgT, std::nullptr_t>) {
                            bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                        } else if constexpr (std::is_same_v<ArgT, std::string>) {
                            bound_params_accumulator.append(QString::fromStdString(arg_val));
                        } else if constexpr (  // Using QVariant::fromValue for Qt types directly
                            std::is_same_v<ArgT, QDateTime> || std::is_same_v<ArgT, QDate> || std::is_same_v<ArgT, QTime> || std::is_same_v<ArgT, QByteArray> || std::is_same_v<ArgT, bool> || std::is_same_v<ArgT, int> || std::is_same_v<ArgT, long long> || std::is_same_v<ArgT, double>) {
                            bound_params_accumulator.append(QVariant::fromValue(arg_val));
                        } else {
                            qWarning() << "QueryBuilder::build_ctes_sql_prefix: Unhandled "
                                          "native type in CTE binding for QVariant conversion:"
                                       << typeid(ArgT).name();
                        }
                    },
                    binding_variant);
            }
            if (i < state_.ctes_.size() - 1) {
                sql_stream << ", ";
            }
        }
        sql_stream << " ";
    }

    bool QueryBuilder::build_one_condition_block_internal_static_helper(std::ostringstream &to_stream, QVariantList &bindings_acc, const std::vector<Condition> &conditions_group, const std::string &op_within_group, bool is_not_group) {
        if (conditions_group.empty()) {
            return false;
        }
        if (is_not_group) {
            to_stream << "NOT ";
        }
        to_stream << "(";
        for (size_t i = 0; i < conditions_group.size(); ++i) {
            if (i > 0) {
                to_stream << " " << op_within_group << " ";
            }
            const std::string &local_query_string = conditions_group[i].query_string;
            const std::vector<QueryValue> &local_args = conditions_group[i].args;
            std::string::size_type last_pos = 0;
            std::string::size_type find_pos = 0;
            int arg_idx = 0;
            while ((find_pos = local_query_string.find('?', last_pos)) != std::string::npos) {
                to_stream << local_query_string.substr(last_pos, find_pos - last_pos);
                if (arg_idx < static_cast<int>(local_args.size())) {
                    const auto &arg_value = local_args[arg_idx++];
                    QVariant qv_arg = QueryBuilder::toQVariant(arg_value, bindings_acc);  // bindings_acc is passed by ref
                    if (std::holds_alternative<SubqueryExpression>(arg_value)) {
                        to_stream << qv_arg.toString().toStdString();
                    } else {
                        to_stream << "?";
                        // bindings_acc.append(qv_arg); // This is now done inside toQVariant for non-subquery values
                        // or if toQVariant is changed to not append, it should be here.
                        // Given `toQVariant` appends subquery bindings,
                        // for non-subquery, `toQVariant` should just return the QVariant,
                        // and `bindings_acc.append(qv_arg)` should happen here.
                        // Let's assume `toQVariant` only appends for subqueries.
                        if (!std::holds_alternative<SubqueryExpression>(arg_value)) {  // Append only if not subquery
                            bindings_acc.append(qv_arg);
                        }
                    }
                } else {
                    qWarning() << "cpporm: Not enough arguments for placeholders in condition string:" << QString::fromStdString(local_query_string);
                    to_stream << "?";
                }
                last_pos = find_pos + 1;
            }
            to_stream << local_query_string.substr(last_pos);
            if (arg_idx < static_cast<int>(local_args.size())) {
                bool only_subqueries_left = true;
                for (size_t k = arg_idx; k < local_args.size(); ++k) {
                    if (!std::holds_alternative<SubqueryExpression>(local_args[k])) {
                        only_subqueries_left = false;
                        break;
                    }
                }
                if (!only_subqueries_left) {
                    qWarning() << "cpporm: Too many non-subquery arguments for placeholders in condition string:" << QString::fromStdString(local_query_string);
                }
            }
        }
        to_stream << ")";
        return true;
    }

    // In build_condition_logic_internal, the variable main_clause_keyword_written_this_call
    // was indeed assigned but its value was not subsequently used to make a decision.
    // The logic relied more on first_overall_condition_written and prepended_scope_sql.empty().
    // I'll simplify this part.
    void QueryBuilder::build_condition_logic_internal(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator, bool &first_overall_condition_written, const std::string &prepended_scope_sql) const {
        std::ostringstream user_conditions_builder_ss;
        QVariantList user_conditions_bindings_list;
        bool any_user_condition_written_in_this_block = false;

        if (!state_.where_conditions_.empty()) {
            any_user_condition_written_in_this_block = build_one_condition_block_internal_static_helper(user_conditions_builder_ss, user_conditions_bindings_list, state_.where_conditions_, "AND", false) || any_user_condition_written_in_this_block;
        }
        if (!state_.or_conditions_.empty()) {
            if (any_user_condition_written_in_this_block) user_conditions_builder_ss << " OR ";
            any_user_condition_written_in_this_block = build_one_condition_block_internal_static_helper(user_conditions_builder_ss, user_conditions_bindings_list, state_.or_conditions_, "OR", false) || any_user_condition_written_in_this_block;
        }
        if (!state_.not_conditions_.empty()) {
            if (any_user_condition_written_in_this_block) user_conditions_builder_ss << " AND ";
            any_user_condition_written_in_this_block = build_one_condition_block_internal_static_helper(user_conditions_builder_ss, user_conditions_bindings_list, state_.not_conditions_, "AND", true) || any_user_condition_written_in_this_block;
        }

        std::string user_conditions_final_sql = user_conditions_builder_ss.str();
        bool wrote_something_in_this_call = false;

        if (!prepended_scope_sql.empty()) {
            if (first_overall_condition_written) {
                sql_stream << " WHERE ";
                first_overall_condition_written = false;
            } else {
                // Check if sql_stream is not empty and doesn't end with an opening parenthesis or operator
                std::string current_sql_in_stream_str = sql_stream.str();
                if (!current_sql_in_stream_str.empty()) {
                    char last_char = ' ';
                    for (auto it = current_sql_in_stream_str.rbegin(); it != current_sql_in_stream_str.rend(); ++it) {
                        if (*it != ' ') {
                            last_char = *it;
                            break;
                        }
                    }
                    if (last_char != '(') sql_stream << " AND ";
                }
            }
            sql_stream << "(" << prepended_scope_sql << ")";
            wrote_something_in_this_call = true;
        }

        if (!user_conditions_final_sql.empty()) {
            if (first_overall_condition_written) {
                sql_stream << " WHERE ";
                first_overall_condition_written = false;
            } else {
                std::string current_sql_in_stream_str = sql_stream.str();
                if (!current_sql_in_stream_str.empty()) {  // If something was already written (e.g. scope)
                    char last_char = ' ';
                    for (auto it = current_sql_in_stream_str.rbegin(); it != current_sql_in_stream_str.rend(); ++it) {
                        if (*it != ' ') {
                            last_char = *it;
                            break;
                        }
                    }
                    if (last_char != '(') sql_stream << " AND ";
                }
            }
            sql_stream << "(" << user_conditions_final_sql << ")";
            bound_params_accumulator.append(user_conditions_bindings_list);
            // wrote_something_in_this_call = true; // Not strictly needed to track for this variable's original warning.
        }
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_lifecycle.cpp
#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // 构造函数接收 std::string connection_name
    QueryBuilder::QueryBuilder(IQueryExecutor *executor, std::string connection_name, const ModelMeta *model_meta) : executor_(executor), connection_name_(std::move(connection_name)) {
        if (model_meta) {
            this->state_.model_meta_ = model_meta;
            if (!model_meta->table_name.empty()) {
                this->state_.from_clause_source_ = model_meta->table_name;
            }
        }
        // Default select_fields_ is already "*" in QueryBuilderState constructor
    }

    QueryBuilder::QueryBuilder(const QueryBuilder &other) : executor_(other.executor_), connection_name_(other.connection_name_), state_(other.state_) {
    }

    QueryBuilder &QueryBuilder::operator=(const QueryBuilder &other) {
        if (this != &other) {
            this->executor_ = other.executor_;
            this->connection_name_ = other.connection_name_;
            this->state_ = other.state_;
        }
        return *this;
    }

    QueryBuilder::QueryBuilder(QueryBuilder &&other) noexcept : executor_(other.executor_), connection_name_(std::move(other.connection_name_)), state_(std::move(other.state_)) {
        other.executor_ = nullptr;
    }

    QueryBuilder &QueryBuilder::operator=(QueryBuilder &&other) noexcept {
        if (this != &other) {
            this->executor_ = other.executor_;
            this->connection_name_ = std::move(other.connection_name_);
            this->state_ = std::move(other.state_);
            other.executor_ = nullptr;
        }
        return *this;
    }

    QueryBuilder::~QueryBuilder() = default;

}  // namespace cpporm// cpporm/builder_parts/query_builder_model_table_from.cpp
#include <QDebug>  // For qWarning, if used by From(QueryBuilder&)

#include "cpporm/model_base.h"
#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // --- 核心 Model/Table/From 设置器 ---
    QueryBuilder &QueryBuilder::Model(const ModelBase *model_instance_hint) {
        if (model_instance_hint) {
            const ModelMeta &meta = model_instance_hint->_getOwnModelMeta();
            this->state_.model_meta_ = &meta;
            if (!meta.table_name.empty()) {
                this->state_.from_clause_source_ = meta.table_name;
            } else {
                this->state_.from_clause_source_ = std::string("");
            }
        } else {
            this->state_.model_meta_ = nullptr;
            this->state_.from_clause_source_ = std::string("");
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Model(const ModelMeta &meta) {
        this->state_.model_meta_ = &meta;
        if (!meta.table_name.empty()) {
            this->state_.from_clause_source_ = meta.table_name;
        } else {
            this->state_.from_clause_source_ = std::string("");
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Table(std::string table_name) {
        this->state_.from_clause_source_ = std::move(table_name);
        if (this->state_.model_meta_ && this->state_.model_meta_->table_name != std::get<std::string>(this->state_.from_clause_source_)) {
            this->state_.model_meta_ = nullptr;
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::From(std::string source_name_or_cte_alias) {
        // std::string old_from_source_string_if_any; // Not used in current logic
        // if (std::holds_alternative<std::string>(this->state_.from_clause_source_)) {
        //   old_from_source_string_if_any =
        //       std::get<std::string>(this->state_.from_clause_source_);
        // }

        this->state_.from_clause_source_ = std::move(source_name_or_cte_alias);

        if (this->state_.model_meta_) {
            // If the new source is a string (table or CTE alias)
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_)) {
                const std::string &new_from_str = std::get<std::string>(this->state_.from_clause_source_);
                bool is_known_cte = false;
                for (const auto &cte_def : this->state_.ctes_) {
                    if (cte_def.name == new_from_str) {
                        is_known_cte = true;
                        break;
                    }
                }
                // If it's a CTE or the new table name doesn't match the model's table name,
                // then the model context is no longer valid.
                if (is_known_cte || (this->state_.model_meta_->table_name != new_from_str && !new_from_str.empty())) {
                    this->state_.model_meta_ = nullptr;
                }
            } else {  // If the new source is a subquery, model_meta_ is definitely not applicable
                this->state_.model_meta_ = nullptr;
            }
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::From(const QueryBuilder &subquery_builder, const std::string &alias) {
        auto sub_expr_expected = subquery_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::From(QueryBuilder): Failed to create "
                          "subquery expression: "
                       << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        this->state_.from_clause_source_ = SubquerySource{std::move(sub_expr_expected.value()), alias};
        this->state_.model_meta_ = nullptr;  // Setting FROM to a subquery invalidates model context
        return *this;
    }

    QueryBuilder &QueryBuilder::From(const SubqueryExpression &subquery_expr, const std::string &alias) {
        this->state_.from_clause_source_ = SubquerySource{subquery_expr, alias};
        this->state_.model_meta_ = nullptr;  // Setting FROM to a subquery invalidates model context
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_onconflict.cpp
#include <memory>  // For std::make_unique

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and OnConflictUpdateSetter

namespace cpporm {

    QueryBuilder &QueryBuilder::OnConflictUpdateAllExcluded() {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::UpdateAllExcluded;
        state_.on_conflict_clause_->update_assignments.clear();
        state_.on_conflict_clause_->conflict_target_columns_db_names.clear();  // Reset target for this action
        return *this;
    }

    QueryBuilder &QueryBuilder::OnConflictDoNothing() {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
        state_.on_conflict_clause_->update_assignments.clear();
        // For DO NOTHING, conflict_target_columns_db_names can be relevant for PG.
        // If the user wants a general DO NOTHING (e.g. MySQL INSERT IGNORE semantic),
        // they should not set targets. If they want PG "ON CONFLICT (target) DO NOTHING",
        // they'd typically call a method to set the target before or after this.
        // For now, this method doesn't clear the target.
        return *this;
    }

    QueryBuilder &QueryBuilder::OnConflictUpdateSpecific(std::function<void(OnConflictUpdateSetter &)> updater_fn) {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::UpdateSpecific;
        // Conflict target should be set by user if needed for PG before calling this,
        // or through a dedicated method. This method doesn't clear target.
        OnConflictUpdateSetter setter(*state_.on_conflict_clause_);
        updater_fn(setter);
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_delete.cpp
#include <QDebug>   // For qWarning
#include <sstream>  // For std::ostringstream
#include <variant>  // For std::holds_alternative

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h"

namespace cpporm {

    std::pair<QString, QVariantList> QueryBuilder::buildDeleteSQL() const {
        if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            qWarning(
                "cpporm QueryBuilder::buildDeleteSQL: DELETE operation cannot "
                "target a subquery directly.");
            return {QString(), QVariantList()};
        }

        QString table_name_qstr = getFromSourceName();  // Returns QString
        if (table_name_qstr.isEmpty()) {
            qWarning("cpporm QueryBuilder: Table name not set for buildDeleteSQL.");
            return {QString(), QVariantList()};
        }

        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;
        sql_stream << "DELETE FROM " << quoteSqlIdentifier(table_name_qstr.toStdString());

        std::string soft_delete_target_fragment_for_hard_delete;
        // This soft delete logic is for building the WHERE clause for a *hard* delete
        // if soft delete scope is active (i.e., "DELETE FROM table WHERE deleted_at IS NULL AND ...other_conditions...")
        // The actual soft delete (which is an UPDATE) is handled in Session::DeleteImpl.
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
                const std::string &from_name_str = std::get<std::string>(state_.from_clause_source_);
                if ((!from_name_str.empty() && from_name_str == state_.model_meta_->table_name) || (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
                    apply_sd_on_this_from_source = true;
                }
            }
            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_target_fragment_for_hard_delete = quoteSqlIdentifier(state_.model_meta_->table_name) + "." +  // Assuming table name from model meta
                                                                  quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool where_clause_started_by_builder = true;  // True if "WHERE" needs to be written
        build_condition_logic_internal(sql_stream, bound_params_accumulator, where_clause_started_by_builder, soft_delete_target_fragment_for_hard_delete);

        if (where_clause_started_by_builder &&                                    // "WHERE" was not written by build_condition_logic_internal
            soft_delete_target_fragment_for_hard_delete.empty() &&                // and no soft delete fragment
            state_.where_conditions_.empty() && state_.or_conditions_.empty() &&  // and no user conditions
            state_.not_conditions_.empty()) {
            qWarning() << "cpporm QueryBuilder::buildDeleteSQL: Generating DELETE "
                          "statement without a WHERE clause for table "
                       << table_name_qstr  // This is QString
                       << ". This will affect ALL rows if not intended.";
        }
        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_insert.cpp
#include <QDebug>     // For qWarning
#include <algorithm>  // For std::tolower in string comparison (if needed for driver name)
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::holds_alternative in QueryBuilder::toQVariant

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta for OnConflictUpdateAllExcluded
#include "cpporm/query_builder.h"

namespace cpporm {

    // Helper (already defined in query_builder_sql_select.cpp, ideally should be in a common util or QueryBuilder itself if static)
    // For now, let's assume it's accessible or re-define locally if necessary.
    // bool string_contains_ci(const std::string& text, const std::string& pattern); // Declaration

    // This is the SOLE definition of buildInsertSQLSuffix
    std::pair<QString, QVariantList> QueryBuilder::buildInsertSQLSuffix(const std::vector<std::string> &inserted_columns_db_names_for_values_clause) const {
        std::ostringstream sql_suffix_stream;
        QVariantList suffix_bindings_accumulator;

        if (!state_.on_conflict_clause_) {
            return {QString(), QVariantList()};
        }

        std::string driver_name_upper_std;                       // Store as std::string
        const std::string &conn_name_std = getConnectionName();  // std::string

        // Simplified driver detection based on connection name content
        // This is a basic heuristic and might need refinement for robustness.
        auto to_upper_std_string = [](std::string s) {
            std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {
                return std::toupper(c);
            });
            return s;
        };

        // Check based on common substrings in connection_name (heuristic)
        // Or, ideally, Session would pass a hint or the driver itself would be queried.
        // For now, sticking to the string contains logic for simplicity.
        if (string_contains_ci(conn_name_std, "psql") || string_contains_ci(conn_name_std, "postgres")) {
            driver_name_upper_std = "QPSQL";  // Using Qt-like names as placeholders for logic
        } else if (string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb")) {
            driver_name_upper_std = "QMYSQL";
        } else if (string_contains_ci(conn_name_std, "sqlite")) {
            driver_name_upper_std = "QSQLITE";
        }
        // Add other dialects if needed

        if (driver_name_upper_std.empty()) {
            // Fallback if connection_name_ doesn't give a hint.
            // qWarning() << "QueryBuilder::buildInsertSQLSuffix: Could not reliably determine SQL dialect from connection name '"
            //            << QString::fromStdString(conn_name_std) << "'. Defaulting to MySQL-like syntax for suffix.";
            driver_name_upper_std = "QMYSQL";  // Default to MySQL behavior if unknown
        }

        if (state_.on_conflict_clause_->action == OnConflictClause::Action::DoNothing) {
            if (driver_name_upper_std == "QMYSQL") {  // MySQL, MariaDB
                // MySQL uses "INSERT IGNORE", which is typically handled by modifying the main "INSERT" verb,
                // not by a suffix. So, this suffix part should be empty for "DoNothing" on MySQL.
                // The caller (Session::CreateImpl or Session's batch create) should adjust "INSERT" to "INSERT IGNORE".
                return {QString(), QVariantList()};
            } else if (driver_name_upper_std == "QPSQL") {  // PostgreSQL
                sql_suffix_stream << " ON CONFLICT";
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < state_.on_conflict_clause_->conflict_target_columns_db_names.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(state_.on_conflict_clause_->conflict_target_columns_db_names[i]);
                        if (i < state_.on_conflict_clause_->conflict_target_columns_db_names.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }
                // If no specific target columns, PG might require ON CONSTRAINT name.
                // GORM often requires specifying a target for PG ON CONFLICT DO NOTHING.
                // For simplicity, if no target, assume general DO NOTHING (might fail on some PG setups without target/constraint).
                sql_suffix_stream << " DO NOTHING";
            } else if (driver_name_upper_std == "QSQLITE") {  // SQLite
                // SQLite uses "INSERT OR IGNORE" or "ON CONFLICT DO NOTHING"
                // "INSERT OR IGNORE" is a verb modification.
                // "ON CONFLICT ... DO NOTHING" is a suffix.
                // Let's assume Session will handle "INSERT OR IGNORE". If suffix is desired:
                sql_suffix_stream << " ON CONFLICT";
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < state_.on_conflict_clause_->conflict_target_columns_db_names.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(state_.on_conflict_clause_->conflict_target_columns_db_names[i]);
                        if (i < state_.on_conflict_clause_->conflict_target_columns_db_names.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }
                sql_suffix_stream << " DO NOTHING";
            }
            // Other dialects might have different syntaxes or no direct "DO NOTHING" via suffix.
        } else if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded || state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific) {
            bool first_update_col = true;
            if (driver_name_upper_std == "QMYSQL") {  // MySQL, MariaDB
                sql_suffix_stream << " ON DUPLICATE KEY UPDATE ";
            } else if (driver_name_upper_std == "QPSQL") {  // PostgreSQL
                sql_suffix_stream << " ON CONFLICT ";
                std::vector<std::string> pg_conflict_targets;
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    pg_conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names;
                } else if (state_.model_meta_ && !state_.model_meta_->primary_keys_db_names.empty()) {
                    pg_conflict_targets = state_.model_meta_->primary_keys_db_names;
                }

                if (!pg_conflict_targets.empty()) {
                    sql_suffix_stream << "(";
                    for (size_t i = 0; i < pg_conflict_targets.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(pg_conflict_targets[i]);
                        if (i < pg_conflict_targets.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ") ";
                } else {
                    qWarning(
                        "cpporm QueryBuilder: For PostgreSQL ON CONFLICT DO UPDATE, "
                        "conflict target (columns or PK) must be defined.");
                    return {QString(), QVariantList()};  // Error condition
                }
                sql_suffix_stream << "DO UPDATE SET ";
            } else if (driver_name_upper_std == "QSQLITE") {  // SQLite
                sql_suffix_stream << " ON CONFLICT";
                // SQLite needs conflict target for DO UPDATE similar to PG
                std::vector<std::string> sqlite_conflict_targets;
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sqlite_conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names;
                } else if (state_.model_meta_ && !state_.model_meta_->primary_keys_db_names.empty()) {
                    sqlite_conflict_targets = state_.model_meta_->primary_keys_db_names;
                }
                if (!sqlite_conflict_targets.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < sqlite_conflict_targets.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(sqlite_conflict_targets[i]);
                        if (i < sqlite_conflict_targets.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }  // SQLite can also infer from PK/UNIQUE constraints if target omitted
                sql_suffix_stream << " DO UPDATE SET ";
            } else {  // Fallback for other/unknown drivers
                qWarning() << "QueryBuilder::buildInsertSQLSuffix: ON CONFLICT UPDATE behavior for driver '" << QString::fromStdString(driver_name_upper_std) << "' is not specifically handled. Defaulting to MySQL-like 'ON DUPLICATE KEY UPDATE'.";
                sql_suffix_stream << " ON DUPLICATE KEY UPDATE ";
            }

            if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded) {
                if (inserted_columns_db_names_for_values_clause.empty() && driver_name_upper_std != "QPSQL" && driver_name_upper_std != "QSQLITE" /*PG/SQLite can use EXCLUDED/excluded even with empty insert list with DEFAULT VALUES*/) {
                    qWarning(
                        "cpporm QueryBuilder: OnConflictUpdateAllExcluded specified for non-PG/non-SQLite, "
                        "but no columns provided from INSERT part to determine VALUES() updates.");
                }
                for (const std::string &db_col_name : inserted_columns_db_names_for_values_clause) {
                    bool skip_this_column_in_set = false;
                    // Skip updating PKs or conflict target columns themselves in the SET clause
                    if (state_.model_meta_) {
                        const auto &conflict_targets_to_check = (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE")
                                                                    ? (state_.on_conflict_clause_->conflict_target_columns_db_names.empty() ? state_.model_meta_->primary_keys_db_names : state_.on_conflict_clause_->conflict_target_columns_db_names)
                                                                    : state_.model_meta_->primary_keys_db_names;  // For MySQL, skip PKs

                        for (const auto &key_col_name : conflict_targets_to_check) {
                            if (key_col_name == db_col_name) {
                                skip_this_column_in_set = true;
                                break;
                            }
                        }
                        // MySQL also skips PKs if not already caught by conflict_targets_to_check
                        if (driver_name_upper_std == "QMYSQL" && !skip_this_column_in_set) {
                            for (const auto &pk_name : state_.model_meta_->primary_keys_db_names) {
                                if (pk_name == db_col_name) {
                                    skip_this_column_in_set = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (skip_this_column_in_set) continue;

                    if (!first_update_col) sql_suffix_stream << ", ";
                    sql_suffix_stream << quoteSqlIdentifier(db_col_name) << " = ";

                    if (driver_name_upper_std == "QMYSQL") {
                        sql_suffix_stream << "VALUES(" << quoteSqlIdentifier(db_col_name) << ")";
                    } else if (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") {
                        sql_suffix_stream << "excluded." << quoteSqlIdentifier(db_col_name);
                    } else {                       // Fallback for other drivers
                        sql_suffix_stream << "?";  // This would require the value to be bound, which is not typical for UpdateAllExcluded
                        qWarning(
                            "QueryBuilder::buildInsertSQLSuffix: UpdateAllExcluded for driver '%s' "
                            "might need specific value passing or is not fully supported by this generic builder. Using '?' for column '%s'.",
                            driver_name_upper_std.c_str(),
                            db_col_name.c_str());
                    }
                    first_update_col = false;
                }
                if (first_update_col && !inserted_columns_db_names_for_values_clause.empty()) {
                    qWarning("cpporm QueryBuilder: OnConflictUpdateAllExcluded resulted in empty SET clause. SQL might be invalid.");
                }
            } else if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific) {
                if (state_.on_conflict_clause_->update_assignments.empty()) {
                    qWarning("cpporm QueryBuilder: OnConflictUpdateSpecific specified, but no update assignments provided.");
                }
                for (const auto &assign_pair : state_.on_conflict_clause_->update_assignments) {
                    // For PG/SQLite, ensure the column being SET is not part of the conflict target itself
                    if ((driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") && state_.model_meta_) {
                        const auto &conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names.empty() ? state_.model_meta_->primary_keys_db_names : state_.on_conflict_clause_->conflict_target_columns_db_names;
                        bool is_conflict_target_col = false;
                        for (const auto &ct_col : conflict_targets) {
                            if (ct_col == assign_pair.first) {
                                is_conflict_target_col = true;
                                break;
                            }
                        }
                        if (is_conflict_target_col) {
                            qWarning() << "QueryBuilder::buildInsertSQLSuffix (" << QString::fromStdString(driver_name_upper_std) << "): Column '" << QString::fromStdString(assign_pair.first) << "' is part of the conflict target and cannot be in the SET clause of ON CONFLICT DO UPDATE. Skipping.";
                            continue;
                        }
                    }

                    if (!first_update_col) sql_suffix_stream << ", ";
                    sql_suffix_stream << quoteSqlIdentifier(assign_pair.first) << " = ";

                    if (std::holds_alternative<SubqueryExpression>(assign_pair.second)) {
                        // toQVariant is static, appends subquery bindings to suffix_bindings_accumulator
                        sql_suffix_stream << QueryBuilder::toQVariant(assign_pair.second, suffix_bindings_accumulator).toString().toStdString();  // Injects "(subquery_sql)"
                    } else {
                        sql_suffix_stream << "?";
                        // toQVariant here just converts the value, does not add to accumulator.
                        // The accumulator is for subquery bindings within the expression.
                        // Regular values are added here.
                        suffix_bindings_accumulator.append(QueryBuilder::toQVariant(assign_pair.second, suffix_bindings_accumulator));
                    }
                    first_update_col = false;
                }
            }

            if (first_update_col &&  // No assignments were actually made
                (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded ||
                 (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific && !state_.on_conflict_clause_->update_assignments.empty() /* only if user provided assignments but all were skipped */))) {
                qWarning(
                    "cpporm QueryBuilder::buildInsertSQLSuffix: Resulted in an ON CONFLICT UPDATE clause "
                    "with no actual assignments. SQL may be invalid or action ineffective.");
                // Depending on DB, an empty SET might be an error or a no-op.
                // For safety, we might return an empty suffix to indicate this problematic state.
                // For now, let it pass, but this is a strong indicator of potential issues.
                // If driver_name_upper_std is PG or SQLite, an empty SET is usually an error.
                if (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") {
                    return {QString(), QVariantList()};  // Return empty to signal failure for PG/SQLite
                }
            }
        }

        return {QString::fromStdString(sql_suffix_stream.str()), suffix_bindings_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_select.cpp
#include <QDebug>     // For qWarning, qInfo
#include <QMetaType>  // For QMetaType::UnknownType
#include <algorithm>  // For std::tolower in string comparison
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::visit

#include "cpporm/model_base.h"     // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h"  // Includes QueryBuilderState via query_builder.h -> query_builder_core.h -> ..._state.h

namespace cpporm {

    std::pair<QString, QVariantList> QueryBuilder::buildSelectSQL(bool for_subquery_generation) const {
        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;  // QueryBuilder still accumulates QVariant bindings internally

        build_ctes_sql_prefix(sql_stream, bound_params_accumulator);

        sql_stream << "SELECT ";
        if (state_.apply_distinct_) {
            sql_stream << "DISTINCT ";
        }

        const std::string &conn_name_std = this->getConnectionName();  // Now std::string

        auto get_field_select_expression = [&conn_name_std, this](const FieldMeta &fm) -> std::string {  // Capture conn_name_std
            // Use helper for case-insensitive check
            bool is_mysql = string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb");

            if (is_mysql) {
                if (fm.db_type_hint == "POINT") {
                    return "ST_AsText(" + quoteSqlIdentifier(fm.db_name) + ") AS " + quoteSqlIdentifier(fm.db_name);
                } else if (fm.db_type_hint == "JSON") {
                    // For MySQL JSON, casting to CHAR might be needed for some clients/drivers
                    // if they don't handle JSON type directly from C++ side.
                    // This was likely for QSql which might treat JSON as string.
                    // SqlDriver might handle JSON better, but keeping the cast for now if it was intentional.
                    return "CAST(" + quoteSqlIdentifier(fm.db_name) + " AS CHAR) AS " + quoteSqlIdentifier(fm.db_name);
                }
            }
            // For other drivers or default case
            return quoteSqlIdentifier(fm.db_name);
        };

        if (state_.select_fields_.empty() || (state_.select_fields_.size() == 1 && std::holds_alternative<std::string>(state_.select_fields_[0]) && std::get<std::string>(state_.select_fields_[0]) == "*")) {
            if (state_.model_meta_) {
                bool first_col = true;
                for (const auto &field_meta_obj : state_.model_meta_->fields) {  // Renamed for clarity
                    if (has_flag(field_meta_obj.flags, FieldFlag::Association) || field_meta_obj.db_name.empty()) {
                        continue;
                    }
                    if (!first_col) {
                        sql_stream << ", ";
                    }
                    sql_stream << get_field_select_expression(field_meta_obj);
                    first_col = false;
                }
                if (first_col) {  // No fields were selected from model_meta
                    sql_stream << "*";
                    qWarning(
                        "cpporm QueryBuilder::buildSelectSQL: SELECT * expanded to "
                        "no columns for model %s, falling back to literal '*'.",
                        state_.model_meta_->table_name.c_str());
                }
            } else {
                sql_stream << "*";  // No model_meta, so select literal "*"
            }
        } else {  // Specific fields or subqueries selected
            for (size_t i = 0; i < state_.select_fields_.size(); ++i) {
                std::visit(
                    [&sql_stream, &bound_params_accumulator, this](auto &&arg) {  // `this` needed for quoteSqlIdentifier
                        using T = std::decay_t<decltype(arg)>;
                        if constexpr (std::is_same_v<T, std::string>) {
                            sql_stream << arg;  // Assumes string is already quoted or is an expression
                        } else if constexpr (std::is_same_v<T, NamedSubqueryField>) {
                            sql_stream << "(" << arg.subquery.sql_string << ") AS " << quoteSqlIdentifier(arg.alias);  // quoteSqlIdentifier is static
                            // Bindings for subquery in SELECT list are QueryValueVariantForSubquery
                            for (const auto &sub_binding_variant : arg.subquery.bindings) {
                                std::visit(
                                    [&bound_params_accumulator](auto &&sub_val) {
                                        using SubVT = std::decay_t<decltype(sub_val)>;
                                        if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                            bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                        } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                            bound_params_accumulator.append(QString::fromStdString(sub_val));
                                        } else if constexpr (std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray> || std::is_same_v<SubVT, bool> || std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> ||
                                                             std::is_same_v<SubVT, double>) {
                                            bound_params_accumulator.append(QVariant::fromValue(sub_val));
                                        } else {
                                            qWarning() << "buildSelectSQL (SelectField): Unhandled "
                                                          "native type in NamedSubqueryField "
                                                          "binding during QVariant conversion for subquery in SELECT.";
                                        }
                                    },
                                    sub_binding_variant);
                            }
                        }
                    },
                    state_.select_fields_[i]);
                if (i < state_.select_fields_.size() - 1) {
                    sql_stream << ", ";
                }
            }
        }

        sql_stream << " FROM ";
        std::visit(
            [&sql_stream, &bound_params_accumulator, this](auto &&arg) {  // `this` needed for getFromSourceName and quoteSqlIdentifier
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::string>) {           // Table name
                    QString table_name_qstr = this->getFromSourceName();  // Returns QString
                    if (table_name_qstr.isEmpty()) {
                        qWarning(
                            "cpporm QueryBuilder: Table name is empty for "
                            "buildSelectSQL FROM clause.");
                        sql_stream << "__MISSING_TABLE_NAME_IN_FROM__";  // Placeholder for error
                    } else {
                        sql_stream << quoteSqlIdentifier(table_name_qstr.toStdString());
                    }
                } else if constexpr (std::is_same_v<T, SubquerySource>) {  // Subquery as source
                    sql_stream << "(" << arg.subquery.sql_string << ") AS " << quoteSqlIdentifier(arg.alias);
                    for (const auto &sub_binding_variant : arg.subquery.bindings) {
                        std::visit(
                            [&bound_params_accumulator](auto &&sub_val) {
                                using SubVT = std::decay_t<decltype(sub_val)>;
                                if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                    bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                    bound_params_accumulator.append(QString::fromStdString(sub_val));
                                } else if constexpr (std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray> || std::is_same_v<SubVT, bool> || std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> ||
                                                     std::is_same_v<SubVT, double>) {
                                    bound_params_accumulator.append(QVariant::fromValue(sub_val));
                                } else {
                                    qWarning() << "buildSelectSQL (FromClauseSource): "
                                                  "Unhandled native type in SubquerySource "
                                                  "binding during QVariant conversion for FROM subquery.";
                                }
                            },
                            sub_binding_variant);
                    }
                }
            },
            state_.from_clause_source_);

        for (const auto &join : state_.join_clauses_) {
            if (!join.join_type.empty() && !join.table_to_join.empty() && !join.on_condition.empty()) {
                sql_stream << " " << join.join_type << " JOIN " << quoteSqlIdentifier(join.table_to_join) << " ON " << join.on_condition;
            } else if (!join.on_condition.empty()) {  // Raw join fragment
                sql_stream << " " << join.on_condition;
            } else {
                qWarning() << "cpporm QueryBuilder: Invalid join clause for source " << getFromSourceName()  // Returns QString
                           << " (type: " << QString::fromStdString(join.join_type) << ", table: " << QString::fromStdString(join.table_to_join) << ").";
            }
        }

        std::string soft_delete_sql_fragment;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            QString current_from_qstr = this->getFromSourceName();  // Returns QString
            if (!current_from_qstr.isEmpty() && state_.model_meta_->table_name == current_from_qstr.toStdString()) {
                apply_sd_on_this_from_source = true;
            }

            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_sql_fragment = quoteSqlIdentifier(state_.model_meta_->table_name) + "." + quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool first_condition_written_flag = true;  // True if "WHERE" needs to be written
        build_condition_logic_internal(sql_stream, bound_params_accumulator, first_condition_written_flag, soft_delete_sql_fragment);

        if (!state_.group_clause_.empty()) {
            sql_stream << " GROUP BY " << state_.group_clause_;
            if (state_.having_condition_) {  // Check if having_condition_ unique_ptr is set
                sql_stream << " HAVING ";
                const std::string &having_query_str = state_.having_condition_->query_string;
                const std::vector<QueryValue> &having_args = state_.having_condition_->args;

                std::string::size_type last_pos_having = 0, find_pos_having = 0;
                int arg_idx_having = 0;
                while ((find_pos_having = having_query_str.find('?', last_pos_having)) != std::string::npos) {
                    sql_stream << having_query_str.substr(last_pos_having, find_pos_having - last_pos_having);
                    if (arg_idx_having < static_cast<int>(having_args.size())) {
                        const auto &arg_val_having = having_args[arg_idx_having++];
                        // toQVariant is static and handles SubqueryExpression by adding its bindings to accumulator
                        QVariant qv_arg_having = QueryBuilder::toQVariant(arg_val_having, bound_params_accumulator);
                        if (std::holds_alternative<SubqueryExpression>(arg_val_having)) {
                            sql_stream << qv_arg_having.toString().toStdString();  // Injects "(subquery_sql)"
                        } else {
                            sql_stream << "?";  // Placeholder for regular value
                        }
                    } else {
                        sql_stream << "?";
                        qWarning() << "cpporm: Not enough arguments for placeholders in "
                                      "HAVING clause: "
                                   << QString::fromStdString(having_query_str);
                    }
                    last_pos_having = find_pos_having + 1;
                }
                sql_stream << having_query_str.substr(last_pos_having);
                if (arg_idx_having < static_cast<int>(having_args.size())) {
                    bool only_subqueries_left_having = true;
                    for (size_t k_having = arg_idx_having; k_having < having_args.size(); ++k_having) {
                        if (!std::holds_alternative<SubqueryExpression>(having_args[k_having])) {
                            only_subqueries_left_having = false;
                            break;
                        }
                    }
                    if (!only_subqueries_left_having) {
                        qWarning() << "cpporm: Too many non-subquery arguments for "
                                      "placeholders in HAVING clause: "
                                   << QString::fromStdString(having_query_str);
                    }
                }
            }
        }

        if (!state_.order_clause_.empty()) {
            sql_stream << " ORDER BY " << state_.order_clause_;
        }

        // LIMIT and OFFSET are not applied if for_subquery_generation is true
        if (!for_subquery_generation) {
            if (state_.limit_val_ > 0) {
                sql_stream << " LIMIT ?";
                bound_params_accumulator.append(QVariant::fromValue(state_.limit_val_));  // Use QVariant::fromValue for clarity
                if (state_.offset_val_ >= 0) {                                            // Only add OFFSET if limit is also present and offset is valid
                    sql_stream << " OFFSET ?";
                    bound_params_accumulator.append(QVariant::fromValue(state_.offset_val_));
                }
            } else if (state_.offset_val_ >= 0) {  // OFFSET without LIMIT (some DBs need a large LIMIT)
                // const std::string& connNameStd = getConnectionName(); // Already fetched
                if (string_contains_ci(conn_name_std, "mysql")) {
                    sql_stream << " LIMIT 18446744073709551615";  // MySQL's max rows
                }
                sql_stream << " OFFSET ?";
                bound_params_accumulator.append(QVariant::fromValue(state_.offset_val_));
                if (!string_contains_ci(conn_name_std, "mysql") && !string_contains_ci(conn_name_std, "sqlite")) {
                    // This warning is fine, just for developer awareness
                    qInfo(
                        "cpporm QueryBuilder: OFFSET without LIMIT is used for driver '%s'. "
                        "Behavior might vary. MySQL and SQLite effectively add a large LIMIT.",
                        conn_name_std.c_str());
                }
            }
        }
        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_update.cpp
#include <QDebug>     // For qWarning
#include <algorithm>  // For std::tolower in string comparison
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::holds_alternative

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta, FieldFlag (indirectly for ST_GeomFromText logic)
#include "cpporm/query_builder.h"

namespace cpporm {

    // Helper (already defined in query_builder_sql_select.cpp, ideally should be in a common util or QueryBuilder itself if static)
    // bool string_contains_ci(const std::string& text, const std::string& pattern); // Declaration

    std::pair<QString, QVariantList> QueryBuilder::buildUpdateSQL(const std::map<std::string, QueryValue> &updates) const {
        if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            qWarning(
                "cpporm QueryBuilder::buildUpdateSQL: UPDATE operation cannot "
                "target a subquery directly.");
            return {QString(), QVariantList()};
        }

        QString table_name_qstr = getFromSourceName();  // Returns QString
        if (table_name_qstr.isEmpty()) {
            qWarning("cpporm QueryBuilder: Table name not set for buildUpdateSQL.");
            return {QString(), QVariantList()};
        }

        if (updates.empty()) {
            qWarning("cpporm QueryBuilder: No update values provided for table %s.", table_name_qstr.toStdString().c_str());
            return {QString(), QVariantList()};
        }

        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;

        sql_stream << "UPDATE " << quoteSqlIdentifier(table_name_qstr.toStdString()) << " SET ";

        std::string driver_name_upper_std;
        const std::string &conn_name_std = getConnectionName();  // std::string

        if (string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb")) {
            driver_name_upper_std = "QMYSQL";
        } else if (string_contains_ci(conn_name_std, "psql") || string_contains_ci(conn_name_std, "postgres")) {
            driver_name_upper_std = "QPSQL";
        } else if (string_contains_ci(conn_name_std, "sqlite")) {
            driver_name_upper_std = "QSQLITE";
        }
        // driver_name_upper_std might remain empty if no match

        bool first_set_col = true;
        for (const auto &pair : updates) {
            if (!first_set_col) {
                sql_stream << ", ";
            }
            sql_stream << quoteSqlIdentifier(pair.first) << " = ";

            if (std::holds_alternative<SubqueryExpression>(pair.second)) {
                // toQVariant is static, appends subquery bindings to bound_params_accumulator
                sql_stream << QueryBuilder::toQVariant(pair.second, bound_params_accumulator).toString().toStdString();  // Injects "(subquery_sql)"
            } else {
                bool use_st_geom_from_text = false;
                if (state_.model_meta_ && (driver_name_upper_std == "QMYSQL" /*|| driver_name_upper_std == "QMARIADB" - covered by QMYSQL logic*/)) {
                    const FieldMeta *fm = state_.model_meta_->findFieldByDbName(pair.first);
                    if (fm && (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" || fm->db_type_hint == "LINESTRING" || fm->db_type_hint == "POLYGON" || fm->db_type_hint == "MULTIPOINT" || fm->db_type_hint == "MULTILINESTRING" || fm->db_type_hint == "MULTIPOLYGON" ||
                               fm->db_type_hint == "GEOMETRYCOLLECTION")) {
                        use_st_geom_from_text = true;
                    }
                }
                // Similar logic for PostgreSQL with ST_GeomFromEWKT or ::geometry might be needed
                // if PostGIS is used and types are WKT strings.
                // For SQLite with SpatiaLite, it would be GeomFromText() or similar.

                if (use_st_geom_from_text) {
                    sql_stream << "ST_GeomFromText(?)";
                } else {
                    sql_stream << "?";
                }
                // Regular value, convert to QVariant and add to accumulator
                // toQVariant here does not add to accumulator, it just converts.
                bound_params_accumulator.append(QueryBuilder::toQVariant(pair.second, bound_params_accumulator));
            }
            first_set_col = false;
        }

        std::string soft_delete_where_fragment;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
                const std::string &from_name_str = std::get<std::string>(state_.from_clause_source_);
                if ((!from_name_str.empty() && from_name_str == state_.model_meta_->table_name) || (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
                    apply_sd_on_this_from_source = true;
                }
            }
            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_where_fragment = quoteSqlIdentifier(state_.model_meta_->table_name) + "." + quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool where_clause_started_by_builder = true;  // True if "WHERE" needs to be written by build_condition_logic_internal
        build_condition_logic_internal(sql_stream, bound_params_accumulator, where_clause_started_by_builder, soft_delete_where_fragment);

        if (where_clause_started_by_builder && soft_delete_where_fragment.empty() && state_.where_conditions_.empty() && state_.or_conditions_.empty() && state_.not_conditions_.empty()) {
            qWarning() << "cpporm QueryBuilder::buildUpdateSQL: Generating UPDATE "
                          "statement without a WHERE clause for table "
                       << table_name_qstr  // This is still QString
                       << ". This will affect ALL rows if not intended.";
        }

        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_state.cpp
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/query_builder.h" // For QueryBuilder::quoteSqlIdentifier

namespace cpporm {

// Definition for the free function mapToConditions
std::vector<Condition>
mapToConditions(const std::map<std::string, QueryValue> &condition_map) {
  std::vector<Condition> conditions_vec;
  conditions_vec.reserve(condition_map.size());
  for (const auto &pair : condition_map) {
    // For map conditions, the key is the column name, and the value is its
    // target. The query string becomes "column_name = ?" If the value is a
    // SubqueryExpression, it will be handled by build_condition_logic_internal
    // when QueryBuilder::toQVariant is called for the argument.
    // Here, we just construct the "column = ?" part.
    conditions_vec.emplace_back(QueryBuilder::quoteSqlIdentifier(pair.first) +
                                    " = ?",
                                std::vector<QueryValue>{pair.second});
  }
  return conditions_vec;
}

} // namespace cpporm// cpporm/builder_parts/query_builder_utils.cpp
#include <QDebug>
#include <QMetaType>  // For QMetaType in AsSubquery and toQVariant
#include <QVariant>   // For QVariant
#include <sstream>    // For std::ostringstream in buildConditionClauseGroup
#include <variant>    // For std::visit on QueryValue

#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // getFromSourceName 返回 QString，这依赖于 connection_name_ (std::string) 的转换。
    // 如果 QueryBuilder 要完全摆脱 QString，这里需要返回 std::string。
    // 目前 QueryBuilder 仍使用 QVariantList，所以 QString 可能仍然方便。
    QString QueryBuilder::getFromSourceName() const {
        if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
            const std::string &table_name_str = std::get<std::string>(state_.from_clause_source_);
            if (!table_name_str.empty()) {
                return QString::fromStdString(table_name_str);
            }
            if (state_.model_meta_ && !state_.model_meta_->table_name.empty()) {
                return QString::fromStdString(state_.model_meta_->table_name);
            }
        } else if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            return QString::fromStdString(std::get<SubquerySource>(state_.from_clause_source_).alias);
        }
        return QString();
    }

    std::expected<SubqueryExpression, Error> QueryBuilder::AsSubquery() const {
        auto [qsql_string, qvariant_bindings] = buildSelectSQL(true);
        if (qsql_string.isEmpty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for subquery."));
        }
        std::vector<QueryValueVariantForSubquery> subquery_native_bindings;
        subquery_native_bindings.reserve(qvariant_bindings.size());

        for (const QVariant &qv : qvariant_bindings) {
            if (qv.isNull() || !qv.isValid()) {
                subquery_native_bindings.push_back(nullptr);
            } else {
                QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
                type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

                if (type_id_val == QMetaType::UnknownType && qv.userType() != QMetaType::UnknownType) {
                    type_id_val = static_cast<QMetaType::Type>(qv.userType());
                }

                if (type_id_val == QMetaType::Int) {
                    subquery_native_bindings.push_back(qv.toInt());
                } else if (type_id_val == QMetaType::LongLong || type_id_val == QMetaType::ULongLong) {
                    subquery_native_bindings.push_back(qv.toLongLong());
                } else if (type_id_val == QMetaType::Double) {
                    subquery_native_bindings.push_back(qv.toDouble());
                } else if (type_id_val == QMetaType::QString) {
                    subquery_native_bindings.push_back(qv.toString().toStdString());
                } else if (type_id_val == QMetaType::Bool) {
                    subquery_native_bindings.push_back(qv.toBool());
                } else if (type_id_val == QMetaType::QDateTime) {
                    subquery_native_bindings.push_back(qv.toDateTime());
                } else if (type_id_val == QMetaType::QDate) {
                    subquery_native_bindings.push_back(qv.toDate());
                } else if (type_id_val == QMetaType::QTime) {
                    subquery_native_bindings.push_back(qv.toTime());
                } else if (type_id_val == QMetaType::QByteArray) {
                    subquery_native_bindings.push_back(qv.toByteArray());
                } else {
                    qWarning() << "cpporm QueryBuilder::AsSubquery: Unhandled QVariant typeId " << static_cast<int>(type_id_val) << " (" << qv.typeName() << ") for native conversion into SubqueryExpression bindings.";
                    return std::unexpected(Error(ErrorCode::MappingError, "Unhandled QVariant type in AsSubquery bindings conversion: " + std::string(qv.typeName())));
                }
            }
        }
        return SubqueryExpression(qsql_string.toStdString(), subquery_native_bindings);
    }

    std::string QueryBuilder::quoteSqlIdentifier(const std::string &identifier) {
        if (identifier.empty()) return "";
        if (identifier == "*" || identifier.find('(') != std::string::npos || identifier.find(')') != std::string::npos || (identifier.front() == '`' && identifier.back() == '`') || (identifier.front() == '"' && identifier.back() == '"')) {
            return identifier;
        }

        char quote_char = '`';  // Default to MySQL/MariaDB style
        // TODO: Potentially use connection_name_ to determine quote style per driver
        // For example, PostgreSQL uses double quotes:
        // if (this->connection_name_.find("psql") != std::string::npos || this->connection_name_.find("postgres") != std::string::npos) {
        //     quote_char = '"';
        // }
        // For now, sticking to backticks as per original.

        std::string result;
        size_t start_pos = 0;
        std::string temp_identifier = identifier;  // Work with a copy for find/substr

        // Handle dot-separated identifiers (e.g., "schema.table.column")
        size_t dot_pos;
        while ((dot_pos = temp_identifier.find('.', start_pos)) != std::string::npos) {
            std::string part = temp_identifier.substr(start_pos, dot_pos - start_pos);
            if (part != "*") {  // Don't quote '*' in "table.*"
                result += quote_char + part + quote_char;
            } else {
                result += part;
            }
            result += ".";
            start_pos = dot_pos + 1;
        }
        // Quote the last part (or the only part if no dots)
        std::string last_part = temp_identifier.substr(start_pos);
        if (last_part != "*") {
            result += quote_char + last_part + quote_char;
        } else {
            result += last_part;
        }
        return result;
    }

    QVariant QueryBuilder::toQVariant(const QueryValue &qv, QVariantList &subquery_bindings_accumulator) {
        return std::visit(
            [&subquery_bindings_accumulator](auto &&arg) -> QVariant {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::nullptr_t>) {
                    return QVariant(QMetaType(QMetaType::UnknownType));
                } else if constexpr (std::is_same_v<T, int>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, long long>) {
                    return QVariant(static_cast<qlonglong>(arg));
                } else if constexpr (std::is_same_v<T, double>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return QVariant(QString::fromStdString(arg));
                } else if constexpr (std::is_same_v<T, bool>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QDateTime>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QDate>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QTime>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QByteArray>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, SubqueryExpression>) {
                    for (const auto &sub_binding_variant : arg.bindings) {
                        std::visit(
                            [&subquery_bindings_accumulator](auto &&sub_val) {
                                using SubVT = std::decay_t<decltype(sub_val)>;
                                if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                    subquery_bindings_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                } else if constexpr (std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> || std::is_same_v<SubVT, double> || std::is_same_v<SubVT, bool> ||  // bool added
                                                     std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray>) {
                                    subquery_bindings_accumulator.append(QVariant::fromValue(sub_val));
                                } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                    subquery_bindings_accumulator.append(QString::fromStdString(sub_val));
                                } else {
                                    qWarning() << "QueryBuilder::toQVariant (Subquery binding): "
                                                  "Unhandled native type in subquery binding: "
                                               << typeid(SubVT).name();
                                }
                            },
                            sub_binding_variant);
                    }
                    return QVariant(QString::fromStdString("(" + arg.sql_string + ")"));
                }
                qWarning() << "QueryBuilder::toQVariant: Unhandled QueryValue variant type: " << typeid(T).name();
                return QVariant();
            },
            qv);
    }

    QueryValue QueryBuilder::qvariantToQueryValue(const QVariant &qv) {
        if (qv.isNull() || !qv.isValid()) return nullptr;

        QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
        type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

        if (type_id_val == QMetaType::UnknownType && qv.userType() != QMetaType::UnknownType) {
            type_id_val = static_cast<QMetaType::Type>(qv.userType());
        }

        if (type_id_val == QMetaType::Int) return qv.toInt();
        if (type_id_val == QMetaType::LongLong) return qv.toLongLong();
        if (type_id_val == QMetaType::ULongLong)  // QueryValue uses signed long long
            return qv.toLongLong();
        if (type_id_val == QMetaType::UInt)  // QueryValue uses signed int
            return static_cast<int>(qv.toUInt());
        if (type_id_val == QMetaType::Double) return qv.toDouble();
        if (type_id_val == QMetaType::Float)  // Promote to double for QueryValue
            return static_cast<double>(qv.toFloat());
        if (type_id_val == QMetaType::QString) return qv.toString().toStdString();
        if (type_id_val == QMetaType::Bool) return qv.toBool();
        if (type_id_val == QMetaType::QDateTime) return qv.toDateTime();
        if (type_id_val == QMetaType::QDate) return qv.toDate();
        if (type_id_val == QMetaType::QTime) return qv.toTime();
        if (type_id_val == QMetaType::QByteArray) return qv.toByteArray();

        qWarning() << "QueryBuilder::qvariantToQueryValue: Unhandled QVariant type "
                      "for QueryValue conversion: "
                   << qv.typeName() << "(TypeId: " << static_cast<int>(type_id_val) << ")";
        return nullptr;
    }

    std::pair<std::string, std::vector<QueryValue>> QueryBuilder::buildConditionClauseGroup() const {
        std::ostringstream group_sql_stream;
        QVariantList group_qbindings;  // Accumulates QVariants first

        std::ostringstream user_defined_conditions_ss;
        bool any_user_condition_written = false;

        if (!state_.where_conditions_.empty()) {
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.where_conditions_, "AND", false);
            any_user_condition_written = true;
        }
        if (!state_.or_conditions_.empty()) {
            if (any_user_condition_written) user_defined_conditions_ss << " OR ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.or_conditions_, "OR", false);
            any_user_condition_written = true;
        }
        if (!state_.not_conditions_.empty()) {
            if (any_user_condition_written) user_defined_conditions_ss << " AND ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.not_conditions_, "AND", true);
            // any_user_condition_written = true; // This was missing, though might not affect logic if not_conditions_ is last
        }
        std::string user_conditions_part_sql = user_defined_conditions_ss.str();

        std::string soft_delete_fragment_for_this_group;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            QString current_from_qstr = this->getFromSourceName();  // Returns QString
            if (!current_from_qstr.isEmpty() && state_.model_meta_->table_name == current_from_qstr.toStdString()) {
                apply_sd_on_this_from_source = true;
            }

            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    // Use QueryBuilder::quoteSqlIdentifier (static)
                    soft_delete_fragment_for_this_group = QueryBuilder::quoteSqlIdentifier(this->getFromSourceName().toStdString()) +  // Uses QB's getFromSourceName
                                                          "." + QueryBuilder::quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool has_soft_delete = !soft_delete_fragment_for_this_group.empty();
        bool has_user_conditions = !user_conditions_part_sql.empty();

        if (has_soft_delete) {
            group_sql_stream << "(" << soft_delete_fragment_for_this_group << ")";
        }
        if (has_soft_delete && has_user_conditions) {
            group_sql_stream << " AND ";
        }
        if (has_user_conditions) {
            group_sql_stream << user_conditions_part_sql;
        }

        std::string final_built_sql_group = group_sql_stream.str();
        if (final_built_sql_group.empty()) {
            return {"", {}};
        }

        std::vector<QueryValue> native_args;
        native_args.reserve(group_qbindings.size());
        for (const QVariant &qv : group_qbindings) {
            native_args.push_back(QueryBuilder::qvariantToQueryValue(qv));
        }

        return {"(" + final_built_sql_group + ")", native_args};
    }

    QString QueryBuilder::toSqlDebug() const {
        auto [sql_qstr, params_list] = this->buildSelectSQL();
        QString debug_sql = sql_qstr;
        int current_param_idx = 0;
        int placeholder_pos = 0;

        while (current_param_idx < params_list.size()) {
            placeholder_pos = debug_sql.indexOf('?', placeholder_pos);
            if (placeholder_pos == -1) break;

            QVariant v = params_list.at(current_param_idx);
            QString param_str_val;

            QMetaType::Type v_type_id;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            v_type_id = static_cast<QMetaType::Type>(v.typeId());
#else
            v_type_id = static_cast<QMetaType::Type>(v.type());
#endif
            if (v_type_id == QMetaType::UnknownType && v.userType() != QMetaType::UnknownType) {
                v_type_id = static_cast<QMetaType::Type>(v.userType());
            }

            if (v.isNull() || !v.isValid() || v_type_id == QMetaType::UnknownType) {
                param_str_val = "NULL";
            } else if (v_type_id == QMetaType::QString) {
                param_str_val = "'" + v.toString().replace("'", "''") + "'";
            } else if (v_type_id == QMetaType::QByteArray) {
                param_str_val = "'<BinaryData:" + QString::number(v.toByteArray().size()) + "bytes>'";
            } else if (v_type_id == QMetaType::QDateTime) {
                param_str_val = "'" + v.toDateTime().toString(Qt::ISODateWithMs) + "'";
            } else if (v_type_id == QMetaType::QDate) {
                param_str_val = "'" + v.toDate().toString(Qt::ISODate) + "'";
            } else if (v_type_id == QMetaType::QTime) {
                param_str_val = "'" + v.toTime().toString(Qt::ISODateWithMs) + "'";
            } else if (v_type_id == QMetaType::Bool) {
                param_str_val = v.toBool() ? "TRUE" : "FALSE";
            } else {  // For numbers (int, long long, double)
                param_str_val = v.toString();
            }

            debug_sql.replace(placeholder_pos, 1, param_str_val);
            placeholder_pos += param_str_val.length();
            current_param_idx++;
        }
        return debug_sql;
    }

}  // namespace cpporm// Base/CppOrm/Source/db_manager.cpp
#include "cpporm/db_manager.h"

#include <QDebug>  // For qWarning

#include "sqldriver/sql_database.h"        // For cpporm_sqldriver::SqlDatabase
#include "sqldriver/sql_driver_manager.h"  // For cpporm_sqldriver::SqlDriverManager

namespace cpporm {

    std::expected<cpporm_sqldriver::SqlDatabase, Error> DbManager::openDatabase(const DbConfig &config) {
        std::string assigned_conn_name = config.connection_name;
        if (assigned_conn_name.empty()) {
            assigned_conn_name = DbConfig::generateUniqueConnectionName();
        }

        // 1. Get a SqlDatabase shell with the correct driver from SqlDriverManager
        cpporm_sqldriver::SqlDatabase db = cpporm_sqldriver::SqlDriverManager::addDatabase(config.driver_type, assigned_conn_name);

        if (!db.isValid()) {                                       // Checks if driver was loaded successfully into SqlDatabase
            cpporm_sqldriver::SqlError last_err = db.lastError();  // Get error from SqlDatabase constructor if driver failed
            std::string error_msg = "Failed to initialize database driver: Type '" + config.driver_type + "'. Connection name: " + assigned_conn_name;
            if (last_err.isValid()) {
                error_msg += ". Driver Msg: " + last_err.text();
            }
            return std::unexpected(Error(ErrorCode::DriverNotFound, error_msg));
        }

        // 2. Set connection parameters on the SqlDatabase object
        // SqlDatabase::open will use these parameters.
        // Or, pass them directly to open()
        cpporm_sqldriver::ConnectionParameters driver_params = config.toDriverParameters();
        // We can set these on db.m_parameters, or pass to db.open().
        // SqlDatabase::open(const ConnectionParameters&) is preferred.

        // 3. Open the connection
        if (!db.open(driver_params)) {
            cpporm_sqldriver::SqlError last_err = db.lastError();
            return std::unexpected(Error(ErrorCode::ConnectionFailed, "Failed to open database connection '" + assigned_conn_name + "': " + last_err.text() + " (Native Code: " + last_err.nativeErrorCode() + ")", last_err.nativeErrorCodeNumeric()));
        }

        // 4. Set client charset if specified
        if (!config.client_charset.empty()) {
            if (!db.setClientCharset(config.client_charset)) {
                cpporm_sqldriver::SqlError charset_err = db.lastError();
                qWarning() << "DbManager::openDatabase: Failed to set client charset '" << QString::fromStdString(config.client_charset) << "' for connection" << QString::fromStdString(assigned_conn_name) << ". Error:" << QString::fromStdString(charset_err.text())
                           << ". Continuing without this charset setting.";
                // This is not treated as a fatal error for opening the database.
            }
        }
        return std::move(db);  // Return the opened and configured SqlDatabase object
    }

    // Commented out methods as Session will own the SqlDatabase handle directly.
    // If these are needed, their implementation must change as SqlDriverManager does not store active instances.
    /*
    cpporm_sqldriver::SqlDatabase DbManager::getDatabase(const std::string &connection_name_str) {
        // This would return a NEW SqlDatabase, not an existing one from a pool.
        return cpporm_sqldriver::SqlDriverManager::database(connection_name_str, false);
    }

    void DbManager::closeDatabase(const std::string &connection_name_str) {
        // SqlDatabase objects should be closed by their owners (e.g. Session destructor).
        // SqlDriverManager::removeDatabase is conceptual in current design.
        // cpporm_sqldriver::SqlDriverManager::removeDatabase(connection_name_str);
    }

    bool DbManager::isConnectionValid(const std::string &connection_name_str) {
        // To check validity, one would need the actual SqlDatabase instance.
        // This function cannot reliably check a connection by name if the manager doesn't store instances.
        cpporm_sqldriver::SqlDatabase db = cpporm_sqldriver::SqlDriverManager::database(connection_name_str, false);
        return db.isValid() && db.isOpen(); // This checks a NEWLY created (or potentially default) one.
    }
    */

}  // namespace cpporm#include "cpporm/model_base.h" // For declarations in model_base.h

namespace cpporm {
namespace internal {

// Definitions for the global model factory registry
std::map<std::type_index, ModelFactory> &getGlobalModelFactoryRegistry() {
  static std::map<std::type_index, ModelFactory> registry;
  return registry;
}

std::mutex &getGlobalModelFactoryRegistryMutex() {
  static std::mutex registry_mutex;
  return registry_mutex;
}

// Definitions for Global Meta Finalization
std::vector<VoidFunc> &getGlobalModelFinalizerFunctions() {
  static std::vector<VoidFunc> finalizers;
  return finalizers;
}
std::mutex &getGlobalModelFinalizersRegistryMutex() {
  static std::mutex mtx;
  return mtx;
}

} // namespace internal

// Definition for the user-callable global finalization function
void finalize_all_model_meta() {
  // It's crucial that this function is called *after* all static initializers
  // (which call registerModelClassForFinalization) have run, and all model
  // class definitions are complete.

  // Create a copy of the finalizer functions to avoid issues if a finalizer
  // somehow tries to re-register (should not happen with current design).
  std::vector<internal::VoidFunc> finalizers_copy;
  {
    std::lock_guard<std::mutex> lock(
        internal::getGlobalModelFinalizersRegistryMutex());
    finalizers_copy = internal::getGlobalModelFinalizerFunctions();
  }

  // Sort finalizers? Not strictly necessary if _finalizeModelMeta is idempotent
  // and handles its dependencies gracefully (which it tries to, but typeid
  // makes it tricky). For now, call in registration order. A more robust system
  // might involve multiple passes or dependency tracking. qInfo() << "cpporm:
  // Globally finalizing metadata for" << finalizers_copy.size() << "models...";
  for (const auto &finalizer_func : finalizers_copy) {
    if (finalizer_func) {
      finalizer_func();
    }
  }
  // qInfo() << "cpporm: Global metadata finalization complete.";

  // Optional: Clear the global list if finalization is truly a one-time startup
  // event. This prevents re-finalization and saves a little memory. However, if
  // models could be registered dynamically later (not typical for this ORM
  // style), clearing would be problematic.
  // {
  //     std::lock_guard<std::mutex>
  //     lock(internal::getGlobalModelFinalizersRegistryMutex());
  //     internal::getGlobalModelFinalizerFunctions().clear();
  // }
}

} // namespace cpporm// Base/CppOrm/Source/session_batch_execution_and_hooks.cpp
#include <QDebug>
#include <QVariant>

#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {

        ExecutionResult executeBatchSql(Session &session, const std::string &sql_to_execute_std, const std::vector<cpporm_sqldriver::SqlValue> &bindings_sqlvalue, const std::vector<ModelBase *> &models_in_db_op, const OnConflictClause *active_conflict_clause) {
            ExecutionResult result;

            auto exec_pair = FriendAccess::callExecuteQueryInternal(session.getDbHandle(), sql_to_execute_std, bindings_sqlvalue);

            // Emplace the SqlQuery object into the optional
            // SqlQuery must be constructible/movable for this.
            // We emplace it regardless of error because SqlQuery object itself might contain more error details
            // or its state might be 'invalid' which is fine.
            result.query_object_opt.emplace(std::move(exec_pair.first));
            result.db_error = exec_pair.second;

            if (result.db_error) {
                // Even if there's an error, numRowsAffected might be relevant or -1
                if (result.query_object_opt && result.query_object_opt->isValid()) {
                    result.rows_affected = result.query_object_opt->numRowsAffected();
                }
                return result;  // Return early on DB error from execution
            }

            // If no DB error, query_object_opt should have a value and be valid
            if (result.query_object_opt && result.query_object_opt->isValid()) {
                result.rows_affected = result.query_object_opt->numRowsAffected();
            } else {
                // This case should ideally be covered by result.db_error if query object is not valid post-execution
                qWarning() << "executeBatchSql: SqlQuery object is not valid after successful-flagged execution.";
                result.rows_affected = -1;     // Indicate error or unknown state
                if (result.db_error.isOk()) {  // If no error was previously set, set one now.
                    result.db_error = Error(ErrorCode::QueryExecutionError, "SQLQuery object invalid post-execution without prior error.");
                }
                return result;
            }

            if (result.rows_affected > 0 || (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing && result.rows_affected >= 0)) {
                for (ModelBase *m : models_in_db_op) {
                    if (m) {
                        m->_is_persisted = true;
                        result.models_potentially_persisted.push_back(m);
                    }
                }
            } else if (result.rows_affected == 0 && active_conflict_clause && active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
                for (ModelBase *m : models_in_db_op) {
                    if (m) {
                        result.models_potentially_persisted.push_back(m);
                    }
                }
            }
            return result;  // NRVO should handle this (result is local)
        }

        void callAfterCreateHooks(Session &session, const std::vector<ModelBase *> &models_for_hooks, Error &in_out_first_error_encountered) {
            for (ModelBase *model_ptr : models_for_hooks) {
                if (!model_ptr || !model_ptr->_is_persisted) {
                    continue;
                }

                Error hook_err = model_ptr->afterCreate(session);
                if (hook_err) {
                    if (in_out_first_error_encountered.isOk()) {
                        in_out_first_error_encountered = hook_err;
                    }
                    qWarning() << "callAfterCreateHooks: afterCreate hook failed for a model (table: " << QString::fromStdString(model_ptr->_getTableName()) << "). Error: " << QString::fromStdString(hook_err.toString());
                }
            }
        }

    }  // namespace internal_batch_helpers
}  // namespace cpporm// Base/CppOrm/Source/session_batch_id_backfillers.cpp
#include <QDebug>
#include <QVariant>
#include <algorithm>

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_enums.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {

        std::vector<ModelBase *> backfillIdsFromReturning(cpporm_sqldriver::SqlQuery &executed_query, const ModelMeta &meta, const std::vector<ModelBase *> &models_to_backfill_from, const std::string &pk_cpp_name_str, const std::type_index &pk_cpp_type) {
            std::vector<ModelBase *> successfully_backfilled_models;
            if (models_to_backfill_from.empty()) {
                return successfully_backfilled_models;
            }

            for (ModelBase *model_to_backfill : models_to_backfill_from) {
                if (!model_to_backfill || !model_to_backfill->_is_persisted) {
                    continue;
                }

                if (!executed_query.next()) {
                    qWarning() << "backfillIdsFromReturning: RETURNING clause provided fewer "
                                  "ID rows than the number of persisted models in the batch for table "
                               << QString::fromStdString(meta.table_name);
                    break;
                }
                cpporm_sqldriver::SqlValue id_sql_val_ret = executed_query.value(0);
                std::any pk_any_val;
                bool conv_ok = false;

                if (id_sql_val_ret.isNull()) {
                    conv_ok = true;
                } else {
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = id_sql_val_ret.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = id_sql_val_ret.toInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned int))
                        pk_any_val = id_sql_val_ret.toUInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned long long))
                        pk_any_val = id_sql_val_ret.toUInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(std::string))
                        pk_any_val = id_sql_val_ret.toString(&conv_ok);
                    else if (pk_cpp_type == typeid(QByteArray))  // Handle QByteArray for UUID etc.
                        pk_any_val = id_sql_val_ret.toByteArray(&conv_ok);
                    else {
                        qWarning() << "backfillIdsFromReturning: Unsupported C++ PK type for backfill: " << pk_cpp_type.name() << "for table" << QString::fromStdString(meta.table_name) << ". Attempting string conversion.";
                        pk_any_val = id_sql_val_ret.toString(&conv_ok);
                    }
                }

                if (conv_ok) {
                    Error set_err = model_to_backfill->setFieldValue(pk_cpp_name_str, pk_any_val);
                    if (set_err) {
                        qWarning() << "backfillIdsFromReturning: Error setting PK value for table " << QString::fromStdString(meta.table_name) << ", field " << QString::fromStdString(pk_cpp_name_str) << " after RETURNING:" << QString::fromStdString(set_err.toString());
                    } else {
                        successfully_backfilled_models.push_back(model_to_backfill);
                    }
                } else {
                    qWarning() << "backfillIdsFromReturning: PK backfill conversion failed for RETURNING. SqlValue type:" << id_sql_val_ret.typeName() << "to C++ type" << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                }
            }
            return successfully_backfilled_models;
        }

        std::vector<ModelBase *> backfillIdsFromLastInsertId(cpporm_sqldriver::SqlQuery &executed_query,
                                                             const Session &session,
                                                             const ModelMeta &meta,
                                                             const std::vector<ModelBase *> &models_to_backfill_from,
                                                             long long total_rows_affected_by_query,
                                                             const std::string &pk_cpp_name_str,
                                                             const std::type_index &pk_cpp_type,
                                                             const OnConflictClause *active_conflict_clause) {
            std::vector<ModelBase *> successfully_backfilled_models;
            if (models_to_backfill_from.empty() || total_rows_affected_by_query <= 0) {
                return successfully_backfilled_models;
            }

            cpporm_sqldriver::SqlValue first_id_sql_val = executed_query.lastInsertId();
            if (!first_id_sql_val.isValid() || first_id_sql_val.isNull()) {
                bool is_zero_id = false;
                bool conv_check_ok = false;
                if (first_id_sql_val.type() == cpporm_sqldriver::SqlValueType::Int32 && first_id_sql_val.toInt32(&conv_check_ok) == 0 && conv_check_ok)
                    is_zero_id = true;
                else if (first_id_sql_val.type() == cpporm_sqldriver::SqlValueType::Int64 && first_id_sql_val.toInt64(&conv_check_ok) == 0 && conv_check_ok)
                    is_zero_id = true;

                if (!is_zero_id || (is_zero_id && pk_cpp_type != typeid(int) && pk_cpp_type != typeid(long long))) {
                    qWarning() << "backfillIdsFromLastInsertId: lastInsertId is invalid, null, or zero (and PK is not int/longlong) for table " << QString::fromStdString(meta.table_name) << ". Value: " << QString::fromStdString(first_id_sql_val.toString());
                    return successfully_backfilled_models;
                }
            }

            std::string db_driver_name_upper_std;
            // Use a const reference to the db_handle to call const methods
            const cpporm_sqldriver::SqlDatabase &const_db_handle = session.getDbHandle();
            if (const_db_handle.driver()) {
                std::string drv_name_full = const_db_handle.driverName();
                std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std), [](unsigned char c) {
                    return std::toupper(c);
                });
            }

            if (models_to_backfill_from.size() == 1 && total_rows_affected_by_query >= 1) {
                ModelBase *single_model = nullptr;
                for (ModelBase *m : models_to_backfill_from) {
                    if (m && m->_is_persisted) {
                        single_model = m;
                        break;
                    }
                }

                if (single_model) {
                    std::any pk_any_val;
                    bool conv_ok = false;
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned int))
                        pk_any_val = first_id_sql_val.toUInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned long long))
                        pk_any_val = first_id_sql_val.toUInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(std::string))
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    else if (pk_cpp_type == typeid(QByteArray))
                        pk_any_val = first_id_sql_val.toByteArray(&conv_ok);
                    else {
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    }

                    if (conv_ok) {
                        Error set_err = single_model->setFieldValue(pk_cpp_name_str, pk_any_val);
                        if (set_err) {
                            qWarning() << "backfillIdsFromLastInsertId (single): Error setting PK value for table " << QString::fromStdString(meta.table_name) << ", field " << QString::fromStdString(pk_cpp_name_str) << ". Error: " << QString::fromStdString(set_err.toString());
                        } else {
                            successfully_backfilled_models.push_back(single_model);
                        }
                    } else {
                        qWarning() << "backfillIdsFromLastInsertId (single): PK backfill conversion failed. SqlValue type:" << first_id_sql_val.typeName() << " to C++ type " << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                    }
                }
            } else if ((db_driver_name_upper_std.find("MYSQL") != std::string::npos || db_driver_name_upper_std.find("MARIADB") != std::string::npos) && total_rows_affected_by_query > 0 && total_rows_affected_by_query <= static_cast<long long>(models_to_backfill_from.size()) &&
                       (!active_conflict_clause || (active_conflict_clause && (active_conflict_clause->action == OnConflictClause::Action::UpdateAllExcluded || active_conflict_clause->action == OnConflictClause::Action::UpdateSpecific)))) {
                bool ok_first_id_ll;
                long long first_id_ll = first_id_sql_val.toInt64(&ok_first_id_ll);
                if (!ok_first_id_ll) {
                    qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): lastInsertId could not be converted to long long for table " << QString::fromStdString(meta.table_name);
                    return successfully_backfilled_models;
                }

                if (total_rows_affected_by_query == static_cast<long long>(models_to_backfill_from.size())) {
                    size_t persisted_model_idx = 0;
                    for (ModelBase *current_model : models_to_backfill_from) {
                        if (!current_model || !current_model->_is_persisted) continue;

                        long long current_model_id_ll = first_id_ll + static_cast<long long>(persisted_model_idx);
                        // Explicitly cast to the correct integer type for SqlValue constructor
                        cpporm_sqldriver::SqlValue current_id_sv(static_cast<int64_t>(current_model_id_ll));
                        std::any pk_any_val_seq;
                        bool conv_ok_seq = false;

                        if (pk_cpp_type == typeid(int))
                            pk_any_val_seq = current_id_sv.toInt32(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(long long))
                            pk_any_val_seq = current_id_sv.toInt64(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(unsigned int))
                            pk_any_val_seq = current_id_sv.toUInt32(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(unsigned long long))
                            pk_any_val_seq = current_id_sv.toUInt64(&conv_ok_seq);
                        else {
                            pk_any_val_seq = current_id_sv.toString(&conv_ok_seq);
                        }

                        if (conv_ok_seq) {
                            Error set_err = current_model->setFieldValue(pk_cpp_name_str, pk_any_val_seq);
                            if (set_err) {
                                qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): Error setting PK value for table " << QString::fromStdString(meta.table_name) << ". Error: " << QString::fromStdString(set_err.toString());
                            } else {
                                successfully_backfilled_models.push_back(current_model);
                            }
                        } else {
                            qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): PK backfill conversion failed for sequential ID. SqlValue type:" << current_id_sv.typeName() << " to C++ type " << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                        }
                        persisted_model_idx++;
                    }
                } else if (total_rows_affected_by_query > 0) {
                    ModelBase *first_persisted_model = nullptr;
                    for (ModelBase *m : models_to_backfill_from) {
                        if (m && m->_is_persisted) {
                            first_persisted_model = m;
                            break;
                        }
                    }

                    if (first_persisted_model) {
                        std::any pk_any_val;
                        bool conv_ok = false;
                        if (pk_cpp_type == typeid(int))
                            pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                        else if (pk_cpp_type == typeid(long long))
                            pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                        else {
                            pk_any_val = first_id_sql_val.toString(&conv_ok);
                        }
                        if (conv_ok) {
                            Error set_err = first_persisted_model->setFieldValue(pk_cpp_name_str, pk_any_val);
                            if (!set_err) successfully_backfilled_models.push_back(first_persisted_model);
                        }
                    }
                    qWarning() << "backfillIdsFromLastInsertId: lastInsertId may not be reliable for all rows (MySQL batch). Rows affected (" << total_rows_affected_by_query << ") != models persisted/attempted in batch (" << models_to_backfill_from.size()
                               << "). Table: " << QString::fromStdString(meta.table_name);
                }

            } else if (db_driver_name_upper_std.find("SQLITE") != std::string::npos && total_rows_affected_by_query == 1 && !models_to_backfill_from.empty()) {
                ModelBase *model_to_set = nullptr;
                for (ModelBase *m : models_to_backfill_from) {
                    if (m && m->_is_persisted) {
                        model_to_set = m;
                        break;
                    }
                }

                if (model_to_set) {
                    std::any pk_any_val;
                    bool conv_ok = false;
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                    else {
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    }

                    if (conv_ok) {
                        Error set_err = model_to_set->setFieldValue(pk_cpp_name_str, pk_any_val);
                        if (!set_err) successfully_backfilled_models.push_back(model_to_set);
                    }
                }
            } else {
                qWarning() << "backfillIdsFromLastInsertId: lastInsertId is not reliably applicable for this batch operation on driver " << QString::fromStdString(db_driver_name_upper_std) << " for table " << QString::fromStdString(meta.table_name)
                           << ". Models processed: " << models_to_backfill_from.size() << ", Rows affected by query: " << total_rows_affected_by_query;
            }
            return successfully_backfilled_models;
        }

    }  // namespace internal_batch_helpers
}  // namespace cpporm#include <QDebug>
#include <QStringList>  // Still used for constructing SQL parts like "(?,?,?)"
#include <QVariant>     // QVariantList for suffix bindings, if QueryBuilder::buildInsertSQLSuffix still uses it

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"  // 包含声明和 FriendAccess 定义

// SqlDriver specific includes
#include "sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {

        std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(Session &session,
                                                                                   const std::vector<ModelBase *> &models_in_provider_chunk,
                                                                                   const ModelMeta &meta,
                                                                                   const std::vector<std::string> &batch_ordered_db_field_names_cache,  // IN
                                                                                   BatchSqlParts &out_sql_parts                                         // OUT
        ) {
            std::vector<ModelBase *> models_prepared_for_sql_build;
            models_prepared_for_sql_build.reserve(models_in_provider_chunk.size());
            Error first_prepare_error = make_ok();

            out_sql_parts.all_values_flattened.clear();  // This will now be std::vector<SqlValue>
            out_sql_parts.row_placeholders.clear();      // This is QStringList

            std::string db_driver_name_upper_std;
            if (session.getDbHandle().driver()) {
                std::string drv_name_full = session.getDbHandle().driverName();
                std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std), [](unsigned char c) {
                    return std::toupper(c);
                });
            }

            for (ModelBase *model_ptr : models_in_provider_chunk) {
                if (!model_ptr) continue;

                Error hook_err = model_ptr->beforeCreate(session);
                if (hook_err) {
                    if (first_prepare_error.isOk()) first_prepare_error = hook_err;
                    qWarning() << "prepareModelsAndSqlPlaceholders: beforeCreate hook failed for model (table: " << QString::fromStdString(meta.table_name) << "): " << QString::fromStdString(hook_err.toString());
                    continue;  // Skip this model if hook fails
                }
                FriendAccess::callAutoSetTimestamps(session, *model_ptr, meta, true);

                // extractModelData now returns map<std::string, SqlValue> for fields_to_write
                internal::SessionModelDataForWrite model_data_struct = FriendAccess::callExtractModelData(session, *model_ptr, meta, false, true);

                QStringList current_model_placeholders_segment_qsl;  // For "(?,?,?)" part
                bool model_can_be_inserted_this_pass = false;

                bool is_pure_auto_inc_pk_current_model = batch_ordered_db_field_names_cache.empty() && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);

                if (!batch_ordered_db_field_names_cache.empty()) {
                    model_can_be_inserted_this_pass = true;
                    for (const std::string &field_db_name : batch_ordered_db_field_names_cache) {
                        auto it = model_data_struct.fields_to_write.find(field_db_name);  // Key is std::string
                        // out_sql_parts.all_values_flattened is now std::vector<SqlValue>
                        out_sql_parts.all_values_flattened.push_back(it != model_data_struct.fields_to_write.end() ? it->second : cpporm_sqldriver::SqlValue() /* Null SqlValue */
                        );
                        current_model_placeholders_segment_qsl.append("?");
                    }
                    out_sql_parts.row_placeholders.append(QString("(%1)").arg(current_model_placeholders_segment_qsl.join(",")));
                } else if (is_pure_auto_inc_pk_current_model) {
                    model_can_be_inserted_this_pass = true;
                    // For pure auto-inc PK, SQL syntax (DEFAULT VALUES or empty VALUES ()) depends on DB.
                    // Placeholders for values are not typically used for this case, but the VALUES () or DEFAULT VALUES part is built.
                    // If PostgreSQL and only one such model in the batch, specific "DEFAULT VALUES" SQL is used later.
                    // For multi-row pure auto-inc for PG, or other DBs, often "()" is used per row.
                    if (db_driver_name_upper_std.find("PSQL") == std::string::npos || models_in_provider_chunk.size() > 1) {
                        out_sql_parts.row_placeholders.append("()");  // For MySQL, SQLite, or multi-row PG auto-inc
                    }
                    // For single PG auto-inc, row_placeholders might remain empty, handled by buildFullBatchSqlStatement.
                }

                if (model_can_be_inserted_this_pass) {
                    models_prepared_for_sql_build.push_back(model_ptr);
                } else {
                    if (first_prepare_error.isOk()) {
                        first_prepare_error = Error(ErrorCode::MappingError, "Model (table: " + meta.table_name + ", C++ type: " + typeid(*model_ptr).name() + ") could not be prepared for batch insertion (no insertable fields).");
                    }
                    qWarning() << "prepareModelsAndSqlPlaceholders: Model " << QString::fromStdString(typeid(*model_ptr).name()) << " for table " << QString::fromStdString(meta.table_name)
                               << " could not be prepared for batch insertion (no insertable fields determined or pure-auto-inc logic issue).";
                }
            }
            return {models_prepared_for_sql_build, first_prepare_error};
        }

        Error buildFullBatchSqlStatement(const Session &session,  // const Session& is fine here as we only read db_handle properties
                                         const QueryBuilder &qb_prototype,
                                         const ModelMeta &meta,
                                         const std::vector<std::string> &batch_ordered_db_field_names_cache,  // Already sorted std::string
                                         const OnConflictClause *active_conflict_clause,
                                         BatchSqlParts &in_out_sql_parts  // IN/OUT
        ) {
            in_out_sql_parts.can_proceed = false;
            std::string db_driver_name_upper_std;
            if (session.getDbHandle().driver()) {
                std::string drv_name_full = session.getDbHandle().driverName();
                std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std), [](unsigned char c) {
                    return std::toupper(c);
                });
            }

            std::string sql_verb_std = "INSERT";  // Use std::string
            if (active_conflict_clause && active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
                if (db_driver_name_upper_std.find("MYSQL") != std::string::npos || db_driver_name_upper_std.find("MARIADB") != std::string::npos) {
                    sql_verb_std = "INSERT IGNORE";
                }
                // For SQLite "INSERT OR IGNORE", or PG "ON CONFLICT DO NOTHING", suffix is preferred.
                // If suffix builder for SQLite returns empty for DO NOTHING, then verb needs to change.
                // For now, assume suffix handles it if possible.
            }

            bool is_pure_auto_inc_pk_case = batch_ordered_db_field_names_cache.empty() && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);

            std::string table_name_quoted_std = QueryBuilder::quoteSqlIdentifier(meta.table_name);
            std::ostringstream sql_base_oss;  // Use ostringstream for std::string

            if (is_pure_auto_inc_pk_case) {
                if (db_driver_name_upper_std.find("PSQL") != std::string::npos && in_out_sql_parts.row_placeholders.isEmpty()) {
                    // Single row PG INSERT ... DEFAULT VALUES
                    sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " DEFAULT VALUES";
                    in_out_sql_parts.all_values_flattened.clear();  // No values for DEFAULT VALUES
                } else if (!in_out_sql_parts.row_placeholders.isEmpty()) {
                    // MySQL, SQLite, or multi-row PG: INSERT INTO ... () VALUES (),()...
                    sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " () VALUES " << in_out_sql_parts.row_placeholders.join(",").toStdString();
                    in_out_sql_parts.all_values_flattened.clear();  // No explicit values for "()"
                } else {
                    qWarning() << "buildFullBatchSqlStatement: Inconsistent state for pure auto-inc PK case. Placeholders: " << in_out_sql_parts.row_placeholders.join(",") << ", Driver: " << QString::fromStdString(db_driver_name_upper_std);
                    return Error(ErrorCode::StatementPreparationError, "Pure auto-inc batch SQL build inconsistency.");
                }
            } else if (!batch_ordered_db_field_names_cache.empty() && !in_out_sql_parts.row_placeholders.isEmpty()) {
                sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " (";
                for (size_t i = 0; i < batch_ordered_db_field_names_cache.size(); ++i) {
                    sql_base_oss << QueryBuilder::quoteSqlIdentifier(batch_ordered_db_field_names_cache[i]) << (i < batch_ordered_db_field_names_cache.size() - 1 ? ", " : "");
                }
                sql_base_oss << ") VALUES " << in_out_sql_parts.row_placeholders.join(",").toStdString();
            } else {
                return Error(ErrorCode::StatementPreparationError, "Cannot build batch INSERT SQL: missing field names or placeholders for table " + meta.table_name);
            }
            in_out_sql_parts.sql_insert_base = QString::fromStdString(sql_base_oss.str());

            in_out_sql_parts.sql_on_conflict_suffix.clear();
            in_out_sql_parts.conflict_suffix_bindings.clear();  // This is QVariantList

            if (active_conflict_clause && !(sql_verb_std != "INSERT" && active_conflict_clause->action == OnConflictClause::Action::DoNothing)) {
                QueryBuilder temp_qb_for_suffix_build(nullptr, session.getConnectionName(), &meta);
                temp_qb_for_suffix_build.getState_().on_conflict_clause_ = std::make_unique<OnConflictClause>(*active_conflict_clause);

                auto suffix_pair_result = temp_qb_for_suffix_build.buildInsertSQLSuffix(batch_ordered_db_field_names_cache);
                in_out_sql_parts.sql_on_conflict_suffix = suffix_pair_result.first;     // QString
                in_out_sql_parts.conflict_suffix_bindings = suffix_pair_result.second;  // QVariantList
            }

            in_out_sql_parts.final_sql_statement = in_out_sql_parts.sql_insert_base.toStdString();  // Start with std::string
            if (!in_out_sql_parts.sql_on_conflict_suffix.isEmpty()) {
                in_out_sql_parts.final_sql_statement += " " + in_out_sql_parts.sql_on_conflict_suffix.toStdString();
            }

            // final_bindings is std::vector<SqlValue>
            in_out_sql_parts.final_bindings = in_out_sql_parts.all_values_flattened;  // Already SqlValue vector
            for (const QVariant &qv_suffix_bind : in_out_sql_parts.conflict_suffix_bindings) {
                in_out_sql_parts.final_bindings.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv_suffix_bind)));
            }

            bool has_pk_for_returning = meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement) && !meta.getPrimaryField()->db_name.empty();
            bool use_returning = (session.getDbHandle().hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId) && (db_driver_name_upper_std.find("PSQL") != std::string::npos || db_driver_name_upper_std.find("SQLITE") != std::string::npos) && has_pk_for_returning &&
                                  (!active_conflict_clause || active_conflict_clause->action != OnConflictClause::Action::DoNothing));

            if (use_returning) {
                in_out_sql_parts.final_sql_statement += " RETURNING " + QueryBuilder::quoteSqlIdentifier(meta.getPrimaryField()->db_name);
            }

            in_out_sql_parts.can_proceed = true;
            return make_ok();
        }

    }  // namespace internal_batch_helpers
}  // namespace cpporm#include "cpporm/model_base.h"     // For ModelBase, ModelMeta
#include "cpporm/query_builder.h"  // QueryBuilder 构造函数已更新
#include "cpporm/session.h"        // 主头文件

namespace cpporm {

    // --- Model/Table selection implementation ---
    QueryBuilder Session::Model(const ModelBase *model_instance_hint) {
        if (!model_instance_hint) {
            // QueryBuilder 构造函数接收 std::string connection_name_
            return QueryBuilder(this, this->connection_name_, nullptr);
        }
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, &(model_instance_hint->_getOwnModelMeta()));
    }

    QueryBuilder Session::Model(const ModelMeta &meta) {
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, &meta);
    }

    QueryBuilder Session::Table(const std::string &table_name) {
        // QueryBuilder 构造函数接收 std::string connection_name_
        QueryBuilder qb(this, this->connection_name_, nullptr);
        qb.Table(table_name);  // QueryBuilder::Table takes std::string
        return qb;
    }

    QueryBuilder Session::MakeQueryBuilder() {
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, nullptr);
    }

    // --- OnConflict clause setters implementation ---
    Session &Session::OnConflictUpdateAllExcluded() {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        temp_on_conflict_clause_->action = OnConflictClause::Action::UpdateAllExcluded;
        temp_on_conflict_clause_->update_assignments.clear();
        temp_on_conflict_clause_->conflict_target_columns_db_names.clear();  // 确保目标也清除
        return *this;
    }

    Session &Session::OnConflictDoNothing() {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        temp_on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
        temp_on_conflict_clause_->update_assignments.clear();
        // conflict_target_columns_db_names 保持不变，用户可能已设置
        return *this;
    }

    Session &Session::OnConflictUpdateSpecific(std::function<void(SessionOnConflictUpdateSetter &)> updater_fn) {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        // SessionOnConflictUpdateSetter 构造函数会设置 action = UpdateSpecific
        SessionOnConflictUpdateSetter setter(*temp_on_conflict_clause_);
        updater_fn(setter);
        return *this;
    }

}  // namespace cpporm// Base/CppOrm/Source/session_create_batch_ops.cpp
#include <QDebug>  // For qInfo, qWarning

#include "cpporm/session.h"
// #include <QSqlQuery>   // Removed
#include <QVariant>  // For QVariantList for suffix bindings if buildInsertSQLSuffix still uses it

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"               // For OnConflictClause in Session, QueryBuilder state access
#include "cpporm/session_priv_batch_helpers.h"  // FriendAccess is defined here

// SqlDriver specific includes
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_enums.h"  // For Feature::LastInsertId, Feature::InsertAndReturnId
#include "sqldriver/sql_query.h"  // For cpporm_sqldriver::SqlQuery
#include "sqldriver/sql_value.h"  // For cpporm_sqldriver::SqlValue

namespace cpporm {

    // CreateBatchWithMeta 现在返回 std::expected<size_t, Error>
    std::expected<size_t, Error> Session::CreateBatchWithMeta(const ModelMeta &meta,
                                                              const std::vector<ModelBase *> &models,  // Pointers to models
                                                              size_t internal_batch_processing_size_hint,
                                                              const OnConflictClause *conflict_options_override) {
        if (models.empty()) {
            return 0UL;
        }
        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateBatchWithMeta: ModelMeta has no table name."));
        }
        if (internal_batch_processing_size_hint == 0) {
            internal_batch_processing_size_hint = 100;            // Default batch size
        } else if (internal_batch_processing_size_hint > 1000) {  // Safety cap
            internal_batch_processing_size_hint = 1000;
        }

        size_t total_successfully_created_count = 0;
        Error first_error_encountered = make_ok();

        QueryBuilder qb_proto = this->Model(meta);  // QB for prototype

        size_t current_provider_idx = 0;
        auto data_provider_lambda = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_provider_idx >= models.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk;
            size_t end_idx = std::min(models.size(), current_provider_idx + internal_batch_processing_size_hint);
            for (size_t i = current_provider_idx; i < end_idx; ++i) {
                if (models[i]) {  // Ensure pointer is not null
                    chunk.push_back(models[i]);
                }
            }
            current_provider_idx = end_idx;
            if (chunk.empty()) return std::nullopt;
            return chunk;
        };

        auto completion_callback_lambda = [&total_successfully_created_count, &first_error_encountered](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error) {
            if (batch_error) {
                if (first_error_encountered.isOk()) {
                    first_error_encountered = batch_error;
                }
            } else {
                for (const auto *m_ptr : processed_batch_models_with_ids) {
                    if (m_ptr && m_ptr->_is_persisted) {  // Count only if truly persisted
                        total_successfully_created_count++;
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, data_provider_lambda, completion_callback_lambda, conflict_options_override);

        if (provider_loop_error) {  // Error from the provider loop itself
            return std::unexpected(provider_loop_error);
        }
        if (first_error_encountered) {  // Error from one of the batch DB operations or hooks
            return std::unexpected(first_error_encountered);
        }

        return total_successfully_created_count;
    }

    Error Session::CreateBatchProviderInternal(QueryBuilder qb_prototype,
                                               std::function<std::optional<std::vector<ModelBase *>>()> data_batch_provider_base,
                                               std::function<void(const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error)> per_db_batch_completion_callback,
                                               const OnConflictClause *conflict_options_override) {
        const ModelMeta *meta_ptr = qb_prototype.getModelMeta();
        if (!meta_ptr) {
            return Error(ErrorCode::InvalidConfiguration, "CreateBatchProviderInternal: QueryBuilder prototype has no ModelMeta.");
        }
        const ModelMeta &meta = *meta_ptr;

        const OnConflictClause *active_conflict_clause = conflict_options_override;
        if (!active_conflict_clause && qb_prototype.getOnConflictClause()) {
            active_conflict_clause = qb_prototype.getOnConflictClause();
        }
        if (!active_conflict_clause && temp_on_conflict_clause_) {
            active_conflict_clause = temp_on_conflict_clause_.get();
        }
        bool clear_temp_clause_at_end = (active_conflict_clause == temp_on_conflict_clause_.get() && !conflict_options_override && !qb_prototype.getOnConflictClause());

        std::vector<std::string> batch_ordered_db_field_names_cache;
        bool is_pure_auto_inc_pk_model_type = data_batch_provider_base && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement) && meta.fields.size() == 1 && meta.associations.empty();

        if (!is_pure_auto_inc_pk_model_type) {
            batch_ordered_db_field_names_cache.clear();
            for (const auto &field_meta_obj : meta.fields) {
                if (has_flag(field_meta_obj.flags, FieldFlag::Association)) continue;
                if (has_flag(field_meta_obj.flags, FieldFlag::AutoIncrement) && has_flag(field_meta_obj.flags, FieldFlag::PrimaryKey)) continue;
                if (field_meta_obj.db_name.empty()) continue;
                batch_ordered_db_field_names_cache.push_back(field_meta_obj.db_name);
            }
            std::sort(batch_ordered_db_field_names_cache.begin(), batch_ordered_db_field_names_cache.end());
            if (batch_ordered_db_field_names_cache.empty() && !is_pure_auto_inc_pk_model_type) {
                qWarning() << "CreateBatchProviderInternal: No insertable fields determined for non-pure-auto-inc model" << QString::fromStdString(meta.table_name) << ". This might be valid if DB supports INSERT ... DEFAULT VALUES for such cases.";
            }
        }

        std::optional<std::vector<ModelBase *>> current_batch_models_opt;
        while ((current_batch_models_opt = data_batch_provider_base()).has_value()) {
            if (!current_batch_models_opt.has_value() || current_batch_models_opt->empty()) {
                break;
            }
            std::vector<ModelBase *> &models_in_current_chunk = *current_batch_models_opt;
            if (models_in_current_chunk.empty()) continue;

            internal_batch_helpers::BatchSqlParts sql_parts_for_chunk;
            Error batch_prep_error;
            std::vector<ModelBase *> models_prepared_for_this_db_batch;

            auto prep_result = internal_batch_helpers::prepareModelsAndSqlPlaceholders(*this, models_in_current_chunk, meta, batch_ordered_db_field_names_cache, sql_parts_for_chunk);
            models_prepared_for_this_db_batch = prep_result.first;
            batch_prep_error = prep_result.second;

            if (batch_prep_error) {
                if (per_db_batch_completion_callback) {
                    per_db_batch_completion_callback({}, batch_prep_error);
                }
                continue;
            }
            if (models_prepared_for_this_db_batch.empty()) {
                if (per_db_batch_completion_callback) {
                    per_db_batch_completion_callback({}, make_ok());
                }
                continue;
            }

            Error build_sql_err = internal_batch_helpers::buildFullBatchSqlStatement(*this, qb_prototype, meta, batch_ordered_db_field_names_cache, active_conflict_clause, sql_parts_for_chunk);

            if (build_sql_err || !sql_parts_for_chunk.can_proceed) {
                if (per_db_batch_completion_callback) {
                    per_db_batch_completion_callback({}, build_sql_err.isOk() ? Error(ErrorCode::StatementPreparationError, "SQL construction failed sanity check.") : build_sql_err);
                }
                continue;
            }

            internal_batch_helpers::ExecutionResult exec_res = internal_batch_helpers::executeBatchSql(*this, sql_parts_for_chunk.final_sql_statement, sql_parts_for_chunk.final_bindings, models_prepared_for_this_db_batch, active_conflict_clause);

            std::vector<ModelBase *> successfully_backfilled_models;
            if (!exec_res.db_error) {
                bool driver_has_returning = db_handle_.hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId);
                bool driver_has_last_insert_id = db_handle_.hasFeature(cpporm_sqldriver::Feature::LastInsertId);
                std::string pk_cpp_name_for_backfill;
                std::type_index pk_cpp_type_for_backfill = typeid(void);

                const FieldMeta *pk_field = meta.getPrimaryField();
                if (pk_field && has_flag(pk_field->flags, FieldFlag::AutoIncrement)) {
                    pk_cpp_name_for_backfill = pk_field->cpp_name;
                    pk_cpp_type_for_backfill = pk_field->cpp_type;
                }

                if (!pk_cpp_name_for_backfill.empty() && exec_res.query_object_opt.has_value()) {
                    if (sql_parts_for_chunk.final_sql_statement.find(" RETURNING ") != std::string::npos && driver_has_returning) {
                        successfully_backfilled_models = internal_batch_helpers::backfillIdsFromReturning(exec_res.query_object_opt.value(), meta, exec_res.models_potentially_persisted, pk_cpp_name_for_backfill, pk_cpp_type_for_backfill);
                    } else if (driver_has_last_insert_id) {
                        successfully_backfilled_models = internal_batch_helpers::backfillIdsFromLastInsertId(exec_res.query_object_opt.value(), *this, meta, exec_res.models_potentially_persisted, exec_res.rows_affected, pk_cpp_name_for_backfill, pk_cpp_type_for_backfill, active_conflict_clause);
                    }
                } else {
                    successfully_backfilled_models = exec_res.models_potentially_persisted;
                }

                Error first_hook_error_after_create = make_ok();
                internal_batch_helpers::callAfterCreateHooks(*this, successfully_backfilled_models, first_hook_error_after_create);
                if (first_hook_error_after_create && exec_res.db_error.isOk()) {
                    exec_res.db_error = first_hook_error_after_create;
                }
            }

            if (per_db_batch_completion_callback) {
                per_db_batch_completion_callback(successfully_backfilled_models, exec_res.db_error);
            }
        }

        if (clear_temp_clause_at_end) this->clearTempOnConflictClause();
        return make_ok();
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant types in QueryValue
#include <QDebug>     // qWarning
#include <QMetaType>  // For QVariant to std::any conversion types
#include <QVariant>   // QVariantList, QueryValue can hold QVariant types
#include <algorithm>  // For std::transform in driver name to upper

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "sqldriver/i_sql_driver.h"  // ISqlDriver for hasFeature
#include "sqldriver/sql_enums.h"     // Feature::LastInsertId, Feature::InsertAndReturnId
#include "sqldriver/sql_query.h"     // SqlQuery
#include "sqldriver/sql_value.h"     // SqlValue

namespace cpporm {

    // Session 的 IQueryExecutor::CreateImpl 实现 (单个模型创建)
    // 返回 std::expected<SqlValue, Error>
    std::expected<cpporm_sqldriver::SqlValue, Error> Session::CreateImpl(const QueryBuilder &qb, ModelBase &model_instance, const OnConflictClause *conflict_options_override) {
        const OnConflictClause *active_conflict_clause = conflict_options_override;
        if (!active_conflict_clause && qb.getOnConflictClause()) {
            active_conflict_clause = qb.getOnConflictClause();
        }
        if (!active_conflict_clause && temp_on_conflict_clause_) {  // Check session's temp clause
            active_conflict_clause = temp_on_conflict_clause_.get();
        }

        bool clear_temp_on_conflict_at_end = (active_conflict_clause == temp_on_conflict_clause_.get() && !conflict_options_override && !qb.getOnConflictClause());

        const ModelMeta *meta_ptr = qb.getModelMeta();
        if (!meta_ptr) {  // If QB doesn't have meta, get from model
            meta_ptr = &(model_instance._getOwnModelMeta());
        }
        if (!meta_ptr || meta_ptr->table_name.empty()) {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateImpl: ModelMeta is not valid or table name is empty."));
        }
        const ModelMeta &meta = *meta_ptr;

        Error hook_err = model_instance.beforeCreate(*this);
        if (hook_err) {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(hook_err);
        }

        this->autoSetTimestamps(model_instance, meta, true);
        // extractModelData 返回 SessionModelDataForWrite，其字段值类型已更新为 SqlValue
        internal::SessionModelDataForWrite data_to_write = this->extractModelData(model_instance, meta, false, true);

        if (data_to_write.fields_to_write.empty() && !data_to_write.has_auto_increment_pk) {
            // 检查是否为纯自增主键模型（例如只有一个自增ID字段）
            bool is_simple_auto_inc_model = data_to_write.has_auto_increment_pk && meta.fields.size() == 1 && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);
            if (!is_simple_auto_inc_model) {
                if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
                return std::unexpected(Error(ErrorCode::MappingError,
                                             "No fields to insert for Create operation "
                                             "and not a simple auto-increment model. Table: " +
                                                 meta.table_name));
            }
        }

        std::vector<std::string> field_names_std_vec;
        std::vector<cpporm_sqldriver::SqlValue> values_to_bind_sqlvalue;
        std::vector<std::string> placeholders_std_vec;
        std::vector<std::string> ordered_db_field_names_vec;

        std::string driverNameStdUpper;
        if (db_handle_.driver()) {
            std::string drv_name_full = db_handle_.driverName();
            std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(driverNameStdUpper), [](unsigned char c) {
                return std::toupper(c);
            });
        }

        for (const auto &[db_name_std, sql_val] : data_to_write.fields_to_write) {
            ordered_db_field_names_vec.push_back(db_name_std);
            field_names_std_vec.push_back(QueryBuilder::quoteSqlIdentifier(db_name_std));
            values_to_bind_sqlvalue.push_back(sql_val);

            bool placeholder_handled = false;
            if (driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) {
                const FieldMeta *fm = meta.findFieldByDbName(db_name_std);
                if (fm && (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" || fm->db_type_hint == "LINESTRING" || fm->db_type_hint == "POLYGON" || fm->db_type_hint == "MULTIPOINT" || fm->db_type_hint == "MULTILINESTRING" || fm->db_type_hint == "MULTIPOLYGON" ||
                           fm->db_type_hint == "GEOMETRYCOLLECTION")) {
                    placeholders_std_vec.push_back("ST_GeomFromText(?)");
                    placeholder_handled = true;
                }
            }
            // Add similar for PG (ST_GeomFromEWKT) or SQLite (GeomFromText) if needed
            if (!placeholder_handled) {
                placeholders_std_vec.push_back("?");
            }
        }

        std::string sql_verb = "INSERT";
        if (active_conflict_clause && active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
            if (driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) {
                sql_verb = "INSERT IGNORE";
            } else if (driverNameStdUpper.find("SQLITE") != std::string::npos) {
                // SQLite can use ON CONFLICT DO NOTHING suffix, or INSERT OR IGNORE verb.
                // If buildInsertSQLSuffix handles "ON CONFLICT DO NOTHING" for SQLite, keep INSERT.
                // If we prefer "INSERT OR IGNORE", change sql_verb here and ensure suffix is not added.
                // For now, assume suffix is preferred if available, so sql_verb remains INSERT.
                // If suffix builder returns empty for SQLite DO NOTHING, then change verb:
                // sql_verb = "INSERT OR IGNORE";
            }
        }

        std::string sql_query_base_std;
        std::ostringstream sql_builder_stream;

        if (!field_names_std_vec.empty()) {
            sql_builder_stream << sql_verb << " INTO " << QueryBuilder::quoteSqlIdentifier(meta.table_name) << " (";
            for (size_t i = 0; i < field_names_std_vec.size(); ++i) {
                sql_builder_stream << field_names_std_vec[i] << (i < field_names_std_vec.size() - 1 ? ", " : "");
            }
            sql_builder_stream << ") VALUES (";
            for (size_t i = 0; i < placeholders_std_vec.size(); ++i) {
                sql_builder_stream << placeholders_std_vec[i] << (i < placeholders_std_vec.size() - 1 ? ", " : "");
            }
            sql_builder_stream << ")";
            sql_query_base_std = sql_builder_stream.str();

        } else if (data_to_write.has_auto_increment_pk) {                // Only auto-inc PK, no other fields
            if (driverNameStdUpper.find("PSQL") != std::string::npos) {  // PostgreSQL
                sql_query_base_std = "INSERT INTO " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " DEFAULT VALUES";
            } else {  // MySQL, SQLite, etc.
                sql_query_base_std = sql_verb + " INTO " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " () VALUES ()";
            }
            values_to_bind_sqlvalue.clear();  // No values to bind in this specific case
        } else {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(Error(ErrorCode::MappingError, "Cannot construct INSERT: no fields and no auto-inc PK. Table: " + meta.table_name));
        }

        QString sql_on_conflict_suffix_qstr;
        QVariantList suffix_qbindings;

        if (active_conflict_clause) {
            // If sql_verb was changed to INSERT IGNORE/OR IGNORE, we might not want a suffix.
            bool skip_suffix_due_to_verb = (sql_verb != "INSERT" && active_conflict_clause->action == OnConflictClause::Action::DoNothing);
            if (!skip_suffix_due_to_verb) {
                QueryBuilder temp_qb_for_suffix(nullptr, this->connection_name_, &meta);
                temp_qb_for_suffix.getState_().on_conflict_clause_ = std::make_unique<OnConflictClause>(*active_conflict_clause);
                auto suffix_pair = temp_qb_for_suffix.buildInsertSQLSuffix(ordered_db_field_names_vec);
                sql_on_conflict_suffix_qstr = suffix_pair.first;
                suffix_qbindings = suffix_pair.second;
            }
        }

        std::string final_sql_query_std = sql_query_base_std;
        if (!sql_on_conflict_suffix_qstr.isEmpty()) {
            final_sql_query_std += " " + sql_on_conflict_suffix_qstr.toStdString();
        }

        std::vector<cpporm_sqldriver::SqlValue> all_bindings_sqlvalue = values_to_bind_sqlvalue;
        for (const QVariant &qv_suffix_bind : suffix_qbindings) {
            all_bindings_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv_suffix_bind)));
        }

        bool driver_can_return_last_id = db_handle_.hasFeature(cpporm_sqldriver::Feature::LastInsertId);
        bool use_returning_clause_feature = db_handle_.hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId);

        bool use_returning_for_this_op = false;
        if (use_returning_clause_feature && data_to_write.has_auto_increment_pk && !data_to_write.auto_increment_pk_name_db.empty() && (!active_conflict_clause || active_conflict_clause->action != OnConflictClause::Action::DoNothing)) {
            // PostgreSQL and SQLite (>=3.35) support RETURNING
            if (driverNameStdUpper.find("PSQL") != std::string::npos || driverNameStdUpper.find("SQLITE") != std::string::npos) {
                use_returning_for_this_op = true;
            }
        }

        if (use_returning_for_this_op) {
            final_sql_query_std += " RETURNING " + QueryBuilder::quoteSqlIdentifier(data_to_write.auto_increment_pk_name_db);
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, final_sql_query_std, all_bindings_sqlvalue);

        if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();

        if (exec_err) return std::unexpected(exec_err);

        long long rows_affected = sql_query_obj.numRowsAffected();
        model_instance._is_persisted = (rows_affected > 0 || (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing && rows_affected >= 0));

        cpporm_sqldriver::SqlValue returned_id_sv;

        bool was_pure_insert_action = (sql_verb == "INSERT" && !active_conflict_clause);  // True insert without conflict clause
        bool was_insert_ignore_action = (sql_verb == "INSERT IGNORE" || sql_verb == "INSERT OR IGNORE");
        bool was_upsert_action = (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing);

        if (use_returning_for_this_op && (was_pure_insert_action || was_upsert_action) && rows_affected > 0) {
            if (sql_query_obj.next()) returned_id_sv = sql_query_obj.value(0);
        } else if (data_to_write.has_auto_increment_pk && driver_can_return_last_id && (was_pure_insert_action || was_insert_ignore_action) && rows_affected == 1) {
            returned_id_sv = sql_query_obj.lastInsertId();
        } else if (data_to_write.has_auto_increment_pk && driver_can_return_last_id && was_upsert_action && rows_affected > 0) {
            // MySQL ON DUPLICATE KEY UPDATE: rows_affected=1 for INSERT, 2 for UPDATE. lastInsertId() is new ID for INSERT.
            if ((driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) && rows_affected == 1) {
                returned_id_sv = sql_query_obj.lastInsertId();
            }
            // SQLite ON CONFLICT DO UPDATE: lastInsertId() is rowid of updated/inserted row.
            else if (driverNameStdUpper.find("SQLITE") != std::string::npos) {
                returned_id_sv = sql_query_obj.lastInsertId();
            }
        }

        if (returned_id_sv.isValid() && !returned_id_sv.isNull() && data_to_write.has_auto_increment_pk) {
            std::any pk_val_any;
            bool conversion_ok = false;
            const auto &pk_type = data_to_write.pk_cpp_type_for_autoincrement;
            const std::string &pk_cpp_name = data_to_write.pk_cpp_name_for_autoincrement;

            // Convert SqlValue to std::any. mapRowToModel has similar logic.
            if (pk_type == typeid(int))
                pk_val_any = returned_id_sv.toInt32(&conversion_ok);
            else if (pk_type == typeid(long long))
                pk_val_any = returned_id_sv.toInt64(&conversion_ok);
            else if (pk_type == typeid(unsigned int))
                pk_val_any = returned_id_sv.toUInt32(&conversion_ok);
            else if (pk_type == typeid(unsigned long long))
                pk_val_any = returned_id_sv.toUInt64(&conversion_ok);
            else if (pk_type == typeid(std::string))
                pk_val_any = returned_id_sv.toString(&conversion_ok);
            // Add other types if PK can be them (e.g. UUID as string)
            else {
                qWarning() << "CreateImpl: PK backfill for type " << pk_type.name() << " is not directly supported. Attempting string conversion.";
                pk_val_any = returned_id_sv.toString(&conversion_ok);
            }

            if (conversion_ok) {
                Error set_pk_err = model_instance.setFieldValue(pk_cpp_name, pk_val_any);
                if (set_pk_err) qWarning() << "CreateImpl: Error setting auto-incremented PK '" << QString::fromStdString(pk_cpp_name) << "': " << QString::fromStdString(set_pk_err.toString());
            } else {
                std::string sv_str_val = returned_id_sv.toString();
                qWarning() << "CreateImpl: Conversion failed for PK backfill. DB val (SqlValue):" << QString::fromStdString(sv_str_val) << " (type: " << returned_id_sv.typeName() << ") to C++ type " << pk_type.name();
            }
        }

        if (model_instance._is_persisted) {  // Only call afterCreate if model is actually persisted
            hook_err = model_instance.afterCreate(*this);
            if (hook_err) return std::unexpected(hook_err);
        }

        if (returned_id_sv.isValid() && !returned_id_sv.isNull()) return returned_id_sv;
        return cpporm_sqldriver::SqlValue(static_cast<int64_t>(rows_affected));
    }

    std::expected<cpporm_sqldriver::SqlValue, Error> Session::Create(ModelBase &model, const OnConflictClause *conflict_options_override) {
        QueryBuilder qb = this->Model(&model);
        return this->CreateImpl(qb, model, conflict_options_override);
    }

}  // namespace cpporm#include <QDateTime>  // For soft delete timestamp
#include <QDebug>     // qWarning, qInfo
#include <QVariant>   // QVariantList from QueryBuilder
#include <algorithm>  // std::min, std::transform

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "sqldriver/sql_query.h"  // SqlQuery
#include "sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::DeleteImpl(const QueryBuilder &qb_const) {
        QueryBuilder qb = qb_const;  // Work with a copy

        const ModelMeta *meta = qb.getModelMeta();

        if (meta && qb.isSoftDeleteScopeActive()) {
            bool can_soft_delete_this_target = false;
            if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
                const std::string &from_name = std::get<std::string>(qb.getFromClauseSource());
                if ((!from_name.empty() && from_name == meta->table_name) || (from_name.empty() && !meta->table_name.empty())) {
                    can_soft_delete_this_target = true;
                }
            }

            if (can_soft_delete_this_target) {
                if (const FieldMeta *deletedAtField = meta->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    if (deletedAtField->cpp_type == typeid(QDateTime)) {  // Assuming QDateTime for DeletedAt
                        std::map<std::string, QueryValue> updates_for_soft_delete;
                        updates_for_soft_delete[deletedAtField->db_name] = QDateTime::currentDateTimeUtc();

                        // Also update 'updated_at' if it exists
                        if (const FieldMeta *updatedAtField = meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
                            if (updatedAtField->cpp_type == typeid(QDateTime)) {
                                updates_for_soft_delete[updatedAtField->db_name] = QDateTime::currentDateTimeUtc();
                            } else {
                                qWarning("Session::DeleteImpl (Soft Delete): Model %s has UpdatedAt field (%s) but it's not QDateTime. It won't be auto-updated during soft delete.", meta->table_name.c_str(), updatedAtField->db_name.c_str());
                            }
                        }
                        // Create a new QueryBuilder for the UPDATE operation, ensuring soft delete scope is off.
                        QueryBuilder update_qb_for_soft_delete = qb;  // Copy original conditions
                        update_qb_for_soft_delete.Unscoped();         // Disable soft delete for the UPDATE itself
                        return this->UpdatesImpl(update_qb_for_soft_delete, updates_for_soft_delete);
                    } else {
                        qWarning("Session::DeleteImpl: Model %s has DeletedAt field (%s) but it's not QDateTime. Soft delete skipped. Hard delete will proceed.", meta->table_name.c_str(), deletedAtField->db_name.c_str());
                    }
                }
            }
        }

        // Proceed with hard delete
        auto [sql_qstr, params_qvariantlist] = qb.buildDeleteSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for hard Delete operation."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) return std::unexpected(exec_err);

        return sql_query_obj.numRowsAffected();
    }

    std::expected<long long, Error> Session::Delete(QueryBuilder qb) {
        if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
            qWarning(
                "Session::Delete(QueryBuilder): QueryBuilder was associated with "
                "a different executor. The operation will use THIS session's context "
                "by calling its DeleteImpl. Ensure this is intended.");
        }
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::Delete(const ModelBase &model_condition) {
        const ModelMeta &meta = model_condition._getOwnModelMeta();
        QueryBuilder qb = this->Model(meta);

        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "Delete by model_condition: No PK defined for model " + meta.table_name));
        }

        std::map<std::string, QueryValue> pk_conditions;
        for (const auto &pk_name : meta.primary_keys_db_names) {
            const FieldMeta *fm = meta.findFieldByDbName(pk_name);
            if (!fm) return std::unexpected(Error(ErrorCode::InternalError, "PK field meta not found for DB name '" + pk_name + "' in Delete by model_condition for table " + meta.table_name));
            std::any val = model_condition.getFieldValue(fm->cpp_name);
            if (!val.has_value()) return std::unexpected(Error(ErrorCode::MappingError, "PK value for '" + fm->cpp_name + "' not set in model_condition for Delete on table " + meta.table_name));

            QueryValue qv_pk = Session::anyToQueryValueForSessionConvenience(val);
            if (std::holds_alternative<std::nullptr_t>(qv_pk) && val.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Delete by model_condition: Unsupported PK type (" + std::string(val.type().name()) + ") for field " + fm->cpp_name));
            }
            pk_conditions[pk_name] = qv_pk;
        }

        if (pk_conditions.empty() || pk_conditions.size() != meta.primary_keys_db_names.size()) return std::unexpected(Error(ErrorCode::MappingError, "Could not extract all PKs for Delete by model_condition on table " + meta.table_name));

        qb.Where(pk_conditions);
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::Delete(const ModelMeta &meta, const std::map<std::string, QueryValue> &conditions) {
        QueryBuilder qb = this->Model(meta);
        if (!conditions.empty()) {
            qb.Where(conditions);
        }  // If conditions are empty, buildDeleteSQL will warn about missing WHERE if applicable
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::DeleteBatch(const ModelMeta &meta, const std::vector<std::map<std::string, QueryValue>> &primary_keys_list, size_t batch_delete_size_hint) {
        if (primary_keys_list.empty()) {
            return 0LL;
        }
        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "DeleteBatch: ModelMeta does not have a valid table name."));
        }
        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "DeleteBatch: Model " + meta.table_name + " has no primary keys defined."));
        }

        long long total_rows_affected_accumulator = 0;
        Error first_error_encountered = make_ok();
        bool an_error_occurred_in_any_batch = false;

        size_t actual_batch_size = batch_delete_size_hint > 0 ? batch_delete_size_hint : 100;  // Default to 100 if 0
        if (primary_keys_list.empty())
            actual_batch_size = 0;  // No batches if list is empty
        else if (actual_batch_size == 0)
            actual_batch_size = 1;  // Ensure at least 1 if list not empty and hint was 0

        if (actual_batch_size > 500) actual_batch_size = 500;  // Cap batch size for safety

        for (size_t i = 0; i < primary_keys_list.size(); i += actual_batch_size) {
            QueryBuilder qb_for_this_batch(this, this->connection_name_, &meta);

            size_t current_batch_end_idx = std::min(i + actual_batch_size, primary_keys_list.size());
            if (current_batch_end_idx <= i) continue;  // Should not happen with proper loop

            if (meta.primary_keys_db_names.size() == 1) {  // Single PK
                const std::string &pk_col_db_name = meta.primary_keys_db_names[0];
                std::vector<QueryValue> pk_values_for_in_clause;
                pk_values_for_in_clause.reserve(current_batch_end_idx - i);

                for (size_t k = i; k < current_batch_end_idx; ++k) {
                    const auto &pk_map_for_item = primary_keys_list[k];
                    auto it = pk_map_for_item.find(pk_col_db_name);
                    if (it != pk_map_for_item.end()) {
                        pk_values_for_in_clause.push_back(it->second);
                    } else {
                        qWarning("DeleteBatch: PK '%s' not found in map for item at index %zu. Skipping this item.", pk_col_db_name.c_str(), k);
                    }
                }
                if (!pk_values_for_in_clause.empty()) {
                    qb_for_this_batch.In(pk_col_db_name, pk_values_for_in_clause);
                } else {
                    continue;  // No valid PKs in this sub-batch
                }
            } else {  // Composite PKs
                std::vector<std::string> or_conditions_str_parts;
                std::vector<QueryValue> all_composite_pk_bindings;
                or_conditions_str_parts.reserve(current_batch_end_idx - i);

                for (size_t k = i; k < current_batch_end_idx; ++k) {
                    std::string current_item_pk_condition_group_str = "(";
                    bool first_col_in_group = true;
                    bool current_item_pk_group_valid = true;
                    std::vector<QueryValue> bindings_for_current_item_group;
                    bindings_for_current_item_group.reserve(meta.primary_keys_db_names.size());

                    for (const std::string &pk_col_db_name_part : meta.primary_keys_db_names) {
                        const auto &pk_map_for_item = primary_keys_list[k];
                        auto it = pk_map_for_item.find(pk_col_db_name_part);
                        if (it == pk_map_for_item.end()) {
                            qWarning("DeleteBatch: Composite PK part '%s' not found for item at index %zu. Skipping this item.", pk_col_db_name_part.c_str(), k);
                            current_item_pk_group_valid = false;
                            break;
                        }
                        if (!first_col_in_group) {
                            current_item_pk_condition_group_str += " AND ";
                        }
                        current_item_pk_condition_group_str += QueryBuilder::quoteSqlIdentifier(pk_col_db_name_part) + " = ?";
                        bindings_for_current_item_group.push_back(it->second);
                        first_col_in_group = false;
                    }
                    current_item_pk_condition_group_str += ")";

                    if (current_item_pk_group_valid && !bindings_for_current_item_group.empty()) {
                        or_conditions_str_parts.push_back(current_item_pk_condition_group_str);
                        all_composite_pk_bindings.insert(all_composite_pk_bindings.end(), std::make_move_iterator(bindings_for_current_item_group.begin()), std::make_move_iterator(bindings_for_current_item_group.end()));
                    }
                }
                if (!or_conditions_str_parts.empty()) {
                    std::string final_or_where_clause_str;
                    for (size_t o_idx = 0; o_idx < or_conditions_str_parts.size(); ++o_idx) {
                        final_or_where_clause_str += or_conditions_str_parts[o_idx];
                        if (o_idx < or_conditions_str_parts.size() - 1) {
                            final_or_where_clause_str += " OR ";
                        }
                    }
                    qb_for_this_batch.Where(final_or_where_clause_str, all_composite_pk_bindings);
                } else {
                    continue;  // No valid composite PKs in this sub-batch
                }
            }

            auto batch_delete_result = this->DeleteImpl(qb_for_this_batch);

            if (batch_delete_result.has_value()) {
                total_rows_affected_accumulator += batch_delete_result.value();
            } else {
                if (!an_error_occurred_in_any_batch) {
                    first_error_encountered = batch_delete_result.error();
                }
                an_error_occurred_in_any_batch = true;  // Mark that an error occurred
                qWarning("DeleteBatch: Error in sub-batch for table %s. Error: %s", meta.table_name.c_str(), batch_delete_result.error().toString().c_str());
                // Optionally break or continue processing other batches
            }
        }

        if (an_error_occurred_in_any_batch) return std::unexpected(first_error_encountered);
        return total_rows_affected_accumulator;
    }

}  // namespace cpporm// Base/CppOrm/Source/session_lifecycle.cpp
#include <QDebug>  // For qWarning

#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"  // For FriendAccess definition
#include "sqldriver/sql_database.h"             // For cpporm_sqldriver::SqlDatabase
#include "sqldriver/sql_driver_manager.h"       // For defaultConnectionName if needed (less likely now)
#include "sqldriver/sql_enums.h"                // For cpporm_sqldriver::Feature
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_query.h"  // For execute_query_internal

namespace cpporm {

    // Constructor now takes an rvalue reference to an SqlDatabase object
    Session::Session(cpporm_sqldriver::SqlDatabase &&db_handle_rval)
        : connection_name_(db_handle_rval.connectionName()),  // Get name before db_handle_rval is moved
          db_handle_(std::move(db_handle_rval)),
          is_explicit_transaction_handle_(false),  // A regular session is not initially transactional
          temp_on_conflict_clause_(nullptr) {
        if (!db_handle_.isValid()) {
            qWarning() << "cpporm Session: Constructed with an invalid SqlDatabase "
                          "handle for connection:"
                       << QString::fromStdString(connection_name_);
        } else if (!db_handle_.isOpen()) {
            qWarning() << "cpporm Session: Constructed with a valid but NOT OPEN SqlDatabase "
                          "handle for connection:"
                       << QString::fromStdString(connection_name_);
        }
    }

    Session::~Session() {
        // If this session represents an explicit transaction that wasn't committed/rolled back,
        // it should be rolled back.
        if (is_explicit_transaction_handle_ && db_handle_.isValid() && db_handle_.isOpen() && db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            if (db_handle_.isTransactionActive()) {  // isTransactionActive() should be on SqlDatabase
                qWarning() << "cpporm Session: Destructor called for an active "
                              "transaction on connection"
                           << QString::fromStdString(connection_name_) << ". Rolling back automatically.";
                db_handle_.rollback();  // SqlDatabase::rollback()
            }
        }
        // db_handle_ (SqlDatabase) destructor will handle closing its connection if it's still open
        // and freeing its ISqlDriver if it owns it.
    }

    Session::Session(Session &&other) noexcept : connection_name_(std::move(other.connection_name_)), db_handle_(std::move(other.db_handle_)), is_explicit_transaction_handle_(other.is_explicit_transaction_handle_), temp_on_conflict_clause_(std::move(other.temp_on_conflict_clause_)) {
        other.is_explicit_transaction_handle_ = false;  // Reset moved-from session's tx state
    }

    Session &Session::operator=(Session &&other) noexcept {
        if (this != &other) {
            // Clean up current session's resources if it's managing an explicit transaction
            if (is_explicit_transaction_handle_ && db_handle_.isValid() && db_handle_.isOpen() && db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
                if (db_handle_.isTransactionActive()) {
                    db_handle_.rollback();
                }
            }
            // db_handle_ old resources will be cleaned up by its move assignment or destructor if it's not moved from.

            connection_name_ = std::move(other.connection_name_);
            db_handle_ = std::move(other.db_handle_);  // SqlDatabase move assignment
            is_explicit_transaction_handle_ = other.is_explicit_transaction_handle_;
            temp_on_conflict_clause_ = std::move(other.temp_on_conflict_clause_);

            other.is_explicit_transaction_handle_ = false;  // Reset moved-from session's tx state
        }
        return *this;
    }

    const std::string &Session::getConnectionName() const {
        return connection_name_;
    }

    cpporm_sqldriver::SqlDatabase &Session::getDbHandle() {
        return db_handle_;
    }
    const cpporm_sqldriver::SqlDatabase &Session::getDbHandle() const {
        return db_handle_;
    }

    const OnConflictClause *Session::getTempOnConflictClause() const {
        return temp_on_conflict_clause_.get();
    }

    void Session::clearTempOnConflictClause() {
        temp_on_conflict_clause_.reset();
    }

    // FriendAccess static method definitions
    // These allow internal_batch_helpers to call private methods of Session
    cpporm::internal::SessionModelDataForWrite internal_batch_helpers::FriendAccess::callExtractModelData(Session &s, const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null) {
        return s.extractModelData(model_instance, meta, for_update, include_timestamps_even_if_null);
    }

    std::pair<cpporm_sqldriver::SqlQuery, Error> internal_batch_helpers::FriendAccess::callExecuteQueryInternal(cpporm_sqldriver::SqlDatabase &db_conn_ref, const std::string &sql, const std::vector<cpporm_sqldriver::SqlValue> &bound_params) {
        // Session::execute_query_internal is already public static, so FriendAccess isn't strictly needed for this one if Session has it public static.
        // However, if it were private, this friend access would be necessary.
        return Session::execute_query_internal(db_conn_ref, sql, bound_params);
    }

    void internal_batch_helpers::FriendAccess::callAutoSetTimestamps(Session &s, ModelBase &model_instance, const ModelMeta &meta, bool is_create_op) {
        s.autoSetTimestamps(model_instance, meta, is_create_op);
    }

}  // namespace cpporm#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QDebug>
#include <QMetaType>

#include "cpporm/model_base.h"
#include "cpporm/session.h"
// #include <QSqlRecord> // No longer using QSqlRecord
#include <QTime>
#include <QVariant>  // Still used for std::any <-> QueryValue <-> SqlValue intermediate if needed

#include "sqldriver/sql_field.h"   // SqlField (from SqlRecord)
#include "sqldriver/sql_query.h"   // SqlQuery
#include "sqldriver/sql_record.h"  // SqlRecord (from SqlQuery)
#include "sqldriver/sql_value.h"   // SqlValue

namespace cpporm {

    Error Session::mapRowToModel(cpporm_sqldriver::SqlQuery &query, ModelBase &model, const ModelMeta &meta) {
        cpporm_sqldriver::SqlRecord record_meta = query.recordMetadata();  // Get metadata once
        if (record_meta.isEmpty()) {
            qWarning() << "cpporm Session::mapRowToModel: Query returned no record metadata for table " << QString::fromStdString(meta.table_name);
            return Error(ErrorCode::MappingError, "Query returned no record metadata.");
        }

        for (int i = 0; i < record_meta.count(); ++i) {
            cpporm_sqldriver::SqlField col_meta_field = record_meta.field(i);  // SqlRecord::field()
            std::string db_col_name_std = col_meta_field.name();

            const FieldMeta *model_field_meta = meta.findFieldByDbName(db_col_name_std);

            if (!model_field_meta) {
                continue;  // Column from DB not mapped in model
            }
            if (has_flag(model_field_meta->flags, FieldFlag::Association)) {
                continue;  // Skip association placeholder fields
            }

            cpporm_sqldriver::SqlValue sql_val = query.value(i);  // SqlQuery::value()
            std::any cpp_value;
            bool conversion_ok = false;

            if (sql_val.isNull()) {
                conversion_ok = true;  // std::any will be empty, representing NULL
            } else {
                // Convert SqlValue to std::any. This requires knowing the target C++ type.
                // SqlValue has toType() methods. We'll use those.
                // This is similar to qvariantToAny but starts from SqlValue.
                const std::type_index &target_cpp_type = model_field_meta->cpp_type;

                if (target_cpp_type == typeid(int)) {
                    cpp_value = sql_val.toInt32(&conversion_ok);
                } else if (target_cpp_type == typeid(long long)) {
                    cpp_value = sql_val.toInt64(&conversion_ok);
                } else if (target_cpp_type == typeid(unsigned int)) {
                    cpp_value = sql_val.toUInt32(&conversion_ok);
                } else if (target_cpp_type == typeid(unsigned long long)) {
                    cpp_value = sql_val.toUInt64(&conversion_ok);
                } else if (target_cpp_type == typeid(double)) {
                    cpp_value = sql_val.toDouble(&conversion_ok);
                } else if (target_cpp_type == typeid(float)) {
                    cpp_value = sql_val.toFloat(&conversion_ok);
                } else if (target_cpp_type == typeid(bool)) {
                    cpp_value = sql_val.toBool(&conversion_ok);
                } else if (target_cpp_type == typeid(std::string)) {
                    cpp_value = sql_val.toString(&conversion_ok);
                } else if (target_cpp_type == typeid(QDateTime)) {
                    cpp_value = sql_val.toDateTime(&conversion_ok);
                } else if (target_cpp_type == typeid(QDate)) {
                    cpp_value = sql_val.toDate(&conversion_ok);
                } else if (target_cpp_type == typeid(QTime)) {
                    cpp_value = sql_val.toTime(&conversion_ok);
                } else if (target_cpp_type == typeid(QByteArray)) {
                    cpp_value = sql_val.toByteArray(&conversion_ok);
                } else {
                    qWarning() << "cpporm Session::mapRowToModel: Unsupported C++ type for field" << QString::fromStdString(model_field_meta->cpp_name) << "Type:" << model_field_meta->cpp_type.name();
                    continue;
                }
            }

            if (!conversion_ok) {
                std::string sv_str = sql_val.isNull() ? "NULL" : sql_val.toString();
                qWarning() << "cpporm Session::mapRowToModel: SqlValue to C++ type conversion failed for field" << QString::fromStdString(model_field_meta->cpp_name) << ". DB value (as string):" << QString::fromStdString(sv_str) << "(SqlValue type:" << sql_val.typeName()
                           << ", Target C++ type:" << model_field_meta->cpp_type.name() << ")";
                // Set to empty std::any to indicate failed conversion for a non-null value
                Error set_err = model.setFieldValue(model_field_meta->cpp_name, std::any{});
                if (set_err) { /* Log or handle */
                }
                continue;
            }

            Error set_err = model.setFieldValue(model_field_meta->cpp_name, cpp_value);
            if (set_err) {
                qWarning() << "cpporm Session::mapRowToModel: Error setting field" << QString::fromStdString(model_field_meta->cpp_name) << "after conversion:" << set_err.toString().c_str();
            }
        }
        model._is_persisted = true;  // Mark model as persisted after successful mapping
        return make_ok();
    }

    cpporm::internal::SessionModelDataForWrite Session::extractModelData(const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null) {
        cpporm::internal::SessionModelDataForWrite data;  // Holds SqlValue now

        for (const auto &field_meta : meta.fields) {
            if (has_flag(field_meta.flags, FieldFlag::Association)) {
                continue;
            }

            bool is_pk = has_flag(field_meta.flags, FieldFlag::PrimaryKey);
            bool is_auto_inc = has_flag(field_meta.flags, FieldFlag::AutoIncrement);

            std::any val_any = model_instance.getFieldValue(field_meta.cpp_name);
            cpporm_sqldriver::SqlValue sql_val_to_write;

            if (!val_any.has_value()) {
                sql_val_to_write = cpporm_sqldriver::SqlValue();  // Null SqlValue
            } else {
                // Convert std::any to SqlValue using its type
                const auto &type = val_any.type();
                if (type == typeid(int))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<int32_t>(std::any_cast<int>(val_any)));
                else if (type == typeid(long long))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<int64_t>(std::any_cast<long long>(val_any)));
                else if (type == typeid(unsigned int))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<uint32_t>(std::any_cast<unsigned int>(val_any)));
                else if (type == typeid(unsigned long long))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<uint64_t>(std::any_cast<unsigned long long>(val_any)));
                else if (type == typeid(double))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<double>(val_any));
                else if (type == typeid(float))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<float>(val_any));
                else if (type == typeid(bool))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<bool>(val_any));
                else if (type == typeid(std::string))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<std::string>(val_any));
                else if (type == typeid(QDateTime))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QDateTime>(val_any));
                else if (type == typeid(QDate))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QDate>(val_any));
                else if (type == typeid(QTime))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QTime>(val_any));
                else if (type == typeid(QByteArray))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QByteArray>(val_any));
                else {
                    qWarning() << "cpporm Session::extractModelData: Unsupported C++ type " << QString::fromLocal8Bit(type.name()) << " in model field " << QString::fromStdString(field_meta.cpp_name) << "for SqlValue conversion.";
                    continue;  // Skip this field
                }
            }

            if (is_pk) {
                if (sql_val_to_write.isValid() && !sql_val_to_write.isNull()) {
                    // primary_key_fields map uses std::string as key
                    data.primary_key_fields[field_meta.db_name] = sql_val_to_write;
                }
                if (is_auto_inc) {
                    data.has_auto_increment_pk = true;
                    // auto_increment_pk_name_db is std::string
                    data.auto_increment_pk_name_db = field_meta.db_name;
                    data.pk_cpp_name_for_autoincrement = field_meta.cpp_name;
                    data.pk_cpp_type_for_autoincrement = field_meta.cpp_type;
                }
            }

            if (for_update) {  // Update operation
                if (is_pk || has_flag(field_meta.flags, FieldFlag::CreatedAt)) {
                    continue;  // Skip PKs and CreatedAt for updates
                }
                // For UpdatedAt, include it if it's non-null OR if include_timestamps_even_if_null is true
                if (has_flag(field_meta.flags, FieldFlag::UpdatedAt) && !include_timestamps_even_if_null && sql_val_to_write.isNull()) {
                    continue;
                }
            } else {  // Create operation
                if (is_auto_inc && is_pk) {
                    continue;  // Skip auto-increment PK for creates (DB handles it)
                }
                // For CreatedAt/UpdatedAt on create, include if non-null OR if include_timestamps_even_if_null
                if ((has_flag(field_meta.flags, FieldFlag::CreatedAt) || has_flag(field_meta.flags, FieldFlag::UpdatedAt)) && !include_timestamps_even_if_null && sql_val_to_write.isNull()) {
                    continue;
                }
            }
            // fields_to_write map uses std::string as key
            data.fields_to_write[field_meta.db_name] = sql_val_to_write;
        }
        return data;
    }

    void Session::autoSetTimestamps(ModelBase &model_instance, const ModelMeta &meta, bool is_create_op) {
        // QDateTime is still used as the C++ type for timestamps
        QDateTime current_ts = QDateTime::currentDateTimeUtc();

        if (is_create_op) {
            if (const FieldMeta *created_at_field = meta.findFieldWithFlag(FieldFlag::CreatedAt)) {
                if (created_at_field->cpp_type == typeid(QDateTime)) {
                    std::any current_val = model_instance.getFieldValue(created_at_field->cpp_name);
                    // Set if current value is not set (empty any) or if it's an invalid QDateTime
                    if (!current_val.has_value() || (current_val.type() == typeid(QDateTime) && !std::any_cast<QDateTime>(current_val).isValid())) {
                        model_instance.setFieldValue(created_at_field->cpp_name, current_ts);
                    }
                }
            }
        }

        if (const FieldMeta *updated_at_field = meta.findFieldWithFlag(FieldFlag::UpdatedAt)) {
            if (updated_at_field->cpp_type == typeid(QDateTime)) {
                model_instance.setFieldValue(updated_at_field->cpp_name, current_ts);
            }
        }
    }

}  // namespace cpporm// Base/CppOrm/Source/session_migrate_column_ops.cpp
#include <QDebug>
#include <QString>
#include <algorithm>  // For std::transform
#include <cctype>     // For std::tolower

#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"  // Contains declarations now
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_field.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_record.h"

namespace cpporm {
    namespace internal {

        // Definition of normalizeDbType
        std::string normalizeDbType(const std::string &db_type_raw, const QString &driverNameUpperQ) {
            std::string lower_type = db_type_raw;
            std::transform(lower_type.begin(), lower_type.end(), lower_type.begin(), [](unsigned char c) {
                return static_cast<char>(std::tolower(c));
            });
            std::string driverNameUpper = driverNameUpperQ.toStdString();

            if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                if (lower_type.rfind("int", 0) == 0 && lower_type.find("unsigned") == std::string::npos && lower_type != "tinyint(1)") return "int";
                if (lower_type.rfind("int unsigned", 0) == 0) return "int unsigned";
                if (lower_type.rfind("bigint", 0) == 0 && lower_type.find("unsigned") == std::string::npos) return "bigint";
                if (lower_type.rfind("bigint unsigned", 0) == 0) return "bigint unsigned";
                if (lower_type == "tinyint(1)") return "boolean";
                if (lower_type.rfind("varchar", 0) == 0) return "varchar";
                if (lower_type.rfind("char", 0) == 0 && lower_type.find("varchar") == std::string::npos) return "char";
                if (lower_type == "text" || lower_type == "tinytext" || lower_type == "mediumtext" || lower_type == "longtext") return "text";
                if (lower_type == "datetime") return "datetime";
                if (lower_type == "timestamp") return "timestamp";
                if (lower_type == "date") return "date";
                if (lower_type == "time") return "time";
                if (lower_type == "float") return "float";
                if (lower_type == "double" || lower_type == "real") return "double";
                if (lower_type.rfind("decimal", 0) == 0 || lower_type.rfind("numeric", 0) == 0) return "decimal";
                if (lower_type == "blob" || lower_type == "tinyblob" || lower_type == "mediumblob" || lower_type == "longblob" || lower_type == "varbinary" || lower_type == "binary") return "blob";
                if (lower_type == "json") return "json";
                if (lower_type == "point" || lower_type == "geometry" /* etc for spatial types */) return "geometry";
            } else if (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") {
                if (lower_type == "integer" || lower_type == "int4") return "int";
                if (lower_type == "bigint" || lower_type == "int8") return "bigint";
                if (lower_type == "smallint" || lower_type == "int2") return "smallint";
                if (lower_type == "boolean" || lower_type == "bool") return "boolean";
                if (lower_type.rfind("character varying", 0) == 0) return "varchar";
                if ((lower_type.rfind("character(", 0) == 0 || lower_type.rfind("char(", 0) == 0) && lower_type.find("varying") == std::string::npos) return "char";
                if (lower_type == "text") return "text";
                if (lower_type == "timestamp without time zone" || lower_type == "timestamp") return "timestamp";
                if (lower_type == "timestamp with time zone") return "timestamptz";
                if (lower_type == "date") return "date";
                if (lower_type == "time without time zone" || lower_type == "time") return "time";
                if (lower_type == "time with time zone") return "timetz";
                if (lower_type == "real" || lower_type == "float4") return "float";
                if (lower_type == "double precision" || lower_type == "float8") return "double";
                if (lower_type == "numeric" || lower_type == "decimal") return "decimal";
                if (lower_type == "bytea") return "blob";
                if (lower_type == "json" || lower_type == "jsonb") return "json";
                if (lower_type == "uuid") return "uuid";
                if (lower_type.find("[]") != std::string::npos) return "array";
            } else if (driverNameUpper == "QSQLITE") {
                if (lower_type.find("int") != std::string::npos) return "int";
                if (lower_type == "text" || lower_type.find("char") != std::string::npos || lower_type.find("clob") != std::string::npos) return "text";
                if (lower_type == "blob" || lower_type.empty()) return "blob";
                if (lower_type == "real" || lower_type.find("floa") != std::string::npos || lower_type.find("doub") != std::string::npos) return "double";
                if (lower_type == "numeric" || lower_type.find("deci") != std::string::npos || lower_type.find("bool") != std::string::npos || lower_type.find("date") != std::string::npos || lower_type.find("datetime") != std::string::npos) return "numeric";
            }
            return lower_type;  // Return lowercased original if not specifically mapped
        }

        std::map<std::string, DbColumnInfo> getTableColumnsInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper) {
            std::map<std::string, DbColumnInfo> columns;
            cpporm_sqldriver::SqlQuery query(session.getDbHandle());
            std::string sql_std;
            std::string tableNameStd = tableNameQString.toStdString();

            if (driverNameUpper == "QSQLITE") {
                sql_std = "PRAGMA table_xinfo(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";
                if (!query.exec(sql_std)) {
                    sql_std = "PRAGMA table_info(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";
                    if (!query.exec(sql_std)) {
                        qWarning() << "getTableColumnsInfo (SQLite): Failed to query PRAGMA table_info/table_xinfo for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text());
                        return columns;
                    }
                }
            } else if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                sql_std = "SHOW FULL COLUMNS FROM " + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ";";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableColumnsInfo (MySQL/MariaDB): Failed to query SHOW FULL COLUMNS for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return columns;
                }
            } else if (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") {
                sql_std =
                    "SELECT column_name, data_type, udt_name, is_nullable, "
                    "column_default, "
                    "character_maximum_length, numeric_precision, numeric_scale, "
                    "collation_name "
                    "FROM information_schema.columns WHERE table_schema = "
                    "current_schema() AND table_name = '" +
                    tableNameStd + "';";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableColumnsInfo (PostgreSQL): Failed to query information_schema.columns for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return columns;
                }
            } else {
                qWarning() << "getTableColumnsInfo: Unsupported driver for detailed column info:" << driverNameUpper;
                return columns;
            }

            cpporm_sqldriver::SqlRecord rec_meta = query.recordMetadata();
            while (query.next()) {
                DbColumnInfo colInfo;
                if (driverNameUpper == "QSQLITE") {
                    colInfo.name = query.value(rec_meta.indexOf("name")).toString();
                    colInfo.type = query.value(rec_meta.indexOf("type")).toString();
                    colInfo.is_nullable = !query.value(rec_meta.indexOf("notnull")).toBool();
                    cpporm_sqldriver::SqlValue dflt_val_sv = query.value(rec_meta.indexOf("dflt_value"));
                    colInfo.default_value = dflt_val_sv.isNull() ? "" : dflt_val_sv.toString();
                    colInfo.column_key = query.value(rec_meta.indexOf("pk")).toInt32() > 0 ? "PRI" : "";
                } else if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                    colInfo.name = query.value(rec_meta.indexOf("Field")).toString();
                    colInfo.type = query.value(rec_meta.indexOf("Type")).toString();
                    std::string nullable_str = query.value(rec_meta.indexOf("Null")).toString();
                    std::transform(nullable_str.begin(), nullable_str.end(), nullable_str.begin(), ::toupper);
                    colInfo.is_nullable = (nullable_str == "YES");
                    cpporm_sqldriver::SqlValue defVal_sv = query.value(rec_meta.indexOf("Default"));
                    colInfo.default_value = defVal_sv.isNull() ? "" : defVal_sv.toString();
                    colInfo.collation_name = query.value(rec_meta.indexOf("Collation")).toString();
                    colInfo.column_key = query.value(rec_meta.indexOf("Key")).toString();
                    colInfo.extra = query.value(rec_meta.indexOf("Extra")).toString();
                } else if (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") {
                    colInfo.name = query.value(rec_meta.indexOf("column_name")).toString();
                    std::string pg_udt_name = query.value(rec_meta.indexOf("udt_name")).toString();
                    std::string pg_data_type = query.value(rec_meta.indexOf("data_type")).toString();

                    if (pg_data_type.rfind("ARRAY", 0) == 0) {
                        colInfo.type = pg_udt_name;
                        if (!colInfo.type.empty() && colInfo.type[0] == '_') colInfo.type.erase(0, 1);
                        colInfo.type += "[]";
                    } else if (pg_udt_name.empty() || pg_udt_name == "anyelement" || pg_udt_name == "anyarray") {
                        colInfo.type = pg_data_type;
                    } else {
                        colInfo.type = pg_udt_name;
                    }
                    std::string nullable_str_pg = query.value(rec_meta.indexOf("is_nullable")).toString();
                    std::transform(nullable_str_pg.begin(), nullable_str_pg.end(), nullable_str_pg.begin(), ::toupper);
                    colInfo.is_nullable = (nullable_str_pg == "YES");
                    colInfo.default_value = query.value(rec_meta.indexOf("column_default")).toString();
                    colInfo.collation_name = query.value(rec_meta.indexOf("collation_name")).toString();
                }
                if (!colInfo.name.empty()) {
                    colInfo.normalized_type = normalizeDbType(colInfo.type, driverNameUpper);
                    columns[colInfo.name] = colInfo;
                }
            }
            return columns;
        }

        Error migrateModifyColumns(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            qInfo() << "migrateModifyColumns: Checking columns for table '" << QString::fromStdString(meta.table_name) << "'...";
            std::map<std::string, DbColumnInfo> existing_db_columns = getTableColumnsInfo(session, QString::fromStdString(meta.table_name), driverNameUpper);

            if (existing_db_columns.empty() && (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
                qWarning() << "migrateModifyColumns: getTableColumnsInfo returned no columns for table '" << QString::fromStdString(meta.table_name) << "' with driver '" << driverNameUpper << "'. Assuming columns need to be added or table was just created if this is the first run.";
            }

            for (const auto &model_field : meta.fields) {
                if (has_flag(model_field.flags, FieldFlag::Association) || model_field.db_name.empty()) {
                    continue;
                }

                std::string model_sql_type_str = Session::getSqlTypeForCppType(model_field, driverNameUpper);
                std::string model_normalized_sql_type = normalizeDbType(model_sql_type_str, driverNameUpper);

                auto it_db_col = existing_db_columns.find(model_field.db_name);
                if (it_db_col == existing_db_columns.end()) {
                    qInfo() << "migrateModifyColumns: Column '" << QString::fromStdString(model_field.db_name) << "' not found in existing DB schema for table '" << QString::fromStdString(meta.table_name) << "'. Attempting to ADD.";

                    std::string add_col_sql_str = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " ADD COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " + model_sql_type_str;

                    // No 'pk_col_db_names_for_constraint' in this function's scope.
                    // Primary Key with AUTOINCREMENT for SQLite should be handled by Session::getSqlTypeForCppType
                    // returning "INTEGER PRIMARY KEY AUTOINCREMENT" or similar if model_field is PK+AI.
                    // Or, if it's a table constraint, it's handled in migrateCreateTable.
                    // Adding column-level PK here is generally not right unless it's the only way for a specific DB.
                    if (has_flag(model_field.flags, FieldFlag::NotNull)) {
                        add_col_sql_str += " NOT NULL";
                    }

                    if (has_flag(model_field.flags, FieldFlag::Unique) && !has_flag(model_field.flags, FieldFlag::PrimaryKey)) {
                        add_col_sql_str += " UNIQUE";
                    }
                    if ((driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") && has_flag(model_field.flags, FieldFlag::AutoIncrement) &&
                        model_sql_type_str.find("AUTO_INCREMENT") == std::string::npos) {  // Check if type string already has it
                        add_col_sql_str += " AUTO_INCREMENT";
                    }
                    add_col_sql_str += ";";

                    qInfo() << "migrateModifyColumns (ADD DDL): " << QString::fromStdString(add_col_sql_str);
                    auto [_, add_err] = execute_ddl_query(session.getDbHandle(), add_col_sql_str);
                    if (add_err) {
                        qWarning() << "migrateModifyColumns: Failed to ADD column '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(add_err.toString());
                    }
                } else {  // Column exists, check for modifications
                    DbColumnInfo &db_col = it_db_col->second;
                    bool needs_alter_type = false;
                    bool needs_alter_notnull = false;

                    if (model_normalized_sql_type != db_col.normalized_type) {
                        needs_alter_type = true;
                        if (driverNameUpper == "QSQLITE" && ((model_normalized_sql_type == "text" && db_col.normalized_type == "varchar") || (model_normalized_sql_type == "varchar" && db_col.normalized_type == "text"))) {
                            needs_alter_type = false;
                        } else if ((model_normalized_sql_type == "int" && db_col.normalized_type == "bigint") || (model_normalized_sql_type == "smallint" && (db_col.normalized_type == "int" || db_col.normalized_type == "bigint"))) {
                            qInfo() << "migrateModifyColumns: Model requests narrowing integer conversion for column '" << QString::fromStdString(model_field.db_name) << "' from DB type '" << QString::fromStdString(db_col.type) << "' to model type '" << QString::fromStdString(model_sql_type_str)
                                    << "'. Skipping automatic type alteration to prevent data loss.";
                            needs_alter_type = false;
                        }
                    }

                    bool model_is_not_null = has_flag(model_field.flags, FieldFlag::NotNull);
                    if (model_is_not_null == db_col.is_nullable) {  // db_col.is_nullable is true if it *can* be null. So if model says NOT NULL (true) and db says IS NULLABLE (true), then they mismatch.
                        needs_alter_notnull = true;
                    }

                    if (needs_alter_type || needs_alter_notnull) {
                        qInfo() << "migrateModifyColumns: Mismatch or desired change for column '" << QString::fromStdString(model_field.db_name) << "'. DB type: '" << QString::fromStdString(db_col.type) << "' (norm: " << QString::fromStdString(db_col.normalized_type)
                                << "), is_nullable:" << db_col.is_nullable << ". Model type: '" << QString::fromStdString(model_sql_type_str) << "' (norm: " << QString::fromStdString(model_normalized_sql_type) << "), not_null:" << model_is_not_null << ". Attempting to MODIFY.";

                        std::string alter_col_sql_str_main;
                        if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                            alter_col_sql_str_main = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " MODIFY COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " + model_sql_type_str;
                            if (model_is_not_null)
                                alter_col_sql_str_main += " NOT NULL";
                            else
                                alter_col_sql_str_main += " NULL";
                            if (has_flag(model_field.flags, FieldFlag::AutoIncrement) && model_sql_type_str.find("AUTO_INCREMENT") == std::string::npos) {
                                alter_col_sql_str_main += " AUTO_INCREMENT";
                            }
                            alter_col_sql_str_main += ";";
                        } else if (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") {
                            if (needs_alter_type) {
                                std::string alter_type_sql = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " ALTER COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " TYPE " + model_sql_type_str + ";";
                                qInfo() << "migrateModifyColumns (PG TYPE DDL): " << QString::fromStdString(alter_type_sql);
                                auto [_, alter_type_err] = execute_ddl_query(session.getDbHandle(), alter_type_sql);
                                if (alter_type_err) qWarning() << "migrateModifyColumns: Failed to MODIFY PG column TYPE for '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(alter_type_err.toString());
                            }
                            if (needs_alter_notnull) {
                                std::string alter_null_sql = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " ALTER COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + (model_is_not_null ? " SET NOT NULL;" : " DROP NOT NULL;");
                                qInfo() << "migrateModifyColumns (PG NULL DDL): " << QString::fromStdString(alter_null_sql);
                                auto [_, alter_null_err] = execute_ddl_query(session.getDbHandle(), alter_null_sql);
                                if (alter_null_err) qWarning() << "migrateModifyColumns: Failed to MODIFY PG column NULLABILITY for '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(alter_null_err.toString());
                            }
                            continue;
                        } else if (driverNameUpper == "QSQLITE") {
                            qWarning() << "migrateModifyColumns: SQLite has very limited ALTER TABLE support for modifying columns. Change for '" << QString::fromStdString(model_field.db_name) << "' skipped.";
                            continue;
                        } else {
                            qWarning() << "migrateModifyColumns: Don't know how to alter column for driver " << driverNameUpper << ". Column '" << QString::fromStdString(model_field.db_name) << "' alteration skipped.";
                            continue;
                        }

                        if (!alter_col_sql_str_main.empty()) {
                            qInfo() << "migrateModifyColumns (MODIFY DDL): " << QString::fromStdString(alter_col_sql_str_main);
                            auto [_, alter_err] = execute_ddl_query(session.getDbHandle(), alter_col_sql_str_main);
                            if (alter_err) {
                                qWarning() << "migrateModifyColumns: Failed to MODIFY column '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(alter_err.toString());
                            }
                        }
                    }
                }
            }
            return make_ok();
        }

    }  // namespace internal
}  // namespace cpporm// Base/CppOrm/Source/session_migrate_index_ops.cpp
#include <QDebug>
#include <QHash>  // For qHash
#include <QString>
#include <algorithm>
#include <set>

#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"  // Should contain normalizeDbType declaration
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_field.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_record.h"

namespace cpporm {
    namespace internal {

        // 确保此函数定义存在且未被注释掉
        bool areIndexDefinitionsEquivalent(const DbIndexInfo &db_idx, const IndexDefinition &model_idx_def, const QString &driverNameUpper) {
            (void)driverNameUpper;  // Not used currently but could be for driver-specific logic
            if (db_idx.is_unique != model_idx_def.is_unique) return false;
            if (db_idx.column_names.size() != model_idx_def.db_column_names.size()) return false;

            // Column order matters for index definition equivalence
            for (size_t i = 0; i < db_idx.column_names.size(); ++i) {
                std::string db_col_lower = db_idx.column_names[i];
                std::string model_col_lower = model_idx_def.db_column_names[i];
                std::transform(db_col_lower.begin(), db_col_lower.end(), db_col_lower.begin(), [](unsigned char c) {
                    return static_cast<char>(std::tolower(c));
                });
                std::transform(model_col_lower.begin(), model_col_lower.end(), model_col_lower.begin(), [](unsigned char c) {
                    return static_cast<char>(std::tolower(c));
                });
                if (db_col_lower != model_col_lower) return false;
            }

            // Compare index type/method if both are specified (case-insensitive)
            if (!model_idx_def.type_str.empty() && !db_idx.type_method.empty()) {
                std::string model_type_lower = model_idx_def.type_str;
                std::string db_type_lower = db_idx.type_method;
                std::transform(model_type_lower.begin(), model_type_lower.end(), model_type_lower.begin(), [](unsigned char c) {
                    return static_cast<char>(std::tolower(c));
                });
                std::transform(db_type_lower.begin(), db_type_lower.end(), db_type_lower.begin(), [](unsigned char c) {
                    return static_cast<char>(std::tolower(c));
                });
                if (model_type_lower != db_type_lower) {
                    return false;
                }
            } else if (!model_idx_def.type_str.empty() && db_idx.type_method.empty()) {
                // Model specifies a type, DB does not report one (or reports default which was filtered out or is empty)
                // This could be a difference if the DB default type is not what model expects and model explicitly wants something else.
                return false;
            }
            // Note: Index condition (model_idx_def.condition_str for partial indexes) is not deeply compared here.
            // A full comparison would require parsing DB index definition or more detailed DB schema queries.
            return true;
        }

        std::map<std::string, DbIndexInfo> getTableIndexesInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper) {
            std::map<std::string, DbIndexInfo> indexes;
            cpporm_sqldriver::SqlQuery query(session.getDbHandle());
            std::string sql_std;
            std::string tableNameStd = tableNameQString.toStdString();

            if (driverNameUpper == "QSQLITE") {
                sql_std = "PRAGMA index_list(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (SQLite): Failed to get index list for" << tableNameQString << ":" << QString::fromStdString(query.lastError().text());
                    return indexes;
                }
                std::vector<DbIndexInfo> temp_index_list_sqlite;
                cpporm_sqldriver::SqlRecord rec_meta_idxlist = query.recordMetadata();
                while (query.next()) {
                    DbIndexInfo idx_base_info;
                    idx_base_info.index_name = query.value(rec_meta_idxlist.indexOf("name")).toString();
                    idx_base_info.is_unique = query.value(rec_meta_idxlist.indexOf("unique")).toInt32() == 1;
                    std::string origin = query.value(rec_meta_idxlist.indexOf("origin")).toString();
                    if (QString::fromStdString(idx_base_info.index_name).startsWith("sqlite_autoindex_") || origin == "pk" || origin == "u") {  // SQLite 自动索引或主键/唯一约束索引
                        if (origin == "pk") idx_base_info.is_primary_key = true;                                                                // 标记是主键
                        // continue; // 不再跳过，而是收集它们，并在后面与模型定义比较时可能跳过
                    }
                    temp_index_list_sqlite.push_back(idx_base_info);
                }

                for (DbIndexInfo &idx_info_ref : temp_index_list_sqlite) {
                    std::string idx_info_sql_std = "PRAGMA index_xinfo(" + QueryBuilder::quoteSqlIdentifier(idx_info_ref.index_name) + ");";
                    if (!query.exec(idx_info_sql_std)) {
                        idx_info_sql_std = "PRAGMA index_info(" + QueryBuilder::quoteSqlIdentifier(idx_info_ref.index_name) + ");";  // Fallback for older SQLite
                        if (!query.exec(idx_info_sql_std)) {
                            qWarning() << "getTableIndexesInfo (SQLite): Failed to get info for index" << QString::fromStdString(idx_info_ref.index_name) << ":" << QString::fromStdString(query.lastError().text());
                            continue;
                        }
                    }
                    std::vector<std::pair<int, std::string>> col_order_pairs;
                    cpporm_sqldriver::SqlRecord rec_meta_idxinfo = query.recordMetadata();
                    bool use_cid = rec_meta_idxinfo.contains("cid");  // Check if 'cid' (column ID) column exists for sorting

                    while (query.next()) {
                        cpporm_sqldriver::SqlValue col_name_val = query.value(rec_meta_idxinfo.indexOf("name"));
                        std::string col_name_str = col_name_val.isNull() ? "" : col_name_val.toString();
                        if (!col_name_str.empty()) {
                            col_order_pairs.push_back({query.value(rec_meta_idxinfo.indexOf(use_cid ? "cid" : "seqno")).toInt32(), col_name_str});
                        }
                    }
                    std::sort(col_order_pairs.begin(), col_order_pairs.end());  // Sort by sequence number
                    for (const auto &p : col_order_pairs) idx_info_ref.column_names.push_back(p.second);

                    if (!idx_info_ref.column_names.empty()) indexes[idx_info_ref.index_name] = idx_info_ref;
                }

            } else if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                sql_std = "SHOW INDEX FROM " + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ";";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (MySQL/MariaDB): Failed for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return indexes;
                }

                // SHOW INDEX 返回每个索引列一行，需要聚合
                std::map<std::string, DbIndexInfo> temp_building_indexes;
                cpporm_sqldriver::SqlRecord rec_meta_mysql = query.recordMetadata();
                while (query.next()) {
                    std::string idx_name_str = query.value(rec_meta_mysql.indexOf("Key_name")).toString();
                    DbIndexInfo &current_idx_ref = temp_building_indexes[idx_name_str];  // Creates if not exists

                    if (current_idx_ref.index_name.empty()) {  // First time seeing this index name
                        current_idx_ref.index_name = idx_name_str;
                        current_idx_ref.is_unique = (query.value(rec_meta_mysql.indexOf("Non_unique")).toInt32() == 0);
                        current_idx_ref.is_primary_key = (idx_name_str == "PRIMARY");
                        current_idx_ref.type_method = query.value(rec_meta_mysql.indexOf("Index_type")).toString();
                    }

                    unsigned int seq = query.value(rec_meta_mysql.indexOf("Seq_in_index")).toUInt32();
                    std::string col_name_to_add = query.value(rec_meta_mysql.indexOf("Column_name")).toString();
                    if (current_idx_ref.column_names.size() < seq) {
                        current_idx_ref.column_names.resize(seq);
                    }
                    current_idx_ref.column_names[seq - 1] = col_name_to_add;  // Seq_in_index is 1-based
                }
                for (const auto &pair_val : temp_building_indexes) {
                    // if (pair_val.second.is_primary_key) continue; // 不再跳过主键，让areIndexDefinitionsEquivalent处理
                    if (!pair_val.second.column_names.empty()) indexes[pair_val.first] = pair_val.second;
                }

            } else if (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") {
                sql_std =
                    "SELECT idx.relname AS index_name, att.attname AS column_name, "
                    "i.indisunique AS is_unique, "
                    "i.indisprimary AS is_primary, am.amname AS index_type, "
                    "array_position(i.indkey, att.attnum) as column_seq "  // 使用 array_position 获取顺序
                    "FROM   pg_index i "
                    "JOIN   pg_class tbl ON tbl.oid = i.indrelid "
                    "JOIN   pg_class idx ON idx.oid = i.indexrelid "
                    "JOIN   pg_attribute att ON att.attrelid = tbl.oid AND att.attnum = ANY(i.indkey) "
                    "LEFT JOIN pg_am am ON am.oid = idx.relam "
                    "WHERE  tbl.relname = '" +
                    tableNameStd +
                    "' AND tbl.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = current_schema()) "
                    "ORDER BY index_name, column_seq;";  // 按索引名和列顺序排序
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (PostgreSQL): Failed for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return indexes;
                }

                std::map<std::string, DbIndexInfo> temp_building_indexes_pg;
                cpporm_sqldriver::SqlRecord rec_meta_pg = query.recordMetadata();
                while (query.next()) {
                    std::string idx_name_str = query.value(rec_meta_pg.indexOf("index_name")).toString();
                    DbIndexInfo &current_idx_ref = temp_building_indexes_pg[idx_name_str];

                    if (current_idx_ref.index_name.empty()) {
                        current_idx_ref.index_name = idx_name_str;
                        current_idx_ref.is_unique = query.value(rec_meta_pg.indexOf("is_unique")).toBool();
                        current_idx_ref.is_primary_key = query.value(rec_meta_pg.indexOf("is_primary")).toBool();
                        current_idx_ref.type_method = query.value(rec_meta_pg.indexOf("index_type")).toString();
                    }
                    // 列已经按 column_seq 排序，所以直接追加
                    current_idx_ref.column_names.push_back(query.value(rec_meta_pg.indexOf("column_name")).toString());
                }
                for (const auto &pair_val : temp_building_indexes_pg) {
                    // if (pair_val.second.is_primary_key) continue; // 不再跳过
                    if (!pair_val.second.column_names.empty()) indexes[pair_val.first] = pair_val.second;
                }
            } else {
                qWarning() << "getTableIndexesInfo: Unsupported driver for index info:" << driverNameUpper;
            }
            return indexes;
        }

        Error migrateManageIndexes(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            qInfo() << "migrateManageIndexes: Managing indexes for table '" << QString::fromStdString(meta.table_name) << "'...";
            std::map<std::string, DbIndexInfo> existing_db_indexes = getTableIndexesInfo(session, QString::fromStdString(meta.table_name), driverNameUpper);

            // Log an informational message if no indexes are found, but don't treat as error immediately.
            if (existing_db_indexes.empty() && (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
                qInfo() << "migrateManageIndexes: getTableIndexesInfo returned no user-defined indexes for table '" << QString::fromStdString(meta.table_name) << "' (MySQL/MariaDB). This is normal if only PRIMARY KEY exists or table is new.";
            }

            std::set<std::string> model_index_names_processed;

            for (const auto &model_idx_def_const : meta.indexes) {
                IndexDefinition model_idx_def = model_idx_def_const;  // Work with a copy to modify name if needed
                if (model_idx_def.db_column_names.empty()) {
                    qWarning() << "migrateManageIndexes: Model index definition for table '" << QString::fromStdString(meta.table_name) << "' (intended name: '" << QString::fromStdString(model_idx_def.index_name) << "') has no columns. Skipping.";
                    continue;
                }

                // Auto-generate index name if not provided
                if (model_idx_def.index_name.empty()) {
                    std::string auto_name_str = (model_idx_def.is_unique ? "uix_" : "idx_") + meta.table_name;
                    for (const auto &col_name_std : model_idx_def.db_column_names) {
                        std::string temp_col_name = col_name_std;
                        std::replace_if(
                            temp_col_name.begin(),
                            temp_col_name.end(),
                            [](char c) {
                                return !std::isalnum(c) && c != '_';
                            },
                            '_');
                        auto_name_str += "_" + temp_col_name;
                    }
                    // Ensure name is not too long for MySQL/MariaDB (common limit is 64 chars)
                    if (auto_name_str.length() > 60) {  // Leave some room for potential suffixes from DB
                        QString q_auto_name_str = QString::fromStdString(auto_name_str);
                        // Use qHash for a short, somewhat unique suffix
                        uint hash_val = qHash(q_auto_name_str + QString::number(model_idx_def.is_unique ? 1 : 0));
                        QString hash_suffix = QString::number(hash_val, 16).left(8);  // 8 hex chars
                        auto_name_str = q_auto_name_str.left(static_cast<int>(60 - 1 - hash_suffix.length())).toStdString() + "_" + hash_suffix.toStdString();
                    }
                    model_idx_def.index_name = auto_name_str;
                }
                model_index_names_processed.insert(model_idx_def.index_name);

                auto it_db_idx = existing_db_indexes.find(model_idx_def.index_name);
                bool needs_create = true;
                bool needs_drop_first = false;

                if (it_db_idx != existing_db_indexes.end()) {
                    if (it_db_idx->second.is_primary_key && model_idx_def.index_name == "PRIMARY") {  // MySQL PRIMARY KEY
                        qInfo() << "migrateManageIndexes: Model index definition for PRIMARY KEY on '" << QString::fromStdString(meta.table_name) << "' matches DB PRIMARY KEY. Management delegated to column/table PK definition.";
                        needs_create = false;
                    } else if (areIndexDefinitionsEquivalent(it_db_idx->second, model_idx_def, driverNameUpper)) {
                        qInfo() << "migrateManageIndexes: Index '" << QString::fromStdString(model_idx_def.index_name) << "' matches existing DB index. No changes.";
                        needs_create = false;
                    } else {
                        qInfo() << "migrateManageIndexes: Index '" << QString::fromStdString(model_idx_def.index_name) << "' exists but definition differs. Will DROP and RECREATE.";
                        needs_drop_first = true;
                    }
                }

                if (needs_drop_first) {
                    std::string drop_sql_std = "DROP INDEX " + QueryBuilder::quoteSqlIdentifier(model_idx_def.index_name);
                    if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                        drop_sql_std += " ON " + QueryBuilder::quoteSqlIdentifier(meta.table_name);
                    }
                    drop_sql_std += ";";
                    qInfo() << "migrateManageIndexes (DROP DDL): " << QString::fromStdString(drop_sql_std);
                    auto [_, drop_err] = execute_ddl_query(session.getDbHandle(), drop_sql_std);
                    if (drop_err) {
                        qWarning() << "migrateManageIndexes: Failed to DROP index '" << QString::fromStdString(model_idx_def.index_name) << "': " << QString::fromStdString(drop_err.toString());
                        // If drop fails, we probably shouldn't proceed to create.
                        // However, for idempotency, if it's "index not found", that's okay.
                        // For now, continue to attempt creation.
                    }
                }

                if (needs_create) {
                    std::string cols_sql_part;
                    for (size_t i = 0; i < model_idx_def.db_column_names.size(); ++i) {
                        std::string col_name_for_index = model_idx_def.db_column_names[i];
                        std::string col_quoted_name = QueryBuilder::quoteSqlIdentifier(col_name_for_index);

                        const FieldMeta *field = meta.findFieldByDbName(col_name_for_index);
                        if (field && (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
                            bool needs_mysql_prefix = false;
                            if (!field->db_type_hint.empty()) {
                                std::string hint_upper = field->db_type_hint;
                                std::transform(hint_upper.begin(), hint_upper.end(), hint_upper.begin(), ::toupper);
                                if (hint_upper.find("TEXT") != std::string::npos || hint_upper.find("BLOB") != std::string::npos || hint_upper.find("JSON") != std::string::npos) {
                                    needs_mysql_prefix = true;
                                }
                                // Don't add prefix if hint is already VARCHAR(N)
                                if (hint_upper.rfind("VARCHAR(", 0) == 0) {
                                    needs_mysql_prefix = false;
                                }
                            } else {
                                std::string cpp_type_sql = Session::getSqlTypeForCppType(*field, driverNameUpper);
                                std::string cpp_type_sql_upper = cpp_type_sql;
                                std::transform(cpp_type_sql_upper.begin(), cpp_type_sql_upper.end(), cpp_type_sql_upper.begin(), ::toupper);
                                if (cpp_type_sql_upper.find("TEXT") != std::string::npos || cpp_type_sql_upper.find("BLOB") != std::string::npos || cpp_type_sql_upper.find("JSON") != std::string::npos) {
                                    needs_mysql_prefix = true;
                                }
                            }
                            if (needs_mysql_prefix) {
                                col_quoted_name += "(255)";
                            }
                        }
                        cols_sql_part += col_quoted_name;
                        if (i < model_idx_def.db_column_names.size() - 1) cols_sql_part += ", ";
                    }

                    std::string create_sql_std = "CREATE " + std::string(model_idx_def.is_unique ? "UNIQUE " : "") + "INDEX ";

                    create_sql_std += QueryBuilder::quoteSqlIdentifier(model_idx_def.index_name) + " ON " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " (" + cols_sql_part + ")";

                    if (!model_idx_def.type_str.empty() && (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL" || driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
                        create_sql_std += " USING " + model_idx_def.type_str;
                    }
                    if (!model_idx_def.condition_str.empty() && (driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL")) {  // Partial index condition
                        create_sql_std += " WHERE (" + model_idx_def.condition_str + ")";
                    }
                    create_sql_std += ";";

                    qInfo() << "migrateManageIndexes (CREATE DDL): " << QString::fromStdString(create_sql_std);
                    auto [_, create_err] = execute_ddl_query(session.getDbHandle(), create_sql_std);
                    if (create_err) {
                        bool ignorable_already_exists_error = false;
                        std::string err_msg_lower = create_err.message;
                        std::transform(err_msg_lower.begin(), err_msg_lower.end(), err_msg_lower.begin(), ::tolower);

                        if (((driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") && create_err.native_db_error_code == 1061 /*ER_DUP_KEYNAME*/) ||
                            (driverNameUpper == "QSQLITE" && err_msg_lower.find("already exists") != std::string::npos) ||
                            ((driverNameUpper == "QPSQL" || driverNameUpper == "POSTGRESQL") && (create_err.sql_state == "42P07" /*duplicate_table (for index)*/ || create_err.sql_state == "42710" /*duplicate_object (general)*/))) {
                            ignorable_already_exists_error = true;
                        }

                        if (ignorable_already_exists_error && !needs_drop_first) {
                            qInfo() << "migrateManageIndexes: Index " << QString::fromStdString(model_idx_def.index_name) << " likely already exists (or an equivalent one with a different name if DB enforces uniqueness on columns): " << QString::fromStdString(create_err.toString());
                        } else if (!ignorable_already_exists_error) {
                            qWarning() << "migrateManageIndexes: Failed to CREATE index '" << QString::fromStdString(model_idx_def.index_name) << "': " << QString::fromStdString(create_err.toString());
                        }
                    }
                }
            }
            // Optionally drop indexes from DB that are not in model_index_names_processed
            for (const auto &[db_idx_name, db_idx_info] : existing_db_indexes) {
                if (db_idx_info.is_primary_key && (db_idx_name == "PRIMARY" || QString::fromStdString(db_idx_name).startsWith("sqlite_autoindex_"))) {  // Don't try to drop PKs or SQLite auto-indexes
                    continue;
                }
                if (model_index_names_processed.find(db_idx_name) == model_index_names_processed.end()) {
                    qInfo() << "migrateManageIndexes: Index '" << QString::fromStdString(db_idx_name) << "' exists in DB but not in model definition. Consider dropping it manually if no longer needed.";
                    // Example: Drop if needed (use with caution)
                    /*
                    std::string drop_extra_sql_std = "DROP INDEX " + QueryBuilder::quoteSqlIdentifier(db_idx_name);
                    if (driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                        drop_extra_sql_std += " ON " + QueryBuilder::quoteSqlIdentifier(meta.table_name);
                    }
                    drop_extra_sql_std += ";";
                    qInfo() << "migrateManageIndexes (DROP EXTRA DDL): " << QString::fromStdString(drop_extra_sql_std);
                    auto [_, drop_extra_err] = execute_ddl_query(session.getDbHandle(), drop_extra_sql_std);
                    if (drop_extra_err) {
                        qWarning() << "migrateManageIndexes: Failed to DROP extra index '" << QString::fromStdString(db_idx_name) << "': " << QString::fromStdString(drop_extra_err.toString());
                    }
                    */
                }
            }
            return make_ok();
        }

    }  // namespace internal
}  // namespace cpporm// Base/CppOrm/Source/session_migrate_ops.cpp
#include "cpporm/model_base.h"
// #include "cpporm/qt_db_manager.h" // Replaced
#include <QDebug>

#include "cpporm/db_manager.h"  // Use new DbManager
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"
// #include <QSqlDriver> // Replaced by cpporm_sqldriver features
// #include <QSqlError> // Replaced by cpporm_sqldriver::SqlError
// #include <QSqlQuery> // Replaced by cpporm_sqldriver::SqlQuery
// #include <QSqlRecord> // Replaced by cpporm_sqldriver::SqlRecord
#include <algorithm>
#include <set>

// Include cpporm_sqldriver types
#include "sqldriver/sql_database.h"

namespace cpporm {

    Error Session::AutoMigrate(const ModelMeta &meta) {
        // db_handle_ is now cpporm_sqldriver::SqlDatabase
        if (!db_handle_.isOpen()) {
            if (!db_handle_.open()) {                                     // SqlDatabase::open()
                cpporm_sqldriver::SqlError err = db_handle_.lastError();  // SqlDatabase::lastError()
                return Error(ErrorCode::ConnectionNotOpen,
                             "Cannot AutoMigrate: Database connection is not open and "
                             "failed to open: " +
                                 err.text());  // SqlError::text()
            }
        }
        if (meta.table_name.empty()) {
            return Error(ErrorCode::InvalidConfiguration, "Cannot AutoMigrate: ModelMeta has no table name.");
        }
        qInfo() << "AutoMigrate: Starting migration for table '" << QString::fromStdString(meta.table_name) << "'...";

        // SqlDatabase::driverName() returns std::string
        QString driverNameUpper = QString::fromStdString(db_handle_.driverName()).toUpper();

        Error table_err = internal::migrateCreateTable(*this, meta, driverNameUpper);
        if (table_err) {
            qWarning() << "AutoMigrate: Failed during table creation for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(table_err.toString());
            return table_err;
        }
        qInfo() << "AutoMigrate: Table creation/check phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        Error column_err = internal::migrateModifyColumns(*this, meta, driverNameUpper);
        if (column_err) {
            qWarning() << "AutoMigrate: Failed during column modification for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(column_err.toString());
            return column_err;
        }
        qInfo() << "AutoMigrate: Column modification phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        Error index_err = internal::migrateManageIndexes(*this, meta, driverNameUpper);
        if (index_err) {
            qWarning() << "AutoMigrate: Failed during index management for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(index_err.toString());
            return index_err;
        }
        qInfo() << "AutoMigrate: Index management phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        qInfo() << "AutoMigrate: Migration successfully completed for table '" << QString::fromStdString(meta.table_name) << "'.";
        return make_ok();
    }

    Error Session::AutoMigrate(const std::vector<const ModelMeta *> &metas_vec) {
        for (const auto *m_ptr : metas_vec) {
            if (m_ptr) {
                if (auto e_obj = AutoMigrate(*m_ptr)) {
                    return e_obj;
                }
            } else {
                qWarning() << "AutoMigrate (vector): Encountered a null ModelMeta "
                              "pointer. Skipping.";
            }
        }
        qInfo() << "AutoMigrate: Batch migration completed for" << metas_vec.size() << "models.";
        return make_ok();
    }

}  // namespace cpporm// Base/CppOrm/Source/session_migrate_table_ops.cpp
#include <QDebug>
#include <QString>
#include <mutex>  // For model factory registry lock

#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"  // Contains declarations
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_query.h"

namespace cpporm {
    namespace internal {

        Error migrateCreateTable(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            if (meta.table_name.empty()) {
                return Error(ErrorCode::InvalidConfiguration, "migrateCreateTable: ModelMeta has no table name.");
            }

            std::vector<std::string> column_definitions_sql;
            std::vector<std::string> pk_col_db_names_for_table_constraint;  // Renamed for clarity
            std::vector<std::string> table_constraints_sql;

            for (const auto &field : meta.fields) {  // Loop variable is 'field'
                if (has_flag(field.flags, FieldFlag::Association) || field.db_name.empty()) {
                    continue;
                }

                std::string col_def_str = QueryBuilder::quoteSqlIdentifier(field.db_name);
                std::string field_sql_type = Session::getSqlTypeForCppType(field, driverNameUpper);

                // Special handling for SQLite INTEGER PRIMARY KEY AUTOINCREMENT
                if (driverNameUpper == "QSQLITE" && has_flag(field.flags, FieldFlag::PrimaryKey) && has_flag(field.flags, FieldFlag::AutoIncrement) && (field.cpp_type == typeid(int) || field.cpp_type == typeid(long long))) {
                    // For SQLite, "INTEGER PRIMARY KEY AUTOINCREMENT" is a column definition.
                    // Ensure getSqlTypeForCppType returns "INTEGER" and we add the rest.
                    if (field_sql_type == "INTEGER") {  // Assuming getSqlType returns base type
                        field_sql_type += " PRIMARY KEY AUTOINCREMENT";
                    } else {
                        qWarning() << "migrateCreateTable: SQLite AUTOINCREMENT PK '" << QString::fromStdString(field.db_name) << "' is not INTEGER type. AUTOINCREMENT keyword might not apply as expected.";
                    }
                    // This column now defines its own PK, so don't add to table-level PK constraint later
                    // if it's the only PK. If composite, table constraint is still needed but this col is already PK.
                } else {
                    if (has_flag(field.flags, FieldFlag::PrimaryKey)) {
                        pk_col_db_names_for_table_constraint.push_back(field.db_name);
                    }
                }

                col_def_str += " " + field_sql_type;

                if ((driverNameUpper == "MYSQL" || driverNameUpper == "MARIADB" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") && has_flag(field.flags, FieldFlag::AutoIncrement) && field_sql_type.find("AUTO_INCREMENT") == std::string::npos &&  // Check if already added by type
                    col_def_str.find("AUTO_INCREMENT") == std::string::npos) {  // Check if already added to col_def_str
                    col_def_str += " AUTO_INCREMENT";
                }

                // NOT NULL constraint (unless already part of PRIMARY KEY for some DBs, but usually separate)
                if (has_flag(field.flags, FieldFlag::NotNull)) {
                    // Avoid redundant "NOT NULL" if type string implies it (e.g., from "INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL")
                    if (field_sql_type.find("NOT NULL") == std::string::npos && col_def_str.find("NOT NULL") == std::string::npos) {
                        col_def_str += " NOT NULL";
                    }
                }

                // UNIQUE constraint for non-primary key columns (handled by column def or explicit index)
                if (has_flag(field.flags, FieldFlag::Unique) && !has_flag(field.flags, FieldFlag::PrimaryKey)) {
                    bool part_of_model_unique_index = false;
                    for (const auto &idx_def : meta.indexes) {
                        if (idx_def.is_unique && idx_def.db_column_names.size() == 1 && idx_def.db_column_names[0] == field.db_name) {
                            part_of_model_unique_index = true;
                            break;
                        }
                    }
                    if (!part_of_model_unique_index && col_def_str.find("UNIQUE") == std::string::npos) {
                        col_def_str += " UNIQUE";
                    }
                }
                column_definitions_sql.push_back(col_def_str);
            }

            // Add table-level PRIMARY KEY constraint if not handled by column def (e.g., composite PKs, or non-SQLite single PKs)
            if (!pk_col_db_names_for_table_constraint.empty()) {
                bool sqlite_single_int_pk_handled_by_col = false;
                if (driverNameUpper == "QSQLITE" && pk_col_db_names_for_table_constraint.size() == 1) {
                    const FieldMeta *pk_field = meta.findFieldByDbName(pk_col_db_names_for_table_constraint[0]);
                    if (pk_field && has_flag(pk_field->flags, FieldFlag::AutoIncrement) && (Session::getSqlTypeForCppType(*pk_field, driverNameUpper).find("PRIMARY KEY AUTOINCREMENT") != std::string::npos)) {
                        sqlite_single_int_pk_handled_by_col = true;
                    } else if (pk_field && (Session::getSqlTypeForCppType(*pk_field, driverNameUpper).find("PRIMARY KEY") != std::string::npos)) {
                        // If type already included "PRIMARY KEY" (e.g. from modified getSqlTypeForCppType for SQLite)
                        sqlite_single_int_pk_handled_by_col = true;
                    }
                }

                if (!sqlite_single_int_pk_handled_by_col) {
                    std::string pk_constraint_str = "PRIMARY KEY (";
                    for (size_t i = 0; i < pk_col_db_names_for_table_constraint.size(); ++i) {
                        pk_constraint_str += QueryBuilder::quoteSqlIdentifier(pk_col_db_names_for_table_constraint[i]);
                        if (i < pk_col_db_names_for_table_constraint.size() - 1) pk_constraint_str += ", ";
                    }
                    pk_constraint_str += ")";
                    table_constraints_sql.push_back(pk_constraint_str);
                }
            }

            for (const auto &assoc : meta.associations) {
                if (assoc.type == AssociationType::BelongsTo && !assoc.foreign_key_db_name.empty()) {
                    std::string fk_col_on_curr_table = assoc.foreign_key_db_name;
                    std::string target_table_name_str;
                    std::string target_pk_col_name_str;

                    cpporm::internal::ModelFactory factory_fn;
                    {
                        std::lock_guard<std::mutex> lock(cpporm::internal::getGlobalModelFactoryRegistryMutex());
                        auto it_factory = cpporm::internal::getGlobalModelFactoryRegistry().find(assoc.target_model_type);
                        if (it_factory != cpporm::internal::getGlobalModelFactoryRegistry().end()) {
                            factory_fn = it_factory->second;
                        }
                    }
                    if (factory_fn) {
                        auto temp_target_model = factory_fn();
                        if (temp_target_model) {
                            const ModelMeta &target_meta = temp_target_model->_getOwnModelMeta();
                            target_table_name_str = target_meta.table_name;
                            if (!assoc.target_model_pk_db_name.empty()) {
                                target_pk_col_name_str = assoc.target_model_pk_db_name;
                            } else if (!target_meta.primary_keys_db_names.empty()) {
                                target_pk_col_name_str = target_meta.primary_keys_db_names[0];
                            }
                        }
                    }

                    if (!target_table_name_str.empty() && !target_pk_col_name_str.empty()) {
                        std::string fk_sql = "FOREIGN KEY (" + QueryBuilder::quoteSqlIdentifier(fk_col_on_curr_table) + ")" + " REFERENCES " + QueryBuilder::quoteSqlIdentifier(target_table_name_str) + " (" + QueryBuilder::quoteSqlIdentifier(target_pk_col_name_str) + ")";
                        table_constraints_sql.push_back(fk_sql);
                    } else {
                        qWarning() << "migrateCreateTable (FK): Could not determine target table/PK for BelongsTo association '" << QString::fromStdString(assoc.cpp_field_name) << "' on table '" << QString::fromStdString(meta.table_name) << "'. FK constraint not created.";
                    }
                }
            }

            std::string all_definitions_sql_str;
            for (size_t i = 0; i < column_definitions_sql.size(); ++i) {
                all_definitions_sql_str += column_definitions_sql[i];
                if (i < column_definitions_sql.size() - 1 || !table_constraints_sql.empty()) {
                    all_definitions_sql_str += ", ";
                }
            }
            for (size_t i = 0; i < table_constraints_sql.size(); ++i) {
                all_definitions_sql_str += table_constraints_sql[i];
                if (i < table_constraints_sql.size() - 1) {
                    all_definitions_sql_str += ", ";
                }
            }
            while (!all_definitions_sql_str.empty() && (all_definitions_sql_str.back() == ',' || all_definitions_sql_str.back() == ' ')) {
                all_definitions_sql_str.pop_back();
            }

            if (all_definitions_sql_str.empty()) {
                return Error(ErrorCode::InvalidConfiguration, "migrateCreateTable: No column definitions or constraints generated for table '" + meta.table_name + "'.");
            }

            std::string create_table_ddl_std = "CREATE TABLE IF NOT EXISTS " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " (" + all_definitions_sql_str + ");";

            qInfo() << "migrateCreateTable (DDL for " << QString::fromStdString(meta.table_name) << "): " << QString::fromStdString(create_table_ddl_std);

            auto [_, err_obj] = execute_ddl_query(session.getDbHandle(), create_table_ddl_std);
            return err_obj;
        }

        // execute_ddl_query is correctly defined here or in session_migrate_priv.h/utils
        // ... (execute_ddl_query definition as before) ...
        std::pair<cpporm_sqldriver::SqlQuery, Error> execute_ddl_query(cpporm_sqldriver::SqlDatabase &db, const std::string &ddl_sql_std) {
            if (!db.isOpen()) {
                if (!db.open()) {
                    cpporm_sqldriver::SqlError err = db.lastError();
                    qWarning() << "execute_ddl_query: Failed to open database for DDL:" << QString::fromStdString(err.text()) << "SQL:" << QString::fromStdString(ddl_sql_std);
                    return std::make_pair(cpporm_sqldriver::SqlQuery(db), Error(ErrorCode::ConnectionNotOpen, "Failed to open database for DDL: " + err.text(), err.nativeErrorCodeNumeric()));
                }
            }
            return Session::execute_query_internal(db, ddl_sql_std, {});
        }

    }  // namespace internal
}  // namespace cpporm// cpporm/session_migrate_utils.cpp (新文件 - 目前为空或只包含辅助声明)
#include "cpporm/session_migrate_priv.h" // For DbColumnInfo, DbIndexInfo potentially if utils are complex

// This file can contain utility functions shared across migration operations.
// For example:
// - More sophisticated DB type normalization.
// - Helpers to parse specific DB information (e.g., default values, constraints
// from strings).
// - If getSqlTypeForCppType is made a free function, it could live here.

namespace cpporm {
namespace internal {

// Example: If getSqlTypeForCppType were moved here:
/*
std::string getSqlTypeForModelField_utility_moved(const FieldMeta &field_meta,
const QString &driverNameUpper) {
    // ... implementation ...
    if (!field_meta.db_type_hint.empty()) return field_meta.db_type_hint;
    // ... rest of type mapping logic ...
    return "TEXT"; // Fallback
}
*/

// Currently, most logic is within the _column_ops.cpp and _index_ops.cpp.
// If common patterns emerge during their full implementation, they can be
// refactored here.

} // namespace internal
} // namespace cpporm#include <QDebug>     // For qWarning
#include <algorithm>  // For std::transform
#include <any>
#include <map>
#include <memory>
#include <mutex>  // For global registry lock
#include <set>    // Not used in current version of this file
#include <string>
#include <vector>

#include "cpporm/i_query_executor.h"  // Not directly used here, but Session uses it
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"

// SqlDriver types are not directly used in this file's logic after Session methods are called,
// but Session's FindImpl will use them internally.

namespace cpporm {

    // any_to_string_for_map_key_in_preload_util remains largely the same,
    // as it converts C++ types from model fields to string keys.
    // QVariant types like QDateTime, QDate are still valid C++ field types.
    static std::string any_to_string_for_map_key_in_preload_util(const std::any &val) {
        if (!val.has_value()) return "__cpporm_NULL_KEY__";

        const auto &type = val.type();
        if (type == typeid(int)) return "i_" + std::to_string(std::any_cast<int>(val));
        if (type == typeid(long long)) return "ll_" + std::to_string(std::any_cast<long long>(val));
        if (type == typeid(unsigned int)) return "ui_" + std::to_string(std::any_cast<unsigned int>(val));
        if (type == typeid(unsigned long long)) return "ull_" + std::to_string(std::any_cast<unsigned long long>(val));
        if (type == typeid(std::string)) return "s_" + std::any_cast<std::string>(val);
        if (type == typeid(const char *)) return "s_" + std::string(std::any_cast<const char *>(val));
        if (type == typeid(QDateTime)) return "dt_" + std::any_cast<QDateTime>(val).toUTC().toString(Qt::ISODateWithMs).toStdString();
        if (type == typeid(QDate)) return "d_" + std::any_cast<QDate>(val).toString(Qt::ISODate).toStdString();
        if (type == typeid(bool)) return "b_" + std::string(std::any_cast<bool>(val) ? "true" : "false");
        if (type == typeid(double)) return "dbl_" + std::to_string(std::any_cast<double>(val));
        if (type == typeid(float)) return "flt_" + std::to_string(std::any_cast<float>(val));
        // Add QByteArray if it can be a key
        if (type == typeid(QByteArray)) {  // UUIDs might be QByteArray or string
            // Convert QByteArray to hex string for a stable key
            return "ba_" + std::any_cast<QByteArray>(val).toHex().toStdString();
        }

        qWarning() << "any_to_string_for_map_key_in_preload_util: Unsupported std::any type ('" << val.type().name() << "') for map key generation during preload. ";
        return "__cpporm_UNSUPPORTED_KEY_TYPE_" + std::string(val.type().name()) + "__";
    }

    Error Session::processPreloadsInternal(const QueryBuilder &qb, std::vector<ModelBase *> &parent_models_raw_ptr) {
        const std::vector<PreloadRequest> &preload_requests = qb.getPreloadRequests();
        const ModelMeta *main_model_meta_ptr = qb.getModelMeta();

        if (!main_model_meta_ptr) {
            return Error(ErrorCode::InvalidConfiguration, "processPreloadsInternal: QueryBuilder has no ModelMeta for main model.");
        }
        const ModelMeta &main_model_meta = *main_model_meta_ptr;

        if (preload_requests.empty() || parent_models_raw_ptr.empty()) {
            return make_ok();
        }

        for (const auto &request : preload_requests) {
            std::string association_to_load = request.association_cpp_field_name;
            // Basic nested preload handling (can be expanded)
            // For "Orders.OrderItems", current_association_name becomes "Orders",
            // remaining_preload_path becomes "OrderItems".
            std::string remaining_preload_path;
            size_t dot_pos = association_to_load.find('.');
            if (dot_pos != std::string::npos) {
                remaining_preload_path = association_to_load.substr(dot_pos + 1);
                association_to_load = association_to_load.substr(0, dot_pos);
            }

            const AssociationMeta *assoc_meta = main_model_meta.findAssociationByCppName(association_to_load);
            if (!assoc_meta) {
                qWarning() << "Session::processPreloadsInternal: Association '" << QString::fromStdString(association_to_load) << "' not found in model '" << QString::fromStdString(main_model_meta.table_name) << "' for preloading.";
                continue;
            }

            Error err = executePreloadForAssociation(*assoc_meta, main_model_meta, parent_models_raw_ptr, remaining_preload_path);
            if (err) {
                qWarning() << "Session::processPreloadsInternal: Error preloading association '" << QString::fromStdString(association_to_load) << "': " << QString::fromStdString(err.toString());
                return err;  // Stop on first error for now
            }
        }
        return make_ok();
    }

    Error Session::processPreloads(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &loaded_models_unique_ptr) {
        if (loaded_models_unique_ptr.empty() || qb.getPreloadRequests().empty()) {
            return make_ok();
        }
        std::vector<ModelBase *> raw_ptr_vec;
        raw_ptr_vec.reserve(loaded_models_unique_ptr.size());
        for (const auto &u_ptr : loaded_models_unique_ptr) {
            if (u_ptr) {
                raw_ptr_vec.push_back(u_ptr.get());
            }
        }
        if (raw_ptr_vec.empty()) {  // All unique_ptrs were null
            return make_ok();
        }
        return processPreloadsInternal(qb, raw_ptr_vec);
    }

    // Added remaining_nested_preload_path parameter
    Error Session::executePreloadForAssociation(const AssociationMeta &assoc_meta, const ModelMeta &parent_model_meta, std::vector<ModelBase *> &parent_models_raw_ptr,
                                                const std::string &remaining_nested_preload_path) {  // New parameter

        if (parent_models_raw_ptr.empty()) {
            return make_ok();
        }

        cpporm::internal::ModelFactory target_model_factory_fn;
        {
            std::lock_guard<std::mutex> lock(internal::getGlobalModelFactoryRegistryMutex());
            auto it_factory = internal::getGlobalModelFactoryRegistry().find(assoc_meta.target_model_type);
            if (it_factory == internal::getGlobalModelFactoryRegistry().end()) {
                return Error(ErrorCode::InternalError, "Preload Error: Target model factory not found for type_index: " + std::string(assoc_meta.target_model_type.name()) + " for association '" + assoc_meta.cpp_field_name + "'.");
            }
            target_model_factory_fn = it_factory->second;
        }

        std::unique_ptr<ModelBase> temp_target_instance_uptr = target_model_factory_fn();
        if (!temp_target_instance_uptr) {
            return Error(ErrorCode::InternalError, "Preload Error: Target model factory failed to create instance for type: " + std::string(assoc_meta.target_model_type.name()) + " for association '" + assoc_meta.cpp_field_name + "'.");
        }
        const ModelMeta &target_model_meta = temp_target_instance_uptr->_getOwnModelMeta();
        if (target_model_meta.table_name.empty()) {
            return Error(ErrorCode::InvalidConfiguration, "Preload Error: Target model '" + std::string(assoc_meta.target_model_type.name()) + "' has an empty table name in its metadata.");
        }

        std::string parent_model_key_cpp_name;  // C++ name on parent model of the key used for joining
        std::string target_model_key_db_name;   // DB name on target model of the key used for joining

        if (assoc_meta.type == AssociationType::HasMany || assoc_meta.type == AssociationType::HasOne) {
            const FieldMeta *pk_field_on_parent = nullptr;
            if (!assoc_meta.primary_key_db_name_on_current_model.empty()) {
                pk_field_on_parent = parent_model_meta.findFieldByDbName(assoc_meta.primary_key_db_name_on_current_model);
            } else if (!parent_model_meta.primary_keys_db_names.empty()) {
                pk_field_on_parent = parent_model_meta.findFieldByDbName(parent_model_meta.primary_keys_db_names[0]);  // Default to first PK
            } else {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Parent model '" + parent_model_meta.table_name + "' has no primary keys defined for association '" + assoc_meta.cpp_field_name + "'.");
            }
            if (!pk_field_on_parent) {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Parent reference key DB name could not be resolved on parent model '" + parent_model_meta.table_name + "' for association '" + assoc_meta.cpp_field_name + "'.");
            }
            parent_model_key_cpp_name = pk_field_on_parent->cpp_name;
            target_model_key_db_name = assoc_meta.foreign_key_db_name;  // This is the FK on the target model referencing parent's PK
            if (target_model_key_db_name.empty()) {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Foreign key on target model not specified for association '" + assoc_meta.cpp_field_name + "'.");
            }
        } else if (assoc_meta.type == AssociationType::BelongsTo) {
            const FieldMeta *fk_field_on_parent = parent_model_meta.findFieldByDbName(assoc_meta.foreign_key_db_name);  // FK on current (parent) model
            if (!fk_field_on_parent) {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Foreign key DB name '" + assoc_meta.foreign_key_db_name + "' not found on parent model '" + parent_model_meta.table_name + "' for association '" + assoc_meta.cpp_field_name + "'.");
            }
            parent_model_key_cpp_name = fk_field_on_parent->cpp_name;  // This is the FK field on the parent
            if (!assoc_meta.target_model_pk_db_name.empty()) {         // PK on target model that FK on parent references
                target_model_key_db_name = assoc_meta.target_model_pk_db_name;
            } else if (!target_model_meta.primary_keys_db_names.empty()) {
                target_model_key_db_name = target_model_meta.primary_keys_db_names[0];  // Default to first PK of target
            } else {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Target model '" + target_model_meta.table_name + "' has no primary keys defined for association '" + assoc_meta.cpp_field_name + "'.");
            }
            if (target_model_key_db_name.empty()) {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Referenced key on target model not specified or determinable for association '" + assoc_meta.cpp_field_name + "'.");
            }
        } else if (assoc_meta.type == AssociationType::ManyToMany) {
            return Error(ErrorCode::UnsupportedFeature, "Preload Error: ManyToMany preloading for association '" + assoc_meta.cpp_field_name + "' is not yet implemented.");
        } else {
            return Error(ErrorCode::InternalError, "Preload Error: Unknown association type for '" + assoc_meta.cpp_field_name + "'.");
        }

        if (parent_model_key_cpp_name.empty() || target_model_key_db_name.empty()) {
            return Error(ErrorCode::MappingError, "Preload Error: Could not determine one or both join key names for association '" + assoc_meta.cpp_field_name + "'. ParentKeyCppName: '" + parent_model_key_cpp_name + "', TargetKeyDbName: '" + target_model_key_db_name + "'.");
        }

        std::vector<QueryValue> parent_key_values_for_in_clause;
        parent_key_values_for_in_clause.reserve(parent_models_raw_ptr.size());
        for (const auto parent_model_ptr : parent_models_raw_ptr) {
            if (parent_model_ptr) {
                std::any key_any = parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
                if (key_any.has_value()) {
                    QueryValue qv = Session::anyToQueryValueForSessionConvenience(key_any);
                    if (std::holds_alternative<std::nullptr_t>(qv) && key_any.has_value()) { /* Warning logged by anyToQV */
                        continue;
                    }
                    if (!std::holds_alternative<std::nullptr_t>(qv)) {  // Don't add actual nulls to IN clause
                        parent_key_values_for_in_clause.push_back(qv);
                    }
                }
            }
        }

        if (parent_key_values_for_in_clause.empty()) {  // No valid keys from parents to query for
            // Still need to set empty associations on parents
            for (auto parent_model_ptr : parent_models_raw_ptr) {
                if (!parent_model_ptr) continue;
                if (assoc_meta.type == AssociationType::HasMany && assoc_meta.data_setter_vector) {
                    std::vector<std::shared_ptr<ModelBase>> empty_vec;
                    assoc_meta.data_setter_vector(parent_model_ptr, empty_vec);
                } else if ((assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) && assoc_meta.data_setter_single) {
                    assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                }
            }
            return make_ok();
        }

        QueryBuilder qb_preload(this, this->connection_name_, &target_model_meta);
        // Add nested preloads to this QueryBuilder if remaining_nested_preload_path is not empty
        if (!remaining_nested_preload_path.empty()) {
            qb_preload.Preload(remaining_nested_preload_path);
        }

        std::string quoted_target_key_db_name = QueryBuilder::quoteSqlIdentifier(target_model_key_db_name);
        qb_preload.In(quoted_target_key_db_name, parent_key_values_for_in_clause);  // Use QueryBuilder::In

        std::vector<std::unique_ptr<ModelBase>> associated_results_unique_ptr_vec;
        // FindImpl will internally call processPreloads if qb_preload has preload requests.
        Error find_err = this->FindImpl(qb_preload, associated_results_unique_ptr_vec, target_model_factory_fn);

        if (find_err) {
            return Error(find_err.code, "Preload Error: Failed to fetch associated models for '" + assoc_meta.cpp_field_name + "' from table '" + target_model_meta.table_name + "': " + find_err.message);
        }

        const FieldMeta *target_model_key_field_meta = target_model_meta.findFieldByDbName(target_model_key_db_name);
        if (!target_model_key_field_meta) {
            return Error(ErrorCode::MappingError, "Preload Error: Target model's join key C++ field meta not found for DB name: '" + target_model_key_db_name + "' on table '" + target_model_meta.table_name + "'. Cannot map results.");
        }

        std::map<std::string, std::vector<std::shared_ptr<ModelBase>>> map_associated_by_their_link_key_value;
        for (auto &assoc_model_uptr : associated_results_unique_ptr_vec) {  // Iterate over unique_ptr
            if (assoc_model_uptr) {
                std::any link_key_val_any = assoc_model_uptr->getFieldValue(target_model_key_field_meta->cpp_name);
                std::string link_key_val_str_key = any_to_string_for_map_key_in_preload_util(link_key_val_any);

                if (link_key_val_str_key.rfind("__cpporm_UNSUPPORTED_KEY_TYPE_", 0) == 0 || link_key_val_str_key == "__cpporm_NULL_KEY__") {
                    qWarning() << "Preload Warning: Could not get or convert foreign key value to string for mapping associated model for " << QString::fromStdString(assoc_meta.cpp_field_name) << ". Skipping this associated model.";
                    continue;
                }
                // Move unique_ptr to shared_ptr for storage in map (or if setter expects shared_ptr)
                map_associated_by_their_link_key_value[link_key_val_str_key].push_back(std::move(assoc_model_uptr));
            }
        }
        associated_results_unique_ptr_vec.clear();  // All valid unique_ptrs are moved

        for (auto parent_model_ptr : parent_models_raw_ptr) {
            if (!parent_model_ptr) continue;
            std::any parent_key_val_any = parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
            std::string parent_key_val_str_key = any_to_string_for_map_key_in_preload_util(parent_key_val_any);

            auto it_found_associated = map_associated_by_their_link_key_value.find(parent_key_val_str_key);

            if (it_found_associated != map_associated_by_their_link_key_value.end()) {
                std::vector<std::shared_ptr<ModelBase>> &associated_for_this_parent_sptrs = it_found_associated->second;
                if (assoc_meta.type == AssociationType::HasMany) {
                    if (assoc_meta.data_setter_vector) {
                        assoc_meta.data_setter_vector(parent_model_ptr, associated_for_this_parent_sptrs);
                    } else { /* qWarning */
                    }
                } else if (assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) {
                    if (assoc_meta.data_setter_single) {
                        if (!associated_for_this_parent_sptrs.empty()) {
                            assoc_meta.data_setter_single(parent_model_ptr, associated_for_this_parent_sptrs.front());
                        } else {
                            assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                        }  // Should not happen if key matched
                    } else { /* qWarning */
                    }
                }
            } else {  // No associated models found for this parent's key
                if (assoc_meta.type == AssociationType::HasMany && assoc_meta.data_setter_vector) {
                    std::vector<std::shared_ptr<ModelBase>> empty_sptr_vec;
                    assoc_meta.data_setter_vector(parent_model_ptr, empty_sptr_vec);
                } else if ((assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) && assoc_meta.data_setter_single) {
                    assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                }
            }
        }
        return make_ok();
    }

}  // namespace cpporm#include <QDebug>        // qWarning
#include <QString>       // For QString in ExecRaw interface
#include <QVariantList>  // For QVariantList in ExecRaw interface

#include "cpporm/error.h"
#include "cpporm/session.h"
#include "sqldriver/sql_query.h"  // SqlQuery
#include "sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    // ExecRaw 保持接收 QString 和 QVariantList 的接口以方便 Qt 用户，内部转换为 SqlDriver 类型。
    std::expected<long long, Error> Session::ExecRaw(const QString &sql_qstr, const QVariantList &args_qvariantlist) {
        std::string sql_std_str = sql_qstr.toStdString();
        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Raw SQL query string is empty."));
        }

        std::vector<cpporm_sqldriver::SqlValue> args_sqlvalue;
        args_sqlvalue.reserve(args_qvariantlist.size());
        for (const QVariant &qv : args_qvariantlist) {
            // QueryBuilder::qvariantToQueryValue 应该是一个公共静态方法
            // Session::queryValueToSqlValue 也是公共静态方法
            args_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, args_sqlvalue);

        if (exec_err) {
            qWarning() << "Session::ExecRaw: Execution failed for SQL:" << sql_qstr << "Args:" << args_qvariantlist << "Error:" << QString::fromStdString(exec_err.toString());
            return std::unexpected(exec_err);
        }

        long long rows_affected = sql_query_obj.numRowsAffected();

        // numRowsAffected() 对于非 DML 语句（如 SELECT）可能返回 -1，这是正常的。
        // 对于 DDL，行为可能因驱动而异。
        // if (rows_affected == -1) {
        //     qInfo() << "Session::ExecRaw: numRowsAffected is -1. SQL: " << sql_qstr
        //             << ". This may be normal for SELECT or DDL statements.";
        // }
        return rows_affected;
    }

}  // namespace cpporm#include <QDebug>     // qWarning, qInfo
#include <QVariant>   // QVariantList for QueryBuilder, and conversion helpers
#include <algorithm>  // For std::transform etc.

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"        // 主头文件
#include "sqldriver/sql_query.h"   // SqlQuery
#include "sqldriver/sql_record.h"  // SqlRecord
#include "sqldriver/sql_value.h"   // SqlValue

namespace cpporm {

    Error Session::FirstImpl(const QueryBuilder &qb, ModelBase &result_model) {
        const ModelMeta *meta = qb.getModelMeta();
        if (!meta) {
            // 如果 QB 没有 meta，尝试从 result_model 获取
            meta = &(result_model._getOwnModelMeta());
            if (!meta || meta->table_name.empty()) {  // 检查从模型获取的 meta 是否有效
                return Error(ErrorCode::InvalidConfiguration, "FirstImpl: Could not determine ModelMeta for query.");
            }
        }

        QueryBuilder local_qb = qb;                                   // 创建副本以修改
        if (local_qb.getModelMeta() == nullptr && meta != nullptr) {  // 如果副本 QB 没有 meta，但我们有，则设置它
            local_qb.Model(*meta);
        }
        local_qb.Limit(1);

        auto [sql_qstr, params_qvariantlist] = local_qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return Error(ErrorCode::StatementPreparationError, "Failed to build SQL for First operation.");
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);

        if (exec_err) {
            return exec_err;
        }

        if (sql_query_obj.next()) {
            Error map_err = mapRowToModel(sql_query_obj, result_model, *meta);
            if (map_err) {
                qWarning() << "cpporm Session::FirstImpl: Error mapping row:" << QString::fromStdString(map_err.toString());
                return map_err;
            }
            // result_model._is_persisted = true; // mapRowToModel 应该设置这个
            Error hook_err = result_model.afterFind(*this);
            if (hook_err) return hook_err;

            if (!qb.getPreloadRequests().empty()) {
                std::vector<ModelBase *> models_for_preload = {&result_model};
                Error preload_err = this->processPreloadsInternal(qb, models_for_preload);
                if (preload_err) {
                    qWarning() << "Session::FirstImpl: Preloading failed after fetching model: " << QString::fromStdString(preload_err.toString());
                    // return preload_err; // Decide if this is fatal
                }
            }
            return make_ok();
        } else {
            return Error(ErrorCode::RecordNotFound, "No record found for First operation.");
        }
    }

    Error Session::FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
        if (!element_type_factory) {
            return Error(ErrorCode::InternalError, "Element type factory function is null for Find operation.");
        }

        const ModelMeta *meta_for_query = qb.getModelMeta();
        QueryBuilder local_qb = qb;  // 创建副本以可能修改

        if (!meta_for_query) {
            auto temp_instance = element_type_factory();
            if (temp_instance && !temp_instance->_getOwnModelMeta().table_name.empty()) {
                meta_for_query = &(temp_instance->_getOwnModelMeta());
                if (local_qb.getModelMeta() == nullptr) {  // 如果副本 QB 没有 meta，则设置它
                    local_qb.Model(*meta_for_query);
                }
            } else {
                return Error(ErrorCode::InvalidConfiguration,
                             "FindImpl: Could not determine ModelMeta for query from "
                             "QueryBuilder or factory.");
            }
        }

        auto [sql_qstr, params_qvariantlist] = local_qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return Error(ErrorCode::StatementPreparationError, "Failed to build SQL for Find operation.");
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) {
            return exec_err;
        }

        results_vector.clear();
        while (sql_query_obj.next()) {
            std::unique_ptr<ModelBase> new_element = element_type_factory();
            if (!new_element) {
                return Error(ErrorCode::InternalError, "Element factory returned nullptr inside Find loop.");
            }
            Error map_err = mapRowToModel(sql_query_obj, *new_element, *meta_for_query);
            if (map_err) {
                qWarning() << "cpporm Session::FindImpl: Error mapping row: " << QString::fromStdString(map_err.toString()) << ". SQL was: " << QString::fromStdString(sql_std_str);
                // return map_err; // 通常不应因单行映射失败而中止整个查找
                continue;  // 跳过此行
            }
            // new_element->_is_persisted = true; // mapRowToModel 应该设置这个
            Error hook_err = new_element->afterFind(*this);
            if (hook_err) {
                qWarning() << "cpporm Session::FindImpl: afterFind hook failed for an element: " << QString::fromStdString(hook_err.toString());
                // return hook_err; // Decide if this is fatal
            }
            results_vector.push_back(std::move(new_element));
        }

        if (!results_vector.empty() && !qb.getPreloadRequests().empty()) {
            Error preload_err = this->processPreloads(qb, results_vector);
            if (preload_err) {
                qWarning() << "cpporm Session::FindImpl: Preloading failed: " << QString::fromStdString(preload_err.toString());
                // return preload_err; // Decide if this is fatal
            }
        }
        return make_ok();
    }

    std::expected<int64_t, Error> Session::CountImpl(const QueryBuilder &qb_const) {
        QueryBuilder qb = qb_const;  // 创建副本
        // 如果 QB 没有 ModelMeta，尝试从一个临时模型实例推断（如果可能，但不直接可行）
        // Count 通常需要知道 FROM 子句。如果 QB 没设置 Model/Table，buildSelectSQL 会失败。
        if (!qb.getModelMeta() && qb.getFromSourceName().isEmpty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CountImpl: QueryBuilder has no Model or Table set."));
        }

        if (!qb.getGroupClause().empty()) {
            qWarning(
                "cpporm Session::CountImpl: Count() called with existing GROUP "
                "BY clause. Clearing GROUP BY for total count.");
            qb.Group("");
        }
        qb.Select("COUNT(*)");
        qb.Order("");
        qb.Limit(-1);
        qb.Offset(-1);
        if (!qb.getState_().preload_requests_.empty()) {                                    // 直接访问 state_ 来修改
            QueryBuilderState &mutable_state = const_cast<QueryBuilder &>(qb).getState_();  // 需要 const_cast 来修改副本的状态
            mutable_state.preload_requests_.clear();
        }

        auto [sql_qstr, params_qvariantlist] = qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for Count operation."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (err) {
            return std::unexpected(err);
        }

        if (sql_query_obj.next()) {
            bool ok_conversion;
            cpporm_sqldriver::SqlValue count_sv = sql_query_obj.value(0);
            int64_t count_val = count_sv.toInt64(&ok_conversion);
            if (ok_conversion) {
                return count_val;
            } else {
                std::string sv_str_val = count_sv.toString();
                return std::unexpected(Error(ErrorCode::MappingError, "Failed to convert COUNT(*) result to integer. Value: " + sv_str_val));
            }
        } else {
            qWarning() << "cpporm Session::CountImpl: COUNT(*) query returned no rows "
                          "(unexpected). SQL:"
                       << QString::fromStdString(sql_std_str);
            return std::unexpected(Error(ErrorCode::QueryExecutionError, "COUNT(*) query returned no rows."));
        }
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant in QueryValue
#include <QDebug>     // qWarning, qInfo
#include <QMetaType>  // For QVariant -> QueryValue helper
#include <QVariant>   // QueryValue helper

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::SaveImpl(const QueryBuilder &qb_param, ModelBase &model_instance) {
        const ModelMeta *meta_from_qb = qb_param.getModelMeta();
        const ModelMeta &meta = meta_from_qb ? *meta_from_qb : model_instance._getOwnModelMeta();

        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "SaveImpl: ModelMeta does not have a valid table_name."));
        }

        Error hook_err = model_instance.beforeSave(*this);
        if (hook_err) return std::unexpected(hook_err);

        bool has_defined_pk = !meta.primary_keys_db_names.empty();
        bool model_has_all_pks_set_and_non_default = false;
        if (has_defined_pk) {
            model_has_all_pks_set_and_non_default = true;
            for (const auto &pk_db_name : meta.primary_keys_db_names) {
                const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
                if (pk_field) {
                    std::any pk_val_any = model_instance.getFieldValue(pk_field->cpp_name);
                    if (!pk_val_any.has_value()) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    // Check for "zero" or "empty" values more robustly
                    QueryValue pk_qv = Session::anyToQueryValueForSessionConvenience(pk_val_any);
                    if (std::holds_alternative<std::nullptr_t>(pk_qv)) {  // Covers uninitialized or unconvertible types
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<int>(pk_qv) && std::get<int>(pk_qv) == 0) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<long long>(pk_qv) && std::get<long long>(pk_qv) == 0) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<std::string>(pk_qv) && std::get<std::string>(pk_qv).empty()) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    // Add checks for other PK types if necessary (e.g., QDate for 0000-00-00)
                } else {
                    model_has_all_pks_set_and_non_default = false;
                    qWarning() << "SaveImpl: PK field meta not found for" << QString::fromStdString(pk_db_name);
                    break;
                }
            }
        }

        bool attempt_update = (model_instance._is_persisted || model_has_all_pks_set_and_non_default) && has_defined_pk;

        if (attempt_update) {
            this->autoSetTimestamps(model_instance, meta, false);                                                         // false for update
            internal::SessionModelDataForWrite data_to_write = this->extractModelData(model_instance, meta, true, true);  // true for update, true for include_timestamps

            if (data_to_write.primary_key_fields.empty() && has_defined_pk) {
                return std::unexpected(Error(ErrorCode::MappingError, "SaveImpl (Update path): Failed to extract valid primary key values for WHERE clause. Table: " + meta.table_name));
            }

            if (data_to_write.fields_to_write.empty()) {
                qInfo("SaveImpl (Update path): No fields (including timestamps) to update for table %s. Skipping DB operation.", meta.table_name.c_str());
                // Still run hooks if appropriate for a "no-op save that was an update attempt"
                hook_err = model_instance.beforeUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterSave(*this);
                if (hook_err) return std::unexpected(hook_err);
                return 0LL;  // 0 rows affected
            }

            hook_err = model_instance.beforeUpdate(*this);
            if (hook_err) return std::unexpected(hook_err);

            QueryBuilder update_qb(this, this->connection_name_, &meta);
            for (const auto &pk_name_std : meta.primary_keys_db_names) {
                auto it = data_to_write.primary_key_fields.find(pk_name_std);
                if (it != data_to_write.primary_key_fields.end() && it->second.isValid() && !it->second.isNull()) {
                    update_qb.Where(pk_name_std + " = ?", {Session::sqlValueToQueryValue(it->second)});
                } else {
                    return std::unexpected(Error(ErrorCode::MappingError, "SaveImpl (Update path): PK '" + pk_name_std + "' missing or invalid in extracted PKs for WHERE clause. Table: " + meta.table_name));
                }
            }

            std::map<std::string, QueryValue> updates_for_impl;
            for (const auto &pair : data_to_write.fields_to_write) {
                // Do not include PKs in the SET clause of an UPDATE
                bool is_this_field_a_pk = false;
                for (const auto &pk_col_name : meta.primary_keys_db_names) {
                    if (pk_col_name == pair.first) {
                        is_this_field_a_pk = true;
                        break;
                    }
                }
                if (!is_this_field_a_pk) {
                    updates_for_impl[pair.first] = Session::sqlValueToQueryValue(pair.second);
                }
            }

            if (updates_for_impl.empty()) {  // If only PKs were in fields_to_write (unlikely due to timestamp logic)
                qInfo("SaveImpl (Update path): After removing PKs, no fields left to update for table %s. Skipping DB operation.", meta.table_name.c_str());
                hook_err = model_instance.afterUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterSave(*this);
                if (hook_err) return std::unexpected(hook_err);
                return 0LL;
            }

            auto update_result = this->UpdatesImpl(update_qb, updates_for_impl);

            if (!update_result.has_value()) return std::unexpected(update_result.error());
            if (update_result.value() > 0)
                model_instance._is_persisted = true;  // If rows were affected, it's persisted
            else if (update_result.value() == 0 && model_instance._is_persisted) {
                // No rows affected, but it was already persisted (e.g., no actual data change)
            } else if (update_result.value() == 0 && !model_instance._is_persisted && model_has_all_pks_set_and_non_default) {
                // PKs were set, but no matching row found for update. This means it's not persisted.
                // This Save should have gone to Create path.
                // This case indicates a potential issue if we expected an update.
                // GORM might then attempt an INSERT. For now, we don't auto-switch.
                qWarning("SaveImpl (Update path): Update affected 0 rows for model (table: %s) with PKs set but not previously marked persisted. Record may not exist.", meta.table_name.c_str());
            }

            hook_err = model_instance.afterUpdate(*this);
            if (hook_err) return std::unexpected(hook_err);
            hook_err = model_instance.afterSave(*this);
            if (hook_err) return std::unexpected(hook_err);
            return update_result.value();

        } else {  // Attempt a CREATE
            // hook_err = model_instance.beforeCreate(*this); // CreateImpl handles this
            // if (hook_err) return std::unexpected(hook_err);
            // this->autoSetTimestamps(model_instance, meta, true); // CreateImpl handles this

            const OnConflictClause *final_conflict_options = nullptr;
            std::unique_ptr<OnConflictClause> save_upsert_clause_ptr;

            if (qb_param.getOnConflictClause()) {
                final_conflict_options = qb_param.getOnConflictClause();
            } else if (this->getTempOnConflictClause()) {
                final_conflict_options = this->getTempOnConflictClause();
            } else if (has_defined_pk && model_has_all_pks_set_and_non_default) {
                // If PKs are set and it's not persisted, default to upsert (update all excluded)
                save_upsert_clause_ptr = std::make_unique<OnConflictClause>(OnConflictClause::Action::UpdateAllExcluded);
                // Set conflict target to PKs for databases like PostgreSQL/SQLite
                if (!meta.primary_keys_db_names.empty() && save_upsert_clause_ptr->conflict_target_columns_db_names.empty()) {
                    save_upsert_clause_ptr->conflict_target_columns_db_names = meta.primary_keys_db_names;
                }
                final_conflict_options = save_upsert_clause_ptr.get();
            }

            auto create_result_sv_expected = this->CreateImpl(qb_param, model_instance, final_conflict_options);

            if (this->getTempOnConflictClause() && !qb_param.getOnConflictClause() && final_conflict_options == this->getTempOnConflictClause()) {
                this->clearTempOnConflictClause();
            }

            if (!create_result_sv_expected.has_value()) return std::unexpected(create_result_sv_expected.error());

            // model_instance._is_persisted and afterCreate hook are handled by CreateImpl

            hook_err = model_instance.afterSave(*this);  // afterSave is specific to Save operation
            if (hook_err) return std::unexpected(hook_err);

            // Determine return value for Save (usually 1 for create/update, 0 for no-op)
            // create_result_sv_expected.value() contains rows_affected or last_insert_id from CreateImpl
            cpporm_sqldriver::SqlValue sv_from_create = create_result_sv_expected.value();
            long long rows_affected_from_create = -1;
            bool ok_conv = false;
            if (sv_from_create.type() == cpporm_sqldriver::SqlValueType::Int64) {  // If it was rows_affected
                rows_affected_from_create = sv_from_create.toInt64(&ok_conv);
            }

            if (final_conflict_options && final_conflict_options->action == OnConflictClause::Action::DoNothing) {
                // If DO NOTHING occurred, and CreateImpl reported 0 rows affected (meaning it existed),
                // _is_persisted should reflect that (CreateImpl should set it true if conflict handler ran).
                // Save operation should return 0 if it was a DO NOTHING on existing.
                // If it was a genuine insert (conflict didn't happen), rows_affected would be > 0.
                if (ok_conv && rows_affected_from_create == 0 && model_instance._is_persisted) return 0LL;  // No-op due to conflict
                if (model_instance._is_persisted) return 1LL;                                               // Actual insert or update from conflict
                return 0LL;                                                                                 // Fallback if not persisted after DO NOTHING attempt
            }
            return model_instance._is_persisted ? 1LL : 0LL;  // 1 if persisted (newly or via upsert), 0 otherwise
        }
    }

    std::expected<long long, Error> Session::Save(ModelBase &model_instance) {
        QueryBuilder qb = this->Model(&model_instance);
        return this->SaveImpl(qb, model_instance);
    }

}  // namespace cpporm// Base/CppOrm/Source/session_static_utils.cpp
#include <QDebug>
#include <QMetaType>
#include <QVariant>
#include <any>
#include <variant>

#include "cpporm/error.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "sqldriver/sql_database.h"
#include "sqldriver/sql_error.h"
#include "sqldriver/sql_query.h"
#include "sqldriver/sql_value.h"

namespace cpporm {

    std::string Session::getSqlTypeForCppType(const FieldMeta &field_meta, const QString &driverName_upper_qstr) {
        std::string driverName_upper = driverName_upper_qstr.toStdString();
        if (!field_meta.db_type_hint.empty()) {
            return field_meta.db_type_hint;
        }
        const std::type_index &cpp_type = field_meta.cpp_type;

        if (cpp_type == typeid(int)) return "INT";
        if (cpp_type == typeid(unsigned int)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "INTEGER";
            return "INT UNSIGNED";
        }
        if (cpp_type == typeid(long long)) return "BIGINT";
        if (cpp_type == typeid(unsigned long long)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "BIGINT";
            return "BIGINT UNSIGNED";
        }
        if (cpp_type == typeid(float)) return "FLOAT";
        if (cpp_type == typeid(double)) return "DOUBLE PRECISION";
        if (cpp_type == typeid(bool)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "BOOLEAN";
            if (driverName_upper == "QMYSQL" || driverName_upper == "QMARIADB") return "TINYINT(1)";
            return "BOOLEAN";
        }
        if (cpp_type == typeid(std::string)) return "TEXT";
        if (cpp_type == typeid(QDateTime)) {
            if (driverName_upper == "QPSQL") return "TIMESTAMP WITH TIME ZONE";
            if (driverName_upper == "QSQLITE") return "DATETIME";
            return "DATETIME";
        }
        if (cpp_type == typeid(QDate)) return "DATE";
        if (cpp_type == typeid(QTime)) return "TIME";
        if (cpp_type == typeid(QByteArray)) {
            if (driverName_upper == "QPSQL") return "BYTEA";
            if (driverName_upper == "QSQLITE") return "BLOB";
            return "BLOB";
        }

        qWarning() << "Session::getSqlTypeForCppType: Unknown C++ type " << QString::fromLocal8Bit(field_meta.cpp_type.name()) << " for field '" << QString::fromStdString(field_meta.cpp_name) << "'. Defaulting to TEXT. Driver: " << driverName_upper_qstr;
        return "TEXT";
    }

    void Session::qvariantToAny(const QVariant &qv, const std::type_index &target_cpp_type, std::any &out_any, bool &out_conversion_ok) {
        out_conversion_ok = false;
        out_any.reset();

        if (qv.isNull() || !qv.isValid() ||
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            qv.typeId() == QMetaType::UnknownType
#else
            qv.type() == QVariant::Invalid || qv.userType() == QMetaType::UnknownType
#endif
        ) {
            out_conversion_ok = true;
            return;
        }
        if (target_cpp_type == typeid(int)) {
            out_any = qv.toInt(&out_conversion_ok);
        } else if (target_cpp_type == typeid(long long)) {
            out_any = qv.toLongLong(&out_conversion_ok);
        } else if (target_cpp_type == typeid(unsigned int)) {
            out_any = qv.toUInt(&out_conversion_ok);
        } else if (target_cpp_type == typeid(unsigned long long)) {
            out_any = qv.toULongLong(&out_conversion_ok);
        } else if (target_cpp_type == typeid(double)) {
            out_any = qv.toDouble(&out_conversion_ok);
        } else if (target_cpp_type == typeid(float)) {
            out_any = qv.toFloat(&out_conversion_ok);
        } else if (target_cpp_type == typeid(bool)) {
            out_any = qv.toBool();
            out_conversion_ok = true;
        } else if (target_cpp_type == typeid(std::string)) {
            if (
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                QMetaType(qv.typeId()).flags().testFlag(QMetaType::IsPointer) ||  // Check if it's a pointer type
                QMetaType(qv.typeId()).flags().testFlag(QMetaType::IsGadget)      // Or a gadget
#else
                qv.type() == QVariant::UserType  // Check if it's a user type (often pointers or gadgets in Qt 5)
#endif
                // Add more specific checks if needed for custom types stored in QVariant
            ) {
                qWarning() << "Session::qvariantToAny: Attempting to convert a complex QVariant type" << qv.typeName() << "to std::string. This might not be meaningful.";
                // Fallback or specific handling if you know how to stringify it
                out_any = qv.toString().toStdString();  // Fallback to QVariant::toString()
                out_conversion_ok = true;               // Assume QVariant::toString() is always "successful"
            } else if (qv.canConvert<QString>()) {
                out_any = qv.toString().toStdString();
                out_conversion_ok = true;
            } else if (
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                qv.typeId() == QMetaType::QByteArray
#else
                qv.type() == QVariant::ByteArray
#endif
            ) {
                QByteArray ba = qv.toByteArray();
                out_any = std::string(ba.constData(), static_cast<size_t>(ba.size()));
                out_conversion_ok = true;
            } else {
                qWarning() << "Session::qvariantToAny: Cannot convert QVariant type" << qv.typeName() << "to std::string for target type" << QString::fromLocal8Bit(target_cpp_type.name());
            }
        } else if (target_cpp_type == typeid(QDateTime)) {
            if (qv.canConvert<QDateTime>()) {
                out_any = qv.toDateTime();
                out_conversion_ok = qv.toDateTime().isValid();
            }
        } else if (target_cpp_type == typeid(QDate)) {
            if (qv.canConvert<QDate>()) {
                out_any = qv.toDate();
                out_conversion_ok = qv.toDate().isValid();
            }
        } else if (target_cpp_type == typeid(QTime)) {
            if (qv.canConvert<QTime>()) {
                out_any = qv.toTime();
                out_conversion_ok = qv.toTime().isValid();
            }
        } else if (target_cpp_type == typeid(QByteArray)) {
            if (qv.canConvert<QByteArray>()) {
                out_any = qv.toByteArray();
                out_conversion_ok = true;
            }
        } else {
            qWarning() << "Session::qvariantToAny: Unsupported C++ target type for "
                          "QVariant conversion: "
                       << QString::fromLocal8Bit(target_cpp_type.name()) << "from QVariant type" << qv.typeName();
        }
        if (!out_conversion_ok && qv.isValid() && !qv.isNull()) {
            qWarning() << "Session::qvariantToAny: Conversion failed for QVariant value [" << qv.toString() << "] of type" << qv.typeName() << "to C++ type" << QString::fromLocal8Bit(target_cpp_type.name());
        }
    }

    QueryValue Session::anyToQueryValueForSessionConvenience(const std::any &val) {
        if (!val.has_value()) return nullptr;
        const auto &type = val.type();
        if (type == typeid(int)) return std::any_cast<int>(val);
        if (type == typeid(long long)) return std::any_cast<long long>(val);
        if (type == typeid(double)) return std::any_cast<double>(val);
        if (type == typeid(std::string)) return std::any_cast<std::string>(val);
        if (type == typeid(bool)) return std::any_cast<bool>(val);
        if (type == typeid(QDateTime)) return std::any_cast<QDateTime>(val);
        if (type == typeid(QDate)) return std::any_cast<QDate>(val);
        if (type == typeid(QTime)) return std::any_cast<QTime>(val);
        if (type == typeid(QByteArray)) return std::any_cast<QByteArray>(val);
        if (type == typeid(const char *)) return std::string(std::any_cast<const char *>(val));
        if (type == typeid(std::nullptr_t)) return nullptr;
        if (type == typeid(float)) return static_cast<double>(std::any_cast<float>(val));
        if (type == typeid(short)) return static_cast<int>(std::any_cast<short>(val));
        if (type == typeid(char)) {
            return static_cast<int>(std::any_cast<char>(val));
        }
        if (type == typeid(unsigned char)) return static_cast<int>(std::any_cast<unsigned char>(val));
        if (type == typeid(unsigned short)) return static_cast<int>(std::any_cast<unsigned short>(val));
        if (type == typeid(unsigned int)) return static_cast<long long>(std::any_cast<unsigned int>(val));
        if (type == typeid(unsigned long long)) return static_cast<long long>(std::any_cast<unsigned long long>(val));

        qWarning() << "Session::anyToQueryValueForSessionConvenience: Unhandled "
                      "std::any type:"
                   << QString::fromLocal8Bit(val.type().name());
        return nullptr;
    }

    cpporm_sqldriver::SqlValue Session::queryValueToSqlValue(const QueryValue &qv) {
        if (std::holds_alternative<std::nullptr_t>(qv)) return cpporm_sqldriver::SqlValue();
        if (std::holds_alternative<int>(qv)) return cpporm_sqldriver::SqlValue(static_cast<int32_t>(std::get<int>(qv)));
        if (std::holds_alternative<long long>(qv)) return cpporm_sqldriver::SqlValue(static_cast<int64_t>(std::get<long long>(qv)));
        if (std::holds_alternative<double>(qv)) return cpporm_sqldriver::SqlValue(std::get<double>(qv));
        if (std::holds_alternative<std::string>(qv)) return cpporm_sqldriver::SqlValue(std::get<std::string>(qv));
        if (std::holds_alternative<bool>(qv)) return cpporm_sqldriver::SqlValue(std::get<bool>(qv));
        if (std::holds_alternative<QDateTime>(qv)) return cpporm_sqldriver::SqlValue(std::get<QDateTime>(qv));
        if (std::holds_alternative<QDate>(qv)) return cpporm_sqldriver::SqlValue(std::get<QDate>(qv));
        if (std::holds_alternative<QTime>(qv)) return cpporm_sqldriver::SqlValue(std::get<QTime>(qv));
        if (std::holds_alternative<QByteArray>(qv)) return cpporm_sqldriver::SqlValue(std::get<QByteArray>(qv));
        if (std::holds_alternative<SubqueryExpression>(qv)) {
            qWarning("Session::queryValueToSqlValue: SubqueryExpression cannot be directly converted to a single SqlValue for binding. This usually indicates a logic error where a subquery is being treated as a simple bind value.");
            return cpporm_sqldriver::SqlValue();
        }
        qWarning("Session::queryValueToSqlValue: Unhandled QueryValue variant type during conversion to SqlValue.");
        return cpporm_sqldriver::SqlValue();
    }

    QueryValue Session::sqlValueToQueryValue(const cpporm_sqldriver::SqlValue &sv) {
        if (sv.isNull()) return nullptr;
        bool ok = false;
        switch (sv.type()) {
            case cpporm_sqldriver::SqlValueType::Bool:
                return sv.toBool(&ok);
            case cpporm_sqldriver::SqlValueType::Int8:
            case cpporm_sqldriver::SqlValueType::UInt8:
            case cpporm_sqldriver::SqlValueType::Int16:
            case cpporm_sqldriver::SqlValueType::UInt16:
            case cpporm_sqldriver::SqlValueType::Int32:
                return sv.toInt32(&ok);
            case cpporm_sqldriver::SqlValueType::UInt32:
                return static_cast<long long>(sv.toUInt32(&ok));
            case cpporm_sqldriver::SqlValueType::Int64:
                return sv.toInt64(&ok);
            case cpporm_sqldriver::SqlValueType::UInt64:
                return static_cast<long long>(sv.toUInt64(&ok));
            case cpporm_sqldriver::SqlValueType::Float:
            case cpporm_sqldriver::SqlValueType::Double:
            case cpporm_sqldriver::SqlValueType::LongDouble:
                return sv.toDouble(&ok);
            case cpporm_sqldriver::SqlValueType::String:
            case cpporm_sqldriver::SqlValueType::FixedString:
            case cpporm_sqldriver::SqlValueType::CharacterLargeObject:
                return sv.toString(&ok);
            case cpporm_sqldriver::SqlValueType::ByteArray:
            case cpporm_sqldriver::SqlValueType::BinaryLargeObject:
                return sv.toByteArray(&ok);
            case cpporm_sqldriver::SqlValueType::Date:
                return sv.toDate(&ok);
            case cpporm_sqldriver::SqlValueType::Time:
                return sv.toTime(&ok);
            case cpporm_sqldriver::SqlValueType::DateTime:
            case cpporm_sqldriver::SqlValueType::Timestamp:
                return sv.toDateTime(&ok);
            case cpporm_sqldriver::SqlValueType::Decimal:
            case cpporm_sqldriver::SqlValueType::Numeric:
                {
                    double d_val = sv.toDouble(&ok);
                    if (ok) return d_val;
                    std::string s_val = sv.toString(&ok);
                    if (ok) return s_val;
                    qWarning() << "Session::sqlValueToQueryValue: Could not convert Decimal/Numeric SqlValue to double or string.";
                }
                break;
            case cpporm_sqldriver::SqlValueType::Json:
                return sv.toString(&ok);
            default:
                qWarning() << "Session::sqlValueToQueryValue: Unhandled SqlValueType: " << static_cast<int>(sv.type()) << " (" << sv.typeName() << "). Attempting toString().";
                std::string s_val = sv.toString(&ok);
                if (ok) return s_val;
        }
        if (!ok && !sv.isNull()) {
            qWarning() << "Session::sqlValueToQueryValue: Conversion from SqlValue (type: " << sv.typeName() << ", value: " << QString::fromStdString(sv.toString()) << ") to a QueryValue alternative failed.";
        }
        return nullptr;
    }

    std::pair<cpporm_sqldriver::SqlQuery, Error> Session::execute_query_internal(cpporm_sqldriver::SqlDatabase &db_handle, const std::string &sql_std_str, const std::vector<cpporm_sqldriver::SqlValue> &bound_params) {
        if (!db_handle.isOpen()) {
            qWarning() << "Session::execute_query_internal: Database handle for connection '" << QString::fromStdString(db_handle.connectionName()) << "' is not open. Attempting to open...";
            if (!db_handle.open()) {
                cpporm_sqldriver::SqlError err = db_handle.lastError();
                return std::make_pair(cpporm_sqldriver::SqlQuery(db_handle),
                                      Error(ErrorCode::ConnectionNotOpen,
                                            "execute_query_internal: Failed to open database for query "
                                            "execution on connection '" +
                                                db_handle.connectionName() + "': " + err.text(),
                                            err.nativeErrorCodeNumeric()));
            }
        }

        cpporm_sqldriver::SqlQuery query(db_handle);

        if (!query.prepare(sql_std_str)) {
            cpporm_sqldriver::SqlError prepareError = query.lastError();
            return std::make_pair(std::move(query), Error(ErrorCode::StatementPreparationError, "Failed to prepare SQL query: " + prepareError.text() + " SQL: " + sql_std_str, prepareError.nativeErrorCodeNumeric()));
        }

        for (size_t i = 0; i < bound_params.size(); ++i) {
            query.bindValue(static_cast<int>(i), bound_params[i]);
        }

        if (!query.exec()) {
            cpporm_sqldriver::SqlError execError = query.lastError();
            std::string params_debug_str;
            for (const auto &p_sv : bound_params) {
                bool conv_ok = false;
                params_debug_str += p_sv.toString(&conv_ok) + ", ";
            }
            if (!params_debug_str.empty()) params_debug_str.resize(params_debug_str.length() - 2);

            return std::make_pair(std::move(query),
                                  Error(ErrorCode::QueryExecutionError, "SQL query execution failed: " + execError.text() + " (Native Code: " + execError.nativeErrorCode() + ")" + "\nSQL: " + sql_std_str + "\nParams: [" + params_debug_str + "]", execError.nativeErrorCodeNumeric(), ""));
        }
        return std::make_pair(std::move(query), make_ok());
    }

}  // namespace cpporm// Base/CppOrm/Source/session_transaction.cpp
#include <QDebug>  // For qWarning

#include "cpporm/session.h"
#include "sqldriver/sql_database.h"  // For cpporm_sqldriver::SqlDatabase
#include "sqldriver/sql_enums.h"     // For cpporm_sqldriver::Feature
#include "sqldriver/sql_error.h"

namespace cpporm {

    std::expected<std::unique_ptr<Session>, Error> Session::Begin() {
        if (is_explicit_transaction_handle_) {
            return std::unexpected(Error(ErrorCode::TransactionError, "Session is already explicitly managing a transaction. Nested Begin() is not supported by creating a new Session wrapper."));
        }

        if (!db_handle_.isValid()) {
            return std::unexpected(Error(ErrorCode::ConnectionInvalid, "Cannot begin transaction: Session's SqlDatabase handle is invalid."));
        }
        if (!db_handle_.isOpen()) {
            qInfo() << "Session::Begin: Database handle for connection '" << QString::fromStdString(db_handle_.connectionName()) << "' was not open. Attempting to open...";
            if (!db_handle_.open()) {  // Assuming db_handle_ has its params cached
                cpporm_sqldriver::SqlError open_err = db_handle_.lastError();
                return std::unexpected(Error(ErrorCode::ConnectionNotOpen, "Failed to open database for transaction: " + open_err.text(), open_err.nativeErrorCodeNumeric()));
            }
        }

        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            return std::unexpected(Error(ErrorCode::UnsupportedFeature, "Database driver for connection '" + connection_name_ + "' does not support transactions."));
        }

        // Check if a transaction is ALREADY active on this shared connection,
        // which might indicate an issue if Begin() is called multiple times without
        // corresponding Commit/Rollback on the same logical connection flow.
        if (db_handle_.isTransactionActive()) {  // Relies on SqlDatabase::isTransactionActive() querying driver
            qWarning() << "Session::Begin: A transaction is already active on the underlying connection '" << QString::fromStdString(connection_name_) << "'. Proceeding to start a new logical transaction Session wrapper.";
            // Depending on DB and driver, `db_handle_.transaction()` might start a nested transaction
            // or be a no-op if already in a transaction, or error.
            // MySQL default behavior with START TRANSACTION inside another is to commit the previous one
            // implicitly, unless savepoints are used. This needs careful handling.
            // For now, we proceed, and `db_handle_.transaction()` will attempt its action.
        }

        if (db_handle_.transaction()) {  // This starts a transaction on this->db_handle_
            // Create a new SqlDatabase object that SHARES the same underlying ISqlDriver.
            // This is now possible because SqlDatabase uses shared_ptr and has a copy constructor.
            cpporm_sqldriver::SqlDatabase transactional_db_handle(this->db_handle_);  // Copy constructs, shares m_driver

            // Create a new Session instance, moving the new SqlDatabase (which shares the driver) into it.
            auto tx_session = std::make_unique<Session>(std::move(transactional_db_handle));
            tx_session->is_explicit_transaction_handle_ = true;  // Mark this new session as managing the transaction

            // The original session 'this' remains valid and usable because its db_handle_
            // still holds a valid shared_ptr to the ISqlDriver.
            return tx_session;
        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            return std::unexpected(Error(ErrorCode::TransactionError, "Failed to begin transaction on connection '" + connection_name_ + "': " + q_error.text(), q_error.nativeErrorCodeNumeric()));
        }
    }

    // Commit, Rollback, IsTransaction methods remain largely the same as the previous fix,
    // relying on is_explicit_transaction_handle_ and the db_handle_'s state.
    Error Session::Commit() {
        if (!is_explicit_transaction_handle_) {
            return Error(ErrorCode::TransactionError, "Commit called on a Session not managing an explicit transaction. Ensure this Session was returned by Begin().");
        }
        if (!db_handle_.isValid()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionInvalid, "Cannot commit: SqlDatabase handle is invalid.");
        }
        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::UnsupportedFeature, "Cannot commit: Driver does not support transactions.");
        }
        // No need to check db_handle_.isTransactionActive() before calling db_handle_.commit(),
        // as db_handle_.commit() should handle the case where no transaction is active (e.g., by returning false and setting an error).

        if (db_handle_.commit()) {
            is_explicit_transaction_handle_ = false;
            return make_ok();
        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            // Do not reset is_explicit_transaction_handle_ on commit failure,
            // as the transaction might still be technically active and require a rollback.
            return Error(ErrorCode::TransactionError, "Failed to commit transaction: " + q_error.text(), q_error.nativeErrorCodeNumeric());
        }
    }

    Error Session::Rollback() {
        if (!is_explicit_transaction_handle_) {
            return Error(ErrorCode::TransactionError, "Rollback called on a Session not managing an explicit transaction.");
        }
        if (!db_handle_.isValid()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionInvalid, "Cannot rollback: SqlDatabase handle is invalid.");
        }
        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::UnsupportedFeature, "Cannot rollback: Driver does not support transactions.");
        }

        if (db_handle_.rollback()) {
            is_explicit_transaction_handle_ = false;
            return make_ok();
        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            is_explicit_transaction_handle_ = false;  // Even on rollback failure, this Session wrapper is done.
            return Error(ErrorCode::TransactionError, "Failed to rollback transaction: " + q_error.text(), q_error.nativeErrorCodeNumeric());
        }
    }

    bool Session::IsTransaction() const {
        if (is_explicit_transaction_handle_) {
            if (db_handle_.isValid() && db_handle_.isOpen()) {
                // Relies on SqlDatabase::isTransactionActive accurately querying the driver
                return db_handle_.isTransactionActive();
            }
            return false;
        }
        return false;
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant types in QueryValue
#include <QDebug>     // qInfo, qWarning
#include <QVariant>   // QVariantList from QueryBuilder
#include <algorithm>  // For std::transform

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "sqldriver/sql_query.h"  // SqlQuery
#include "sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::UpdatesImpl(const QueryBuilder &qb_const, const std::map<std::string, QueryValue> &updates_map_in) {
        QueryBuilder qb = qb_const;  // Work with a copy

        if (updates_map_in.empty()) {
            qInfo("cpporm Session::UpdatesImpl: No update values provided.");
            return 0LL;
        }

        std::map<std::string, QueryValue> final_updates = updates_map_in;
        const ModelMeta *meta = qb.getModelMeta();

        if (meta) {
            bool update_model_table_directly = false;
            if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
                const std::string &from_name = std::get<std::string>(qb.getFromClauseSource());
                if ((!from_name.empty() && from_name == meta->table_name) || (from_name.empty() && !meta->table_name.empty())) {
                    update_model_table_directly = true;
                }
            }

            if (update_model_table_directly) {
                if (const FieldMeta *updatedAtField = meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
                    if (updatedAtField->cpp_type == typeid(QDateTime)) {
                        final_updates[updatedAtField->db_name] = QDateTime::currentDateTimeUtc();
                    }
                }
            }
        }

        auto [sql_qstr, params_qvariantlist] = qb.buildUpdateSQL(final_updates);
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError,
                                         "Failed to build SQL for Updates operation. Target might be "
                                         "invalid or table name missing."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) {
            return std::unexpected(exec_err);
        }

        return sql_query_obj.numRowsAffected();
    }

    std::expected<long long, Error> Session::Updates(QueryBuilder qb, const std::map<std::string, QueryValue> &updates) {
        if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
            qWarning(
                "Session::Updates(QueryBuilder, ...): QueryBuilder was associated "
                "with a different executor. The operation will use THIS session's context "
                "by calling its UpdatesImpl. Ensure this is intended.");
        }
        // Always call this session's Impl to ensure correct context and timestamp handling
        return this->UpdatesImpl(qb, updates);
    }

    std::expected<long long, Error> Session::Updates(const ModelMeta &meta, const std::map<std::string, QueryValue> &updates_map, const std::map<std::string, QueryValue> &conditions) {
        if (updates_map.empty()) {
            qInfo("cpporm Session::Updates (by meta): No update values provided.");
            return 0LL;
        }
        QueryBuilder qb = this->Model(meta);
        if (!conditions.empty()) {
            qb.Where(conditions);
        }
        return this->UpdatesImpl(qb, updates_map);
    }

    std::expected<long long, Error> Session::Updates(const ModelBase &model_condition, const std::map<std::string, QueryValue> &updates_map) {
        if (updates_map.empty()) {
            qInfo("cpporm Session::Updates (by model): No update values provided.");
            return 0LL;
        }
        const ModelMeta &meta = model_condition._getOwnModelMeta();
        QueryBuilder qb = this->Model(meta);

        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: No primary key defined for model " + meta.table_name));
        }

        std::map<std::string, QueryValue> pk_conditions;
        for (const auto &pk_db_name : meta.primary_keys_db_names) {
            const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
            if (!pk_field) {
                return std::unexpected(Error(ErrorCode::InternalError, "Updates by model instance: PK field meta not found for " + pk_db_name));
            }
            std::any pk_val_any = model_condition.getFieldValue(pk_field->cpp_name);
            if (!pk_val_any.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: PK value for " + pk_db_name + " is not set in the model."));
            }
            QueryValue qv_pk = Session::anyToQueryValueForSessionConvenience(pk_val_any);
            if (std::holds_alternative<std::nullptr_t>(qv_pk) && pk_val_any.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Updates by model_condition: Unsupported PK type (" + std::string(pk_val_any.type().name()) + ") for field " + pk_db_name));
            }
            pk_conditions[pk_db_name] = qv_pk;
        }

        if (pk_conditions.empty()) {  // Should be caught by !pk_val_any.has_value() or conversion failure
            return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: Failed to extract valid PK conditions."));
        }
        qb.Where(pk_conditions);
        return this->UpdatesImpl(qb, updates_map);
    }

}  // namespace cpporm