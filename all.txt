#ifndef BOLTPROTOCOL_CORE_TYPES_H
#define BOLTPROTOCOL_CORE_TYPES_H

#include <cstdint>  // For uintXX_t types
#include <map>
#include <memory>  // For std::shared_ptr
#include <string>
#include <variant>  // For std::variant
#include <vector>

// Forward declarations within this file if mutually dependent, or include necessary headers
// For now, PackStreamStructure, BoltList, BoltMap are defined before Value uses them with shared_ptr.

namespace boltprotocol {

    // Forward declarations for Value variant members
    struct BoltList;
    struct BoltMap;
    struct PackStreamStructure;

    // Core PackStream Value type
    using Value = std::variant<std::nullptr_t, bool, int64_t, double, std::string, std::shared_ptr<BoltList>, std::shared_ptr<BoltMap>, std::shared_ptr<PackStreamStructure> >;

    // Definition for BoltList
    struct BoltList {
        std::vector<Value> elements;
        bool operator==(const BoltList& other) const {
            // Simple comparison, might need deep comparison for shared_ptr<Value> elements if Value itself can be complex.
            // Current Value::operator== handles shared_ptr comparison correctly.
            return elements == other.elements;
        }
    };

    // Definition for BoltMap
    struct BoltMap {
        std::map<std::string, Value> pairs;
        bool operator==(const BoltMap& other) const {
            return pairs == other.pairs;
        }
    };

    // Definition for PackStreamStructure
    struct PackStreamStructure {
        uint8_t tag = 0;
        std::vector<Value> fields;
        bool operator==(const PackStreamStructure& other) const {
            return tag == other.tag && fields == other.fields;
        }
    };

    // Global operator== for Value, needs full definitions of BoltList, BoltMap, PackStreamStructure
    // This declaration should ideally be where Value is fully defined or usable.
    // If moved to a .cpp, it needs to be declared here.
    // Keeping it here for header-only convenience if types are simple enough.
    // bool operator==(const Value& lhs, const Value& rhs); // Definition will be in message_defs.cpp (or a new core_types.cpp)

    // Global Constants
    constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;
    // extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING; // Declaration here, definition in a .cpp file
    constexpr uint16_t MAX_CHUNK_PAYLOAD_SIZE = 65535;
    constexpr uint16_t CHUNK_HEADER_SIZE = 2;

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CORE_TYPES_H#ifndef BOLTPROTOCOL_ERRORS_VERSIONS_H
#define BOLTPROTOCOL_ERRORS_VERSIONS_H

#include <array>
#include <cstdint>
#include <vector>

namespace boltprotocol {

    enum class BoltError {
        SUCCESS = 0,
        UNKNOWN_ERROR,
        INVALID_ARGUMENT,
        SERIALIZATION_ERROR,
        DESERIALIZATION_ERROR,
        INVALID_MESSAGE_FORMAT,
        UNSUPPORTED_PROTOCOL_VERSION,
        NETWORK_ERROR,
        HANDSHAKE_FAILED,
        HANDSHAKE_NO_COMMON_VERSION,
        HANDSHAKE_MAGIC_MISMATCH,
        CHUNK_TOO_LARGE,
        CHUNK_ENCODING_ERROR,
        CHUNK_DECODING_ERROR,
        OUT_OF_MEMORY,
        RECURSION_DEPTH_EXCEEDED,
        MESSAGE_TOO_LARGE
    };

    namespace versions {
        struct Version {
            uint8_t major = 0;
            uint8_t minor = 0;

            Version() = default;
            constexpr Version(uint8_t maj, uint8_t min) : major(maj), minor(min) {
            }

            bool operator<(const Version& other) const;
            bool operator==(const Version& other) const;
            bool operator!=(const Version& other) const;

            std::array<uint8_t, 4> to_handshake_bytes() const;
            static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
        };

        // Declare version constants as extern
        extern const Version V5_4, V5_3, V5_2, V5_1, V5_0, V4_4;
        // extern const Version V4_3, V4_2, V4_1, V4_0, V3_0; // Add more if defined

        // Declare the function to get default proposed versions
        extern const std::vector<Version>& get_default_proposed_versions();
    }  // namespace versions

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_ERRORS_VERSIONS_H#ifndef BOLTPROTOCOL_MESSAGE_PARAMS_H
#define BOLTPROTOCOL_MESSAGE_PARAMS_H

#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Message Parameter Structures ---

    struct HelloMessageParams { /* ... (remains as in previous version) ... */
        std::string user_agent;
        std::optional<std::string> auth_scheme;
        std::optional<std::string> auth_principal;
        std::optional<std::string> auth_credentials;
        std::optional<std::map<std::string, Value>> auth_scheme_specific_tokens;
        std::optional<std::map<std::string, Value>> routing_context;
        std::optional<std::vector<std::string>> patch_bolt;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        struct BoltAgentInfo {
            std::string product;
            std::optional<std::string> platform;
            std::optional<std::string> language;
            std::optional<std::string> language_details;
        };
        std::optional<BoltAgentInfo> bolt_agent;
        std::map<std::string, Value> other_extra_tokens;
    };

    struct RunMessageParams { /* ... (remains as in previous version) ... */
        std::string cypher_query;
        std::map<std::string, Value> parameters;
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;
        std::optional<std::map<std::string, Value>> tx_metadata;
        std::optional<std::string> mode;
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;
    };

    struct DiscardMessageParams { /* ... (remains as in previous version) ... */
        std::optional<int64_t> n;
        std::optional<int64_t> qid;
    };
    struct PullMessageParams { /* ... (remains as in previous version) ... */
        std::optional<int64_t> n;
        std::optional<int64_t> qid;
    };
    struct BeginMessageParams { /* ... (remains as in previous version) ... */
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;
        std::optional<std::map<std::string, Value>> tx_metadata;
        std::optional<std::string> mode;
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;
    };

    struct CommitMessageParams { /* PSS field is an empty map {} */
    };
    struct RollbackMessageParams { /* PSS field is an empty map {} */
    };

    struct RouteMessageParams {
        // Field 1: routing::Dictionary
        std::map<std::string, Value> routing_table_context;  // Renamed for clarity from routing_context to avoid clash with HELLO

        // Field 2: bookmarks::List<String>
        std::vector<std::string> bookmarks;

        // For Bolt 4.3, Field 3 is db::String (or null)
        std::optional<std::string> db_name_for_v43;

        // For Bolt 4.4+, Field 3 is extra::Dictionary(db::String, imp_user::String)
        // This map can contain "db" and/or "imp_user".
        std::optional<std::map<std::string, Value>> extra_for_v44_plus;
    };

    struct TelemetryMessageParams { /* ... (remains as in previous version) ... */
        std::map<std::string, Value> metadata;
    };
    struct LogonMessageParams { /* ... (remains as in previous version) ... */
        std::map<std::string, Value> auth_tokens;
    };
    struct LogoffMessageParams { /* No fields */
    };

    struct SuccessMessageParams { /* ... (remains as in previous version) ... */
        std::map<std::string, Value> metadata;
    };
    struct RecordMessageParams { /* ... (remains as in previous version) ... */
        std::vector<Value> fields;
    };
    struct FailureMessageParams { /* ... (remains as in previous version) ... */
        std::map<std::string, Value> metadata;
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_PARAMS_H#ifndef BOLTPROTOCOL_MESSAGE_TAGS_H
#define BOLTPROTOCOL_MESSAGE_TAGS_H

#include <cstdint>

namespace boltprotocol {

    enum class MessageTag : uint8_t {
        HELLO = 0x01,
        RUN = 0x10,
        DISCARD = 0x2F,
        PULL = 0x3F,
        BEGIN = 0x11,
        COMMIT = 0x12,
        ROLLBACK = 0x13,
        RESET = 0x0F,
        GOODBYE = 0x02,
        ROUTE = 0x66,
        TELEMETRY = 0x54,
        LOGON = 0x6A,
        LOGOFF = 0x6B,
        SUCCESS = 0x70,
        RECORD = 0x71,
        IGNORED = 0x7E,
        FAILURE = 0x7F,
        // INIT = 0x01, // Same as HELLO tag
        // ACK_FAILURE = 0x0E // Bolt v1/v2 only
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_TAGS_H#ifndef BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H
#define BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_structure_types.h"

namespace boltprotocol {

    // --- Conversion from PackStreamStructure to Typed Struct ---

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    // For from_packstream, utc_patch_active might not be strictly needed if we rely on the tag ('I' vs 'F') primarily.
    // However, for to_packstream, it's crucial for Bolt 4.4.
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);

    // --- Conversion from Typed Struct to PackStreamStructure ---

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);               // <--- MODIFIED
    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);  // <--- MODIFIED
    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss);

    // Convenience template to extract from Value
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct, const versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Dispatch to the correct from_packstream overload based on T
        if constexpr (std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId> || std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath>) {
            // These types' from_packstream take bolt_version.
            // For DateTime/DateTimeZoneId, utc_patch_active is not directly used by from_packstream (tag driven).
            return from_packstream(*pss_sptr, out_typed_struct, bolt_version);
        } else {
            // For types like BoltDate, BoltTime, etc., that don't need bolt_version for from_packstream.
            return from_packstream(*pss_sptr, out_typed_struct);
        }
    }
    // Keep the overload for types not needing version or patch info for deserialization (tag-driven)
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // This simple overload is suitable for types whose from_packstream does not need a version.
        // For version-dependent types, the other overload must be used.
        return from_packstream(*pss_sptr, out_typed_struct);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H#ifndef BOLTPROTOCOL_STRUCTURE_TYPES_H
#define BOLTPROTOCOL_STRUCTURE_TYPES_H

#include <cstdint>
#include <map>
#include <memory>  // For std::shared_ptr in Path
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"  // For Value, BoltMap, BoltList, PackStreamStructure
// bolt_errors_versions.h might be needed if version checks are done during construction/conversion
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Graph Primitives ---

    // Tag: 0x4E ('N')
    struct BoltNode {
        int64_t id;                               // Field 0: id (Integer)
        std::vector<std::string> labels;          // Field 1: labels (List<String>)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        // Default constructor
        BoltNode() : id(0) {
        }

        bool operator==(const BoltNode& other) const {
            return id == other.id && labels == other.labels && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x52 ('R')
    struct BoltRelationship {
        int64_t id;                                        // Field 0: id (Integer)
        int64_t start_node_id;                             // Field 1: startNodeId (Integer)
        int64_t end_node_id;                               // Field 2: endNodeId (Integer)
        std::string type;                                  // Field 3: type (String)
        std::map<std::string, Value> properties;           // Field 4: properties (Map)
        std::optional<std::string> element_id;             // Field 5: element_id (String, Bolt 5.0+)
        std::optional<std::string> start_node_element_id;  // Field 6: start_node_element_id (String, Bolt 5.0+)
        std::optional<std::string> end_node_element_id;    // Field 7: end_node_element_id (String, Bolt 5.0+)

        BoltRelationship() : id(0), start_node_id(0), end_node_id(0) {
        }

        bool operator==(const BoltRelationship& other) const {
            return id == other.id && start_node_id == other.start_node_id && end_node_id == other.end_node_id && type == other.type && properties == other.properties && element_id == other.element_id && start_node_element_id == other.start_node_element_id &&
                   end_node_element_id == other.end_node_element_id;
        }
    };

    // Tag: 0x72 ('r') - Unbound Relationship (used within Path)
    struct BoltUnboundRelationship {
        int64_t id;                               // Field 0: id (Integer)
        std::string type;                         // Field 1: type (String)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        BoltUnboundRelationship() : id(0) {
        }

        bool operator==(const BoltUnboundRelationship& other) const {
            return id == other.id && type == other.type && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x50 ('P')
    struct BoltPath {
        std::vector<BoltNode> nodes;                // Field 0: nodes (List<Node>)
        std::vector<BoltUnboundRelationship> rels;  // Field 1: rels (List<UnboundRelationship>)
        std::vector<int64_t> indices;               // Field 2: indices (List<Integer>)
        // Note: For Path, nodes and rels are lists of *actual* BoltNode/BoltUnboundRelationship objects,
        // not shared_ptr<PackStreamStructure>. The conversion logic will handle this.

        bool operator==(const BoltPath& other) const {
            return nodes == other.nodes && rels == other.rels && indices == other.indices;
        }
    };

    // --- Temporal Types ---

    // Tag: 0x44 ('D') - Date
    struct BoltDate {
        int64_t days_since_epoch;  // days since Unix epoch (1970-01-01)

        BoltDate(int64_t days = 0) : days_since_epoch(days) {
        }
        bool operator==(const BoltDate& other) const {
            return days_since_epoch == other.days_since_epoch;
        }
    };

    // Tag: 0x54 ('T') - Time (with offset)
    struct BoltTime {
        int64_t nanoseconds_since_midnight;  // nanoseconds since midnight for the given offset
        int32_t tz_offset_seconds;           // offset in seconds from UTC

        BoltTime(int64_t nanos = 0, int32_t offset = 0) : nanoseconds_since_midnight(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x74 ('t') - LocalTime
    struct BoltLocalTime {
        int64_t nanoseconds_since_midnight;

        BoltLocalTime(int64_t nanos = 0) : nanoseconds_since_midnight(nanos) {
        }
        bool operator==(const BoltLocalTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight;
        }
    };

    // Tag: 0x49 ('I') - DateTime (with offset, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTime (tag 0x46 'F')
    struct BoltDateTime {
        int64_t seconds_epoch_utc;      // seconds since Unix epoch (UTC)
        int32_t nanoseconds_of_second;  // nanoseconds within the second (0 to 999,999,999)
        int32_t tz_offset_seconds;      // offset in seconds from UTC for the original instant

        BoltDateTime(int64_t secs = 0, int32_t nanos = 0, int32_t offset = 0) : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltDateTime& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x69 ('i') - DateTimeZoneId (with named zone, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTimeZoneId (tag 0x66 'f')
    struct BoltDateTimeZoneId {
        int64_t seconds_epoch_utc;
        int32_t nanoseconds_of_second;
        std::string tz_id;  // Timezone ID string (e.g., "Europe/Paris")

        BoltDateTimeZoneId(int64_t secs = 0, int32_t nanos = 0, std::string id = "") : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_id(std::move(id)) {
        }
        bool operator==(const BoltDateTimeZoneId& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_id == other.tz_id;
        }
    };

    // Tag: 0x64 ('d') - LocalDateTime
    struct BoltLocalDateTime {
        int64_t seconds_epoch_local;  // seconds since Unix epoch, interpreted as local datetime
        int32_t nanoseconds_of_second;

        BoltLocalDateTime(int64_t secs = 0, int32_t nanos = 0) : seconds_epoch_local(secs), nanoseconds_of_second(nanos) {
        }
        bool operator==(const BoltLocalDateTime& other) const {
            return seconds_epoch_local == other.seconds_epoch_local && nanoseconds_of_second == other.nanoseconds_of_second;
        }
    };

    // Tag: 0x45 ('E') - Duration
    struct BoltDuration {
        int64_t months;
        int64_t days;
        int64_t seconds;
        int32_t nanoseconds;  // nanoseconds adjustment for seconds component

        BoltDuration(int64_t m = 0, int64_t d = 0, int64_t s = 0, int32_t ns = 0) : months(m), days(d), seconds(s), nanoseconds(ns) {
        }
        bool operator==(const BoltDuration& other) const {
            return months == other.months && days == other.days && seconds == other.seconds && nanoseconds == other.nanoseconds;
        }
    };

    // --- Spatial Types ---

    // Tag: 0x58 ('X') - Point2D
    struct BoltPoint2D {
        uint32_t srid;  // Spatial Reference System Identifier
        double x;
        double y;

        BoltPoint2D(uint32_t id = 0, double px = 0.0, double py = 0.0) : srid(id), x(px), y(py) {
        }
        bool operator==(const BoltPoint2D& other) const {
            return srid == other.srid && x == other.x && y == other.y;
        }
    };

    // Tag: 0x59 ('Y') - Point3D
    struct BoltPoint3D {
        uint32_t srid;
        double x;
        double y;
        double z;

        BoltPoint3D(uint32_t id = 0, double px = 0.0, double py = 0.0, double pz = 0.0) : srid(id), x(px), y(py), z(pz) {
        }
        bool operator==(const BoltPoint3D& other) const {
            return srid == other.srid && x == other.x && y == other.y && z == other.z;
        }
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_TYPES_H#ifndef BOLTPROTOCOL_CHUNKING_H
#define BOLTPROTOCOL_CHUNKING_H

#include <cstdint>
#include <functional>  // For std::function
#include <iosfwd>      // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE

namespace boltprotocol {

    /**
     * @brief ChunkedWriter 用于将完整的 Bolt 消息分块写入输出流。
     */
    class ChunkedWriter {
      public:
        explicit ChunkedWriter(std::ostream& stream);

        // 禁止拷贝和移动，因为其持有流的引用
        ChunkedWriter(const ChunkedWriter&) = delete;
        ChunkedWriter& operator=(const ChunkedWriter&) = delete;
        ChunkedWriter(ChunkedWriter&&) = delete;
        ChunkedWriter& operator=(ChunkedWriter&&) = delete;

        /**
         * @brief 将提供的完整消息数据分块写入流。
         *        会自动添加块头和末尾的空块。
         * @param message_data 包含单个完整 Bolt 消息的字节向量。
         * @return BoltError::SUCCESS 如果所有块都成功写入。
         *         BoltError::NETWORK_ERROR 如果流写入失败。
         *         BoltError::SERIALIZATION_ERROR 如果内部逻辑错误（例如块大小计算）。
         */
        BoltError write_message(const std::vector<uint8_t>& message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }

        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError write_chunk(const uint8_t* data, uint16_t size);
        BoltError write_chunk_header(uint16_t chunk_payload_size);
        BoltError write_end_of_message_marker();  // Writes a zero-size chunk

        void set_error(BoltError err);

        std::ostream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
    };

    /**
     * @brief ChunkedReader 用于从输入流中读取分块的 Bolt 消息。
     */
    class ChunkedReader {
      public:
        explicit ChunkedReader(std::istream& stream);

        // 禁止拷贝和移动
        ChunkedReader(const ChunkedReader&) = delete;
        ChunkedReader& operator=(const ChunkedReader&) = delete;
        ChunkedReader(ChunkedReader&&) = delete;
        ChunkedReader& operator=(ChunkedReader&&) = delete;

        /**
         * @brief 从流中读取一个完整的 Bolt 消息。
         *        它会持续读取数据块，直到遇到表示消息结束的空块。
         * @param out_message_data 输出参数，用于存储组装好的完整消息字节。
         *                         如果发生错误，此参数的内容未定义。
         * @return BoltError::SUCCESS 如果成功读取并组装了一个完整的消息。
         *         BoltError::NETWORK_ERROR 如果流读取失败。
         *         BoltError::DESERIALIZATION_ERROR 如果块格式无效或消息过大。
         *         BoltError::CHUNK_TOO_LARGE 如果单个块的声明大小超过 MAX_CHUNK_PAYLOAD_SIZE.
         */
        BoltError read_message(std::vector<uint8_t>& out_message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }
        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError read_chunk_header(uint16_t& out_chunk_payload_size);
        BoltError read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to);

        void set_error(BoltError err);

        std::istream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
        // 可以在这里添加一个内部缓冲区来优化小块的读取，但为了简单起见，暂时直接追加到输出向量
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CHUNKING_H#ifndef BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H
#define BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H

#include <map>
#include <memory>  // For std::shared_ptr
#include <optional>
#include <string>
#include <variant>  // For std::holds_alternative, std::get
#include <vector>

#include "boltprotocol/bolt_core_types.h"       // For Value, BoltList, BoltMap, PackStreamStructure
#include "boltprotocol/bolt_errors_versions.h"  // For versions::Version, BoltError
#include "boltprotocol/bolt_structure_types.h"  // For forward declaring BoltNode etc. if needed, or full defs for recursion

// Forward declare from_packstream for recursive calls in get_typed_list_field
namespace boltprotocol {
    // We need to forward declare all from_packstream overloads that might be called recursively
    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);
}  // namespace boltprotocol

namespace boltprotocol {
    namespace detail {

        template <typename T>
        inline std::optional<T> get_typed_field(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<T>(field_value)) {
                    try {
                        return std::get<T>(field_value);
                    } catch (const std::bad_variant_access&) { /* Defensive */
                    }
                }
            }
            return std::nullopt;
        }

        // Specialization for shared_ptr<BoltMap> to return the inner map directly
        template <>
        inline std::optional<std::map<std::string, Value>> get_typed_field<std::map<std::string, Value>>(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltMap>>(field_value)) {
                    const auto& map_sptr = std::get<std::shared_ptr<BoltMap>>(field_value);
                    if (map_sptr) {
                        try {
                            return map_sptr->pairs;
                        } catch (...) { /* map copy failed */
                        }
                    }
                }
            }
            return std::nullopt;
        }

        template <typename T>  // T is the target strong type, e.g., BoltNode
        inline std::optional<std::vector<T>> get_typed_list_field(const std::vector<Value>& fields, size_t index, const versions::Version* bolt_version_for_nested = nullptr) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltList>>(field_value)) {
                    const auto& list_sptr = std::get<std::shared_ptr<BoltList>>(field_value);
                    if (list_sptr) {
                        std::vector<T> result;
                        result.reserve(list_sptr->elements.size());
                        bool conversion_ok = true;
                        for (const auto& list_element_value : list_sptr->elements) {
                            if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(list_element_value)) {
                                const auto& element_pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(list_element_value);
                                if (element_pss_sptr) {
                                    T typed_element;
                                    BoltError err = BoltError::UNKNOWN_ERROR;  // Initialize to an error state

                                    // Dispatch based on type T for version parameter
                                    if constexpr (std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath> || std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId>) {
                                        if (!bolt_version_for_nested) {  // Version is required for these types
                                            conversion_ok = false;
                                            break;
                                        }
                                        err = from_packstream(*element_pss_sptr, typed_element, *bolt_version_for_nested);
                                    } else {  // For types like BoltDate, BoltTime, etc., that don't need version for from_packstream
                                        err = from_packstream(*element_pss_sptr, typed_element);
                                    }

                                    if (err == BoltError::SUCCESS) {
                                        try {
                                            result.push_back(std::move(typed_element));
                                        } catch (...) {
                                            conversion_ok = false;
                                            break;
                                        }
                                    } else {
                                        conversion_ok = false;
                                        break;
                                    }
                                } else {
                                    conversion_ok = false;
                                    break;
                                }  // Null PSS in list
                            } else {
                                conversion_ok = false;
                                break;
                            }  // Element not a PSS
                        }
                        if (conversion_ok) return result;
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H#ifndef BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H
#define BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H

#include <algorithm>  // For std::reverse
#include <bit>        // For std::endian (C++20 and later)
#include <cstdint>
#include <type_traits>  // For std::is_integral_v, std::is_enum_v

namespace boltprotocol {
    namespace detail {

        // Helper to swap bytes of an integer type T
        template <typename T>
        inline T swap_bytes_helper(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "swap_bytes_helper requires an integral or enum type.");
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
            auto* bytes = reinterpret_cast<unsigned char*>(&value);
            std::reverse(bytes, bytes + sizeof(T));
            return value;
        }

        // --- Host to Big Endian (Network Order) ---
        inline uint16_t host_to_be(uint16_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {  // std::endian::big (or other, assuming network order is what we want if not little)
                return val;
            }
        }

        inline uint32_t host_to_be(uint32_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        inline uint64_t host_to_be(uint64_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        // --- Big Endian (Network Order) to Host ---
        inline uint16_t be_to_host(uint16_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint32_t be_to_host(uint32_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint64_t be_to_host(uint64_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H#ifndef BOLTPROTOCOL_HANDSHAKE_H
#define BOLTPROTOCOL_HANDSHAKE_H

#include <array>
#include <boost/asio/basic_socket_iostream.hpp>  // For boost::asio::basic_socket_iostream
#include <boost/asio/ip/tcp.hpp>                 // For boost::asio::ip::tcp
#include <boost/asio/read.hpp>
#include <boost/asio/ssl/stream.hpp>  // For boost::asio::ssl::stream
#include <boost/asio/write.hpp>
#include <boost/system/error_code.hpp>
#include <cstdint>
#include <cstring>  // For std::memcpy
#include <istream>  // For std::istream characteristics if needed
#include <ostream>  // For std::ostream characteristics if needed
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"

namespace boltprotocol {

    constexpr size_t HANDSHAKE_NUM_PROPOSED_VERSIONS = 4;
    constexpr size_t HANDSHAKE_VERSION_SIZE_BYTES = 4;
    constexpr size_t HANDSHAKE_REQUEST_SIZE_BYTES = sizeof(BOLT_MAGIC_PREAMBLE) + (HANDSHAKE_NUM_PROPOSED_VERSIONS * HANDSHAKE_VERSION_SIZE_BYTES);
    constexpr size_t HANDSHAKE_RESPONSE_SIZE_BYTES = HANDSHAKE_VERSION_SIZE_BYTES;

    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes);
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response, versions::Version& out_negotiated_version);

    template <typename StreamType>
    BoltError perform_handshake(StreamType& stream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version) {
        std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes;
        BoltError build_err = build_handshake_request(proposed_versions, handshake_request_bytes);
        if (build_err != BoltError::SUCCESS) {
            return build_err;
        }

        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes;
        boost::system::error_code ec;

        // 使用 if constexpr 根据 StreamType 选择不同的 IO 操作
        if constexpr (std::is_base_of_v<std::basic_iostream<char>, StreamType> &&
                      // 进一步区分 basic_socket_iostream 和其他可能继承 std::iostream 的 Boost 类型
                      (std::is_same_v<StreamType, boost::asio::ip::tcp::iostream> || std::is_same_v<StreamType, boost::asio::basic_socket_iostream<boost::asio::ip::tcp>>)) {
            // 这是 boost::asio::ip::tcp::iostream 或其基类 basic_socket_iostream
            // 使用标准的 iostream 成员函数
            stream.write(reinterpret_cast<const char*>(handshake_request_bytes.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
            if (stream.fail()) return BoltError::NETWORK_ERROR;
            stream.flush();
            if (stream.fail()) return BoltError::NETWORK_ERROR;

            stream.read(reinterpret_cast<char*>(server_response_bytes.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
            if (stream.fail() || static_cast<size_t>(stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
                return BoltError::NETWORK_ERROR;
            }
        } else {
            // 假设是其他 Boost.ASIO 同步流类型，如 ssl::stream 或 ip::tcp::socket
            // 使用 boost::asio::write 和 boost::asio::read 自由函数
            boost::asio::write(stream, boost::asio::buffer(handshake_request_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }

            boost::asio::read(stream, boost::asio::buffer(server_response_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }
        }

        return parse_handshake_response(server_response_bytes, out_negotiated_version);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_HANDSHAKE_H#ifndef BOLTPROTOCOL_MESSAGE_DEFS_H
#define BOLTPROTOCOL_MESSAGE_DEFS_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_message_params.h"
#include "bolt_message_tags.h"
#include "bolt_structure_types.h"  // <--- ADDED: For BoltNode, BoltDate etc.
// bolt_structure_serialization.h is for functions, not direct types needed by message_params generally

namespace boltprotocol {
    extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING;
    bool operator==(const Value& lhs, const Value& rhs);
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_DEFS_H#ifndef BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H
#define BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    // --- Client Message Serialization (Client -> Server) ---
    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version);
    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_goodbye_message(PackStreamWriter& writer);
    BoltError serialize_reset_message(PackStreamWriter& writer);
    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_commit_message(PackStreamWriter& writer);
    BoltError serialize_rollback_message(PackStreamWriter& writer);
    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version);
    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logoff_message(PackStreamWriter& writer);

    // --- Server Message Deserialization (Server -> Client) ---
    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params);
    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params);
    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params);
    BoltError deserialize_ignored_message(PackStreamReader& reader);

    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents);

    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count);

    // --- Server-Side Deserialization of Client Requests ---
    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params);
    BoltError deserialize_logoff_message_request(PackStreamReader& reader);
    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version);

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version);        // <--- MODIFIED
    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- MODIFIED
    BoltError deserialize_commit_message_request(PackStreamReader& reader);
    BoltError deserialize_rollback_message_request(PackStreamReader& reader);
    BoltError deserialize_reset_message_request(PackStreamReader& reader);
    BoltError deserialize_goodbye_message_request(PackStreamReader& reader);
    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- ADDED
    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params);                                              // <--- ADDED

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H

#include <cstdint>

namespace boltprotocol {

    // PackStream Marker Bytes
    constexpr uint8_t MARKER_NULL = 0xC0;
    constexpr uint8_t MARKER_FALSE = 0xC2;
    constexpr uint8_t MARKER_TRUE = 0xC3;
    constexpr uint8_t MARKER_FLOAT64 = 0xC1;

    // Integer markers
    // Tiny Int: -16 to 127 directly encoded in the marker byte
    // INT_8:  0xC8 <int8>
    // INT_16: 0xC9 <int16>
    // INT_32: 0xCA <int32>
    // INT_64: 0xCB <int64>
    constexpr uint8_t MARKER_INT_8 = 0xC8;
    constexpr uint8_t MARKER_INT_16 = 0xC9;
    constexpr uint8_t MARKER_INT_32 = 0xCA;
    constexpr uint8_t MARKER_INT_64 = 0xCB;

    // String markers
    // TINY_STRING: 0x80..0x8F (length 0-15)
    // STRING_8:    0xD0 <len_uint8> <utf8_bytes>
    // STRING_16:   0xD1 <len_uint16> <utf8_bytes>
    // STRING_32:   0xD2 <len_uint32> <utf8_bytes>
    constexpr uint8_t MARKER_TINY_STRING_BASE = 0x80;  // Base for 0x80 | len
    constexpr uint8_t MARKER_STRING_8 = 0xD0;
    constexpr uint8_t MARKER_STRING_16 = 0xD1;
    constexpr uint8_t MARKER_STRING_32 = 0xD2;

    // List markers
    // TINY_LIST:   0x90..0x9F (size 0-15)
    // LIST_8:      0xD4 <size_uint8>
    // LIST_16:     0xD5 <size_uint16>
    // LIST_32:     0xD6 <size_uint32>
    constexpr uint8_t MARKER_TINY_LIST_BASE = 0x90;  // Base for 0x90 | size
    constexpr uint8_t MARKER_LIST_8 = 0xD4;
    constexpr uint8_t MARKER_LIST_16 = 0xD5;
    constexpr uint8_t MARKER_LIST_32 = 0xD6;

    // Map markers
    // TINY_MAP:    0xA0..0xAF (size 0-15)
    // MAP_8:       0xD8 <size_uint8>
    // MAP_16:      0xD9 <size_uint16>
    // MAP_32:      0xDA <size_uint32>
    constexpr uint8_t MARKER_TINY_MAP_BASE = 0xA0;  // Base for 0xA0 | size
    constexpr uint8_t MARKER_MAP_8 = 0xD8;
    constexpr uint8_t MARKER_MAP_16 = 0xD9;
    constexpr uint8_t MARKER_MAP_32 = 0xDA;

    // Structure markers
    // TINY_STRUCT: 0xB0..0xBF (size 0-15) <tag_uint8>
    // STRUCT_8:    0xDC <size_uint8> <tag_uint8>
    // STRUCT_16:   0xDD <size_uint16> <tag_uint8>
    constexpr uint8_t MARKER_TINY_STRUCT_BASE = 0xB0;  // Base for 0xB0 | size
    constexpr uint8_t MARKER_STRUCT_8 = 0xDC;
    constexpr uint8_t MARKER_STRUCT_16 = 0xDD;

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamReader {
      public:
        explicit PackStreamReader(const std::vector<uint8_t>& buffer);
        explicit PackStreamReader(std::istream& stream);

        // 禁止拷贝和移动以避免对内部状态和流/缓冲区的复杂管理
        PackStreamReader(const PackStreamReader&) = delete;
        PackStreamReader& operator=(const PackStreamReader&) = delete;
        PackStreamReader(PackStreamReader&&) = delete;
        PackStreamReader& operator=(PackStreamReader&&) = delete;

        /**
         * @brief Reads a single PackStream Value from the input.
         * @param out_value Output parameter where the read Value will be stored if successful.
         *                  Its content is undefined if an error occurs.
         * @return BoltError::SUCCESS on successful read.
         *         BoltError::DESERIALIZATION_ERROR for format errors, unexpected EOF, etc.
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if reader not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails.
         */
        BoltError read(Value& out_value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

        /**
         * @brief Checks if the end of the underlying buffer or stream has been reached.
         *        Also returns true if an error has occurred, as further reading is not possible.
         * @return True if EOF or error, false otherwise.
         */
        bool eof() const;

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError peek_byte(uint8_t& out_byte);
        BoltError consume_byte(uint8_t& out_byte);
        BoltError consume_bytes(void* dest, size_t size);

        template <typename T>
        BoltError consume_network_int(T& out_val) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "consume_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;  // 如果已处于错误状态，则不继续

            // 初始化 out_val 以防早期返回
            out_val = T{};
            BoltError err;

            if constexpr (sizeof(T) == 1) {
                uint8_t byte_val;
                err = consume_byte(byte_val);
                if (err != BoltError::SUCCESS) return err;
                out_val = static_cast<T>(byte_val);
                return BoltError::SUCCESS;
            } else {
                typename std::conditional<sizeof(T) == 2, uint16_t, typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type>::type raw_be_val = 0;

                err = consume_bytes(&raw_be_val, sizeof(raw_be_val));
                if (err != BoltError::SUCCESS) return err;

                if constexpr (sizeof(T) == 2) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint16_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 4) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint32_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 8) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint64_t>(raw_be_val)));
                } else {
                    static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for consume_network_int.");
                    set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                    return BoltError::INVALID_ARGUMENT;
                }
                return BoltError::SUCCESS;
            }
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的读取辅助函数 (现在返回 BoltError 并通过 out_value 输出参数返回结果)
        BoltError read_null_value(Value& out_value);
        BoltError read_boolean_value(bool bool_val_from_marker, Value& out_value);
        BoltError read_float64_value(Value& out_value);
        BoltError read_integer_value(uint8_t marker, Value& out_value);
        BoltError read_string_value(uint8_t marker, Value& out_value);
        BoltError read_string_data_into(std::string& out_string, uint32_t size);
        BoltError read_list_value(uint8_t marker, Value& out_value);
        BoltError read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size);
        BoltError read_map_value(uint8_t marker, Value& out_value);
        BoltError read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size);
        BoltError read_struct_value(uint8_t marker, Value& out_value);
        BoltError read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size);

        const std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::istream* stream_ptr_ = nullptr;
        size_t buffer_pos_ = 0;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器，用于防止解析恶意构造的数据时栈溢出
        // (在实际的 read_list/map/struct_elements_into 中使用)
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 可配置
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamWriter {
      public:
        explicit PackStreamWriter(std::vector<uint8_t>& buffer);
        explicit PackStreamWriter(std::ostream& stream);

        // 禁止拷贝和移动
        PackStreamWriter(const PackStreamWriter&) = delete;
        PackStreamWriter& operator=(const PackStreamWriter&) = delete;
        PackStreamWriter(PackStreamWriter&&) = delete;
        PackStreamWriter& operator=(PackStreamWriter&&) = delete;

        /**
         * @brief Writes a single PackStream Value to the output.
         * @param value The Value to serialize and write.
         * @return BoltError::SUCCESS on successful write.
         *         BoltError::SERIALIZATION_ERROR for logical errors (e.g., string too long).
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if writer not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails (e.g. vector resize).
         */
        BoltError write(const Value& value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError append_byte(uint8_t byte);
        BoltError append_bytes(const void* data, size_t size);

        template <typename T>
        BoltError append_network_int(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "append_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;

            BoltError err;
            if constexpr (sizeof(T) == 1) {
                err = append_byte(static_cast<uint8_t>(value));
            } else if constexpr (sizeof(T) == 2) {
                uint16_t be_val = detail::host_to_be(static_cast<uint16_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 4) {
                uint32_t be_val = detail::host_to_be(static_cast<uint32_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 8) {
                uint64_t be_val = detail::host_to_be(static_cast<uint64_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else {
                static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for append_network_int.");
                set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                return BoltError::INVALID_ARGUMENT;
            }
            return err;  // 返回 append_byte 或 append_bytes 的结果
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的内部写入函数 (现在返回 BoltError)
        BoltError write_null_internal();
        BoltError write_boolean_internal(bool bool_value);
        BoltError write_integer_internal(int64_t int_value);
        BoltError write_float_internal(double float_value);
        BoltError write_string_header_internal(uint32_t size);
        BoltError write_string_data_internal(const std::string& value_str);  // 已改为 const ref
        BoltError serialize_string_internal(const std::string& str_value);
        BoltError write_list_header_internal(uint32_t size);
        BoltError serialize_list_internal(const BoltList& list_data);  // 已改为 const ref
        BoltError write_map_header_internal(uint32_t size);
        BoltError serialize_map_internal(const BoltMap& map_data);  // 已改为 const ref
        BoltError write_struct_header_internal(uint8_t tag, uint32_t size);
        BoltError serialize_structure_internal(const PackStreamStructure& struct_data);  // 已改为 const ref

        std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::ostream* stream_ptr_ = nullptr;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 与 Reader 保持一致
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H