file(GLOB_RECURSE NEO4J_BOLT_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(Neo4jBoltTransport ${NEO4J_BOLT_TRANSPORT_SOURCE})

target_include_directories(Neo4jBoltTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(Neo4jBoltTransport PUBLIC Boost::asio Boost::system)
target_link_libraries(Neo4jBoltTransport PUBLIC Protocol)
target_compile_definitions(Neo4jBoltTransport PUBLIC SPDLOG_USE_STD_FORMAT)
target_link_libraries(Neo4jBoltTransport
    PUBLIC
    spdlog::spdlog_header_only
)#ifndef NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H
#define NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H

#include <map>
#include <memory>  // For std::shared_ptr for field_names
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/bolt_structure_types.h"
#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {

    class BoltRecord {
      public:
        // Constructor takes rvalue refs to move data if possible.
        // field_names_ptr is shared because multiple records from the same result stream share it.
        BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> field_names_ptr);

        BoltRecord(const BoltRecord&) = delete;  // Typically records are not copied once created
        BoltRecord& operator=(const BoltRecord&) = delete;
        BoltRecord(BoltRecord&&) noexcept = default;
        BoltRecord& operator=(BoltRecord&&) noexcept = default;

        // Access by index
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(size_t index) const;

        // Access by name
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(const std::string& field_name) const;

        // Typed access by index
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(size_t index) const;

        // Typed access by name
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(const std::string& field_name) const;

        // Typed access for Bolt Structures (Node, Relationship, etc.)
        // These require the Bolt version for correct deserialization of version-dependent fields.
        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(size_t index,
                                                                                  const boltprotocol::versions::Version& bolt_version,
                                                                                  bool utc_patch_active_for_4_4 = false  // Relevant for DateTime types in Bolt 4.4
        ) const;

        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) const;

        size_t field_count() const noexcept {
            return fields_.size();
        }
        const std::vector<std::string>& field_names() const;  // Returns empty if no names available

      private:
        std::vector<boltprotocol::Value> fields_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_;  // Pointer to shared field names
        // Optional: Cache field name to index map for faster named lookups if records are long-lived
        // mutable std::optional<std::map<std::string, size_t>> field_name_to_index_cache_;
        // const std::map<std::string, size_t>& get_field_name_map() const;
    };

    // --- Template Implementations for BoltRecord ---
    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(size_t index) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T{}};
        }
        if (std::holds_alternative<T>(value_result.second)) {
            try {
                return {boltprotocol::BoltError::SUCCESS, std::get<T>(value_result.second)};
            } catch (const std::bad_variant_access&) {                         // Should not happen if holds_alternative is true
                return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
            }
        }
        // Special case for int64_t, allow conversion from other integral types if safe (e.g. int32_t -> int64_t)
        // This requires more complex logic or a dedicated conversion utility.
        // For now, strict type match.
        return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
    }

    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // No field names available
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // Field name not found
        }
        return get_as<T>(static_cast<size_t>(index));
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(size_t index, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T_BoltStructure{}};
        }

        T_BoltStructure typed_struct;
        boltprotocol::BoltError conversion_err;

        // Use the value_to_typed_struct that takes version and patch info
        if constexpr (std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTime> || std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTimeZoneId> || std::is_same_v<T_BoltStructure, boltprotocol::BoltNode> || std::is_same_v<T_BoltStructure, boltprotocol::BoltRelationship> ||
                      std::is_same_v<T_BoltStructure, boltprotocol::BoltUnboundRelationship> || std::is_same_v<T_BoltStructure, boltprotocol::BoltPath>) {
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct, bolt_version, utc_patch_active_for_4_4);
        } else {  // For types like BoltDate, BoltTime that don't need version for deserialization
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct);
        }

        if (conversion_err != boltprotocol::BoltError::SUCCESS) {
            return {conversion_err, T_BoltStructure{}};
        }
        return {boltprotocol::BoltError::SUCCESS, typed_struct};
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        return get_bolt_structure_as<T_BoltStructure>(static_cast<size_t>(index), bolt_version, utc_patch_active_for_4_4);
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H

#include <map>
#include <optional>
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For boltprotocol::Value

namespace neo4j_bolt_transport {
    namespace config {

        struct NoAuth {};

        struct BasicAuth {
            std::string username;
            std::string password;
            std::optional<std::string> realm;
        };

        struct KerberosAuth {
            std::string base64_ticket;
        };

        struct CustomAuth {
            std::string principal;
            std::string credentials;
            std::optional<std::string> realm;
            std::string scheme;  // The custom scheme name, e.g., "custom_sso"
            std::optional<std::map<std::string, boltprotocol::Value>> parameters;
        };

        struct BearerAuth {
            std::string token;  // The bearer token
        };

        // Variant to hold different authentication types
        using AuthTokenVariant = std::variant<NoAuth, BasicAuth, KerberosAuth, BearerAuth, CustomAuth>;

        // Factory class for creating AuthTokenVariant instances easily
        class AuthTokens {
          public:
            AuthTokens() = delete;  // Static factory methods only

            static AuthTokenVariant none();
            static AuthTokenVariant basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm = std::nullopt);
            static AuthTokenVariant kerberos(const std::string& base64_ticket);
            static AuthTokenVariant bearer(const std::string& token);
            static AuthTokenVariant custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters = std::nullopt);
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {
    namespace config {

        enum class AccessMode { READ, WRITE };

        struct SessionParameters {
            std::optional<std::string> database_name;
            AccessMode default_access_mode = AccessMode::WRITE;
            std::vector<std::string> initial_bookmarks;
            std::optional<std::string> impersonated_user;

            // Default number of records to fetch in each PULL message.
            // -1 typically means "fetch all remaining".
            // Drivers often have a default like 1000.
            int64_t default_fetch_size = 1000;

            SessionParameters() = default;

            static SessionParameters for_database(const std::string& db_name) {
                SessionParameters p;
                p.database_name = db_name;
                return p;
            }

            SessionParameters& with_database(const std::string& db_name) {
                database_name = db_name;
                return *this;
            }
            SessionParameters& with_default_access_mode(AccessMode mode) {
                default_access_mode = mode;
                return *this;
            }
            SessionParameters& with_bookmarks(const std::vector<std::string>& new_bookmarks) {
                initial_bookmarks = new_bookmarks;
                return *this;
            }
            SessionParameters& with_impersonated_user(const std::string& user) {
                impersonated_user = user;
                return *this;
            }
            SessionParameters& with_fetch_size(int64_t size) {
                default_fetch_size = size;
                return *this;
            }
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H

#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <set>  // For set of ServerAddress
#include <string>
#include <vector>

#include "auth_token.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/routing/server_address.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    namespace uri {
        struct ParsedUri;
    }

    namespace config {

        struct TransportConfig {
            std::string uri_string;
            AuthTokenVariant auth_token = AuthTokens::none();
            std::string user_agent_override;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info;

            enum class EncryptionStrategy { NEGOTIATE_FROM_URI_SCHEME, FORCE_PLAINTEXT, FORCE_ENCRYPTED_SYSTEM_CERTS, FORCE_ENCRYPTED_TRUST_ALL_CERTS, FORCE_ENCRYPTED_CUSTOM_CERTS };
            EncryptionStrategy encryption_strategy = EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            std::size_t max_connection_pool_size = 100;
            uint32_t connection_acquisition_timeout_ms = 60000;  // Timeout for acquiring a connection from the pool
            uint32_t max_connection_lifetime_ms = 3600000;       // Max lifetime of a pooled connection
            uint32_t idle_timeout_ms = 600000;                   // Max idle time for a pooled connection
            uint32_t idle_time_before_health_check_ms = 30000;   // Idle time after which a health check (ping) is performed before reuse

            // Socket level timeouts
            uint32_t tcp_connect_timeout_ms = 5000;  // Timeout for establishing the TCP connection
            uint32_t socket_read_timeout_ms = 0;     // Timeout for socket read operations (0 = system default/infinite)
            uint32_t socket_write_timeout_ms = 0;    // Timeout for socket write operations (0 = system default/infinite)
            bool tcp_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;

            // Bolt protocol level timeouts
            uint32_t hello_timeout_ms = 15000;   // Timeout for HELLO message exchange
            uint32_t goodbye_timeout_ms = 5000;  // Timeout for GOODBYE message exchange (if sent)

            // Transaction related configurations
            uint32_t max_transaction_retry_time_ms = 30000;  // Max total time for retrying a managed transaction
            uint32_t transaction_retry_delay_initial_ms = 1000;
            uint32_t transaction_retry_delay_multiplier = 2;
            uint32_t transaction_retry_delay_max_ms = 60000;
            uint32_t explicit_transaction_timeout_default_ms = 0;  // Default timeout for explicit transactions if not specified per-transaction (0 = server default)

            // --- Routing ---
            bool client_side_routing_enabled = true;
            uint32_t routing_table_refresh_ttl_margin_ms = 5000;
            uint32_t routing_max_retry_attempts = 3;
            std::function<routing::ServerAddress(const routing::ServerAddress&)> server_address_resolver;
            std::map<std::string, std::vector<routing::ServerAddress>> initial_router_addresses_override;

            // --- Bolt Protocol ---
            std::vector<boltprotocol::versions::Version> preferred_bolt_versions;

            // --- Logging ---
            std::shared_ptr<spdlog::logger> logger;
            spdlog::level::level_enum log_level = spdlog::level::info;

            TransportConfig(const std::string& uri_str = "bolt://localhost:7687");
            TransportConfig();

            boltprotocol::BoltError apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri);
            void prepare_agent_strings(const std::string& default_transport_name_version = "Neo4jBoltTransportCpp/0.6.0");  // Version bump

            std::shared_ptr<spdlog::logger> get_or_create_logger(const std::string& logger_name = "Neo4jBoltTransport");
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H
#define NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H

#include <optional>
#include <string>

#include "boltprotocol/message_defs.h"  // For BoltError and FailureMessageParams

namespace neo4j_bolt_transport {
    namespace error {

        // Creates a detailed error message string from FailureMessageParams
        inline std::string format_server_failure(const boltprotocol::FailureMessageParams& failure_params) {
            std::string server_code = "Unknown.Error";
            std::string server_message = "An error occurred on the server.";

            auto extract_string_from_value = [](const boltprotocol::Value& val) -> std::optional<std::string> {
                if (std::holds_alternative<std::string>(val)) {
                    return std::get<std::string>(val);
                }
                return std::nullopt;
            };

            auto it_code = failure_params.metadata.find("neo4j_code");  // Bolt 5.7+
            if (it_code == failure_params.metadata.end() || !extract_string_from_value(it_code->second).has_value()) {
                it_code = failure_params.metadata.find("code");  // Legacy
            }
            if (it_code != failure_params.metadata.end()) {
                if (auto code_opt = extract_string_from_value(it_code->second)) {
                    server_code = *code_opt;
                }
            }

            auto it_msg = failure_params.metadata.find("message");
            if (it_msg != failure_params.metadata.end()) {
                if (auto msg_opt = extract_string_from_value(it_msg->second)) {
                    server_message = *msg_opt;
                }
            }

            return "[" + server_code + "] " + server_message;
        }

        // Converts BoltError enum to a human-readable string (basic version)
        inline std::string bolt_error_to_string(boltprotocol::BoltError err_code) {
            switch (err_code) {
                case boltprotocol::BoltError::SUCCESS:
                    return "SUCCESS";
                case boltprotocol::BoltError::UNKNOWN_ERROR:
                    return "UNKNOWN_ERROR";
                case boltprotocol::BoltError::INVALID_ARGUMENT:
                    return "INVALID_ARGUMENT";
                case boltprotocol::BoltError::SERIALIZATION_ERROR:
                    return "SERIALIZATION_ERROR";
                case boltprotocol::BoltError::DESERIALIZATION_ERROR:
                    return "DESERIALIZATION_ERROR";
                case boltprotocol::BoltError::INVALID_MESSAGE_FORMAT:
                    return "INVALID_MESSAGE_FORMAT";
                case boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION:
                    return "UNSUPPORTED_PROTOCOL_VERSION";
                case boltprotocol::BoltError::NETWORK_ERROR:
                    return "NETWORK_ERROR";
                case boltprotocol::BoltError::HANDSHAKE_FAILED:
                    return "HANDSHAKE_FAILED";
                // ... add all other BoltError codes ...
                default:
                    return "UNRECOGNIZED_BOLT_ERROR (" + std::to_string(static_cast<int>(err_code)) + ")";
            }
        }

        // Combines a BoltError with a context message and potentially a server failure message
        inline std::string format_error_message(const std::string& context, boltprotocol::BoltError err_code, const std::optional<std::string>& server_failure_detail = std::nullopt) {
            std::string msg = context + ": " + bolt_error_to_string(err_code) + " (code " + std::to_string(static_cast<int>(err_code)) + ")";
            if (server_failure_detail && !server_failure_detail->empty()) {
                msg += "; Server detail: " + *server_failure_detail;
            }
            return msg;
        }

    }  // namespace error
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H

#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <memory>  // For std::weak_ptr
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version

namespace neo4j_bolt_transport {
    namespace internal {

        // Represents an established, active asynchronous stream and its parameters.
        // Ownership of the stream object is held by this context.
        struct ActiveAsyncStreamContext {
            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> stream;

            boltprotocol::versions::Version negotiated_bolt_version;
            std::string server_agent_string;
            std::string server_connection_id;
            bool utc_patch_active = false;
            bool encryption_was_used = false;

            ActiveAsyncStreamContext(std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> s, boltprotocol::versions::Version bv, std::string sa, std::string cid, bool utc, bool enc_used)
                : stream(std::move(s)), negotiated_bolt_version(bv), server_agent_string(std::move(sa)), server_connection_id(std::move(cid)), utc_patch_active(utc), encryption_was_used(enc_used) {
            }

            explicit ActiveAsyncStreamContext(boost::asio::io_context& ioc) : stream(boost::asio::ip::tcp::socket(ioc)) {
            }
            ActiveAsyncStreamContext() = delete;

            ActiveAsyncStreamContext(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext& operator=(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext(ActiveAsyncStreamContext&&) = default;
            ActiveAsyncStreamContext& operator=(ActiveAsyncStreamContext&&) = default;

            boost::asio::any_io_executor get_executor() {
                return std::visit(
                    [](auto& s) {
                        return s.get_executor();
                    },
                    stream);
            }
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/ip/tcp.hpp>      // For socket type in template
#include <boost/asio/ssl/stream.hpp>  // For ssl::stream type in template
#include <chrono>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

// Forward declaration of BoltPhysicalConnection to avoid full include here
namespace neo4j_bolt_transport {
    namespace internal {
        class BoltPhysicalConnection;  // Forward declaration
    }
}  // namespace neo4j_bolt_transport

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Adapter to dispatch read/write operations (declaration only)
            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op);

            // Timeout wrapper template function (declaration only)
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(  // Renamed to avoid conflict with previous attempts
                BoltPhysicalConnection* conn_obj_ptr,
                Stream& stream,
                BufferType buffers,
                std::chrono::milliseconds timeout_duration,
                const std::string& operation_name,
                bool is_read_operation);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

// Include the implementation file for templates at the end of the header
#include "async_utils.tpp"  // Or async_utils_inl.h

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H// No include guard needed in .tpp as it's included by a .h with a guard

#include "boltprotocol/bolt_errors_versions.h"                       // For BoltError
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // Full definition needed for implementation

// Boost ASIO includes for implementation details
#include <spdlog/spdlog.h>

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Definition for dispatch_read_write_operation
            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op) {
                if (is_read_op) {
                    return boost::asio::async_read(stream, buffers, std::forward<CompletionToken>(token));
                } else {
                    return boost::asio::async_write(stream, buffers, std::forward<CompletionToken>(token));
                }
            }

            // Definition for async_io_with_timeout
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(  // Matches declaration
                BoltPhysicalConnection* conn_obj_ptr,
                Stream& stream,
                BufferType buffers,
                std::chrono::milliseconds timeout_duration,
                const std::string& operation_name,
                bool is_read_operation) {
                if (!conn_obj_ptr) {
                    co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                }
                // Now we can safely access BoltPhysicalConnection members
                std::shared_ptr<spdlog::logger> logger = conn_obj_ptr->get_logger();
                boost::system::error_code ec;
                std::size_t bytes_transferred = 0;

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtil {}] {} on closed stream (conn id {}).", operation_name, conn_obj_ptr->get_id());
                    // conn_obj_ptr->_mark_as_defunct(...); // Can now call this
                    co_return {boltprotocol::BoltError::NETWORK_ERROR, 0};
                }

                if (timeout_duration.count() <= 0) {  // No timeout
                    try {
                        bytes_transferred = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, ec), is_read_operation);
                    } catch (const boost::system::system_error& e_sys) {
                        ec = e_sys.code();
                        if (logger) logger->error("[AsyncUtil {}] Exception in {} (no timeout, conn id {}): {}", operation_name, conn_obj_ptr->get_id(), e_sys.what());
                    }
                    if (ec) {
                        if (logger) logger->warn("[AsyncUtil {}] {} failed (no timeout, conn id {}): {}", operation_name, conn_obj_ptr->get_id(), ec.message());
                        conn_obj_ptr->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, operation_name + " failed (no timeout): " + ec.message());
                        co_return {conn_obj_ptr->get_last_error_code(), 0};
                    }
                    co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                }

                boost::asio::steady_timer timer(stream.get_executor());
                timer.expires_after(timeout_duration);

                std::optional<std::pair<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        std::size_t temp_bytes = 0;
                        try {
                            temp_bytes = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec), is_read_operation);
                        } catch (const boost::system::system_error& e_sys) {
                            temp_ec = e_sys.code();
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = {{temp_ec, temp_bytes}};
                            boost::system::error_code cancel_timer_ec_ignored;  // Error code for cancel is usually ignored
                            timer.cancel();                                     // Correct: no error_code parameter
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {temp_ec};
                            if (temp_ec != boost::asio::error::operation_aborted) {
                                boost::system::error_code cancel_io_ec;
                                stream.lowest_layer().cancel(cancel_io_ec);
                                if (logger && cancel_io_ec) logger->trace("[AsyncUtil {}] {} socket cancel (due to timeout) returned: {}", operation_name, conn_obj_ptr->get_id(), cancel_io_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(stream.get_executor(), boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    ec = io_result_opt.value().first;
                    bytes_transferred = io_result_opt.value().second;
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    ec = boost::asio::error::timed_out;
                    if (logger) logger->warn("[AsyncUtil {}] {} timed out after {}ms (conn id {}).", operation_name, timeout_duration.count(), conn_obj_ptr->get_id());
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        ec = boost::asio::error::fault;
                        if (logger) logger->error("[AsyncUtil {}] {} logic error: Timer aborted but no I/O result (conn id {}).", operation_name, conn_obj_ptr->get_id());
                    }
                } else {
                    ec = boost::asio::error::fault;
                    if (logger) logger->error("[AsyncUtil {}] {} unexpected fallthrough in timeout logic (conn id {}).", operation_name, conn_obj_ptr->get_id());
                }

                if (ec) {
                    if (logger && ec != boost::asio::error::operation_aborted) {
                        logger->warn("[AsyncUtil {}] {} failed (conn id {}): {}", operation_name, conn_obj_ptr->get_id(), ec.message());
                    }
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;

                    if (ec != boost::asio::error::operation_aborted || !io_result_opt.has_value() || io_result_opt.value().first) {
                        conn_obj_ptr->_mark_as_defunct(mapped_error, operation_name + " failed: " + ec.message());
                        co_return {conn_obj_ptr->get_last_error_code(), 0};
                    } else {
                        co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                    }
                }
                co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport// Include/neo4j_bolt_transport/internal/async_utils_decl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <chrono>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"  // Depend on the interface

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op);

            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(IAsyncContextCallbacks* callbacks,  // Uses the interface
                                                                                                          Stream& stream,
                                                                                                          BufferType buffers,
                                                                                                          std::chrono::milliseconds timeout_duration,
                                                                                                          const std::string& operation_name,
                                                                                                          bool is_read_operation);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#include "async_utils_impl.h"

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H// Include/neo4j_bolt_transport/internal/async_utils_impl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H

// We don't include bolt_physical_connection.h here anymore.
// All interaction is through IAsyncContextCallbacks.
#include <spdlog/spdlog.h>  // For logger implementation

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>

#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op) {
                if (is_read_op) {
                    return boost::asio::async_read(stream, buffers, std::forward<CompletionToken>(token));
                } else {
                    return boost::asio::async_write(stream, buffers, std::forward<CompletionToken>(token));
                }
            }

            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(IAsyncContextCallbacks* callbacks,  // Uses the interface
                                                                                                          Stream& stream,
                                                                                                          BufferType buffers,
                                                                                                          std::chrono::milliseconds timeout_duration,
                                                                                                          const std::string& operation_name,
                                                                                                          bool is_read_operation) {
                if (!callbacks) {  // Check if callbacks pointer is valid
                    // Cannot log here as we don't have a logger from callbacks
                    return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};  // Or throw
                }
                std::shared_ptr<spdlog::logger> logger = callbacks->get_logger();
                boost::system::error_code ec;
                std::size_t bytes_transferred = 0;

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtil {}] {} on closed stream (obj id {}).", operation_name, callbacks->get_id_for_logging());
                    co_return {boltprotocol::BoltError::NETWORK_ERROR, 0};
                }

                if (timeout_duration.count() <= 0) {
                    try {
                        bytes_transferred = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, ec), is_read_operation);
                    } catch (const boost::system::system_error& e_sys) {
                        ec = e_sys.code();
                        if (logger) logger->error("[AsyncUtil {}] Exception in {} (no timeout, obj id {}): {}", operation_name, callbacks->get_id_for_logging(), e_sys.what());
                    }
                    if (ec) {
                        if (logger) logger->warn("[AsyncUtil {}] {} failed (no timeout, obj id {}): {}", operation_name, callbacks->get_id_for_logging(), ec.message());
                        callbacks->mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, operation_name + " failed (no timeout): " + ec.message());
                        co_return {callbacks->get_last_error_code_from_async(), 0};
                    }
                    co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                }

                boost::asio::steady_timer timer(stream.get_executor());
                timer.expires_after(timeout_duration);

                std::optional<std::pair<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        std::size_t temp_bytes = 0;
                        try {
                            temp_bytes = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec), is_read_operation);
                        } catch (const boost::system::system_error& e_sys) {
                            temp_ec = e_sys.code();
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = {{temp_ec, temp_bytes}};
                            timer.cancel();
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {temp_ec};
                            if (temp_ec != boost::asio::error::operation_aborted) {
                                boost::system::error_code cancel_io_ec;
                                stream.lowest_layer().cancel(cancel_io_ec);
                                if (logger && cancel_io_ec) logger->trace("[AsyncUtil {}] {} socket cancel (due to timeout) returned: {}", operation_name, callbacks->get_id_for_logging(), cancel_io_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(stream.get_executor(), boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    ec = io_result_opt.value().first;
                    bytes_transferred = io_result_opt.value().second;
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    ec = boost::asio::error::timed_out;
                    if (logger) logger->warn("[AsyncUtil {}] {} timed out after {}ms (obj id {}).", operation_name, timeout_duration.count(), callbacks->get_id_for_logging());
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        ec = boost::asio::error::fault;
                        if (logger) logger->error("[AsyncUtil {}] {} logic error: Timer aborted but no I/O result (obj id {}).", operation_name, callbacks->get_id_for_logging());
                    }
                } else {
                    ec = boost::asio::error::fault;
                    if (logger) logger->error("[AsyncUtil {}] {} unexpected fallthrough in timeout logic (obj id {}).", operation_name, callbacks->get_id_for_logging());
                }

                if (ec) {
                    if (logger && ec != boost::asio::error::operation_aborted) {
                        logger->warn("[AsyncUtil {}] {} failed (obj id {}): {}", operation_name, callbacks->get_id_for_logging(), ec.message());
                    }
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;

                    if (ec != boost::asio::error::operation_aborted || !io_result_opt.has_value() || io_result_opt.value().first) {
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return {callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                    }
                }
                co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"                     // For Value, Version
#include "neo4j_bolt_transport/config/transport_config.h"  // For AuthTokenVariant, EncryptionStrategy

namespace neo4j_bolt_transport {
    namespace internal {

        struct BoltConnectionConfig {
            std::string target_host;
            uint16_t target_port;

            config::AuthTokenVariant auth_token;
            std::string user_agent_for_hello;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info_for_hello;

            bool encryption_enabled = false;
            config::TransportConfig::EncryptionStrategy resolved_encryption_strategy = config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            uint32_t tcp_connect_timeout_ms = 5000;
            uint32_t socket_read_timeout_ms = 0;   // Added
            uint32_t socket_write_timeout_ms = 0;  // Added
            bool socket_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;
            uint32_t bolt_handshake_timeout_ms = 10000;
            uint32_t hello_timeout_ms = 15000;   // Added
            uint32_t goodbye_timeout_ms = 5000;  // Added

            std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_context;
            std::optional<std::vector<boltprotocol::versions::Version>> preferred_bolt_versions;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H

#include <atomic>
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl/context.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "bolt_connection_config.h"
#include "boltprotocol/chunking.h"   // Should not be needed here if chunking methods are on this class
#include "boltprotocol/handshake.h"  // For boltprotocol::perform_handshake (sync)
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "neo4j_bolt_transport/internal/async_types.h"  // Include ActiveAsyncStreamContext
#include "spdlog/spdlog.h"

// Forward declare the template function from async_utils.h for friending
namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout_impl(BoltPhysicalConnection* conn_obj_ptr, Stream& stream, BufferType buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name, bool is_read_operation);
        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

namespace neo4j_bolt_transport {

    class SessionHandle;

    namespace internal {

        class BoltPhysicalConnection : public std::enable_shared_from_this<BoltPhysicalConnection> {  // Added enable_shared_from_this
          public:
            using PooledConnection = std::unique_ptr<BoltPhysicalConnection>;
            enum class InternalState {
                FRESH,
                TCP_CONNECTING,
                ASYNC_TCP_CONNECTING,
                TCP_CONNECTED,
                SSL_CONTEXT_SETUP,
                SSL_HANDSHAKING,
                ASYNC_SSL_HANDSHAKING,
                SSL_HANDSHAKEN,
                BOLT_HANDSHAKING,
                ASYNC_BOLT_HANDSHAKING,
                BOLT_HANDSHAKEN,
                HELLO_AUTH_SENT,
                ASYNC_HELLO_AUTH_SENT,
                READY,
                STREAMING,
                AWAITING_SUMMARY,
                FAILED_SERVER_REPORTED,
                DEFUNCT
            };

            BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr);
            ~BoltPhysicalConnection();

            BoltPhysicalConnection(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection& operator=(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept;
            BoltPhysicalConnection& operator=(BoltPhysicalConnection&& other) noexcept;

            // --- Synchronous API ---
            boltprotocol::BoltError establish();
            boltprotocol::BoltError terminate(bool send_goodbye = true);
            boltprotocol::BoltError ping(std::chrono::milliseconds timeout);
            bool is_ready_for_queries() const;
            bool is_defunct() const;
            boltprotocol::BoltError get_last_error_code() const {
                return last_error_code_;
            }
            std::string get_last_error_message() const {
                return last_error_message_;
            }
            uint64_t get_id() const {
                return id_;
            }
            const boltprotocol::versions::Version& get_bolt_version() const {
                return negotiated_bolt_version_;
            }
            bool is_utc_patch_active() const {
                return utc_patch_active_;
            }
            const std::string& get_server_agent() const {
                return server_agent_string_;
            }
            const std::string& get_connection_id() const {
                return server_assigned_conn_id_;
            }
            const BoltConnectionConfig& get_config() const {
                return conn_config_;
            }
            std::shared_ptr<spdlog::logger> get_logger() const {
                return logger_;
            }
            boost::asio::io_context& get_io_context() {
                return io_context_ref_;
            }
            std::chrono::steady_clock::time_point get_creation_timestamp() const {
                return creation_timestamp_;
            }
            std::chrono::steady_clock::time_point get_last_used_timestamp() const {
                return last_used_timestamp_.load(std::memory_order_relaxed);
            }
            void mark_as_used();
            bool is_encrypted() const;

            using MessageHandler = std::function<boltprotocol::BoltError(boltprotocol::MessageTag tag, const std::vector<uint8_t>& payload, BoltPhysicalConnection& connection)>;
            boltprotocol::BoltError send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError perform_reset();
            boltprotocol::BoltError perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success);
            boltprotocol::BoltError perform_logoff(boltprotocol::SuccessMessageParams& out_success);

            // --- Asynchronous API ---
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> establish_async();

            // Public async messaging methods removed from here. They will operate on ActiveAsyncStreamContext.
            // terminate_async and ping_async are kept as placeholders but their utility on a non-stream-owning object is limited.
            boost::asio::awaitable<boltprotocol::BoltError> terminate_async(bool send_goodbye = true);
            boost::asio::awaitable<boltprotocol::BoltError> ping_async(std::chrono::milliseconds timeout);

            // Made public for async_utils helper, or make helper a friend
            void _mark_as_defunct(boltprotocol::BoltError reason, const std::string& message = "");

          private:
            friend class neo4j_bolt_transport::SessionHandle;
            // Friend declaration for the template function in async_utils namespace
            template <typename Stream, typename BufferType>
            friend boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_utils::async_io_with_timeout_impl(
                BoltPhysicalConnection* conn_obj_ptr, Stream& stream, BufferType buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name, bool is_read_operation);

            // --- Synchronous Connection Stages ---
            boltprotocol::BoltError _stage_tcp_connect();
            boltprotocol::BoltError _stage_ssl_context_setup();
            boltprotocol::BoltError _stage_ssl_handshake();
            boltprotocol::BoltError _stage_bolt_handshake();
            boltprotocol::BoltError _stage_send_hello_and_initial_auth();

            // --- Asynchronous Connection Stages ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket&>& stream, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref,  // Pass by ref
                                                                                        std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_send_hello_and_initial_auth_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);  // Pass by ref

            void _prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const;
            boltprotocol::BoltError _execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure);
            // _execute_logon_message_async was primarily for use by perform_logon_async.
            // Since perform_logon_async (public) is removed, this internal one might also be re-evaluated
            // or become part of _stage_send_hello_and_initial_auth_async if Bolt >= 5.1.
            // For now, keep its signature matching previous, but its utility is reduced.
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> _execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                        std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref  // Pass by ref
            );

            // Low-level I/O (Synchronous)
            boltprotocol::BoltError _write_to_active_sync_stream(const uint8_t* data, size_t size);
            boltprotocol::BoltError _read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read);

            // Low-level I/O (Asynchronous)
            boost::asio::awaitable<boltprotocol::BoltError> _write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                          const std::vector<uint8_t>& data);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                                                            size_t size_to_read);

            // Chunking (Synchronous)
            boltprotocol::BoltError _send_chunked_payload_sync(const std::vector<uint8_t>& payload);
            boltprotocol::BoltError _receive_chunked_payload_sync(std::vector<uint8_t>& out_payload);

            // Chunking (Asynchronous)
            boost::asio::awaitable<boltprotocol::BoltError> _send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                        std::vector<uint8_t> payload);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref  // Pass by ref
            );

            boltprotocol::BoltError _peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const;

            void _reset_resources_and_state(bool called_from_destructor = false);
            void _update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta);
            void _update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta);
            boltprotocol::BoltError _classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta);
            // _mark_as_defunct moved to public for friend helper, keep private section clean if desired
            std::string _get_current_state_as_string() const;

            uint64_t id_;
            BoltConnectionConfig conn_config_;
            boost::asio::io_context& io_context_ref_;
            std::shared_ptr<spdlog::logger> logger_;

            std::unique_ptr<boost::asio::ip::tcp::socket> owned_socket_for_sync_plain_;
            std::unique_ptr<boost::asio::ip::tcp::iostream> plain_iostream_wrapper_;
            std::unique_ptr<boost::asio::ssl::context> ssl_context_sync_;
            std::unique_ptr<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ssl_stream_sync_;

            std::atomic<InternalState> current_state_;
            // These are results of a connection attempt, not state of an "active" connection object
            boltprotocol::versions::Version negotiated_bolt_version_;
            std::string server_agent_string_;
            std::string server_assigned_conn_id_;  // This is the one from HELLO/LOGON success
            bool utc_patch_active_ = false;

            std::chrono::steady_clock::time_point creation_timestamp_;
            std::atomic<std::chrono::steady_clock::time_point> last_used_timestamp_;

            boltprotocol::BoltError last_error_code_ = boltprotocol::BoltError::SUCCESS;
            std::string last_error_message_;

            static std::atomic<uint64_t> next_connection_id_counter_;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H

#include <cstdint>  // For uint64_t
#include <memory>
#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "spdlog/fwd.h"                         // Forward declaration for spdlog::logger

namespace neo4j_bolt_transport {
    namespace internal {

        class IAsyncContextCallbacks {
          public:
            virtual ~IAsyncContextCallbacks() = default;

            virtual std::shared_ptr<spdlog::logger> get_logger() const = 0;
            virtual uint64_t get_id_for_logging() const = 0;                                                          // Renamed to avoid conflict if BoltPhysicalConnection has get_id() with different semantics
            virtual void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) = 0;  // Specific name for async context
            virtual boltprotocol::BoltError get_last_error_code_from_async() const = 0;                               // Specific name
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H

#include <atomic>
#include <boost/asio/executor_work_guard.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/asio/steady_timer.hpp>  // For eviction_timer_
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include "config/transport_config.h"
#include "internal/bolt_physical_connection.h"
#include "routing/routing_table.h"
#include "routing/server_address.h"
#include "session_handle.h"
#include "uri/parsed_uri.h"

// 暂时移除异步相关的 Boost.Asio include，因为具体实现被推迟
// #include <boost/asio/co_spawn.hpp>
// #include <boost/asio/detached.hpp>
// #include <boost/asio/awaitable.hpp>

namespace neo4j_bolt_transport {

    namespace config {
        struct SessionParameters;
    }
    class AsyncSessionHandle;  // 前向声明，即使实现被推迟，头文件可能仍需它

    class Neo4jBoltTransport {
      public:
        explicit Neo4jBoltTransport(config::TransportConfig config);
        ~Neo4jBoltTransport();

        Neo4jBoltTransport(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport& operator=(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport(Neo4jBoltTransport&&) = delete;
        Neo4jBoltTransport& operator=(Neo4jBoltTransport&&) = delete;

        // --- Synchronous API ---
        boltprotocol::BoltError verify_connectivity();
        std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> acquire_session(const config::SessionParameters& params);
        void close();

        const config::TransportConfig& get_config() const {
            return config_;
        }
        boost::asio::io_context& get_io_context() {
            return io_context_;
        }

        void release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy = true);

        // --- Asynchronous API (占位符) ---
        // 实际返回类型可能是 boost::asio::awaitable<...>
        // 为了编译通过（即使AsyncSessionHandle不完整），暂时用一个可以构造的类型
        // 或者完全注释掉，直到 AsyncSessionHandle 准备好
        // boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
        // acquire_async_session(const config::SessionParameters& params);

      private:
        // --- 连接池与路由辅助函数 ---
        std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> _acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        // boost::asio::awaitable<std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection>>
        // _acquire_async_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        std::pair<boltprotocol::BoltError, routing::ServerAddress> _get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint);
        std::shared_ptr<routing::RoutingTable> _get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user);
        boltprotocol::BoltError _fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update, const std::vector<routing::ServerAddress>& initial_routers_for_context, const std::string& database_name_hint, const std::optional<std::string>& impersonated_user_hint);
        void _handle_routing_failure(const routing::ServerAddress& failed_address, const std::string& database_context_key);

        void _evict_stale_connections_task();
        internal::BoltConnectionConfig _create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const;

        // 静态私有辅助函数，用于生成路由上下文键
        static std::string _make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user);

        config::TransportConfig config_;
        uri::ParsedUri parsed_initial_uri_;

        boost::asio::io_context io_context_;
        std::unique_ptr<std::thread> io_thread_;
        bool own_io_thread_ = false;
        std::unique_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> work_guard_;

        std::deque<internal::BoltPhysicalConnection::PooledConnection> idle_connections_;
        std::size_t total_connections_currently_pooled_ = 0;
        std::size_t total_connections_ever_created_ = 0;
        std::mutex pool_mutex_;
        std::condition_variable pool_condition_;
        std::atomic<bool> closing_{false};

        std::string finalized_user_agent_;
        boltprotocol::HelloMessageParams::BoltAgentInfo finalized_bolt_agent_info_;

        std::map<std::string, std::shared_ptr<routing::RoutingTable>> routing_tables_;
        std::mutex routing_table_mutex_;

        std::unique_ptr<boost::asio::steady_timer> eviction_timer_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H

#include <functional>  // For std::function
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For Value, SuccessMessageParams, FailureMessageParams
// BoltRecord and BoltResultStream are needed for the 'run' method's return type
#include "bolt_record.h"
#include "result_stream.h"

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // TransactionContext is passed to user-provided transaction functions (lambdas).
    // It provides methods to execute queries within the scope of the managed transaction.
    class TransactionContext {
      public:
        // Constructor taking a non-owning pointer to the SessionHandle that manages this transaction.
        // The SessionHandle must outlive the TransactionContext.
        explicit TransactionContext(SessionHandle& session);
        virtual ~TransactionContext() = default;  // Good practice for base classes if inherited

        // Executes a query within the current transaction.
        // Returns a pair: { {Error, ErrorMsg}, ResultStreamUniquePtr }.
        // The ResultStream unique_ptr is null if an error occurred before streaming could start.
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters = {}  // Default empty parameters
        );

        // Executes a query and consumes its result, returning only the summary.
        // Useful for DML statements (CREATE, MERGE, DELETE, SET).
        // Returns {Error, ErrorMsg}. out_summary and out_failure are populated.
        std::pair<boltprotocol::BoltError, std::string> run_consume(const std::string& cypher,
                                                                    const std::map<std::string, boltprotocol::Value>& parameters,  // No default for params here
                                                                    boltprotocol::SuccessMessageParams& out_summary,
                                                                    boltprotocol::FailureMessageParams& out_failure);

        // Note: A full-fledged TransactionContext in official drivers often mirrors
        // many methods of the Session object (like run, commit, rollback, close).
        // However, for the managed transaction function pattern, the Session handles
        // commit/rollback/close based on the lambda's outcome.
        // If we want the lambda to have more control, these methods could be added here,
        // and they would signal the Session to perform the action.
        // For now, we keep it to query execution.

        // boltprotocol::BoltError commit(); // Example: Signals the managing Session to commit
        // boltprotocol::BoltError rollback(); // Example: Signals the managing Session to rollback
        // bool is_open() const; // Example: Checks if the underlying transaction is still active

      private:
        SessionHandle& owner_session_;  // Non-owning reference to the session managing the transaction
    };

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return a TransactionWorkResult indicating success or application-level failure.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H

#include <functional>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

namespace neo4j_bolt_transport {

    // Forward declare TransactionContext (defined in neo4j_transaction_context.h)
    class TransactionContext;

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return SUCCESS if work is done, or an error code + message if app logic fails.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

    // REMOVED conflicting TransactionContext class definition from here.
    // The primary definition is in neo4j_transaction_context.h

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H
#define NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H

#include <deque>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "bolt_record.h"
#include "boltprotocol/message_defs.h"
#include "result_summary.h"  // <--- NEW

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    class BoltResultStream {
      public:
        // Constructor now takes initial raw summary and connection info for typed summary
        BoltResultStream(SessionHandle* session,
                         std::optional<int64_t> query_id_for_streaming,
                         boltprotocol::SuccessMessageParams run_summary_params,  // Raw params from RUN
                         std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                         std::vector<boltprotocol::RecordMessageParams> initial_records,
                         bool server_might_have_more,
                         const boltprotocol::versions::Version& bolt_version,          // For ResultSummary
                         bool utc_patch_active,                                        // For ResultSummary
                         const std::string& server_address_for_summary,                // For ResultSummary
                         const std::optional<std::string>& database_name_for_summary,  // For ResultSummary
                         boltprotocol::BoltError initial_error = boltprotocol::BoltError::SUCCESS,
                         const std::string& initial_error_message = "",
                         const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details = std::nullopt);

        ~BoltResultStream();

        BoltResultStream(const BoltResultStream&) = delete;
        BoltResultStream& operator=(const BoltResultStream&) = delete;
        BoltResultStream(BoltResultStream&& other) noexcept;
        BoltResultStream& operator=(BoltResultStream&& other) noexcept;

        std::pair<boltprotocol::BoltError, std::string> has_next(bool& out_has_next);
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> next();
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> single();  // <--- NEW

        std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> list_all();
        std::tuple<boltprotocol::BoltError, std::string, ResultSummary> consume();  // <--- MODIFIED to return typed ResultSummary

        const ResultSummary& get_run_summary() const {
            return run_summary_typed_;
        }  // <--- MODIFIED
        const ResultSummary& get_final_summary() const {
            return final_summary_typed_;
        }  // <--- MODIFIED (after full consumption/discard)

        bool is_fully_consumed_or_failed() const;
        bool has_failed() const;
        boltprotocol::BoltError get_failure_reason() const;
        const std::string& get_failure_message() const;
        const boltprotocol::FailureMessageParams& get_failure_details() const;  // For raw server failure
        const std::vector<std::string>& field_names() const;

      private:
        friend class SessionHandle;
        friend class TransactionContext;

        std::pair<boltprotocol::BoltError, std::string> _fetch_more_records(int64_t n);
        std::pair<boltprotocol::BoltError, std::string> _discard_all_remaining_records();
        void _set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details = std::nullopt);
        void _update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary);

        SessionHandle* owner_session_;
        std::optional<int64_t> query_id_;

        std::deque<boltprotocol::RecordMessageParams> raw_record_buffer_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_cache_;

        ResultSummary run_summary_typed_;    // Summary from RUN message (available immediately)
        ResultSummary final_summary_typed_;  // Summary from final PULL/DISCARD (available after consumption)
                                             // This needs careful initialization.

        boltprotocol::FailureMessageParams failure_details_raw_;  // Store raw failure

        bool server_has_more_records_ = false;
        bool initial_server_has_more_records_ = false;
        bool stream_fully_consumed_or_discarded_ = false;
        bool stream_failed_ = false;
        boltprotocol::BoltError failure_reason_ = boltprotocol::BoltError::SUCCESS;
        std::string failure_message_;
        bool is_first_pull_attempt_ = true;

        // For ResultSummary creation
        boltprotocol::versions::Version bolt_version_cache_;
        bool utc_patch_active_cache_;
        std::string server_address_cache_;
        std::optional<std::string> database_name_cache_;
    };

    // Inline simple getters
    inline bool BoltResultStream::is_fully_consumed_or_failed() const {
        return stream_fully_consumed_or_discarded_ || stream_failed_;
    }
    inline bool BoltResultStream::has_failed() const {
        return stream_failed_;
    }
    inline boltprotocol::BoltError BoltResultStream::get_failure_reason() const {
        return failure_reason_;
    }
    inline const std::string& BoltResultStream::get_failure_message() const {
        return failure_message_;
    }
    inline const boltprotocol::FailureMessageParams& BoltResultStream::get_failure_details() const {
        return failure_details_raw_;
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H
#define NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For SuccessMessageParams, Value, Version

namespace neo4j_bolt_transport {

    // Forward declarations for Plan, ProfiledPlan, Notification if they become complex classes
    // struct Plan;
    // struct ProfiledPlan;
    // struct Notification;

    struct QueryCounters {
        int64_t nodes_created = 0;
        int64_t nodes_deleted = 0;
        int64_t relationships_created = 0;
        int64_t relationships_deleted = 0;
        int64_t properties_set = 0;
        int64_t labels_added = 0;
        int64_t labels_removed = 0;
        int64_t indexes_added = 0;
        int64_t indexes_removed = 0;
        int64_t constraints_added = 0;
        int64_t constraints_removed = 0;
        bool contains_updates = false;
        bool contains_system_updates = false;
        int64_t system_updates = 0;

        QueryCounters() = default;
    };

    enum class QueryType { UNKNOWN, READ_ONLY, READ_WRITE, WRITE_ONLY, SCHEMA_WRITE };

    // Simplified notification structure
    struct ServerNotification {
        std::string code;
        std::string title;
        std::string description;
        std::optional<std::map<std::string, boltprotocol::Value>> position;  // e.g., {"offset": <int>, "line": <int>, "column": <int>}
        std::string severity;                                                // e.g., "WARNING", "INFORMATION"
        std::string category;                                                // e.g., "HINT", "UNRECOGNIZED" (Bolt 5.2+)

        ServerNotification() = default;
    };

    class ResultSummary {
      public:
        // Constructor takes the raw success message params and connection info
        ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params,
                      const boltprotocol::versions::Version& bolt_version,
                      bool utc_patch_active,
                      const std::string& server_address,                            // Address of the server that executed the query
                      const std::optional<std::string>& database_name_from_session  // DB name from session config
        );

        const boltprotocol::SuccessMessageParams& raw_params() const {
            return raw_params_;
        }

        QueryType query_type() const {
            return query_type_;
        }
        const QueryCounters& counters() const {
            return counters_;
        }

        const std::string& server_address() const {
            return server_address_;
        }
        const std::string& database_name() const {
            return database_name_;
        }  // Effective DB name for the query

        std::optional<std::chrono::milliseconds> result_available_after() const {
            return result_available_after_ms_;
        }
        std::optional<std::chrono::milliseconds> result_consumed_after() const {
            return result_consumed_after_ms_;
        }

        const std::vector<ServerNotification>& notifications() const {
            return notifications_;
        }

        // std::optional<Plan> plan() const; // TODO if Plan parsing is added
        // std::optional<ProfiledPlan> profiled_plan() const; // TODO if ProfiledPlan parsing is added

      private:
        void parse_metadata(const boltprotocol::versions::Version& bolt_version, bool utc_patch_active);
        void parse_query_type(const boltprotocol::Value& type_val);
        void parse_counters(const boltprotocol::Value& counters_val);
        void parse_notifications(const boltprotocol::Value& notifications_val, const boltprotocol::versions::Version& bolt_version);

        boltprotocol::SuccessMessageParams raw_params_;
        QueryType query_type_ = QueryType::UNKNOWN;
        QueryCounters counters_;
        std::vector<ServerNotification> notifications_;

        std::string server_address_;  // Server that executed the query
        std::string database_name_;   // Effective database for the query

        std::optional<std::chrono::milliseconds> result_available_after_ms_;
        std::optional<std::chrono::milliseconds> result_consumed_after_ms_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H

#include <atomic>
#include <chrono>
#include <mutex>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError (used in status)
#include "server_address.h"

namespace neo4j_bolt_transport {
    namespace routing {

        enum class ServerRole { ROUTER, READER, WRITER };

        class RoutingTable {
          public:
            RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds);

            // Tries to get a server for the given role.
            // Returns nullopt if no suitable server or table is stale.
            std::optional<ServerAddress> get_server(ServerRole role);

            // Updates the table with new data from a ROUTE message response.
            // Returns BoltError::SUCCESS or an error code if parsing fails.
            boltprotocol::BoltError update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds);

            bool is_stale() const;
            void mark_as_stale();  // Forcefully mark as stale, e.g., after a connection error

            const std::string& get_database_context_key() const {
                return database_context_key_;
            }
            const std::vector<ServerAddress>& get_routers() const;

            // Remove a server from all lists (e.g., if it becomes unreachable)
            void forget_server(const ServerAddress& address);

          private:
            std::string database_context_key_;  // e.g., "mydatabase@user" or "system"
            std::vector<ServerAddress> routers_;
            std::vector<ServerAddress> readers_;
            std::vector<ServerAddress> writers_;

            std::chrono::steady_clock::time_point last_updated_time_;
            std::chrono::seconds ttl_;

            std::atomic<std::size_t> next_reader_index_ = 0;
            std::atomic<std::size_t> next_writer_index_ = 0;
            std::atomic<std::size_t> next_router_index_ = 0;  // For trying different routers

            mutable std::mutex mutex_;  // Protects access to server lists and indices
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H

#include <cstdint>
#include <functional>  // For std::hash
#include <string>

namespace neo4j_bolt_transport {
    namespace routing {

        struct ServerAddress {
            std::string host;
            std::uint16_t port;

            ServerAddress(std::string h = "", std::uint16_t p = 0) : host(std::move(h)), port(p) {
            }

            bool operator==(const ServerAddress& other) const {
                return host == other.host && port == other.port;
            }

            bool operator<(const ServerAddress& other) const {
                if (host != other.host) {
                    return host < other.host;
                }
                return port < other.port;
            }

            std::string to_string() const {
                return host + ":" + std::to_string(port);
            }
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

namespace std {
    template <>
    struct hash<neo4j_bolt_transport::routing::ServerAddress> {
        size_t operator()(const neo4j_bolt_transport::routing::ServerAddress& addr) const noexcept {
            size_t h1 = std::hash<std::string>{}(addr.host);
            size_t h2 = std::hash<std::uint16_t>{}(addr.port);
            return h1 ^ (h2 << 1);  // Basic combination
        }
    };
}  // namespace std

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H#ifndef NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H
#define NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H

#include <chrono>
#include <deque>
#include <map>  // For parameters
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "config/session_parameters.h"
#include "internal/bolt_physical_connection.h"
#include "neo4j_transaction_work.h"
#include "result_stream.h"  // Includes ResultSummary transitively

namespace neo4j_bolt_transport {

    class Neo4jBoltTransport;  // Forward declaration

    struct TransactionConfigOverrides {  // New struct for clarity
        std::optional<std::map<std::string, boltprotocol::Value>> metadata;
        std::optional<std::chrono::milliseconds> timeout;
    };

    class SessionHandle {
      public:
        SessionHandle(Neo4jBoltTransport* transport_manager, internal::BoltPhysicalConnection::PooledConnection connection, config::SessionParameters params);
        ~SessionHandle();

        SessionHandle(const SessionHandle&) = delete;
        SessionHandle& operator=(const SessionHandle&) = delete;
        SessionHandle(SessionHandle&& other) noexcept;
        SessionHandle& operator=(SessionHandle&& other) noexcept;

        // --- Explicit Transaction Management ---
        std::pair<boltprotocol::BoltError, std::string> begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt,
                                                                          const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt  // Already present
        );
        std::pair<boltprotocol::BoltError, std::string> commit_transaction();
        std::pair<boltprotocol::BoltError, std::string> rollback_transaction();
        bool is_in_transaction() const {
            return in_explicit_transaction_;
        }

        // --- Managed Transaction Functions ---
        TransactionWorkResult execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);
        TransactionWorkResult execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);

        // --- Query Execution (Auto-commit transactions) ---
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run_query(const std::string& cypher,
                                                                                                                const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                                                const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> run_query_and_consume(const std::string& cypher,
                                                                                                        const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                        const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<boltprotocol::BoltError, std::string> run_query_without_result(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                 const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        const std::vector<std::string>& get_last_bookmarks() const;
        void update_bookmarks(const std::vector<std::string>& new_bookmarks);

        void close();
        bool is_closed() const {
            return is_closed_;
        }
        bool is_connection_valid() const {
            return connection_is_valid_;
        }

        friend class BoltResultStream;
        friend class TransactionContext;

      private:
        std::pair<boltprotocol::BoltError, std::string> _prepare_auto_commit_run(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                 const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,  // Kept for RunMessageParams
                                                                                 const std::optional<std::chrono::milliseconds>& tx_timeout,                    // Kept for RunMessageParams
                                                                                 boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                 boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw);
        std::pair<boltprotocol::BoltError, std::string> _stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw);

        void _release_connection_to_pool(bool mark_healthy = true);
        void _invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message);
        internal::BoltPhysicalConnection* _get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context);

        TransactionWorkResult _execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout);

        Neo4jBoltTransport* transport_manager_;
        internal::BoltPhysicalConnection::PooledConnection connection_;
        config::SessionParameters session_params_;

        bool in_explicit_transaction_ = false;
        std::optional<int64_t> current_transaction_query_id_;

        std::vector<std::string> current_bookmarks_;
        bool is_closed_ = false;
        bool connection_is_valid_ = true;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H#ifndef NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H
#define NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace neo4j_bolt_transport {
    namespace uri {

        // Holds the deconstructed parts of a Neo4j connection URI.
        struct ParsedUri {
            std::string input_uri;
            std::string scheme;

            // For non-routing schemes, hosts will contain one entry.
            // For routing schemes (neo4j://, neo4j+s://), hosts can contain multiple seed router addresses.
            std::vector<std::pair<std::string, uint16_t>> hosts_with_ports;

            // Userinfo extracted from URI (if present)
            std::optional<std::string> username_from_uri;
            std::optional<std::string> password_from_uri;

            // Query parameters from the URI
            std::map<std::string, std::string> query_parameters;

            // Interpretation of the scheme
            bool is_valid = false;
            bool is_routing_scheme = false;
            bool tls_enabled_by_scheme = false;
            enum class SchemeTrustStrategy {
                NONE,            // e.g. bolt, neo4j (depends on server default or further config)
                SYSTEM_CAS,      // e.g. bolt+s, neo4j+s
                TRUST_ALL_CERTS  // e.g. bolt+ssc, neo4j+ssc (discouraged)
            };
            SchemeTrustStrategy trust_strategy_hint = SchemeTrustStrategy::NONE;

            // Standard default ports
            static constexpr uint16_t DEFAULT_BOLT_PORT = 7687;
            // Neo4j typically uses the same port for TLS-enabled Bolt (server-side config)
            static constexpr uint16_t DEFAULT_BOLTS_PORT = 7687;
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H#ifndef NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H
#define NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H

#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "parsed_uri.h"

namespace neo4j_bolt_transport {
    namespace uri {

        class UriParser {
          public:
            UriParser() = delete;  // Static methods only

            // Parses the given URI string and populates the ParsedUri struct.
            // Returns BoltError::SUCCESS on success, or an error code if parsing fails.
            static boltprotocol::BoltError parse(const std::string& uri_string, ParsedUri& out_parsed_uri);
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H#include "neo4j_bolt_transport/bolt_record.h"

namespace neo4j_bolt_transport {

    BoltRecord::BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> names_ptr) : fields_(std::move(fields_data)), field_names_ptr_(std::move(names_ptr)) {
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(size_t index) const {
        if (index >= fields_.size()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Or a more specific "IndexOutOfBounds"
        }
        // Return a copy of the Value, or handle lifetime if Value contains non-copyable shared_ptrs carefully.
        // std::variant copy semantics should handle this correctly.
        return {boltprotocol::BoltError::SUCCESS, fields_[index]};
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // No field names available
        }
        // Could optimize with a cached map if records are accessed by name frequently
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                if (i < fields_.size()) {  // Should always be true if names match fields
                    return {boltprotocol::BoltError::SUCCESS, fields_[i]};
                } else {
                    // This indicates an internal inconsistency (more names than fields)
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
            }
        }
        return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Field name not found
    }

    const std::vector<std::string>& BoltRecord::field_names() const {
        static const std::vector<std::string> empty_field_names;  // For returning if no names ptr
        if (field_names_ptr_) {
            return *field_names_ptr_;
        }
        return empty_field_names;
    }

    // Template method implementations are in the header due to template instantiation.

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/auth_token.h"

namespace neo4j_bolt_transport {
    namespace config {

        AuthTokenVariant AuthTokens::none() {
            return NoAuth{};
        }

        AuthTokenVariant AuthTokens::basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm) {
            return BasicAuth{username, password, realm};
        }

        AuthTokenVariant AuthTokens::kerberos(const std::string& base64_ticket) {
            return KerberosAuth{base64_ticket};
        }

        AuthTokenVariant AuthTokens::bearer(const std::string& token) {
            return BearerAuth{token};
        }

        AuthTokenVariant AuthTokens::custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters) {
            return CustomAuth{principal, credentials, realm, scheme, parameters};
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/transport_config.h"

#include <iostream>

#include "boltprotocol/bolt_errors_versions.h"  // For default versions
#include "neo4j_bolt_transport/uri/parsed_uri.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {
    namespace config {

        TransportConfig::TransportConfig(const std::string& a_uri_string) : uri_string(a_uri_string.empty() ? "bolt://localhost:7687" : a_uri_string) {
            uri::ParsedUri parsed_uri_info;
            if (uri::UriParser::parse(uri_string, parsed_uri_info) == boltprotocol::BoltError::SUCCESS) {
                apply_parsed_uri_settings(parsed_uri_info);
            } else {
                if (logger) {
                    logger->error("Failed to parse URI '{}' during TransportConfig construction. Using defaults where possible.", uri_string);
                } else {
                    std::cerr << "Error: Failed to parse URI '" << uri_string << "' during TransportConfig construction." << std::endl;
                }
            }
            if (preferred_bolt_versions.empty()) {
                preferred_bolt_versions = boltprotocol::versions::get_default_proposed_versions();
            }
            prepare_agent_strings();          // Call prepare_agent_strings before get_or_create_logger
            logger = get_or_create_logger();  // Ensure logger is initialized
        }

        TransportConfig::TransportConfig() : TransportConfig("bolt://localhost:7687") {
        }

        boltprotocol::BoltError TransportConfig::apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri) {
            if (!parsed_uri.is_valid) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            if (encryption_strategy == EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME) {
                if (parsed_uri.tls_enabled_by_scheme) {
                    if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::SYSTEM_CAS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    } else if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS;
                    } else {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    }
                } else {
                    encryption_strategy = EncryptionStrategy::FORCE_PLAINTEXT;
                }
            }

            if (!parsed_uri.is_routing_scheme) {
                client_side_routing_enabled = false;
            }

            if (std::holds_alternative<NoAuth>(auth_token)) {
                if (parsed_uri.username_from_uri.has_value()) {
                    auth_token = AuthTokens::basic(parsed_uri.username_from_uri.value(), parsed_uri.password_from_uri.value_or(""), std::nullopt);
                }
            }

            if (client_side_routing_enabled && initial_router_addresses_override.empty() && !parsed_uri.hosts_with_ports.empty()) {
                std::string initial_context_key = parsed_uri.scheme + "://";
                if (!parsed_uri.hosts_with_ports.empty()) {
                    initial_context_key += parsed_uri.hosts_with_ports.front().first;  // Simplified context key
                }

                std::vector<routing::ServerAddress> initial_routers;
                for (const auto& host_port_pair : parsed_uri.hosts_with_ports) {
                    initial_routers.emplace_back(host_port_pair.first, host_port_pair.second);
                }
                initial_router_addresses_override[initial_context_key] = initial_routers;
            }

            auto it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout");  // Renamed in spec sometimes
            if (it_conn_timeout == parsed_uri.query_parameters.end()) {                     // try alternative name
                it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout_ms");
            }
            if (it_conn_timeout != parsed_uri.query_parameters.end()) {
                try {
                    tcp_connect_timeout_ms = static_cast<uint32_t>(std::stoul(it_conn_timeout->second));
                } catch (const std::exception&) { /* ignore invalid param */
                }
            }

            auto it_max_retry_time = parsed_uri.query_parameters.find("max_transaction_retry_time");
            if (it_max_retry_time != parsed_uri.query_parameters.end()) {
                try {
                    // Assuming time is in ms if specified like "15s" or "15000ms" this needs parsing logic
                    // For simplicity, assume it's just ms for now if it's a number
                    max_transaction_retry_time_ms = static_cast<uint32_t>(std::stoul(it_max_retry_time->second));
                } catch (const std::exception&) { /* ignore */
                }
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        void TransportConfig::prepare_agent_strings(const std::string& default_transport_name_version) {
            if (bolt_agent_info.product.empty()) {
                bolt_agent_info.product = default_transport_name_version;
            }
        }

        std::shared_ptr<spdlog::logger> TransportConfig::get_or_create_logger(const std::string& logger_name) {
            if (logger) {
                logger->set_level(log_level);
                return logger;
            }
            auto default_logger = spdlog::get(logger_name);
            if (!default_logger) {
                try {
                    default_logger = spdlog::stdout_color_mt(logger_name);                            // Or any other default sink
                    default_logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%n] [tid %t] %v");  // Added thread id
                    default_logger->set_level(log_level);
                } catch (const spdlog::spdlog_ex& ex) {
                    std::cerr << "Logger (" << logger_name << ") initialization failed: " << ex.what() << std::endl;
                    return nullptr;  // Or throw
                }
            } else {
                default_logger->set_level(log_level);
            }
            return default_logger;
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // For MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                                            std::vector<uint8_t> payload) {                                                                                            // Take payload by value

            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async send chunked payload on defunct connection.", id_);
                co_return last_error_code_;
            }

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            std::vector<uint8_t> chunk_header_bytes(boltprotocol::CHUNK_HEADER_SIZE);

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);
                std::memcpy(chunk_header_bytes.data(), &chunk_size_be, boltprotocol::CHUNK_HEADER_SIZE);

                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                // Create a vector for the current chunk's data to pass to _write_to_active_async_stream
                // This involves a copy, but ensures data is valid for the async op.
                std::vector<uint8_t> current_chunk_data(data_ptr, data_ptr + chunk_size);
                err = co_await _write_to_active_async_stream(stream_variant_ref, current_chunk_data);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                std::memcpy(chunk_header_bytes.data(), &zero_chunk_be, boltprotocol::CHUNK_HEADER_SIZE);
                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
            }

            co_return err;  // _write_to_active_async_stream calls _mark_as_defunct on error.
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref) {  // Pass by ref
            std::vector<uint8_t> out_payload_vec;
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async receive chunked payload on defunct connection.", id_);
                co_return {last_error_code_, {}};
            }

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;
            std::pair<boltprotocol::BoltError, std::vector<uint8_t>> read_result;

            while (true) {
                read_result = co_await _read_from_active_async_stream(stream_variant_ref, boltprotocol::CHUNK_HEADER_SIZE);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& header_bytes = read_result.second;
                if (header_bytes.size() != boltprotocol::CHUNK_HEADER_SIZE) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    _mark_as_defunct(err, "Async receive chunk header: incorrect size read.");
                    break;
                }
                uint16_t chunk_size_be;
                std::memcpy(&chunk_size_be, header_bytes.data(), boltprotocol::CHUNK_HEADER_SIZE);
                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {  // End of message
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Async received chunk larger than max: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->error("[ConnAsyncChunking {}] {}", id_, msg);
                    break;
                }

                read_result = co_await _read_from_active_async_stream(stream_variant_ref, chunk_payload_size);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& chunk_data = read_result.second;
                if (chunk_data.size() != chunk_payload_size) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    _mark_as_defunct(err, "Async receive chunk payload: incorrect size read.");
                    break;
                }
                try {
                    out_payload_vec.insert(out_payload_vec.end(), chunk_data.begin(), chunk_data.end());
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory appending async chunk to payload buffer.";
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->critical("[ConnAsyncChunking {}] {}", id_, msg);
                    break;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                co_return {err, {}};
            } else if (total_bytes_read_for_message == 0 && out_payload_vec.empty()) {
                if (logger_) logger_->trace("[ConnAsyncChunking {}] Async received NOOP message.", id_);
            }
            co_return {boltprotocol::BoltError::SUCCESS, std::move(out_payload_vec)};
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>            // For std::min with chunking
#include <boost/asio/post.hpp>  // For yielding in timeout helper
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>  // For std::memcpy
#include <iostream>
#include <optional>  // For std::optional in timeout helper
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_utils.h"  // Include the async_utils header
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async write on defunct connection.", id_);
                co_return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (data.empty()) {
                co_return boltprotocol::BoltError::SUCCESS;
            }

            std::chrono::milliseconds timeout(conn_config_.socket_write_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Write {} bytes. Timeout: {}ms", id_, data.size(), timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async write: stream_ptr in variant is null.", id_);
                        co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // Pass 'this' as BoltPhysicalConnection* for the first argument of async_io_with_timeout_impl
                    co_return co_await async_utils::async_io_with_timeout_impl(this, *stream_ptr, boost::asio::buffer(data), timeout, "Async Write", false);
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                // _mark_as_defunct is called within async_utils::async_io_with_timeout_impl if ec is set
                co_return last_error_code_;
            }
            if (result.second != data.size()) {
                std::string msg = "Partial async write. Expected " + std::to_string(data.size()) + ", wrote " + std::to_string(result.second);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", id_, msg);
                co_return last_error_code_;
            }
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async read on defunct connection.", id_);
                co_return {last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            if (size_to_read == 0) {
                co_return {boltprotocol::BoltError::SUCCESS, {}};
            }

            std::vector<uint8_t> buffer_vec(size_to_read);
            std::chrono::milliseconds timeout(conn_config_.socket_read_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Read {} bytes. Timeout: {}ms", id_, size_to_read, timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async read: stream_ptr in variant is null.", id_);
                        co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // Pass 'this' as BoltPhysicalConnection*
                    co_return co_await async_utils::async_io_with_timeout_impl(this, *stream_ptr, boost::asio::buffer(buffer_vec), timeout, "Async Read", true);
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return {last_error_code_, {}};
            }
            if (result.second < size_to_read) {
                std::string msg = "Incomplete async read. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(result.second);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", id_, msg);
                co_return {last_error_code_, {}};
            }
            co_return {boltprotocol::BoltError::SUCCESS, std::move(buffer_vec)};
        }
    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <iostream>
#include <variant>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const {
            out_params.auth_tokens.clear();
            std::visit(
                [&](auto&& arg) {
                    using T = std::decay_t<decltype(arg)>;
                    if constexpr (std::is_same_v<T, config::BasicAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("basic");
                        out_params.auth_tokens["principal"] = arg.username;
                        out_params.auth_tokens["credentials"] = arg.password;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                    } else if constexpr (std::is_same_v<T, config::BearerAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("bearer");
                        out_params.auth_tokens["credentials"] = arg.token;
                    } else if constexpr (std::is_same_v<T, config::KerberosAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("kerberos");
                        out_params.auth_tokens["credentials"] = arg.base64_ticket;
                    } else if constexpr (std::is_same_v<T, config::CustomAuth>) {
                        out_params.auth_tokens["scheme"] = arg.scheme;
                        out_params.auth_tokens["principal"] = arg.principal;
                        out_params.auth_tokens["credentials"] = arg.credentials;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                        if (arg.parameters) {
                            for (const auto& pair : *arg.parameters) {
                                if (pair.first != "scheme" && pair.first != "principal" && pair.first != "credentials" && pair.first != "realm") {
                                    out_params.auth_tokens[pair.first] = pair.second;
                                }
                            }
                        }
                    } else if constexpr (std::is_same_v<T, config::NoAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("none");
                    }
                },
                conn_config_.auth_token);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure) {
            InternalState state_before_logon = current_state_.load();
            if (state_before_logon != InternalState::HELLO_AUTH_SENT && state_before_logon != InternalState::READY && state_before_logon != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, "LOGON executed in invalid state: " + _get_current_state_as_string());
                if (logger_) logger_->error("[ConnAuth {}] LOGON in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }

            std::vector<uint8_t> logon_payload;
            boltprotocol::PackStreamWriter ps_writer(logon_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnAuth {}] Sending LOGON message (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            err = send_request_receive_summary(logon_payload, out_success, out_failure);

            if (err == boltprotocol::BoltError::SUCCESS) {
                if (last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                    _update_metadata_from_logon_success(out_success);
                    if (current_state_.load() != InternalState::DEFUNCT) {
                        current_state_.store(InternalState::READY);
                    }
                    if (logger_) logger_->info("[ConnAuth {}] LOGON successful.", id_);
                } else {
                    if (logger_) logger_->warn("[ConnAuth {}] LOGON server response not SUCCESS. Code: {}, Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                }
            } else {
                if (logger_) logger_->error("[ConnAuth {}] LOGON message send/receive summary failed. Error: {}", id_, static_cast<int>(err));
            }
            return last_error_code_;
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGON message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }

            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::READY && current_s != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon called in invalid state " + _get_current_state_as_string());
                if (logger_) logger_->warn("[ConnAuth {}] perform_logon in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }
            mark_as_used();

            boltprotocol::FailureMessageParams ignored_failure_details;
            return _execute_logon_message(logon_params, out_success, ignored_failure_details);
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logoff(boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGOFF message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }
            if (!is_ready_for_queries()) {
                std::string msg = "perform_logoff called when connection not ready. Current state: " + _get_current_state_as_string();
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, msg);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuth {}] Performing LOGOFF.", id_);

            std::vector<uint8_t> logoff_payload;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            boltprotocol::FailureMessageParams ignored_failure_details;
            err = send_request_receive_summary(logoff_payload, out_success, ignored_failure_details);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuth {}] LOGOFF successful.", id_);
                if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {  // Pre-5.1, LOGOFF means state goes back to HELLO_AUTH_SENT (if HELLO was used for auth)
                    current_state_.store(InternalState::HELLO_AUTH_SENT);
                } else {  // Bolt 5.1+, LOGOFF returns to BOLT_HANDSHAKEN (or ASYNC_BOLT_HANDSHAKEN) state
                    current_state_.store(InternalState::BOLT_HANDSHAKEN);
                }
            } else {
                if (logger_) logger_->warn("[ConnAuth {}] LOGOFF failed. Error: {}, Server Msg: {}", id_, static_cast<int>(err), last_error_message_);
            }
            return last_error_code_;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::_execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                                            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref  // Pass by ref
        ) {
            if (logger_) logger_->debug("[ConnAuthAsync {}] Executing LOGON message async (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            // Check if the variant holds a valid stream pointer
            bool stream_valid = std::visit(
                [](auto* stream_ptr) {
                    return stream_ptr != nullptr && stream_ptr->lowest_layer().is_open();
                },
                async_stream_variant_ref);
            if (!stream_valid) {
                if (logger_) logger_->error("[ConnAuthAsync {}] _execute_logon_message_async: No valid async stream provided.", id_);
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "_execute_logon_message_async: No valid async stream provided.");
                co_return {last_error_code_, {}};
            }

            std::vector<uint8_t> logon_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logon_payload_storage);

            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Async LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            // Send LOGON and receive summary (placeholder for send_request_receive_summary_async)
            auto [send_err, chunk_send_result] = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logon_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON send failed: {}", id_, static_cast<int>(send_err));
                // _mark_as_defunct should be called by _send_chunked_payload_async
                co_return {last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;  // Not directly used in return but needed for deserialize
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            // Loop to receive summary, skipping NOOPs
            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON receive summary failed: {}", id_, static_cast<int>(recv_err));
                    summary_err = last_error_code_;  // _receive_chunked_payload_async marks defunct
                    break;
                }
                if (response_payload.empty()) {  // NOOP
                    if (logger_) logger_->trace("[ConnAuthAsync {}] Received NOOP while awaiting LOGON summary.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                boltprotocol::BoltError peek_err = _peek_message_tag(response_payload, tag);
                if (peek_err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(peek_err, "Async LOGON: Failed to peek tag for summary response.");
                    summary_err = last_error_code_;
                    break;
                }

                boltprotocol::PackStreamReader reader(response_payload);
                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(summary_err, "Async LOGON: Failed to deserialize SUCCESS summary.");
                        summary_err = last_error_code_;
                    }
                    // else last_error_code_ remains/becomes SUCCESS
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    boltprotocol::BoltError deser_fail_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (deser_fail_err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(deser_fail_err, "Async LOGON: Failed to deserialize FAILURE summary.");
                        summary_err = last_error_code_;
                    } else {
                        summary_err = _classify_and_set_server_failure(failure_meta);  // This sets last_error_code_
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    // IGNORED for LOGON is unexpected and likely an error condition or server misbehavior.
                    // Treat as failure.
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Received IGNORED instead of SUCCESS/FAILURE.");
                    summary_err = last_error_code_;
                    break;
                } else {
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Unexpected message tag " + std::to_string(static_cast<int>(tag)) + " for summary.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                _update_metadata_from_logon_success(success_meta);
                if (current_state_.load() != InternalState::DEFUNCT) {
                    current_state_.store(InternalState::ASYNC_READY);  // Or READY if not distinguishing
                }
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGON successful.", id_);
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGON server response not SUCCESS. Final Error: {}, Server/Conn Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logon_async(boltprotocol::LogonMessageParams logon_params) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async: LOGON not supported in Bolt < 5.1", id_);
                co_return std::make_pair(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, boltprotocol::SuccessMessageParams{});
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN && current_s != InternalState::ASYNC_BOLT_HANDSHAKEN &&  // Added ASYNC_BOLT_HANDSHAKEN
                current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async in invalid state {}", id_, _get_current_state_as_string());
                co_return std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, boltprotocol::SuccessMessageParams{});
            }
            mark_as_used();

            // CRITICAL: This method needs access to the *active asynchronous stream*
            // that was established by establish_async. This is now passed as a parameter to _execute_logon_message_async.
            // The caller (e.g., establish_async or a higher-level async session object) must provide this.
            // For now, this method cannot directly call _execute_logon_message_async without it.
            // This implies perform_logon_async needs to be called from a context that has the ActiveAsyncStreamContext.

            if (logger_) logger_->error("[ConnAuthAsync {}] perform_logon_async cannot be called directly on BoltPhysicalConnection without an active async stream context. This method should be part of an async flow that manages the stream.", id_);
            co_return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            // Example of how it might be called if stream was available:
            // ActiveAsyncStreamContext& active_ctx = ... get from somewhere ...
            // co_return co_await _execute_logon_message_async(std::move(logon_params), active_ctx.stream_variant_ref_for_internal_use_only_or_similar);
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logoff_async() {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async: LOGOFF not supported in Bolt < 5.1", id_);
                co_return std::make_pair(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, boltprotocol::SuccessMessageParams{});
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY && current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async called when not ready. State: {}", id_, _get_current_state_as_string());
                co_return std::make_pair(last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, boltprotocol::SuccessMessageParams{});
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuthAsync {}] Performing LOGOFF async.", id_);

            // Similar to perform_logon_async, this needs an active async stream.
            if (logger_) logger_->error("[ConnAuthAsync {}] perform_logoff_async cannot be called directly on BoltPhysicalConnection without an active async stream context.", id_);
            co_return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};

            // Placeholder for actual implementation if stream context were available:
            /*
            ActiveAsyncStreamContext& active_ctx = ... ; // Get from context
            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& active_async_stream_variant_ref = active_ctx.stream_variant_ref_for_internal_use_only_or_similar;

            std::vector<uint8_t> logoff_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload_storage);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Async LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            // Send LOGOFF and receive summary
            auto [send_err, chunk_send_result] = co_await _send_chunked_payload_async(active_async_stream_variant_ref, std::move(logoff_payload_storage));
             if (send_err != boltprotocol::BoltError::SUCCESS) {
                 if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGOFF send failed: {}", id_, static_cast<int>(send_err));
                 co_return {last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            // ... similar receive summary logic as _execute_logon_message_async ...
            // (Receive, peek tag, deserialize SUCCESS/FAILURE)

            // if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
            //     if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGOFF successful.", id_);
            //     if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
            //          current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            //     } else {
            //          current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);
            //     }
            //     co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            // } else {
            //     boltprotocol::BoltError final_err = last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : summary_err;
            //     if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGOFF failed. SummaryExchangeError: {}, FinalConnError: {}, Server Msg: {}", id_, static_cast<int>(summary_err), static_cast<int>(last_error_code_), last_error_message_);
            //     co_return std::make_pair(final_err, boltprotocol::SuccessMessageParams{});
            // }
            */
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // For initial logger checks
#include <utility>   // For std::move

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        std::atomic<uint64_t> BoltPhysicalConnection::next_connection_id_counter_(0);

        BoltPhysicalConnection::BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr)
            : id_(next_connection_id_counter_++),
              conn_config_(std::move(config)),
              io_context_ref_(io_ctx),
              logger_(logger_ptr),  // Directly use passed logger
              current_state_(InternalState::FRESH),
              negotiated_bolt_version_(0, 0),
              creation_timestamp_(std::chrono::steady_clock::now()) {
            if (!logger_) {  // Fallback if a null logger was somehow passed
                std::cerr << "Warning: BoltPhysicalConnection " << id_ << " created with a null logger." << std::endl;
                // Optionally create a default emergency logger here if critical
            }

            last_used_timestamp_.store(creation_timestamp_, std::memory_order_relaxed);
            if (logger_) {
                logger_->debug("[ConnConstruct {}] Constructed. Target: {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            }
        }

        BoltPhysicalConnection::~BoltPhysicalConnection() {
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destructing. Current state: {}", id_, _get_current_state_as_string());
            }
            // Ensure resources are cleaned up. terminate(false) handles most of it.
            // _reset_resources_and_state(true) is a fallback if terminate wasn't called or state is already DEFUNCT/FRESH.
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::DEFUNCT && current_s != InternalState::FRESH) {
                terminate(false);  // Don't send GOODBYE from destructor
            } else {
                // If already defunct or fresh, still ensure resources are reset, especially if construction failed partway.
                _reset_resources_and_state(true);  // called_from_destructor = true
            }
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destruction complete.", id_);
            }
        }

        BoltPhysicalConnection::BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept
            : id_(other.id_),
              conn_config_(std::move(other.conn_config_)),
              io_context_ref_(other.io_context_ref_),
              logger_(std::move(other.logger_)),  // Move the logger
              owned_socket_for_sync_plain_(std::move(other.owned_socket_for_sync_plain_)),
              plain_iostream_wrapper_(std::move(other.plain_iostream_wrapper_)),
              ssl_context_sync_(std::move(other.ssl_context_sync_)),
              ssl_stream_sync_(std::move(other.ssl_stream_sync_)),
              // current_state_ is atomic, needs load/store
              negotiated_bolt_version_(other.negotiated_bolt_version_),
              server_agent_string_(std::move(other.server_agent_string_)),
              server_assigned_conn_id_(std::move(other.server_assigned_conn_id_)),
              utc_patch_active_(other.utc_patch_active_),
              creation_timestamp_(other.creation_timestamp_),
              // last_used_timestamp_ is atomic
              last_error_code_(other.last_error_code_),
              last_error_message_(std::move(other.last_error_message_)) {
            current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
            last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);

            // Invalidate 'other' to prevent double resource management
            other.id_ = static_cast<uint64_t>(-1);  // Mark as moved-from
            other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
            // Logger in 'other' is now nullptr due to move.
            // other's unique_ptrs are now nullptr due to move.

            if (logger_) {
                logger_->trace("[ConnMoveConstruct {}] Move constructed from (now defunct) old connection {}.", id_, other.id_);
            }
        }

        BoltPhysicalConnection& BoltPhysicalConnection::operator=(BoltPhysicalConnection&& other) noexcept {
            if (this != &other) {
                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assigning from old ID {}. Current state before: {}", id_, other.id_, _get_current_state_as_string());
                }
                // Properly terminate current connection's resources before overwriting
                InternalState current_s_before_assign = current_state_.load(std::memory_order_relaxed);
                if (current_s_before_assign != InternalState::DEFUNCT && current_s_before_assign != InternalState::FRESH) {
                    terminate(false);  // Gracefully terminate self if active
                } else {
                    _reset_resources_and_state(false);  // Clean up if FRESH but resources might exist
                }

                id_ = other.id_;
                conn_config_ = std::move(other.conn_config_);
                // io_context_ref_ is a reference, assumed to be compatible and not changed.
                logger_ = std::move(other.logger_);

                owned_socket_for_sync_plain_ = std::move(other.owned_socket_for_sync_plain_);
                plain_iostream_wrapper_ = std::move(other.plain_iostream_wrapper_);
                ssl_context_sync_ = std::move(other.ssl_context_sync_);
                ssl_stream_sync_ = std::move(other.ssl_stream_sync_);

                current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                negotiated_bolt_version_ = other.negotiated_bolt_version_;
                server_agent_string_ = std::move(other.server_agent_string_);
                server_assigned_conn_id_ = std::move(other.server_assigned_conn_id_);
                utc_patch_active_ = other.utc_patch_active_;
                creation_timestamp_ = other.creation_timestamp_;
                last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                last_error_code_ = other.last_error_code_;
                last_error_message_ = std::move(other.last_error_message_);

                // Invalidate 'other'
                other.id_ = static_cast<uint64_t>(-1);
                other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
                // Logger in 'other' is now nullptr.
                // other's unique_ptrs are now nullptr.

                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assignment complete.", id_);
                }
            }
            return *this;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <variant>

#include "boltprotocol/handshake.h"                       // For boltprotocol::perform_handshake
#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_bolt_handshake() {
            InternalState expected_prev_state;
            bool is_ssl = conn_config_.encryption_enabled;

            if (is_ssl) {
                expected_prev_state = InternalState::SSL_HANDSHAKEN;
                if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] SSL stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            } else {
                expected_prev_state = InternalState::TCP_CONNECTED;
                if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] Plain stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            }

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state) {
                std::string msg = "Bolt handshake (sync) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            current_state_.store(InternalState::BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHS {}] Performing (sync) Bolt handshake.", id_);

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for handshake.");
                if (logger_) logger_->error("[ConnBoltHS {}] No Bolt versions to propose.", id_);
                return last_error_code_;
            }

            // perform_handshake is synchronous and uses the stream's blocking operations.
            // Timeout for this synchronous operation is harder to implement directly here
            // unless perform_handshake itself supports it, or we wrap its stream.
            // The bolt_handshake_timeout_ms from config is more of a hint for the overall stage.
            boltprotocol::BoltError err;
            if (is_ssl) {
                // Pass the underlying SSL stream to perform_handshake
                // perform_handshake expects a reference to a stream type that has read/write/flush.
                // boost::asio::ssl::stream directly supports this.
                err = boltprotocol::perform_handshake(*ssl_stream_sync_, proposed_versions, negotiated_bolt_version_);
            } else {
                // plain_iostream_wrapper_ is a std::iostream compatible type
                err = boltprotocol::perform_handshake(*plain_iostream_wrapper_, proposed_versions, negotiated_bolt_version_);
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Sync Bolt handshake failed: " + error::bolt_error_to_string(err);
                _mark_as_defunct(err, msg);  // perform_handshake does not call _mark_as_defunct
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (logger_) logger_->debug("[ConnBoltHS {}] Sync Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);

            current_state_.store(InternalState::BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref,  // Pass by ref
                                                                                                            std::chrono::milliseconds timeout) {
            // Determine expected previous state based on whether the stream is SSL or plain
            bool is_ssl_stream = std::holds_alternative<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>(async_stream_variant_ref);
            InternalState expected_prev_state = is_ssl_stream ? InternalState::SSL_HANDSHAKEN : InternalState::TCP_CONNECTED;
            // Note: These states (SSL_HANDSHAKEN, TCP_CONNECTED) might need async equivalents if we differentiate strictly
            // e.g. ASYNC_SSL_HANDSHAKEN, ASYNC_TCP_CONNECTED. For now, assume they are set by prior async stages.

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state && !(is_ssl_stream && current_s == InternalState::ASYNC_SSL_HANDSHAKING) &&  // Allow if just finished async SSL HS
                !(!is_ssl_stream && current_s == InternalState::ASYNC_TCP_CONNECTING)) {                                      // Allow if just finished async TCP connect
                std::string msg = "Bolt handshake (async) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl_stream ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Performing (async) Bolt handshake. Timeout: {}ms", id_, timeout.count());

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for async handshake.");
                if (logger_) logger_->error("[ConnBoltHSAsync {}] No Bolt versions to propose.", id_);
                co_return last_error_code_;
            }

            // This would be the truly async version. For now, it's a placeholder.
            // It requires implementing boltprotocol::perform_handshake_async or similar.
            // Here, we'll implement the handshake steps directly using _write_to_active_async_stream and _read_from_active_async_stream.

            // 1. Send proposed versions
            std::vector<uint8_t> handshake_bytes;
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0xB0);
            handshake_bytes.push_back(0x17);  // Bolt Magic
            for (const auto& version : proposed_versions) {
                handshake_bytes.push_back(version.minor);
                handshake_bytes.push_back(version.major);
                handshake_bytes.push_back(0);  // No patch range
                handshake_bytes.push_back(0);  // No patch range
            }
            // Fill remaining to 20 bytes if fewer than 4 versions proposed
            while (handshake_bytes.size() < 20) {
                handshake_bytes.push_back(0);
            }

            boltprotocol::BoltError err = co_await _write_to_active_async_stream(async_stream_variant_ref, handshake_bytes);
            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to send proposed versions: " + error::bolt_error_to_string(err);
                _mark_as_defunct(err, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            // 2. Receive negotiated version (4 bytes)
            auto [read_err, negotiated_version_bytes] = co_await _read_from_active_async_stream(async_stream_variant_ref, 4);
            if (read_err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to read negotiated version: " + error::bolt_error_to_string(read_err);
                // _read_from_active_async_stream already calls _mark_as_defunct
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (negotiated_version_bytes.size() != 4) {
                std::string msg = "Async Bolt handshake: received incorrect size for negotiated version.";
                _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            negotiated_bolt_version_.patch = 0;  // Assume no patch for now
            negotiated_bolt_version_.minor = negotiated_version_bytes[1];
            negotiated_bolt_version_.major = negotiated_version_bytes[0];
            // Bytes 2 and 3 are usually 0 unless patch ranges are used by server.

            bool version_supported = false;
            for (const auto& proposed : proposed_versions) {
                if (proposed.major == negotiated_bolt_version_.major && proposed.minor == negotiated_bolt_version_.minor) {
                    version_supported = true;
                    break;
                }
            }

            if (negotiated_bolt_version_.major == 0 && negotiated_bolt_version_.minor == 0) {  // Server rejected all versions
                std::string msg = "Async Bolt handshake: Server rejected all proposed Bolt versions (responded with 0.0).";
                _mark_as_defunct(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (!version_supported) {  // Server picked a version we didn't propose or understand.
                std::string msg = "Async Bolt handshake: Server chose an unsupported Bolt version: " + negotiated_bolt_version_.to_string();
                _mark_as_defunct(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Async Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ip/tcp.hpp>      // For tcp::socket for establish_async
#include <boost/asio/ssl/stream.hpp>  // For ssl::stream for establish_async
#include <variant>                    // For std::variant in establish_async

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_types.h"  // For ActiveAsyncStreamContext
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// Note: Full implementation of async methods depends on robust async I/O and chunking,
// and careful management of the async stream's lifecycle.

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> BoltPhysicalConnection::establish_async() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::ASYNC_TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::ASYNC_READY || current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCAsync {}] Establish_async called but connection is already READY.", id_);
                    // Need to reconstruct ActiveAsyncStreamContext if already ready and returning success
                    // This part is tricky as the stream is not stored in BoltPhysicalConnection directly for async.
                    // For now, assume if READY, something else holds the stream. This path is problematic for this function's return type.
                    // Let's assume for now if it's READY, it's an error to call establish_async again on this object
                    // without a proper way to retrieve the existing async stream.
                    // Or, return a default/empty ActiveAsyncStreamContext on success if already ready.
                    // A better approach is to manage the ActiveAsyncStreamContext lifecycle outside BoltPhysicalConnection (e.g., in a session object).
                    // For now, if it's READY, we can't return a valid ActiveAsyncStreamContext from here.
                    std::string msg = "Establish_async called but connection is already READY. Cannot provide a new ActiveAsyncStreamContext.";
                    if (logger_) logger_->warn("[ConnLCAsync {}] {}", id_, msg);
                    _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // Mark as error for now
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                std::string msg = "Establish_async called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCAsync {}] {}", id_, msg);
                co_return {(current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (logger_) logger_->info("[ConnLCAsync {}] Establishing (async) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);

            _reset_resources_and_state(false);  // Reset synchronous resources first
            current_state_.store(InternalState::ASYNC_TCP_CONNECTING, std::memory_order_relaxed);

            // The async stream (socket or ssl::stream) will be owned by the returned ActiveAsyncStreamContext.
            // Create the socket that will eventually be moved into the variant.
            boost::asio::ip::tcp::socket temp_socket(io_context_ref_);
            boltprotocol::BoltError err = boltprotocol::BoltError::UNKNOWN_ERROR;

            err = co_await _stage_tcp_connect_async(temp_socket, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async TCP connect stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);                               // Reset to allow retry
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};  // last_error_code_ set by _stage_tcp_connect_async
            }
            // State should be TCP_CONNECTED (or ASYNC_TCP_CONNECTED) if _stage_tcp_connect_async sets it.

            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> final_stream_variant(std::move(temp_socket));  // Start with plain socket
            bool encryption_used_for_context = false;

            if (conn_config_.encryption_enabled) {
                encryption_used_for_context = true;
                // SSL Context setup is mostly synchronous
                err = _stage_ssl_context_setup();  // Sets up ssl_context_sync_
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }

                // Move the socket into an SSL stream
                // The original socket is in the variant, extract and move it.
                boost::asio::ip::tcp::socket plain_socket_for_ssl = std::get<boost::asio::ip::tcp::socket>(std::move(final_stream_variant));
                boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket_stream(std::move(plain_socket_for_ssl), *ssl_context_sync_);
                current_state_.store(InternalState::ASYNC_SSL_HANDSHAKING);

                err = co_await _stage_ssl_handshake_async(ssl_socket_stream, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
                if (err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnLCAsync {}] Async SSL handshake stage failed: {}", id_, error::bolt_error_to_string(err));
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                final_stream_variant = std::move(ssl_socket_stream);  // Move SSL stream into variant
                current_state_.store(InternalState::SSL_HANDSHAKEN);
            }

            // Create a pointer-based variant for internal stage calls
            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> active_async_stream_ptr_variant;
            if (std::holds_alternative<boost::asio::ip::tcp::socket>(final_stream_variant)) {
                active_async_stream_ptr_variant = &std::get<boost::asio::ip::tcp::socket>(final_stream_variant);
            } else {
                active_async_stream_ptr_variant = &std::get<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(final_stream_variant);
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING);
            err = co_await _stage_bolt_handshake_async(active_async_stream_ptr_variant, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async Bolt handshake stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);

            current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            err = co_await _stage_send_hello_and_initial_auth_async(active_async_stream_ptr_variant);
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async HELLO/Auth stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            // _stage_send_hello_and_initial_auth_async should set state to ASYNC_READY or READY

            if (current_state_.load(std::memory_order_relaxed) != InternalState::ASYNC_READY && current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Async connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCAsync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            mark_as_used();
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCAsync {}] Async Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);

            ActiveAsyncStreamContext async_context(std::move(final_stream_variant), negotiated_bolt_version_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_, encryption_used_for_context);
            co_return {boltprotocol::BoltError::SUCCESS, std::move(async_context)};
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::terminate_async(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) {
                std::string prev_state_str = "UNKNOWN";  // Placeholder for previous state string
                // This is a bit complex because _get_current_state_as_string() reads the *current* atomic state.
                // For logging previous_state, you'd need a switch or map.
                // For simplicity, just log that termination is happening.
                logger_->debug("[ConnLCAsync {}] Terminating (async). Previous state was {}. Send goodbye: {}", id_, static_cast<int>(previous_state), send_goodbye);
            }

            if (previous_state == InternalState::DEFUNCT) {
                _reset_resources_and_state(false);  // Ensure sync resources are clean
                co_return boltprotocol::BoltError::SUCCESS;
            }

            // Async GOODBYE would require the active async stream.
            // This is problematic if establish_async doesn't make the stream persist with the object.
            // This function, as part of BoltPhysicalConnection, typically won't have the ActiveAsyncStreamContext
            // unless it's passed in or managed differently. For now, this part is a placeholder.
            if (send_goodbye && previous_state >= InternalState::ASYNC_BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT && !(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                if (logger_) logger_->trace("[ConnLCAsync {}] Async GOODBYE logic placeholder: Requires active async stream. This will not be sent.", id_);
                // To send GOODBYE, this function would need the ActiveAsyncStreamContext.
                // For example:
                // if (active_async_context_is_available) {
                //    std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> stream_ptr_variant;
                //    // ... get stream_ptr_variant from active_async_context ...
                //    std::vector<uint8_t> goodbye_payload;
                //    boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                //    if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                //        co_await _send_chunked_payload_async(stream_ptr_variant, std::move(goodbye_payload));
                //    }
                //    // Then close the stream in ActiveAsyncStreamContext
                // }
            }

            _reset_resources_and_state(false);  // Clean up sync resources. Async resources are managed by their coroutines/ActiveAsyncStreamContext.
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::ping_async(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCAsync {}] Pinging (async) connection (via async RESET). Timeout hint: {}ms", id_, timeout.count());
            // This requires perform_reset_async to be fully implemented.
            // For now, it's a placeholder. True async ping would need the ActiveAsyncStreamContext.
            if (logger_) logger_->error("[ConnLCAsync {}] ping_async is a placeholder and requires an active async stream context to perform a true async RESET.", id_);
            co_return boltprotocol::BoltError::UNKNOWN_ERROR;  // Placeholder
            // To implement:
            // ActiveAsyncStreamContext& active_ctx = ... get from somewhere ...
            // co_return co_await perform_reset_async_with_context(active_ctx, timeout);
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/ssl.h>  // For SSL_get_shutdown, SSL_RECEIVED_SHUTDOWN, SSL_SENT_SHUTDOWN (needed by _reset_resources_and_state)

#include <boost/asio/ip/tcp.hpp>  // For socket::shutdown_both

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_reset_resources_and_state(bool called_from_destructor) {
            // This function is critical for cleaning up resources.
            // It's called from establish() before new attempt, terminate(), destructor, and move assignment.

            // 1. Close SSL stream (if exists and open)
            if (ssl_stream_sync_) {
                boost::system::error_code ec_ssl_shutdown, ec_tcp_close;
                if (ssl_stream_sync_->lowest_layer().is_open()) {
                    // Attempt graceful SSL shutdown only if not already shut down by peer.
                    // SSL_get_shutdown checks SSL state.
                    if (!(SSL_get_shutdown(ssl_stream_sync_->native_handle()) & (SSL_RECEIVED_SHUTDOWN | SSL_SENT_SHUTDOWN))) {
                        try {
                            ssl_stream_sync_->shutdown(ec_ssl_shutdown);                                                                                                     // Graceful SSL shutdown
                            if (logger_ && ec_ssl_shutdown && ec_ssl_shutdown != boost::asio::error::eof && ec_ssl_shutdown != boost::asio::ssl::error::stream_truncated) {  // EOF/truncated is common on close
                                logger_->trace("[ConnReset {}] SSL shutdown error: {}", id_, ec_ssl_shutdown.message());
                            }
                        } catch (const boost::system::system_error& e) {
                            if (logger_) logger_->trace("[ConnReset {}] Exception during SSL stream shutdown: {}", id_, e.what());
                        }
                    }
                    // Close the underlying socket
                    try {
                        ssl_stream_sync_->lowest_layer().close(ec_tcp_close);
                        if (logger_ && ec_tcp_close) {
                            logger_->trace("[ConnReset {}] SSL lowest_layer close error: {}", id_, ec_tcp_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during SSL lowest_layer close: {}", id_, e.what());
                    }
                }
                ssl_stream_sync_.reset();  // Release the unique_ptr
            }

            // 2. Reset SSL context (if exists)
            if (ssl_context_sync_) {
                ssl_context_sync_.reset();
            }

            // 3. Close plain iostream wrapper (if exists, it owns its socket if not SSL)
            if (plain_iostream_wrapper_) {
                // Destroying iostream wrapper will close its associated socket if it has one.
                plain_iostream_wrapper_.reset();
            }

            // 4. Close the raw owned socket (if it still exists and wasn't moved to iostream/ssl_stream)
            if (owned_socket_for_sync_plain_) {
                if (owned_socket_for_sync_plain_->is_open()) {
                    boost::system::error_code ec_shutdown, ec_close;
                    try {
                        owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_shutdown);
                        if (logger_ && ec_shutdown) {
                            logger_->trace("[ConnReset {}] Plain socket shutdown error: {}", id_, ec_shutdown.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket shutdown: {}", id_, e.what());
                    }
                    try {
                        owned_socket_for_sync_plain_->close(ec_close);
                        if (logger_ && ec_close) {
                            logger_->trace("[ConnReset {}] Plain socket close error: {}", id_, ec_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket close: {}", id_, e.what());
                    }
                }
                owned_socket_for_sync_plain_.reset();
            }

            // 5. Reset Bolt protocol specific state
            negotiated_bolt_version_ = boltprotocol::versions::Version(0, 0);
            server_agent_string_.clear();
            server_assigned_conn_id_.clear();
            utc_patch_active_ = false;

            // 6. Reset error state, unless in destructor of an already defunct connection
            //    or if we want to preserve the "original sin" error.
            //    For a full reset to FRESH for reuse, error should be cleared.
            if (!called_from_destructor || current_state_.load(std::memory_order_relaxed) != InternalState::DEFUNCT) {
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
            }

            // 7. Set state to FRESH, unless in destructor and already DEFUNCT (don't revive it)
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (!called_from_destructor || current_s != InternalState::DEFUNCT) {
                current_state_.store(InternalState::FRESH, std::memory_order_relaxed);
            }

            if (logger_) logger_->trace("[ConnReset {}] Resources and state reset. Current state for reuse (if not dtor): {}", id_, _get_current_state_as_string());
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <vector>

#include "boltprotocol/message_serialization.h"           // For serialize_goodbye_message
#include "boltprotocol/packstream_writer.h"               // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::establish() {
            InternalState expected_fresh = InternalState::FRESH;
            // Attempt to transition from FRESH. If already connecting/ready/defunct, handle appropriately.
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCSync {}] Establish called but connection is already READY.", id_);
                    return boltprotocol::BoltError::SUCCESS;
                }
                // If trying to establish on a connection that's in an intermediate async state, or defunct.
                std::string msg = "Establish (sync) called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCSync {}] {}", id_, msg);
                // If it's defunct, return its last error. Otherwise, it's an unexpected state.
                return (current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR;
            }

            if (logger_) logger_->info("[ConnLCSync {}] Establishing (sync) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);

            // Critical: Reset resources and state *before* attempting to connect.
            // This ensures that if establish() is called on an object that failed a previous attempt
            // (and was thus reset to FRESH but might have lingering handles if reset wasn't perfect),
            // it starts truly fresh.
            _reset_resources_and_state(false);
            // After _reset_resources_and_state, current_state_ is FRESH. We are now proceeding to connect.
            current_state_.store(InternalState::TCP_CONNECTING, std::memory_order_relaxed);

            boltprotocol::BoltError err = _stage_tcp_connect();
            if (err != boltprotocol::BoltError::SUCCESS) {
                // _stage_tcp_connect calls _mark_as_defunct and _reset_resources_and_state on failure,
                // then sets state to FRESH.
                return last_error_code_;  // Return the error that _stage_tcp_connect set.
            }

            if (conn_config_.encryption_enabled) {
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
                err = _stage_ssl_handshake();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
            }

            err = _stage_bolt_handshake();
            if (err != boltprotocol::BoltError::SUCCESS) {
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            // _stage_send_hello_and_initial_auth handles setting state to READY on success
            // or FAILED_SERVER_REPORTED/DEFUNCT on failure.
            err = _stage_send_hello_and_initial_auth();
            if (err != boltprotocol::BoltError::SUCCESS) {
                // If HELLO/auth failed, connection is not READY. It might be FAILED_SERVER_REPORTED or DEFUNCT.
                // We want to ensure it's reset to FRESH if it's intended for reuse after this failure.
                // However, _mark_as_defunct (called by stages on error) already sets DEFUNCT.
                // _reset_resources_and_state is then called by terminate or destructor.
                // If we want `establish` to leave it FRESH on failure for immediate retry:
                if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                }
                return last_error_code_;
            }

            // Final check: if all stages reported SUCCESS but state is not READY, something is wrong.
            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Sync connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCSync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            mark_as_used();  // Mark as used upon successful establishment
            // last_error_code_ should be SUCCESS if we reach here and state is READY
            if (last_error_code_ != boltprotocol::BoltError::SUCCESS && logger_) {
                logger_->warn("[ConnLCSync {}] Established but last_error_code_ is {}. Overriding to SUCCESS as state is READY.", id_, static_cast<int>(last_error_code_));
            }
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCSync {}] Sync Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::terminate(bool send_goodbye) {
            // Atomically set state to DEFUNCT and get the previous state.
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);

            // Log after exchanging state to show "Terminating" message with the new DEFUNCT state,
            // but refer to previous_state for logic regarding sending GOODBYE.
            if (logger_)
                logger_->debug("[ConnLCSync {}] Terminating (sync). Previous state was {}. Send goodbye: {}",
                               id_,
                               (previous_state == InternalState::DEFUNCT ? "already DEFUNCT" : _get_current_state_as_string()),  // Use a string for previous_state for clarity
                               send_goodbye);

            if (previous_state == InternalState::DEFUNCT) {
                if (logger_) logger_->trace("[ConnLCSync {}] Already defunct, ensuring resources are clean.", id_);
                _reset_resources_and_state(false);        // Ensure cleanup even if already marked defunct
                return boltprotocol::BoltError::SUCCESS;  // Or return last_error_code_ if that's more appropriate
            }

            // Attempt to send GOODBYE only if connection was in a state where it's meaningful
            // and not already DEFUNCT.
            if (send_goodbye && previous_state >= InternalState::BOLT_HANDSHAKEN &&  // Must have at least completed Bolt handshake
                previous_state < InternalState::DEFUNCT) {                           // And not have been defunct before this call

                if (!(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {  // GOODBYE for Bolt 3.0+
                    bool can_send = false;
                    if (conn_config_.encryption_enabled) {
                        can_send = ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                    } else {
                        can_send = plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                    }

                    if (can_send) {
                        if (logger_) logger_->trace("[ConnLCSync {}] Attempting to send GOODBYE.", id_);
                        std::vector<uint8_t> goodbye_payload;
                        boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                        if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                            // _send_chunked_payload_sync will use _write_to_active_sync_stream
                            // It will also call _mark_as_defunct on its own errors, but state is already DEFUNCT.
                            boltprotocol::BoltError goodbye_err = _send_chunked_payload_sync(goodbye_payload);
                            if (goodbye_err != boltprotocol::BoltError::SUCCESS && logger_) {
                                // Log the GOODBYE error, but the connection is being terminated anyway.
                                logger_->warn("[ConnLCSync {}] Sending GOODBYE failed: {}", id_, error::bolt_error_to_string(goodbye_err));
                            } else if (logger_ && goodbye_err == boltprotocol::BoltError::SUCCESS) {
                                logger_->trace("[ConnLCSync {}] GOODBYE message sent.", id_);
                            }
                        }
                    } else {
                        if (logger_) logger_->trace("[ConnLCSync {}] Cannot send GOODBYE (stream not ready or Bolt version too low). Previous state was {}.", id_, (int)previous_state);
                    }
                } else {
                    if (logger_) logger_->trace("[ConnLCSync {}] GOODBYE not applicable for Bolt version {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
                }
            }

            _reset_resources_and_state(false);        // Clean up all sync resources
            return boltprotocol::BoltError::SUCCESS;  // Terminate itself is successful in cleaning up.
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds timeout) {
            // Timeout parameter is for the overall ping operation.
            // perform_reset internally calls send_request_receive_summary, which uses synchronous IO
            // without explicit per-operation timeouts other than TCP level.
            // A true ping timeout would require more complex handling or async mechanisms.
            // For now, timeout is informational.
            if (logger_) logger_->debug("[ConnLCSync {}] Pinging (sync) connection (via RESET). Timeout hint: {}ms", id_, timeout.count());

            // perform_reset itself will mark_as_used.
            // It will also set connection state appropriately (READY on success, DEFUNCT on failure).
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>
#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const {
            if (payload.empty()) {
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
            }
            boltprotocol::PackStreamReader temp_reader(payload);
            uint8_t raw_tag_byte = 0;
            uint32_t num_fields = 0;

            boltprotocol::BoltError peek_err = boltprotocol::peek_message_structure_header(temp_reader, raw_tag_byte, num_fields);
            if (peek_err != boltprotocol::BoltError::SUCCESS) {
                return peek_err;
            }
            out_tag = static_cast<boltprotocol::MessageTag>(raw_tag_byte);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_summary called in invalid state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);  // Corrected
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);

            std::vector<uint8_t> response_payload;
            while (true) {
                err = _receive_chunked_payload_sync(response_payload);  // Corrected
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }
                if (!response_payload.empty()) break;
                if (logger_) logger_->trace("[ConnMsg {}] Received NOOP while awaiting summary.", id_);
            }

            boltprotocol::MessageTag tag;
            err = _peek_message_tag(response_payload, tag);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Failed to peek tag for summary response.");
                return last_error_code_;
            }

            boltprotocol::PackStreamReader reader(response_payload);
            if (tag == boltprotocol::MessageTag::SUCCESS) {
                err = boltprotocol::deserialize_success_message(reader, out_summary);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize SUCCESS summary.");
                    return last_error_code_;
                }
                if (current_state_.load(std::memory_order_relaxed) == InternalState::AWAITING_SUMMARY) {
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                }
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
                return boltprotocol::BoltError::SUCCESS;

            } else if (tag == boltprotocol::MessageTag::FAILURE) {
                err = boltprotocol::deserialize_failure_message(reader, out_failure);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize FAILURE summary.");
                    return last_error_code_;
                }
                return _classify_and_set_server_failure(out_failure);

            } else if (tag == boltprotocol::MessageTag::IGNORED) {
                err = boltprotocol::deserialize_ignored_message(reader);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize IGNORED summary.");
                    return last_error_code_;
                }
                out_failure.metadata.clear();
                out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_ = "Operation ignored by server.";
                return boltprotocol::BoltError::SUCCESS;

            } else {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag for summary: " + std::to_string(static_cast<int>(tag)));
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            if (!is_ready_for_queries()) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_stream called when not ready. State: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);  // Corrected
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::STREAMING, std::memory_order_relaxed);

            while (true) {
                std::vector<uint8_t> response_payload;
                err = _receive_chunked_payload_sync(response_payload);  // Corrected
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }

                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnMsg {}] Received NOOP during stream.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                err = _peek_message_tag(response_payload, tag);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to peek tag during streaming.");
                    return last_error_code_;
                }

                if (tag == boltprotocol::MessageTag::RECORD) {
                    if (record_handler) {
                        err = record_handler(tag, response_payload, *this);
                        if (err != boltprotocol::BoltError::SUCCESS) {
                            std::string msg = "Record handler returned error: " + error::bolt_error_to_string(err);
                            _mark_as_defunct(err, msg);
                            return last_error_code_;
                        }
                    } else {
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "Received RECORD but no handler provided.");
                        return last_error_code_;
                    }
                } else if (tag == boltprotocol::MessageTag::SUCCESS) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_success_message(reader, out_summary);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize SUCCESS summary in stream.");
                        return last_error_code_;
                    }
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_.clear();
                    return boltprotocol::BoltError::SUCCESS;

                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_failure_message(reader, out_failure);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize FAILURE summary in stream.");
                        return last_error_code_;
                    }
                    return _classify_and_set_server_failure(out_failure);

                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_ignored_message(reader);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize IGNORED summary in stream.");
                        return last_error_code_;
                    }
                    out_failure.metadata.clear();
                    out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                    out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                    current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_ = "Operation ignored by server.";
                    return boltprotocol::BoltError::SUCCESS;

                } else {
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag in stream: " + std::to_string(static_cast<int>(tag)));
                    return last_error_code_;
                }
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_reset() {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT || current_s < InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] perform_reset called in unsuitable state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (logger_) logger_->debug("[ConnMsg {}] Performing RESET...", id_);
            mark_as_used();

            std::vector<uint8_t> reset_payload_bytes;
            boltprotocol::PackStreamWriter writer(reset_payload_bytes);
            boltprotocol::BoltError err = boltprotocol::serialize_reset_message(writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "RESET serialization failed.");
                return last_error_code_;
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;

            err = send_request_receive_summary(reset_payload_bytes, success_meta, failure_meta);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                current_state_.store(InternalState::READY, std::memory_order_relaxed);
                if (logger_) logger_->info("[ConnMsg {}] RESET successful. Connection is READY.", id_);
                return boltprotocol::BoltError::SUCCESS;
            } else {
                if (logger_) logger_->error("[ConnMsg {}] RESET failed. Error: {}, Last Conn Error Code: {}, Msg: {}", id_, static_cast<int>(err), static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds /*timeout_placeholder*/) {
            if (logger_) logger_->debug("[ConnMsg {}] Pinging connection (via RESET)...", id_);
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ssl.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_context_setup() {
            if (!conn_config_.encryption_enabled) {
                // Not an error, just means SSL is not configured for this connection.
                if (logger_) logger_->debug("[ConnSSLCTX {}] SSL encryption not enabled, skipping context setup.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            // Ensure TCP is connected before setting up SSL context
            if (current_state_.load(std::memory_order_relaxed) != InternalState::TCP_CONNECTED) {
                std::string msg = "SSL context setup called but TCP not connected. Current state: " + _get_current_state_as_string();
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_CONTEXT_SETUP, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLCTX {}] Setting up SSL context.", id_);

            try {
                ssl_context_sync_ = std::make_unique<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12_client);
                boost::system::error_code ec_ssl_setup;

                // Determine verification strategy based on resolved_encryption_strategy
                switch (conn_config_.resolved_encryption_strategy) {
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_none, ec_ssl_setup);
                        if (logger_ && !ec_ssl_setup) logger_->warn("[ConnSSLCTX {}] SSL configured to TRUST_ALL_CERTIFICATES (verify_none). THIS IS INSECURE.", id_);
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS:
                        ssl_context_sync_->set_default_verify_paths(ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_CUSTOM_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);  // Peer verification is a must for custom CAs
                        if (!ec_ssl_setup) {
                            if (conn_config_.trusted_certificates_pem_files.empty() && logger_) {
                                logger_->warn("[ConnSSLCTX {}] SSL configured for custom CAs but no CA certificate files provided. Verification will likely fail.", id_);
                            }
                            for (const auto& cert_path : conn_config_.trusted_certificates_pem_files) {
                                ssl_context_sync_->load_verify_file(cert_path, ec_ssl_setup);
                                if (ec_ssl_setup) {
                                    if (logger_) logger_->error("[ConnSSLCTX {}] Failed to load custom CA certificate file '{}': {}", id_, cert_path, ec_ssl_setup.message());
                                    break;  // Stop on first error
                                }
                                if (logger_) logger_->debug("[ConnSSLCTX {}] Successfully loaded custom CA certificate file: {}", id_, cert_path);
                            }
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT:            // Should have been caught by encryption_enabled check
                    case config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME:  // Should have been resolved earlier
                    default:
                        std::string msg = "Invalid or unresolved encryption strategy for SSL context setup: " + std::to_string(static_cast<int>(conn_config_.resolved_encryption_strategy));
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                }

                if (ec_ssl_setup) {  // Check error from verify_mode or load_verify_file
                    std::string msg = "SSL context verification setup failed: " + ec_ssl_setup.message();
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);  // Or more specific SSL error
                    if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Client certificate authentication (mTLS)
                if (conn_config_.client_certificate_pem_file.has_value()) {
                    if (!conn_config_.client_private_key_pem_file.has_value()) {
                        std::string msg = "Client certificate provided, but client private key is missing.";
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client certificate: {}", id_, conn_config_.client_certificate_pem_file.value());
                    ssl_context_sync_->use_certificate_chain_file(conn_config_.client_certificate_pem_file.value(), ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client certificate chain file '" + conn_config_.client_certificate_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client private key: {}", id_, conn_config_.client_private_key_pem_file.value());
                    if (conn_config_.client_private_key_password.has_value() && !conn_config_.client_private_key_password.value().empty()) {
                        ssl_context_sync_->set_password_callback(
                            [pwd = conn_config_.client_private_key_password.value()](std::size_t /*max_length*/, boost::asio::ssl::context_base::password_purpose /*purpose*/) {
                                return pwd;
                            },
                            ec_ssl_setup);
                        if (ec_ssl_setup) {
                            std::string msg = "Failed to set password callback for client private key: " + ec_ssl_setup.message();
                            _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                            if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    }
                    ssl_context_sync_->use_private_key_file(conn_config_.client_private_key_pem_file.value(), boost::asio::ssl::context::pem, ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client private key file '" + conn_config_.client_private_key_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }
                    if (logger_) logger_->info("[ConnSSLCTX {}] Client certificate and private key loaded successfully for mTLS.", id_);
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL context setup: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {  // Catch other standard exceptions like std::bad_alloc
                std::string msg = "Standard exception during SSL context setup: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLCTX {}] SSL context setup complete.", id_);
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/asio/ssl/host_name_verification.hpp>  // For host_name_verification
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// For OpenSSL specific calls if needed (SNI, error details)
#include <openssl/err.h>  // For ERR_get_error, ERR_error_string_n
#include <openssl/ssl.h>  // For SSL_set_tlsext_host_name

namespace neo4j_bolt_transport {
    namespace internal {

        // Re-declare or include the helper if it's made common
        template <typename AsyncOperation>
        boost::system::error_code run_with_timeout_sync_internal_hs(  // Renamed to avoid conflict if it stays local
            boost::asio::io_context& io_ctx,
            std::chrono::milliseconds timeout_duration,
            AsyncOperation op,
            std::shared_ptr<spdlog::logger> logger,
            uint64_t conn_id,
            const std::string& op_name,
            boost::asio::ssl::stream<boost::asio::ip::tcp::socket>* stream_to_cancel_on_timeout = nullptr) {
            boost::system::error_code result_ec = boost::asio::error::would_block;
            std::atomic<bool> operation_completed_flag{false};

            boost::asio::co_spawn(
                io_ctx,
                [&]() -> boost::asio::awaitable<void> {
                    boost::system::error_code op_ec;
                    try {
                        co_await op(op_ec);
                    } catch (const boost::system::system_error& e) {
                        op_ec = e.code();
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                    } catch (const std::exception& e) {
                        op_ec = boost::asio::error::fault;
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                    }
                    result_ec = op_ec;
                    operation_completed_flag.store(true, std::memory_order_release);
                    co_return;
                },
                boost::asio::detached);

            boost::asio::steady_timer timer(io_ctx);
            bool timed_out_flag = false;

            if (timeout_duration.count() > 0) {
                timer.expires_after(timeout_duration);
                timer.async_wait([&](const boost::system::error_code& ec_timer) {
                    if (ec_timer != boost::asio::error::operation_aborted) {
                        if (!operation_completed_flag.load(std::memory_order_acquire)) {
                            if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timed out.", conn_id, op_name);
                            timed_out_flag = true;
                            result_ec = boost::asio::error::timed_out;
                            if (stream_to_cancel_on_timeout && stream_to_cancel_on_timeout->lowest_layer().is_open()) {
                                boost::system::error_code cancel_ec;
                                // For SSL stream, cancelling the lowest layer is usually the way for handshake
                                stream_to_cancel_on_timeout->lowest_layer().cancel(cancel_ec);
                                if (logger && cancel_ec) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timeout socket cancel error: {}", conn_id, op_name, cancel_ec.message());
                            }
                            operation_completed_flag.store(true, std::memory_order_release);
                        }
                    }
                });
            }

            io_ctx.restart();
            while (!operation_completed_flag.load(std::memory_order_acquire)) {
                if (io_ctx.stopped()) {
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] io_context stopped during op '{}'.", conn_id, op_name);
                    if (!timed_out_flag) result_ec = boost::asio::error::interrupted;
                    break;
                }
                io_ctx.poll_one();
                if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                    std::this_thread::yield();
                }
            }
            timer.cancel();
            return result_ec;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_handshake() {
            if (!conn_config_.encryption_enabled) {
                // This stage is skipped if encryption is not enabled.
                if (logger_) logger_->debug("[ConnSSLHS {}] SSL encryption not enabled, skipping handshake.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::SSL_CONTEXT_SETUP) {
                std::string msg = "SSL handshake called in unexpected state: " + _get_current_state_as_string() + ". Expected SSL_CONTEXT_SETUP.";
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }
            // owned_socket_for_sync_plain_ should have been connected in _stage_tcp_connect
            // and ssl_context_sync_ should have been set up in _stage_ssl_context_setup.
            if (!ssl_context_sync_ || !owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                std::string msg = "SSL handshake attempted without a valid SSL context or a connected TCP socket.";
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLHS {}] Performing SSL handshake for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, conn_config_.bolt_handshake_timeout_ms);

            try {
                // Create the SSL stream, taking ownership of the socket
                ssl_stream_sync_ = std::make_unique<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(std::move(*owned_socket_for_sync_plain_), *ssl_context_sync_);
                owned_socket_for_sync_plain_.reset();  // Socket ownership transferred

                // Set SNI (Server Name Indication) and hostname verification
                if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                    // Set SNI hostname for TLS extension
                    if (!SSL_set_tlsext_host_name(ssl_stream_sync_->native_handle(), conn_config_.target_host.c_str())) {
                        boost::system::error_code sni_ec(static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category());
                        // SNI failure is usually not fatal for the handshake itself but might lead to cert validation issues.
                        if (logger_) logger_->warn("[ConnSSLHS {}] Failed to set SNI extension for host {}: {}. Handshake will proceed.", id_, conn_config_.target_host, sni_ec.message());
                    } else {
                        if (logger_) logger_->trace("[ConnSSLHS {}] SNI hostname set to: {}", id_, conn_config_.target_host);
                    }

                    // Set the verify callback for hostname verification.
                    ssl_stream_sync_->set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
                    if (logger_) logger_->trace("[ConnSSLHS {}] Hostname verification enabled for: {}", id_, conn_config_.target_host);
                } else {
                    if (logger_) logger_->debug("[ConnSSLHS {}] Hostname verification skipped (disabled or trust_all_certs).", id_);
                }

                // Perform the SSL handshake
                boost::system::error_code handshake_ec;
                auto handshake_op = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    try {
                        co_await ssl_stream_sync_->async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    } catch (const boost::system::system_error& e) {
                        op_ec_ref = e.code();
                    }
                    co_return;
                };

                handshake_ec = run_with_timeout_sync_internal_hs(io_context_ref_,
                                                                 std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms),  // Using bolt_handshake_timeout_ms
                                                                 handshake_op,
                                                                 logger_,
                                                                 id_,
                                                                 "SSL Handshake",
                                                                 ssl_stream_sync_.get());

                if (handshake_ec) {
                    std::string msg;
                    if (handshake_ec == boost::asio::error::timed_out) {
                        msg = "SSL handshake timed out for host " + conn_config_.target_host + " after " + std::to_string(conn_config_.bolt_handshake_timeout_ms) + "ms.";
                    } else {
                        msg = "SSL handshake failed for host " + conn_config_.target_host + ": " + handshake_ec.message();
                        // Append OpenSSL error details if available
                        unsigned long openssl_err_code = ERR_get_error();  // Get last OpenSSL error
                        while (openssl_err_code != 0) {                    // Loop if there are multiple errors in the queue
                            char err_buf[256];
                            ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                            msg += " (OpenSSL: " + std::string(err_buf) + ")";
                            openssl_err_code = ERR_get_error();  // Get next error
                        }
                    }
                    _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                    if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                    return last_error_code_;
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL handshake: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL handshake: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLHS {}] SSL handshake successful for {}.", id_, conn_config_.target_host);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket&>& stream_ref,  // Pass stream by reference
                                                                                                           std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Performing SSL handshake async for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, timeout.count());
            boost::system::error_code ec;

            // SNI and hostname verification setup
            if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                if (!SSL_set_tlsext_host_name(stream_ref.native_handle(), conn_config_.target_host.c_str())) {
                    if (logger_) logger_->warn("[ConnSSLHSAsync {}] Failed to set SNI (async) for host {}", id_, conn_config_.target_host);
                }
                stream_ref.set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
            }

            boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
            std::atomic<bool> handshake_timed_out{false};
            std::atomic<bool> handshake_completed{false};

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            if (!handshake_completed.load(std::memory_order_acquire)) {
                                handshake_timed_out.store(true, std::memory_order_release);
                                boost::system::error_code cancel_ec;
                                stream_ref.lowest_layer().cancel(cancel_ec);  // Cancel underlying socket
                                if (logger_) logger_->warn("[ConnSSLHSAsync {}] SSL handshake async timed out, lowest_layer cancelled (ec: {}).", id_, cancel_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            // Perform handshake
            co_await stream_ref.async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            handshake_completed.store(true, std::memory_order_release);
            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (handshake_timed_out.load(std::memory_order_acquire) || ec == boost::asio::error::operation_aborted) {
                    msg = "Async SSL handshake for host " + conn_config_.target_host + " timed out or was cancelled.";
                    ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async SSL handshake failed: " + ec.message();
                    unsigned long openssl_err_code = ERR_get_error();
                    while (openssl_err_code != 0) {
                        char err_buf[256];
                        ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                        msg += " (OpenSSL: " + std::string(err_buf) + ")";
                        openssl_err_code = ERR_get_error();
                    }
                }
                if (logger_) logger_->error("[ConnSSLHSAsync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                co_return boltprotocol::BoltError::HANDSHAKE_FAILED;
            }

            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Async SSL handshake successful.", id_);
            current_state_.store(InternalState::SSL_HANDSHAKEN);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _update_metadata_from_hello_success: 从 HELLO 成功消息中更新连接元数据
        void BoltPhysicalConnection::_update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_server = meta.metadata.find("server");
            if (it_server != meta.metadata.end() && std::holds_alternative<std::string>(it_server->second)) {
                server_agent_string_ = std::get<std::string>(it_server->second);
            } else {
                server_agent_string_.clear();  // 如果没有提供，则清空
            }

            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                server_assigned_conn_id_ = std::get<std::string>(it_conn_id->second);
            } else {
                server_assigned_conn_id_.clear();
            }

            // 处理 UTC 补丁 (patch_bolt)
            utc_patch_active_ = false;  // 默认为 false
            // Bolt 4.3 和 4.4 可能通过 patch_bolt 启用 UTC
            if (negotiated_bolt_version_ == boltprotocol::versions::Version(4, 3) || negotiated_bolt_version_ == boltprotocol::versions::Version(4, 4)) {
                auto it_patch = meta.metadata.find("patch_bolt");
                if (it_patch != meta.metadata.end()) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second)) {
                        auto list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second);
                        if (list_ptr) {
                            for (const auto& val : list_ptr->elements) {
                                if (std::holds_alternative<std::string>(val)) {
                                    if (std::get<std::string>(val) == "utc") {
                                        utc_patch_active_ = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Bolt 5.0 及更高版本默认启用 UTC 行为（即时间戳为UTC）
            if (negotiated_bolt_version_ >= boltprotocol::versions::Version(5, 0)) {
                utc_patch_active_ = true;
            }

            if (logger_) logger_->debug("[ConnState {}] Metadata updated from HELLO. Server: '{}', ConnId: '{}', UTC Patch Active: {}", id_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_);
        }

        // _update_metadata_from_logon_success: 从 LOGON 成功消息中更新元数据
        void BoltPhysicalConnection::_update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta) {
            // LOGON 响应也可能包含 "connection_id"，如果服务器选择在此时分配或更改它
            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                std::string new_conn_id = std::get<std::string>(it_conn_id->second);
                if (server_assigned_conn_id_ != new_conn_id && logger_) {
                    logger_->debug("[ConnState {}] Connection ID changed by LOGON from '{}' to '{}'", id_, server_assigned_conn_id_, new_conn_id);
                }
                server_assigned_conn_id_ = new_conn_id;
            }
            // LOGON 响应通常不包含其他如 server agent 或 patch_bolt 的元数据，这些在 HELLO 中处理
            if (logger_) logger_->debug("[ConnState {}] Metadata updated from LOGON. ConnId: '{}'", id_, server_assigned_conn_id_);
        }

        // _classify_and_set_server_failure: 分类服务器 FAILURE 消息并设置连接错误状态
        boltprotocol::BoltError BoltPhysicalConnection::_classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta) {
            std::string neo4j_code = "Unknown.Error";
            std::string message = "An unspecified error occurred on the server.";

            auto extract_string_from_map = [&](const std::string& key) -> std::optional<std::string> {
                auto it = meta.metadata.find(key);
                if (it != meta.metadata.end() && std::holds_alternative<std::string>(it->second)) {
                    return std::get<std::string>(it->second);
                }
                return std::nullopt;
            };

            // Neo4j 错误码优先 (Bolt 5.1+)
            if (auto code_opt = extract_string_from_map("neo4j_code")) {
                neo4j_code = *code_opt;
            } else if (auto legacy_code_opt = extract_string_from_map("code")) {  // 旧版 "code"
                neo4j_code = *legacy_code_opt;
            }

            if (auto msg_opt = extract_string_from_map("message")) {
                message = *msg_opt;
            }

            std::string full_error_message = "Server error: [" + neo4j_code + "] " + message;

            // 根据错误码分类并设置状态
            // 这是一个简化的分类，实际驱动会更细致
            boltprotocol::BoltError classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            InternalState next_state = InternalState::FAILED_SERVER_REPORTED;  // 默认服务器报告错误后可重置

            if (neo4j_code.find("TransientError") != std::string::npos || neo4j_code.find("DatabaseUnavailable") != std::string::npos || neo4j_code.find("NotALeader") != std::string::npos || neo4j_code.find("ForbiddenOnReadOnlyDatabase") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::NETWORK_ERROR;  // 可视为网络/集群问题
                // next_state 保持 FAILED_SERVER_REPORTED，允许重试/获取新路由
            } else if (neo4j_code.find("ClientError.Security") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::HANDSHAKE_FAILED;  // 认证/授权问题
                next_state = InternalState::DEFUNCT;                                // 安全问题通常使连接失效
            } else if (neo4j_code.find("ClientError.Statement") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::INVALID_ARGUMENT;  // 语句错误
                // next_state 保持 FAILED_SERVER_REPORTED，通常语句错误不使连接失效
            } else if (neo4j_code.find("ClientError.Transaction") != std::string::npos) {
                // 事务相关的客户端错误，例如无效的事务状态
                classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;  // 或更具体的事务错误码
                // next_state 保持 FAILED_SERVER_REPORTED
            } else {
                // 其他未知错误
                // next_state 保持 FAILED_SERVER_REPORTED
            }

            // _mark_as_defunct 会将状态设为 DEFUNCT，这里我们根据错误类型决定是否调用它
            if (next_state == InternalState::DEFUNCT) {
                _mark_as_defunct(classified_error_code, full_error_message);
            } else {
                // 对于非 DEFUNCT 的服务器错误，我们设置错误码和消息，并将状态设为 FAILED_SERVER_REPORTED
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = classified_error_code;
                last_error_message_ = full_error_message;
            }

            if (logger_) logger_->warn("[ConnState {}] Server reported failure. Code: '{}', Msg: '{}'. Classified as: {}, Next state: {}", id_, neo4j_code, message, error::bolt_error_to_string(last_error_code_), _get_current_state_as_string());
            return last_error_code_;  // 返回分类后的错误码
        }

        // _mark_as_defunct: 将连接标记为失效
        void BoltPhysicalConnection::_mark_as_defunct(boltprotocol::BoltError reason, const std::string& message) {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            // 如果已经失效且原因是相同的，则只追加消息（如果不同）
            if (current_s == InternalState::DEFUNCT && last_error_code_ != boltprotocol::BoltError::SUCCESS && reason == last_error_code_) {
                if (!message.empty() && last_error_message_.find(message) == std::string::npos) {
                    last_error_message_ += "; Additional info: " + message;
                }
                return;  // 避免重复日志和不必要的原子操作
            }

            current_state_.store(InternalState::DEFUNCT, std::memory_order_acq_rel);  // 使用 acquire/release 语义
            last_error_code_ = reason;
            last_error_message_ = message;

            if (logger_) {
                logger_->error("[ConnState {}] Marked as DEFUNCT. Reason: {} ({}), Message: {}", id_, static_cast<int>(reason), error::bolt_error_to_string(reason), message);
            }
        }

        // _get_current_state_as_string: 获取当前状态的字符串表示
        std::string BoltPhysicalConnection::_get_current_state_as_string() const {
            switch (current_state_.load(std::memory_order_relaxed)) {
                case InternalState::FRESH:
                    return "FRESH";
                case InternalState::TCP_CONNECTING:
                    return "TCP_CONNECTING";
                case InternalState::TCP_CONNECTED:
                    return "TCP_CONNECTED";
                case InternalState::SSL_CONTEXT_SETUP:
                    return "SSL_CONTEXT_SETUP";
                case InternalState::SSL_HANDSHAKING:
                    return "SSL_HANDSHAKING";
                case InternalState::SSL_HANDSHAKEN:
                    return "SSL_HANDSHAKEN";
                case InternalState::BOLT_HANDSHAKING:
                    return "BOLT_HANDSHAKING";
                case InternalState::BOLT_HANDSHAKEN:
                    return "BOLT_HANDSHAKEN";
                case InternalState::HELLO_AUTH_SENT:
                    return "HELLO_AUTH_SENT";
                case InternalState::READY:
                    return "READY";
                case InternalState::STREAMING:
                    return "STREAMING";
                case InternalState::AWAITING_SUMMARY:
                    return "AWAITING_SUMMARY";
                case InternalState::FAILED_SERVER_REPORTED:
                    return "FAILED_SERVER_REPORTED";
                case InternalState::DEFUNCT:
                    return "DEFUNCT";
                default:
                    return "UNKNOWN_STATE_" + std::to_string(static_cast<int>(current_state_.load(std::memory_order_relaxed)));
            }
        }

        // is_ready_for_queries: 检查连接是否准备好执行查询
        bool BoltPhysicalConnection::is_ready_for_queries() const {
            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                return false;
            }
            // 检查底层流是否仍然有效
            if (conn_config_.encryption_enabled) {
                return ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();  // 使用 _sync_ 后缀
            } else {
                return plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
            }
        }

        // is_defunct: 检查连接是否已失效
        bool BoltPhysicalConnection::is_defunct() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT) {
                return true;
            }
            // 即使状态不是 DEFUNCT，如果底层流已关闭，也应视为失效
            if (current_s > InternalState::FRESH && current_s < InternalState::DEFUNCT) {  // 意味着至少尝试过连接
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {  // 使用 _sync_ 后缀
                        // (const_cast<BoltPhysicalConnection*>(this))->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream found closed unexpectedly.");
                        return true;
                    }
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        // (const_cast<BoltPhysicalConnection*>(this))->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream found bad unexpectedly.");
                        return true;
                    }
                }
            }
            return false;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host
#include "boltprotocol/message_defs.h"             // For MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_send_chunked_payload_sync(const std::vector<uint8_t>& payload) {
            if (is_defunct()) return last_error_code_;

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);

                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    // _write_to_active_sync_stream already logs and marks defunct
                    return err;
                }

                err = _write_to_active_sync_stream(data_ptr, chunk_size);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            // Send end-of-message marker (zero-size chunk)
            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&zero_chunk_be), boltprotocol::CHUNK_HEADER_SIZE);
            }

            return err;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_receive_chunked_payload_sync(std::vector<uint8_t>& out_payload) {
            out_payload.clear();
            if (is_defunct()) return last_error_code_;

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (true) {
                uint16_t chunk_size_be = 0;
                size_t bytes_read_header = 0;
                err = _read_from_active_sync_stream(reinterpret_cast<uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE, bytes_read_header);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();  // Ensure out_payload is clear on error
                    return err;
                }

                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {  // End of message
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Received chunk larger than max allowed size: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->error("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t current_payload_offset = out_payload.size();
                try {
                    out_payload.resize(current_payload_offset + chunk_payload_size);
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory resizing payload buffer for chunk.";
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->critical("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t bytes_read_payload = 0;
                err = _read_from_active_sync_stream(out_payload.data() + current_payload_offset, chunk_payload_size, bytes_read_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (total_bytes_read_for_message == 0 && out_payload.empty()) {  // Received only an EOM marker
                if (logger_) logger_->trace("[ConnSyncChunking {}] Received NOOP message (empty payload from chunks).", id_);
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>   // For errno with iostream
#include <iostream>  // For std::ios_base::failure

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
// No boltprotocol includes needed here as these are pure ASIO/iostream operations

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_write_to_active_sync_stream(const uint8_t* data, size_t size) {
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Write attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            boost::system::error_code ec;
            size_t bytes_written = 0;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Write {} bytes", id_, size);
                    bytes_written = boost::asio::write(*ssl_stream_sync_, boost::asio::buffer(data, size), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Write {} bytes via iostream", id_, size);
                    plain_iostream_wrapper_->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
                    if (plain_iostream_wrapper_->fail()) {
                        // Try to get a more specific error if possible, otherwise assume generic stream error
                        // For iostreams, fail() doesn't directly give a boost::system::error_code in the same way.
                        // We might need to rely on errno or a generic error.
                        int stream_errno = errno;  // POSIX errno
                        ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EPIPE /*Broken pipe is common*/, boost::system::system_category());
                    } else {
                        bytes_written = size;  // Assume full write if no fail bit
                        plain_iostream_wrapper_->flush();
                        if (plain_iostream_wrapper_->fail()) {
                            int stream_errno_flush = errno;
                            ec = boost::system::error_code(stream_errno_flush != 0 ? stream_errno_flush : EPIPE, boost::system::system_category());
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {  // Catches ASIO errors
                ec = e.code();
                std::string msg = "ASIO system error during sync write: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {  // Catches iostream errors if exceptions are enabled
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO /*Generic I/O error*/, boost::system::system_category());
                std::string msg = "iostream failure during sync write: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg = "Sync write to stream failed: " + ec.message();
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_written != size) {
                // This case is less likely with boost::asio::write which tries to write all.
                // For iostream, if fail() wasn't set, we assume full write. More robust checking might be needed
                // if partial writes without failbit are possible for plain_iostream_wrapper_.
                std::string msg = "Partial sync write to stream. Expected " + std::to_string(size) + ", wrote " + std::to_string(bytes_written);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read) {
            bytes_read = 0;
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Read attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (size_to_read == 0) return boltprotocol::BoltError::SUCCESS;  // Nothing to read

            boost::system::error_code ec;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Read {} bytes", id_, size_to_read);
                    // boost::asio::read ensures all bytes are read or an error (like EOF) occurs.
                    bytes_read = boost::asio::read(*ssl_stream_sync_, boost::asio::buffer(buffer, size_to_read), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Read {} bytes via iostream", id_, size_to_read);
                    plain_iostream_wrapper_->read(reinterpret_cast<char*>(buffer), static_cast<std::streamsize>(size_to_read));
                    bytes_read = static_cast<size_t>(plain_iostream_wrapper_->gcount());

                    if (bytes_read < size_to_read) {  // If not all bytes were read
                        if (plain_iostream_wrapper_->eof()) {
                            ec = boost::asio::error::eof;  // End of file reached before all bytes read
                        } else if (plain_iostream_wrapper_->fail()) {
                            int stream_errno = errno;
                            ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                        } else {
                            // Should not happen if gcount() < size_to_read and no fail/eof bits are set, but defensive.
                            ec = boost::asio::error::fault;  // Unexpected: not enough bytes but no error state
                        }
                    }
                    // If bytes_read == size_to_read, no error from iostream perspective for this read call.
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync read: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync read: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg;
                if (ec == boost::asio::error::eof) {
                    msg = "Sync read from stream failed: EOF reached prematurely. Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                } else {
                    msg = "Sync read from stream failed: " + ec.message() + ". Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                }
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            // This check is crucial. boost::asio::read guarantees full read or error.
            // For iostream, we check gcount().
            if (bytes_read < size_to_read) {
                std::string msg = "Incomplete sync read from stream. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(bytes_read) + ". No specific stream error reported.";
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);  // Treat as error
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>  // For co_spawn in sync connect helper
#include <boost/asio/connect.hpp>   // For boost::asio::async_connect with endpoint sequence
#include <boost/asio/detached.hpp>  // For detached in sync connect helper
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>  // For redirect_error
#include <boost/asio/steady_timer.hpp>    // For timeout in sync connect helper
#include <thread>                         // For std::this_thread::yield in sync connect helper

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// Helper function for synchronous connect with timeout (copied from your earlier version)
// This should ideally be in a common utility or made static within this file if only used here.
namespace {  // Anonymous namespace
    template <typename AsyncOperation>
    boost::system::error_code run_sync_op_with_timeout_tcp(  // Renamed to avoid conflicts
        boost::asio::io_context& io_ctx,
        std::chrono::milliseconds timeout_duration,
        AsyncOperation op,  // This lambda captures the socket by reference
        std::shared_ptr<spdlog::logger> logger,
        uint64_t conn_id,
        const std::string& op_name,
        boost::asio::ip::tcp::socket* socket_to_cancel_on_timeout) {
        boost::system::error_code result_ec = boost::asio::error::would_block;  // Default to an in-progress code
        std::atomic<bool> operation_completed_flag{false};

        // Launch the operation as a coroutine on the io_context
        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_local;
                try {
                    co_await op(op_ec_local);  // The lambda 'op' itself is awaitable or wraps an awaitable
                } catch (const boost::system::system_error& e) {
                    op_ec_local = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_local = boost::asio::error::fault;  // Generic error
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_local;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&, logger, conn_id, op_name, socket_to_cancel_on_timeout]  // Capture logger etc.
                             (const boost::system::error_code& ec_timer) {
                                 if (ec_timer != boost::asio::error::operation_aborted) {              // Timer wasn't cancelled
                                     if (!operation_completed_flag.load(std::memory_order_acquire)) {  // Op still running
                                         if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timed out.", conn_id, op_name);
                                         timed_out_flag = true;
                                         result_ec = boost::asio::error::timed_out;
                                         if (socket_to_cancel_on_timeout && socket_to_cancel_on_timeout->is_open()) {
                                             boost::system::error_code cancel_ec;
                                             socket_to_cancel_on_timeout->cancel(cancel_ec);  // Attempt to cancel the socket operation
                                             if (logger && cancel_ec) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timeout socket cancel error: {}", conn_id, op_name, cancel_ec.message());
                                         }
                                         operation_completed_flag.store(true, std::memory_order_release);  // Mark as completed (due to timeout)
                                     }
                                 }
                             });
        }

        // Run the io_context until the operation completes or times out.
        // This loop is for a synchronous call that internally uses async mechanisms.
        io_ctx.restart();  // Ensure io_context is not stopped
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilTCP {}] io_context stopped during op '{}' before completion.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {  // If not timed out and still 'would_block'
                    result_ec = boost::asio::error::interrupted;                        // Or some other appropriate error
                }
                break;
            }
            io_ctx.poll_one();  // Process one handler
            // If still not completed and io_context might have no more work temporarily (e.g. in a tight loop after poll_one returns 0)
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();  // Yield to other threads if any, or just to break busy wait.
                io_ctx.restart();           // Restart if it stopped because of no work
            }
        }
        timer.cancel();  // Cancel timer if it hasn't fired (op completed first)
        return result_ec;
    }
}  // anonymous namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_tcp_connect() {
            // Reset any previous socket/stream state for synchronous operations
            if (plain_iostream_wrapper_) plain_iostream_wrapper_.reset();
            if (ssl_stream_sync_) ssl_stream_sync_.reset();  // Should be reset if we are re-doing TCP connect
            if (owned_socket_for_sync_plain_ && owned_socket_for_sync_plain_->is_open()) {
                boost::system::error_code ignored_ec;
                try {
                    owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
                    owned_socket_for_sync_plain_->close(ignored_ec);
                } catch (...) { /* Ignore errors during cleanup */
                }
            }
            owned_socket_for_sync_plain_ = std::make_unique<boost::asio::ip::tcp::socket>(io_context_ref_);
            // current_state_ should already be TCP_CONNECTING or ASYNC_TCP_CONNECTING when this is called by establish/establish_async

            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, conn_config_.tcp_connect_timeout_ms);

            boost::system::error_code ec;
            try {
                boost::asio::ip::tcp::resolver resolver(io_context_ref_);
                // Resolve can throw if host is malformed, though async_resolve is often preferred for non-blocking.
                // For sync, resolve directly is fine.
                boost::asio::ip::tcp::resolver::results_type endpoints = resolver.resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), ec);

                if (ec) {
                    std::string msg = "DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }
                if (endpoints.empty()) {
                    std::string msg = "DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Define the connect operation as a lambda for the timeout helper
                auto connect_op_lambda = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    // This lambda is itself a coroutine because it co_awaits.
                    // It will be run by co_spawn within run_sync_op_with_timeout_tcp.
                    co_await boost::asio::async_connect(*owned_socket_for_sync_plain_, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    co_return;
                };

                ec = run_sync_op_with_timeout_tcp(io_context_ref_, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms), connect_op_lambda, logger_, id_, "Sync TCP Connect", owned_socket_for_sync_plain_.get());

                if (ec) {
                    std::string msg;
                    if (ec == boost::asio::error::timed_out) {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out after " + std::to_string(conn_config_.tcp_connect_timeout_ms) + "ms.";
                    } else {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                    }
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Set socket options
                if (conn_config_.socket_keep_alive_enabled) {
                    boost::system::error_code keep_alive_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                    if (keep_alive_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                    }
                }
                if (conn_config_.tcp_no_delay_enabled) {
                    boost::system::error_code no_delay_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                    if (no_delay_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                    }
                }

                // If not using SSL, wrap the socket in an iostream
                if (!conn_config_.encryption_enabled) {
                    if (!owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Socket not open for plain stream wrapper after connect.");
                        if (logger_) logger_->error("[ConnTCP {}] Socket not open for plain iostream wrapper post-connect.", id_);
                        return last_error_code_;
                    }
                    try {
                        // Pass the socket by rvalue reference to transfer ownership to iostream
                        plain_iostream_wrapper_ = std::make_unique<boost::asio::ip::tcp::iostream>(std::move(*owned_socket_for_sync_plain_));
                        owned_socket_for_sync_plain_.reset();  // Socket is now owned by iostream_wrapper_
                        if (!plain_iostream_wrapper_->good()) {
                            std::string msg = "Failed to initialize plain iostream wrapper after TCP connect (stream not good).";
                            _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                            if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    } catch (const std::exception& e) {  // Catch potential exceptions from iostream constructor
                        std::string msg = "Exception creating plain iostream wrapper: " + std::string(e.what());
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                        if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                        return last_error_code_;
                    }
                }
                // If SSL is enabled, owned_socket_for_sync_plain_ remains and will be used by _stage_ssl_handshake

            } catch (const boost::system::system_error& e) {  // Catch errors from resolver.resolve or socket options
                std::string msg = "ASIO system error during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {  // Catch other std exceptions
                std::string msg = "Standard exception during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket,  // Takes a reference to an existing socket
                                                                                                         std::chrono::milliseconds timeout) {
            // current_state_ should be ASYNC_TCP_CONNECTING, set by establish_async
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, timeout.count());

            boost::system::error_code ec;
            boost::asio::ip::tcp::resolver resolver(socket.get_executor());  // Use socket's executor

            auto endpoints = co_await resolver.async_resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            if (ec) {
                std::string msg = "Async DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }
            if (endpoints.empty()) {
                std::string msg = "Async DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            boost::asio::steady_timer timer(socket.get_executor());
            bool timed_out = false;

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                // Start a separate coroutine for the timer that cancels the connect op
                boost::asio::co_spawn(
                    socket.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {  // Timer expired
                            timed_out = true;
                            boost::system::error_code cancel_ec;
                            socket.cancel(cancel_ec);  // Cancel the connect operation
                            if (logger_ && cancel_ec) logger_->trace("[ConnTCPAsync {}] Connect op socket cancel returned: {}", id_, cancel_ec.message());
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await boost::asio::async_connect(socket, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, ec));

            if (timeout.count() > 0) {
                timer.cancel();  // If connect finished (with or without error), cancel the timer
            }

            if (ec) {
                std::string msg;
                if (timed_out || ec == boost::asio::error::operation_aborted /*due to timer cancel*/) {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out or was cancelled.";
                    // Ensure ec reflects timeout if timed_out is true, even if cancel caused a different ec
                    if (timed_out) ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                }
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            // Set socket options (same as sync version)
            if (conn_config_.socket_keep_alive_enabled) {
                boost::system::error_code keep_alive_ec;
                socket.set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                if (keep_alive_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                }
            }
            if (conn_config_.tcp_no_delay_enabled) {
                boost::system::error_code no_delay_ec;
                socket.set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                if (no_delay_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                }
            }

            // Unlike sync, we don't wrap in iostream here. The raw socket (or later SSL stream) is used.
            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);  // Or ASYNC_TCP_CONNECTED if differentiating
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 调试用

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {

    // Static private helper method definition
    std::string Neo4jBoltTransport::_make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string db_part = database_name.empty() ? "system" : database_name;
        if (impersonated_user && !impersonated_user->empty()) {
            return db_part + "@" + *impersonated_user;
        }
        return db_part;
    }

    Neo4jBoltTransport::Neo4jBoltTransport(config::TransportConfig a_config) : config_(std::move(a_config)) {
        if (!config_.logger) {
            config_.logger = config_.get_or_create_logger();
            if (!config_.logger) {
                std::cerr << "CRITICAL ERROR: Logger creation/retrieval failed during Neo4jBoltTransport initialization!" << std::endl;
                throw std::runtime_error("Logger initialization failed for Neo4jBoltTransport.");
            }
        }

        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initializing with URI: '{}'", config_.uri_string);

        if (uri::UriParser::parse(config_.uri_string, parsed_initial_uri_) != boltprotocol::BoltError::SUCCESS) {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty()) {
                if (config_.logger) config_.logger->error("[TransportLC] URI '{}' parsing failed and no initial router override provided. Routing may not work.", config_.uri_string);
            } else if (config_.logger) {
                config_.logger->warn("[TransportLC] URI '{}' parsing failed, but routing is disabled or initial router override is provided.", config_.uri_string);
            }
        } else {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty() && parsed_initial_uri_.is_routing_scheme && !parsed_initial_uri_.hosts_with_ports.empty()) {
                std::vector<routing::ServerAddress> initial_routers_from_uri;
                for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                    initial_routers_from_uri.emplace_back(hp.first, hp.second);
                }
                std::string default_context_key = _make_routing_context_key("", std::nullopt);
                config_.initial_router_addresses_override[default_context_key] = initial_routers_from_uri;
                if (config_.logger) config_.logger->info("[TransportLC] Set {} initial routers from URI for context '{}'.", initial_routers_from_uri.size(), default_context_key);
            }
        }

        config_.prepare_agent_strings();
        finalized_user_agent_ = config_.user_agent_override.empty() ? config_.bolt_agent_info.product : config_.user_agent_override;
        finalized_bolt_agent_info_ = config_.bolt_agent_info;

        if (io_context_.stopped()) {
            io_context_.restart();
        }
        work_guard_ = std::make_unique<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(boost::asio::make_work_guard(io_context_));

        if (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0) {
            eviction_timer_ = std::make_unique<boost::asio::steady_timer>(io_context_);

            uint32_t first_eviction_delay_ms = 10000;
            if (config_.idle_timeout_ms > 0) {
                first_eviction_delay_ms = config_.idle_timeout_ms / 2;
            } else if (config_.max_connection_lifetime_ms > 0) {
                first_eviction_delay_ms = config_.max_connection_lifetime_ms / 4;
            }
            first_eviction_delay_ms = std::max(1000u, first_eviction_delay_ms);

            eviction_timer_->expires_after(std::chrono::milliseconds(first_eviction_delay_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec_lambda) {
                if (ec_lambda != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->info("[TransportLC] Connection eviction task scheduled in {}ms.", first_eviction_delay_ms);
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initialized.");
    }

    Neo4jBoltTransport::~Neo4jBoltTransport() {
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destructing.");
        close();
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destruction complete.");
    }

    void Neo4jBoltTransport::close() {
        bool already_closing = closing_.exchange(true);
        if (already_closing) {
            if (config_.logger) config_.logger->debug("[TransportLC] Close already called or in progress.");
            return;
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closing...");

        if (eviction_timer_) {
            try {
                std::size_t cancelled_count = eviction_timer_->cancel();  // No error_code parameter
                if (config_.logger) {
                    config_.logger->trace("[TransportLC] Eviction timer cancelled {} pending operations.", cancelled_count);
                }
            } catch (const boost::system::system_error& e) {
                if (config_.logger) {
                    config_.logger->warn("[TransportLC] Exception during eviction_timer_.cancel(): {}", e.what());
                }
            }
            eviction_timer_.reset();
            if (config_.logger) config_.logger->trace("[TransportLC] Eviction timer reset.");
        }

        {
            std::lock_guard<std::mutex> lock(pool_mutex_);
            if (config_.logger) config_.logger->debug("[TransportLC] Terminating {} idle connections.", idle_connections_.size());
            for (auto& conn_ptr : idle_connections_) {
                if (conn_ptr) {
                    conn_ptr->terminate(true);
                }
            }
            idle_connections_.clear();
            total_connections_currently_pooled_ = 0;
        }
        pool_condition_.notify_all();

        {
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            routing_tables_.clear();
            if (config_.logger) config_.logger->debug("[TransportLC] Routing tables cleared.");
        }

        if (work_guard_) {
            work_guard_->reset();
        }
        if (!io_context_.stopped()) {
            io_context_.stop();
        }

        if (own_io_thread_ && io_thread_ && io_thread_->joinable()) {
            if (config_.logger) config_.logger->debug("[TransportLC] Joining IO thread...");
            try {
                io_thread_->join();
                if (config_.logger) config_.logger->debug("[TransportLC] IO thread joined.");
            } catch (const std::system_error& e) {
                if (config_.logger) config_.logger->error("[TransportLC] Error joining IO thread: {}", e.what());
            }
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closed.");
    }

    boltprotocol::BoltError Neo4jBoltTransport::verify_connectivity() {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[TransportVerify] Attempting to verify connectivity on a closing transport.");
            return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Verifying connectivity...");

        routing::ServerAddress address_to_verify;
        bool use_routing_for_verify = config_.client_side_routing_enabled && (parsed_initial_uri_.scheme != "bolt" && parsed_initial_uri_.scheme != "bolt+s" && parsed_initial_uri_.scheme != "bolt+ssc");

        if (use_routing_for_verify) {
            auto [addr_err, router_addr] = _get_server_address_for_session(config::SessionParameters{}.with_database("system"), routing::ServerRole::ROUTER);
            if (addr_err != boltprotocol::BoltError::SUCCESS || router_addr.host.empty()) {
                if (config_.logger) config_.logger->warn("[TransportVerify] Failed to get a router address for verification. Error: {}. Falling back to initial URI if possible.", neo4j_bolt_transport::error::bolt_error_to_string(addr_err));
                if (!parsed_initial_uri_.hosts_with_ports.empty()) {
                    const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
                    address_to_verify = routing::ServerAddress(hp.first, hp.second);
                    if (config_.logger) config_.logger->debug("[TransportVerify] Using direct address from URI for verification: {}", address_to_verify.to_string());
                } else {
                    if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No router available and no direct address in URI.");
                    return boltprotocol::BoltError::NETWORK_ERROR;
                }
            } else {
                address_to_verify = router_addr;
            }
        } else {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No direct address in URI for non-routing scheme.");
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
            address_to_verify = routing::ServerAddress(hp.first, hp.second);
        }

        if (address_to_verify.host.empty()) {
            if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: Final address to verify is empty.");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        routing::ServerAddress resolved_address_to_verify = address_to_verify;
        if (config_.server_address_resolver) {
            resolved_address_to_verify = config_.server_address_resolver(address_to_verify);
        }

        if (config_.logger) config_.logger->debug("[TransportVerify] Attempting to acquire connection to {} (resolved from {}) for verification.", resolved_address_to_verify.to_string(), address_to_verify.to_string());

        auto [conn_err, conn] = _acquire_pooled_connection(resolved_address_to_verify, std::nullopt);

        if (conn_err != boltprotocol::BoltError::SUCCESS || !conn) {
            if (config_.logger) config_.logger->error("[TransportVerify] Failed to acquire connection to {} for verification. Error: {}", resolved_address_to_verify.to_string(), neo4j_bolt_transport::error::bolt_error_to_string(conn_err));
            return conn_err;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Connectivity to {} verified successfully (connection {} acquired).", resolved_address_to_verify.to_string(), conn->get_id());
        release_connection(std::move(conn), true);
        return boltprotocol::BoltError::SUCCESS;
    }

    internal::BoltConnectionConfig Neo4jBoltTransport::_create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const {
        internal::BoltConnectionConfig physical_conf;
        physical_conf.target_host = target_address.host;
        physical_conf.target_port = target_address.port;
        physical_conf.auth_token = config_.auth_token;
        physical_conf.user_agent_for_hello = finalized_user_agent_;
        physical_conf.bolt_agent_info_for_hello = finalized_bolt_agent_info_;

        physical_conf.resolved_encryption_strategy = config_.encryption_strategy;
        if (config_.encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT) {
            physical_conf.encryption_enabled = true;
            physical_conf.trusted_certificates_pem_files = config_.trusted_certificates_pem_files;
            physical_conf.client_certificate_pem_file = config_.client_certificate_pem_file;
            physical_conf.client_private_key_pem_file = config_.client_private_key_pem_file;
            physical_conf.client_private_key_password = config_.client_private_key_password;
            physical_conf.hostname_verification_enabled = config_.hostname_verification_enabled;
        } else {
            physical_conf.encryption_enabled = false;
        }

        physical_conf.tcp_connect_timeout_ms = config_.tcp_connect_timeout_ms;
        physical_conf.socket_read_timeout_ms = config_.socket_read_timeout_ms;
        physical_conf.socket_write_timeout_ms = config_.socket_write_timeout_ms;
        physical_conf.socket_keep_alive_enabled = config_.tcp_keep_alive_enabled;
        physical_conf.tcp_no_delay_enabled = config_.tcp_no_delay_enabled;
        physical_conf.bolt_handshake_timeout_ms = config_.hello_timeout_ms;  // Note: This was hello_timeout_ms, perhaps should be a dedicated handshake_timeout_ms in TransportConfig?
        physical_conf.hello_timeout_ms = config_.hello_timeout_ms;
        physical_conf.goodbye_timeout_ms = config_.goodbye_timeout_ms;

        if (routing_context_for_hello.has_value()) {
            physical_conf.hello_routing_context = routing_context_for_hello;
        }

        if (!config_.preferred_bolt_versions.empty()) {
            physical_conf.preferred_bolt_versions = config_.preferred_bolt_versions;
        }

        if (config_.logger) {
            std::string preferred_versions_str = "default";
            if (physical_conf.preferred_bolt_versions.has_value() && !physical_conf.preferred_bolt_versions->empty()) {
                preferred_versions_str.clear();
                for (const auto& v : physical_conf.preferred_bolt_versions.value()) {
                    preferred_versions_str += v.to_string() + " ";
                }
            }
            config_.logger->trace("[TransportLC] Created physical connection config: Host={}, Port={}, Enc={}, Strategy={}, ReadTimeout={}, WriteTimeout={}, HelloTimeout={}, TCPNoDelay={}, HelloRoutingCtx={}, PreferredBoltVersions=[{}]",
                                  physical_conf.target_host,
                                  physical_conf.target_port,
                                  physical_conf.encryption_enabled,
                                  static_cast<int>(physical_conf.resolved_encryption_strategy),
                                  physical_conf.socket_read_timeout_ms,
                                  physical_conf.socket_write_timeout_ms,
                                  physical_conf.hello_timeout_ms,
                                  physical_conf.tcp_no_delay_enabled,
                                  physical_conf.hello_routing_context.has_value() ? "Yes" : "No",
                                  preferred_versions_str);
        }
        return physical_conf;
    }

}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _acquire_pooled_connection: 从池中获取或创建一个到 *特定已知地址* 的连接。
    // 路由选择逻辑在此函数之前完成。
    std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> Neo4jBoltTransport::_acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint /*用于日志和未来可能的优化*/) {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[PoolCore] 尝试在关闭的 transport 上获取到 {} 的连接。", target_address.to_string());
            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
        }

        std::unique_lock<std::mutex> lock(pool_mutex_);
        auto start_time = std::chrono::steady_clock::now();

        while (true) {
            // 1. 尝试从空闲连接中查找一个到 target_address 的可用连接
            for (auto it = idle_connections_.begin(); it != idle_connections_.end(); /* manual increment */) {
                internal::BoltPhysicalConnection::PooledConnection& conn_ptr_ref = *it;

                if (conn_ptr_ref->get_config().target_host == target_address.host && conn_ptr_ref->get_config().target_port == target_address.port) {
                    internal::BoltPhysicalConnection::PooledConnection conn_to_check = std::move(conn_ptr_ref);
                    it = idle_connections_.erase(it);  // 从池中移除
                    total_connections_currently_pooled_--;

                    bool healthy = true;
                    std::string unhealthy_reason;

                    if (conn_to_check->is_defunct()) {
                        healthy = false;
                        unhealthy_reason = "is_defunct";
                    } else if (config_.max_connection_lifetime_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms))) {
                        healthy = false;
                        unhealthy_reason = "exceeded max lifetime";
                    } else if (config_.idle_time_before_health_check_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_time_before_health_check_ms))) {
                        if (config_.logger) config_.logger->trace("[PoolCore] 空闲连接 {} (到 {}) 需要健康检查 (ping)。", conn_to_check->get_id(), target_address.to_string());

                        lock.unlock();
                        boltprotocol::BoltError ping_err = conn_to_check->ping(std::chrono::milliseconds(config_.tcp_connect_timeout_ms));
                        lock.lock();

                        if (closing_.load(std::memory_order_acquire)) {
                            if (config_.logger) config_.logger->warn("[PoolCore] Ping 后 transport 关闭。");
                            if (conn_to_check) conn_to_check->terminate(false);
                            total_connections_ever_created_--;
                            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                        }

                        if (ping_err != boltprotocol::BoltError::SUCCESS) {
                            healthy = false;
                            unhealthy_reason = "ping failed (" + error::bolt_error_to_string(ping_err) + ")";
                        } else {
                            if (config_.logger) config_.logger->trace("[PoolCore] 空闲连接 {} (到 {}) ping 成功。", conn_to_check->get_id(), target_address.to_string());
                        }
                    }

                    if (healthy) {
                        if (config_.logger) config_.logger->debug("[PoolCore] 复用空闲连接 {} 到 {} (数据库提示: '{}')", conn_to_check->get_id(), target_address.to_string(), database_name_hint.value_or("<无>"));
                        conn_to_check->mark_as_used();
                        return {boltprotocol::BoltError::SUCCESS, std::move(conn_to_check)};
                    } else {
                        if (config_.logger) config_.logger->info("[PoolCore] 终止过时/不健康的空闲连接 {} (到 {}) (原因: {}).", (conn_to_check ? conn_to_check->get_id() : 0), target_address.to_string(), unhealthy_reason);
                        if (conn_to_check) conn_to_check->terminate(false);
                        total_connections_ever_created_--;
                        // 继续在 idle_connections_ 中查找 (迭代器已通过 erase 更新)
                        // it = idle_connections_.erase(it) 已经移动了迭代器，所以不需要 it++
                        continue;
                    }
                }
                ++it;  // 检查下一个空闲连接
            }

            // 2. 如果池中没有到 target_address 的合适连接，并且池未满，则创建新连接
            if (total_connections_ever_created_ < config_.max_connection_pool_size) {
                std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_ctx_opt;
                if (config_.client_side_routing_enabled) {
                    std::map<std::string, boltprotocol::Value> ctx_map;
                    ctx_map["address"] = target_address.to_string();  // HELLO 上下文是目标地址
                    hello_routing_ctx_opt = ctx_map;
                }

                internal::BoltConnectionConfig physical_conn_conf = _create_physical_connection_config(target_address, hello_routing_ctx_opt);
                std::shared_ptr<spdlog::logger> conn_logger = config_.get_or_create_logger("BoltConnection");

                lock.unlock();
                if (config_.logger) config_.logger->debug("[PoolCore] 创建到 {} 的新连接 (数据库提示: '{}')", target_address.to_string(), database_name_hint.value_or("<无>"));

                auto new_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(physical_conn_conf), io_context_, conn_logger);
                boltprotocol::BoltError establish_err = new_conn->establish();
                lock.lock();

                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] Transport 在新连接建立期间关闭。");
                    if (new_conn) new_conn->terminate(false);
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }

                if (establish_err == boltprotocol::BoltError::SUCCESS) {
                    if (config_.logger) config_.logger->info("[PoolCore] 到 {} 的新连接 {} 已建立。", target_address.to_string(), new_conn->get_id());
                    total_connections_ever_created_++;
                    new_conn->mark_as_used();
                    return {boltprotocol::BoltError::SUCCESS, std::move(new_conn)};
                } else {
                    if (config_.logger) config_.logger->error("[PoolCore] 无法建立到 {} 的新连接。错误: {} ({})", target_address.to_string(), static_cast<int>(establish_err), new_conn ? new_conn->get_last_error_message() : error::bolt_error_to_string(establish_err));
                    // 连接失败不应该直接在这里处理路由表，因为此函数只负责连接到 *给定* 地址。
                    // 调用此函数的上层（例如路由逻辑）应该处理地址不可达的情况。
                    return {establish_err, nullptr};
                }
            }

            // 3. 如果池已满，等待
            auto time_waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time);
            auto remaining_timeout_ms = std::chrono::milliseconds(config_.connection_acquisition_timeout_ms) - time_waited;

            if (remaining_timeout_ms <= std::chrono::milliseconds(0)) {
                if (config_.logger) config_.logger->error("[PoolCore] 等待到 {} 的连接超时 (最大池大小: {})。", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // TODO: 更具体的超时错误码
            }

            if (config_.logger) {
                config_.logger->trace("[PoolCore] 池已满 ({}/{})，等待 {}ms 获取到 {} 的连接。",
                                      total_connections_ever_created_,
                                      config_.max_connection_pool_size,  // 使用 ever_created 作为当前“正在使用或空闲”的总数上限
                                      remaining_timeout_ms.count(),
                                      target_address.to_string());
            }

            if (pool_condition_.wait_for(lock, remaining_timeout_ms, [this] {
                    return closing_.load(std::memory_order_relaxed) || !idle_connections_.empty();  // 等待有任何空闲连接或关闭
                })) {
                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] 等待期间 transport 关闭。");
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
                if (config_.logger) config_.logger->trace("[PoolCore] 被唤醒，可能有空闲连接或 transport 关闭。");
            } else {
                if (config_.logger) config_.logger->error("[PoolCore] 等待到 {} 的连接在 wait_for 后超时 (最大池大小: {})。", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // 超时
            }
            // 继续循环
        }
    }

    void Neo4jBoltTransport::release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy) {
        if (!connection) return;

        bool transport_is_closing = closing_.load(std::memory_order_acquire);
        uint64_t conn_id = connection->get_id();
        routing::ServerAddress conn_target(connection->get_config().target_host, connection->get_config().target_port);

        if (transport_is_closing) {
            if (config_.logger) config_.logger->debug("[PoolCore] 在 transport 关闭期间释放连接 {} (到 {}), 将其终止。", conn_id, conn_target.to_string());
            connection->terminate(false);  // 不发送 GOODBYE
            // total_connections_ever_created_ 应该在这里减少，因为这个连接不再存在于系统中。
            // 加锁是为了保护 total_connections_ever_created_
            std::lock_guard<std::mutex> lock(pool_mutex_);
            total_connections_ever_created_ = std::max(0, (int)total_connections_ever_created_ - 1);  // 确保不为负
            return;
        }

        std::lock_guard<std::mutex> lock(pool_mutex_);

        if (!mark_as_healthy || connection->is_defunct()) {
            if (config_.logger) config_.logger->info("[PoolCore] 释放不健康/失效的连接 {} (到 {}), 将其终止。健康标记: {}, 失效: {}", conn_id, conn_target.to_string(), mark_as_healthy, connection->is_defunct());
            connection->terminate(false);
            total_connections_ever_created_--;
            pool_condition_.notify_one();
            return;
        }

        bool should_retire_due_to_age = false;
        if (config_.max_connection_lifetime_ms > 0) {
            auto age = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - connection->get_creation_timestamp());
            if (age.count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                should_retire_due_to_age = true;
                if (config_.logger) config_.logger->info("[PoolCore] 连接 {} (到 {}) 因达到最大生命周期而淘汰。", conn_id, conn_target.to_string());
            }
        }

        // 如果空闲连接数已达到池上限（max_connection_pool_size 通常指总连接数，但这里也可理解为空闲连接上限）
        // 或者连接已老化，则关闭此连接
        // 注意：max_connection_pool_size 应该与 total_connections_ever_created_ 比较。
        // total_connections_currently_pooled_ 是当前空闲的连接数。
        if (should_retire_due_to_age || total_connections_currently_pooled_ >= config_.max_connection_pool_size) {
            if (config_.logger) config_.logger->debug("[PoolCore] 终止连接 {} (到 {})。淘汰: {}, 当前空闲: {}, 配置池大小(上限): {}", conn_id, conn_target.to_string(), should_retire_due_to_age, total_connections_currently_pooled_, config_.max_connection_pool_size);
            connection->terminate(true);  // 发送 GOODBYE
            total_connections_ever_created_--;
            pool_condition_.notify_one();
        } else {
            if (config_.logger) config_.logger->debug("[PoolCore] 将连接 {} (到 {}) 返回到空闲池。当前空闲池大小: {}", conn_id, conn_target.to_string(), total_connections_currently_pooled_);
            connection->mark_as_used();  // 更新最后使用时间戳
            idle_connections_.push_back(std::move(connection));
            total_connections_currently_pooled_++;
            pool_condition_.notify_one();
        }
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::remove_if
#include <chrono>
#include <iostream>  // 调试用

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 虽然这里可能不需要，但保持一致性
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    void Neo4jBoltTransport::_evict_stale_connections_task() {
        if (closing_.load(std::memory_order_acquire)) return;

        if (config_.logger) config_.logger->trace("[PoolEvictor] 开始检查过期的空闲连接...");

        std::unique_lock<std::mutex> lock(pool_mutex_);
        if (closing_.load(std::memory_order_acquire)) return;  // 再次检查，因为获取锁可能耗时

        auto now = std::chrono::steady_clock::now();
        int evicted_count = 0;

        auto it_remove = std::remove_if(idle_connections_.begin(), idle_connections_.end(), [&](const internal::BoltPhysicalConnection::PooledConnection& conn_ptr) {
            if (!conn_ptr) return true;  // 防御性编程

            bool evict = false;
            std::string reason;
            routing::ServerAddress conn_target(conn_ptr->get_config().target_host, conn_ptr->get_config().target_port);

            if (config_.max_connection_lifetime_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                    evict = true;
                    reason = "达到最大生命周期";
                }
            }
            if (!evict && config_.idle_timeout_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_timeout_ms)) {
                    evict = true;
                    reason = "空闲超时";
                }
            }
            if (!evict && conn_ptr->is_defunct()) {  // 安全检查，理论上不应在池中
                evict = true;
                reason = "在池中发现失效连接";
            }

            if (evict) {
                if (config_.logger) config_.logger->info("[PoolEvictor] 驱逐连接 {} (到 {}) 原因: {}.", conn_ptr->get_id(), conn_target.to_string(), reason);
                conn_ptr->terminate(false);  // 终止，不发送 GOODBYE
                return true;                 // 标记为移除
            }
            return false;  // 保留
        });

        evicted_count = std::distance(it_remove, idle_connections_.end());
        if (evicted_count > 0) {
            idle_connections_.erase(it_remove, idle_connections_.end());
            total_connections_currently_pooled_ -= evicted_count;
            total_connections_ever_created_ -= evicted_count;
            if (config_.logger) config_.logger->debug("[PoolEvictor] 驱逐了 {} 个连接。当前空闲: {}. 总创建数: {}", evicted_count, total_connections_currently_pooled_, total_connections_ever_created_);
            pool_condition_.notify_all();  // 通知可能因池满而等待的线程
        }
        lock.unlock();  // 手动解锁

        // 重新调度驱逐任务 (如果 transport 未关闭)
        if (!closing_.load(std::memory_order_acquire) && eviction_timer_ && (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0)) {
            // 计算下一个合理的检查时间，例如最短超时的一半，但不小于1秒
            uint32_t next_check_interval_ms = 10000;  // 默认10秒
            if (config_.idle_timeout_ms > 0 && config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = std::min(config_.idle_timeout_ms, config_.max_connection_lifetime_ms);
            } else if (config_.idle_timeout_ms > 0) {
                next_check_interval_ms = config_.idle_timeout_ms;
            } else if (config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = config_.max_connection_lifetime_ms;
            }
            next_check_interval_ms = std::max(1000u, next_check_interval_ms / 2);

            eviction_timer_->expires_after(std::chrono::milliseconds(next_check_interval_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec) {
                if (ec != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->trace("[PoolEvictor] 下一次连接驱逐检查已调度在 {}ms 后。", next_check_interval_ms);
        } else if (config_.logger) {
            config_.logger->trace("[PoolEvictor] 连接驱逐任务未重新调度 (transport关闭或定时器/配置禁用)。");
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/session_parameters.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/session_handle.h"
// #include "neo4j_bolt_transport/async_session_handle.h" // 暂时移除
#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"

namespace neo4j_bolt_transport {

    // --- Neo4jBoltTransport - acquire_session (同步) ---
    std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> Neo4jBoltTransport::acquire_session(const config::SessionParameters& params) {
        if (closing_.load(std::memory_order_acquire)) {
            std::string err_msg = "尝试在关闭的 transport 上获取会话。";
            if (config_.logger) config_.logger->warn("[SessionAcq] {}", err_msg);
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->debug("[SessionAcq] 尝试获取会话，数据库: '{}', 访问模式: {}", params.database_name.value_or("<默认>"), (params.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"));

        routing::ServerRole role_hint = (params.default_access_mode == config::AccessMode::READ) ? routing::ServerRole::READER : routing::ServerRole::WRITER;

        auto [addr_err, target_server_address] = _get_server_address_for_session(params, role_hint);

        if (addr_err != boltprotocol::BoltError::SUCCESS || target_server_address.host.empty()) {
            std::string err_msg = "无法为会话确定服务器地址 (DB: " + params.database_name.value_or("<默认>") + ", 角色: " + (role_hint == routing::ServerRole::READER ? "R" : "W") + "): " + error::bolt_error_to_string(addr_err);
            if (!target_server_address.host.empty()) {
                err_msg += " (目标地址尝试: " + target_server_address.to_string() + ")";
            }
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);
            return {{addr_err, err_msg}, SessionHandle(this, nullptr, params)};
        }

        auto [conn_err_code, pooled_conn] = _acquire_pooled_connection(target_server_address, params.database_name);

        if (conn_err_code != boltprotocol::BoltError::SUCCESS || !pooled_conn) {
            std::string err_msg = "无法从池中获取到 " + target_server_address.to_string() + " 的连接: (" + error::bolt_error_to_string(conn_err_code) + ")";
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);

            if (config_.client_side_routing_enabled && conn_err_code == boltprotocol::BoltError::NETWORK_ERROR) {
                std::string db_name_for_routing_key = params.database_name.value_or("");
                // 调用 Neo4jBoltTransport 的静态私有方法
                _handle_routing_failure(target_server_address, Neo4jBoltTransport::_make_routing_context_key(db_name_for_routing_key, params.impersonated_user));
            }
            return {{conn_err_code, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->info("[SessionAcq] 会话已成功获取，使用连接 {} 到 {}", pooled_conn->get_id(), target_server_address.to_string());
        return {{boltprotocol::BoltError::SUCCESS, ""}, SessionHandle(this, std::move(pooled_conn), params)};
    }

    // acquire_async_session 的函数体暂时移除，只保留声明在头文件中（或也从头文件中移除，后续添加）
    /*
    boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
    Neo4jBoltTransport::acquire_async_session(const config::SessionParameters& params) {
        // ... (之前的占位符或完全移除) ...
        if (config_.logger) config_.logger->debug("[SessionAcqAsync] 异步获取会话 (当前未实现)。");
        co_return std::make_pair(std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, "Async session acquisition not implemented."), AsyncSessionHandle(this, nullptr, params));
    }
    */

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/neo4j_transaction_context.h"

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能需要
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionContext::TransactionContext(SessionHandle& session) : owner_session_(session) {
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> TransactionContext::run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters) {
        if (!owner_session_.is_in_transaction()) {
            std::string err_msg = "TransactionContext::run called, but SessionHandle is not in an active explicit transaction.";
            boltprotocol::SuccessMessageParams dummy_run_summary_raw;
            auto dummy_field_names = std::make_shared<const std::vector<std::string>>();
            std::vector<boltprotocol::RecordMessageParams> empty_records;

            // 获取创建 BoltResultStream 所需的附加参数
            std::string server_addr = "unknown_server";
            boltprotocol::versions::Version bolt_ver(0, 0);
            bool utc_patch = false;
            if (owner_session_.connection_ && owner_session_.connection_->is_ready_for_queries()) {  // 检查连接有效性
                server_addr = owner_session_.connection_->get_config().target_host + ":" + std::to_string(owner_session_.connection_->get_config().target_port);
                bolt_ver = owner_session_.connection_->get_bolt_version();
                utc_patch = owner_session_.connection_->is_utc_patch_active();
            }

            // 使用更新后的构造函数
            auto failed_stream = std::make_unique<BoltResultStream>(&owner_session_,
                                                                    std::nullopt,
                                                                    std::move(dummy_run_summary_raw),
                                                                    dummy_field_names,
                                                                    std::move(empty_records),
                                                                    false,  // server_might_have_more
                                                                    bolt_ver,
                                                                    utc_patch,
                                                                    server_addr,
                                                                    owner_session_.session_params_.database_name,  // session_params_ 是 SessionHandle 的成员
                                                                    boltprotocol::BoltError::INVALID_ARGUMENT,     // initial_error
                                                                    err_msg,                                       // initial_error_message
                                                                    std::nullopt                                   // initial_failure_details
            );
            // failed_stream->_set_failure_state(boltprotocol::BoltError::INVALID_ARGUMENT, err_msg); // 这行现在由构造函数处理

            return {{boltprotocol::BoltError::INVALID_ARGUMENT, err_msg}, std::move(failed_stream)};
        }
        return owner_session_.run_query(cypher, parameters, std::nullopt);
    }

    // 注意：SessionHandle 中 run_consume 已改为 run_query_and_consume，并且返回 ResultSummary
    // TransactionContext::run_consume 的职责可能需要重新评估。
    // 如果它仍然需要返回原始的 SuccessMessageParams 和 FailureMessageParams，
    // 那么 SessionHandle 可能需要一个保留这种行为的底层方法，或者 TransactionContext 需要从 ResultSummary 中提取这些。
    // 为了简单修复编译错误，假设我们仍然希望 TransactionContext::run_consume 返回原始参数，
    // 这意味着 SessionHandle 需要一个类似 run_query_and_get_raw_summary 的方法，或者我们调整接口。
    //
    // 简单的修复：让 TransactionContext::run_consume 调用 run_query 然后 consume，然后从 ResultSummary 提取原始数据。
    // 但这有点低效。更好的方法是 SessionHandle 提供一个直接返回原始参数的 consume 方法。
    //
    // 假设我们修改 TransactionContext::run_consume 的目标是获取最终的 ResultSummary。
    // 如果要保持原接口，SessionHandle 需要一个不同的方法。
    //
    // 当前修复：修改 TransactionContext::run_consume 以匹配 SessionHandle::run_query_and_consume 的返回类型，
    // 或者，如果必须保持原始签名，则进行适配。
    //
    // **方案1: 修改 TransactionContext::run_consume 签名 (推荐)**
    // std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary>
    // TransactionContext::run_consume(const std::string& cypher,
    //                                 const std::map<std::string, boltprotocol::Value>& parameters) {
    //     if (!owner_session_.is_in_transaction()) {
    //         // ... 构造一个失败的 ResultSummary ...
    //         return {{boltprotocol::BoltError::INVALID_ARGUMENT, "Not in transaction"}, ResultSummary(...)};
    //     }
    //     return owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);
    // }

    // **方案2: 尝试适配现有签名 (更复杂，可能不完全符合预期)**
    std::pair<boltprotocol::BoltError, std::string> TransactionContext::run_consume(const std::string& cypher,
                                                                                    const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                    boltprotocol::SuccessMessageParams& out_summary_raw,  // 注意这是原始参数
                                                                                    boltprotocol::FailureMessageParams& out_failure_raw) {
        if (!owner_session_.is_in_transaction()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "TransactionContext::run_consume called, but SessionHandle is not in an active explicit transaction."};
        }

        // 调用 SessionHandle 的 run_query_and_consume
        auto [err_pair, result_summary_typed] = owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);

        // 从 ResultSummary 中获取原始参数
        out_summary_raw = result_summary_typed.raw_params();  // 这需要 ResultSummary 暴露 raw_params()
                                                              // 并且需要处理 ResultSummary 失败的情况

        if (err_pair.first != boltprotocol::BoltError::SUCCESS) {
            // 如果操作失败，尝试从 ResultStream 的失败详情中填充 out_failure_raw
            // BoltResultStream *stream_ptr_for_failure = nullptr; // 如何获取？
            // if (stream_ptr_for_failure && stream_ptr_for_failure->has_failed()){
            //    out_failure_raw = stream_ptr_for_failure->get_failure_details();
            // } else {
            out_failure_raw.metadata["message"] = boltprotocol::Value(err_pair.second);
            // }
        } else {
            out_failure_raw.metadata.clear();  // 成功时清除
        }
        return err_pair;
    }

}  // namespace neo4j_bolt_transport#include <iostream>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::tuple<boltprotocol::BoltError, std::string, ResultSummary> BoltResultStream::consume() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consuming stream.", (void*)this);

        if (stream_failed_) {
            // If failed, final_summary_typed_ might not be meaningful or might be from RUN.
            // Return run_summary_typed_ or a default-constructed ResultSummary if even that is bad.
            // For now, return existing final_summary_typed_ which should be default/run summary.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }
        if (stream_fully_consumed_or_discarded_) {
            return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
        }

        auto discard_result_pair = _discard_all_remaining_records();  // This will update final_summary_typed_ internally via _update_final_summary

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            // _set_failure_state was called by _discard_all_remaining_records
            // final_summary_typed_ might reflect the RUN summary in this case.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }

        // Update session bookmarks from the final summary for auto-commit sessions.
        // This happens only if consume was successful and it was an auto-commit query.
        if (owner_session_ && !owner_session_->is_in_transaction() && !stream_failed_) {
            auto it_bookmark = final_summary_typed_.raw_params().metadata.find("bookmark");
            if (it_bookmark != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                owner_session_->update_bookmarks({std::get<std::string>(it_bookmark->second)});
            } else {
                if (failure_reason_ == boltprotocol::BoltError::SUCCESS) {  // Only clear if server operation was success
                    owner_session_->update_bookmarks({});
                }
            }
        }
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consume successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_fetch_more_records(int64_t n) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            std::string msg = "Fetch records: Invalid session or connection.";
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, msg);
            if (logger) logger->warn("[ResultStreamFETCH {}] {}", (void*)this, msg);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || (stream_fully_consumed_or_discarded_ && !is_first_pull_attempt_)) {
            if (logger) logger->trace("[ResultStreamFETCH {}] Already failed or consumed. Failed: {}, Consumed: {}, FirstPull: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_, is_first_pull_attempt_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::UNKNOWN_ERROR, failure_message_};
        }

        if (logger) logger->trace("[ResultStreamFETCH {}] Fetching {} records. QID: {}", (void*)this, n, (query_id_ ? std::to_string(*query_id_) : "auto"));

        std::vector<boltprotocol::RecordMessageParams> fetched_records;
        boltprotocol::SuccessMessageParams current_pull_summary_raw;  // 从 _stream_pull_records 获取原始摘要

        std::optional<int64_t> qid_for_this_pull = query_id_;

        // 调用 SessionHandle 的方法来实际与物理连接交互
        auto pull_result_pair = owner_session_->_stream_pull_records(qid_for_this_pull, n, fetched_records, current_pull_summary_raw);
        is_first_pull_attempt_ = false;  // 无论成功与否，都已经尝试过 PULL

        if (pull_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            // 尝试从连接获取更具体的服务器错误信息（如果与 PULL 操作的错误不同）
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != pull_result_pair.first) {  // 仅当连接错误更具体时
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    // temp_fail.metadata["code"] = ... (如果可以从 BoltPhysicalConnection 获取 Neo4j 错误码)
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(pull_result_pair.first, pull_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamFETCH {}] _stream_pull_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(pull_result_pair.first), pull_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        // PULL 消息交换成功，服务器返回了 SUCCESS 摘要
        _update_final_summary(std::move(current_pull_summary_raw));  // 使用收到的原始摘要更新类型化的 final_summary_typed_

        for (auto& rec : fetched_records) {
            raw_record_buffer_.push_back(std::move(rec));
        }

        // 从更新后的 final_summary_typed_ 中检查 has_more
        auto it_has_more = final_summary_typed_.raw_params().metadata.find("has_more");
        if (it_has_more != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
            server_has_more_records_ = std::get<bool>(it_has_more->second);
        } else {
            server_has_more_records_ = false;  // 如果 PULL 摘要中没有 "has_more"，则假定没有更多了
        }

        if (!server_has_more_records_ && raw_record_buffer_.empty()) {
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamFETCH {}] Fetched {}. Buffer: {}. ServerMore: {}", (void*)this, fetched_records.size(), raw_record_buffer_.size(), server_has_more_records_);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_discard_all_remaining_records() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discarding. QID: {}", (void*)this, (query_id_ ? std::to_string(*query_id_) : "auto"));

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Discard: Invalid session/connection.");
            if (logger) logger->warn("[ResultStreamDISCARD {}] Invalid session/connection.", (void*)this);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamDISCARD {}] Already failed or consumed. Failed: {}, Consumed: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::SUCCESS, failure_message_};
        }

        raw_record_buffer_.clear();  // 清空本地缓冲的记录

        // 检查是否真的需要向服务器发送 DISCARD
        // server_has_more_records_ 反映了上一个 PULL/DISCARD 的 has_more 标志
        // initial_server_has_more_records_ 反映了 RUN 响应的 has_more 标志
        // is_first_pull_attempt_ 表示是否还没有执行过 PULL 或 DISCARD
        bool needs_server_discard = false;
        if (is_first_pull_attempt_) {  // 第一次操作（之前没有PULL/DISCARD）
            needs_server_discard = initial_server_has_more_records_;
        } else {  // 已经有过PULL/DISCARD
            needs_server_discard = server_has_more_records_;
        }

        if (!needs_server_discard) {
            stream_fully_consumed_or_discarded_ = true;
            // 如果这是第一次操作（例如，RUN 后直接 consume，且 RUN 表明没有记录），
            // final_summary_typed_ 应该等于 run_summary_typed_。
            // _update_final_summary 在构造时已经用 run_summary 初始化了 final_summary。
            // 如果之前有PULL，final_summary_typed_ 已经被该PULL的摘要更新。
            if (is_first_pull_attempt_) {
                // 确保 final_summary_typed_ 反映的是 run_summary_typed_ 的状态，因为它没有发生网络交互
                // _update_final_summary(boltprotocol::SuccessMessageParams(run_summary_typed_.raw_params()));
                // 上面这行可能不必要，因为构造时 final_summary_typed_ 已经是 run_summary_typed_ 的一个副本了。
            }
            if (logger) logger->trace("[ResultStreamDISCARD {}] No records on server to discard. FirstPull: {}, InitialServerMore: {}, CurrentServerMore: {}", (void*)this, is_first_pull_attempt_, initial_server_has_more_records_, server_has_more_records_);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        // 需要向服务器发送 DISCARD
        boltprotocol::SuccessMessageParams discard_summary_raw;  // 用于接收原始摘要
        std::optional<int64_t> qid_for_discard = query_id_;

        auto discard_result_pair = owner_session_->_stream_discard_records(qid_for_discard, -1, discard_summary_raw);
        is_first_pull_attempt_ = false;              // 标记已尝试过 PULL/DISCARD
        stream_fully_consumed_or_discarded_ = true;  // DISCARD 意味着流结束

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != discard_result_pair.first) {
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(discard_result_pair.first, discard_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamDISCARD {}] _stream_discard_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(discard_result_pair.first), discard_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        _update_final_summary(std::move(discard_summary_raw));  // 使用收到的原始摘要更新类型化的 final_summary_typed_
        server_has_more_records_ = false;                       // DISCARD 后，服务器肯定没有更多记录了
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discard successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // ... (has_next 实现) ...
    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::has_next(bool& out_has_next) {
        out_has_next = false;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream already failed. Reason: {}", (void*)this, static_cast<int>(failure_reason_));
            return {failure_reason_, failure_message_};
        }
        if (stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream fully consumed/discarded.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }
        if (!raw_record_buffer_.empty()) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Records in buffer.", (void*)this);
            out_has_next = true;
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        bool effectively_has_more_on_server = is_first_pull_attempt_ ? initial_server_has_more_records_ : server_has_more_records_;

        if (!effectively_has_more_on_server) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, server indicates no more records.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
            // 如果这是流的末尾，并且没有发生错误，确保 final_summary_typed_ 是最新的
            // （它可能已经是 run_summary_typed_ 或者上一次 PULL 的结果）
            // 如果之前没有 PULL/DISCARD，并且 RUN 表明没有更多记录，final_summary 应该等于 run_summary
            if (is_first_pull_attempt_) {
                // 确保 final_summary_typed_ 反映的是 run_summary_typed_ 的状态
                // 在 BoltResultStream 构造函数中，final_summary_typed_ 已经用 run_summary_params_raw 初始化
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        int64_t fetch_n = 1000;  // 默认的拉取大小
        if (owner_session_ && owner_session_->session_params_.default_fetch_size != 0) {
            fetch_n = (owner_session_->session_params_.default_fetch_size > 0 || owner_session_->session_params_.default_fetch_size == -1) ? owner_session_->session_params_.default_fetch_size : 1000;
        }

        if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, attempting to fetch {} records.", (void*)this, fetch_n);
        auto fetch_result = _fetch_more_records(fetch_n);  // 这个方法内部会更新 final_summary_typed_

        if (fetch_result.first != boltprotocol::BoltError::SUCCESS) {
            return fetch_result;  // _fetch_more_records 内部已设置失败状态
        }

        out_has_next = !raw_record_buffer_.empty();
        if (!out_has_next && !server_has_more_records_) {  // 拉取后，缓冲区仍为空，且服务器确认没有更多
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Fetched, buffer still empty, PULL confirms no more.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamITER {}] has_next: After fetch, out_has_next={}", (void*)this, out_has_next);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::next() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        bool has_more = false;
        auto has_next_res_pair = has_next(has_more);  // has_next_res_pair 是 std::pair

        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);  // 从 pair 中移动

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            return {err_code_has_next, std::move(err_msg_has_next), std::nullopt};
        }
        if (!has_more) {
            if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};
            if (logger) logger->trace("[ResultStreamITER {}] next: No more records.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, "No more records in stream.", std::nullopt};
        }

        if (raw_record_buffer_.empty() && !stream_failed_) {
            _set_failure_state(boltprotocol::BoltError::UNKNOWN_ERROR, "Internal error: has_next() was true but buffer is empty and not failed.");
            if (logger) logger->error("[ResultStreamITER {}] next: Internal error - has_next true but buffer empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }
        if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};

        boltprotocol::RecordMessageParams raw_record_params = std::move(raw_record_buffer_.front());
        raw_record_buffer_.pop_front();

        if (logger) logger->trace("[ResultStreamITER {}] next: Popped one record. Buffer size: {}", (void*)this, raw_record_buffer_.size());

        BoltRecord record(std::move(raw_record_params.fields), field_names_ptr_cache_);
        return {boltprotocol::BoltError::SUCCESS, "", std::make_optional<BoltRecord>(std::move(record))};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::single() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] single() called.", (void*)this);

        auto next_result_tuple = next();  // 调用 next()
        boltprotocol::BoltError err_code_next = std::get<0>(next_result_tuple);
        std::string err_msg_next = std::get<1>(std::move(next_result_tuple));
        std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_result_tuple));

        if (err_code_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error from first next(): {}.", (void*)this, err_msg_next);
            return {err_code_next, std::move(err_msg_next), std::nullopt};
        }
        if (!record_opt.has_value()) {
            if (stream_failed_) {  // 如果流因为 next() 内部的 has_next() -> _fetch_more_records() 失败
                if (logger) logger->trace("[ResultStreamITER {}] single(): No record, stream failed. Reason: {}.", (void*)this, failure_message_);
                return {failure_reason_, failure_message_, std::nullopt};
            }
            // 如果没有失败，但 next() 返回空，意味着流是空的
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but stream was empty.");
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, stream empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        // 成功获取一个记录，现在检查是否还有更多
        bool has_more_records = false;
        auto has_next_res_pair = has_next(has_more_records);
        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error checking for more records after finding one: {}.", (void*)this, err_msg_has_next);
            _set_failure_state(err_code_has_next, "Error checking for subsequent records in single(): " + err_msg_has_next);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (has_more_records) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, but more found. Discarding rest.", (void*)this);
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamITER {}] single(): Discarding extra records failed: {}", (void*)this, discard_res.second);
            }
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but found more.");
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (logger) logger->trace("[ResultStreamITER {}] single() successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", std::move(record_opt)};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> BoltResultStream::list_all() {
        std::vector<BoltRecord> all_records_converted;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] list_all: Starting.", (void*)this);

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] list_all: Stream already failed.", (void*)this);
            return {failure_reason_, failure_message_, std::move(all_records_converted)};
        }

        while (true) {
            auto next_res_tuple = next();
            boltprotocol::BoltError err_code = std::get<0>(next_res_tuple);
            std::string err_msg = std::get<1>(std::move(next_res_tuple));                   // 可以移动
            std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_res_tuple));  // 可以移动

            if (err_code != boltprotocol::BoltError::SUCCESS) {
                if (logger) logger->warn("[ResultStreamITER {}] list_all: Error from next(): {}.", (void*)this, err_msg);
                // 返回已收集的记录以及错误
                return {err_code, std::move(err_msg), std::move(all_records_converted)};
            }
            if (!record_opt.has_value()) {  // 流结束
                if (logger) logger->trace("[ResultStreamITER {}] list_all: End of stream reached by next().", (void*)this);
                break;
            }
            all_records_converted.push_back(std::move(*record_opt));  // 从 optional 中移动 BoltRecord
        }

        if (logger) logger->trace("[ResultStreamITER {}] list_all: Finished. Records: {}", (void*)this, all_records_converted.size());
        return {boltprotocol::BoltError::SUCCESS, "", std::move(all_records_converted)};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    BoltResultStream::BoltResultStream(SessionHandle* session,
                                       std::optional<int64_t> query_id_for_streaming,
                                       boltprotocol::SuccessMessageParams run_summary_params_raw,
                                       std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                                       std::vector<boltprotocol::RecordMessageParams> initial_records,
                                       bool server_might_have_more,
                                       const boltprotocol::versions::Version& bolt_version,
                                       bool utc_patch_active,
                                       const std::string& server_address_for_summary,
                                       const std::optional<std::string>& database_name_for_summary,
                                       boltprotocol::BoltError initial_error,
                                       const std::string& initial_error_message,
                                       const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details)
        : owner_session_(session),
          query_id_(query_id_for_streaming),
          field_names_ptr_cache_(std::move(field_names_ptr)),
          // Initialize run_summary_typed_ with a copy of raw params for now
          run_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          // final_summary_typed_ initialized similarly, will be updated by _update_final_summary
          final_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          initial_server_has_more_records_(server_might_have_more),
          server_has_more_records_(server_might_have_more),
          bolt_version_cache_(bolt_version),
          utc_patch_active_cache_(utc_patch_active),
          server_address_cache_(server_address_for_summary),
          database_name_cache_(database_name_for_summary) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        for (auto&& rec_param : initial_records) {
            raw_record_buffer_.push_back(std::move(rec_param));
        }

        if (initial_error != boltprotocol::BoltError::SUCCESS) {
            _set_failure_state(initial_error, initial_error_message, initial_failure_details);
        } else if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Session or connection invalid at ResultStream creation.");
        }

        // Ensure field_names_ptr_cache_ is populated from run_summary_typed_ if it was null
        if (!field_names_ptr_cache_ || field_names_ptr_cache_->empty()) {
            auto it_fields = run_summary_typed_.raw_params().metadata.find("fields");
            if (it_fields != run_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
                auto temp_field_names = std::make_shared<std::vector<std::string>>();
                const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
                if (list_ptr) {
                    temp_field_names->reserve(list_ptr->elements.size());
                    for (const auto& field_val : list_ptr->elements) {
                        if (std::holds_alternative<std::string>(field_val)) {
                            temp_field_names->push_back(std::get<std::string>(field_val));
                        }
                    }
                }
                field_names_ptr_cache_ = std::const_pointer_cast<const std::vector<std::string>>(temp_field_names);
            } else {
                field_names_ptr_cache_ = std::make_shared<const std::vector<std::string>>();  // Empty
            }
        }

        if (!stream_failed_) {
            // If no records were pipelined and server RUN summary says no more, then stream is done.
            if (raw_record_buffer_.empty() && !initial_server_has_more_records_) {
                stream_fully_consumed_or_discarded_ = true;
                // final_summary_typed_ is already a copy of run_summary_typed_ here
            }
        }

        // A PULL/DISCARD is needed if: buffer is empty AND server might have more records (initial_server_has_more_records_) AND not failed
        is_first_pull_attempt_ = raw_record_buffer_.empty() && initial_server_has_more_records_ && !stream_failed_;

        if (logger) {
            logger->debug("[ResultStreamLC {}] Created. QID: {}. InitRecs: {}. InitialSrvMore: {}. Failed: {}. FirstPullAttempt: {}", (void*)this, query_id_ ? std::to_string(*query_id_) : "N/A", raw_record_buffer_.size(), initial_server_has_more_records_, stream_failed_, is_first_pull_attempt_);
        }
    }

    BoltResultStream::~BoltResultStream() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->debug("[ResultStreamLC {}] Destructing. Consumed: {}, Failed: {}", (void*)this, stream_fully_consumed_or_discarded_, stream_failed_);
        }

        if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
            if (logger) logger->trace("[ResultStreamLC {}] Auto-discarding in dtor.", (void*)this);
            // This will update final_summary_typed_
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamLC {}] Auto-discard in dtor failed: {}", (void*)this, discard_res.second);
            }
        }
    }

    BoltResultStream::BoltResultStream(BoltResultStream&& other) noexcept
        : owner_session_(other.owner_session_),
          query_id_(other.query_id_),
          raw_record_buffer_(std::move(other.raw_record_buffer_)),
          field_names_ptr_cache_(std::move(other.field_names_ptr_cache_)),
          run_summary_typed_(std::move(other.run_summary_typed_)),
          final_summary_typed_(std::move(other.final_summary_typed_)),
          failure_details_raw_(std::move(other.failure_details_raw_)),
          server_has_more_records_(other.server_has_more_records_),
          initial_server_has_more_records_(other.initial_server_has_more_records_),
          stream_fully_consumed_or_discarded_(other.stream_fully_consumed_or_discarded_),
          stream_failed_(other.stream_failed_),
          failure_reason_(other.failure_reason_),
          failure_message_(std::move(other.failure_message_)),
          is_first_pull_attempt_(other.is_first_pull_attempt_),
          bolt_version_cache_(other.bolt_version_cache_),
          utc_patch_active_cache_(other.utc_patch_active_cache_),
          server_address_cache_(std::move(other.server_address_cache_)),
          database_name_cache_(std::move(other.database_name_cache_)) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamLC {}] Move constructed from ResultStream {}.", (void*)this, (void*)&other);

        other.owner_session_ = nullptr;  // Invalidate other
        other.stream_fully_consumed_or_discarded_ = true;
        other.stream_failed_ = true;  // Mark other as unusable
    }

    BoltResultStream& BoltResultStream::operator=(BoltResultStream&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
            if (logger) logger->trace("[ResultStreamLC {}] Move assigning from ResultStream {}.", (void*)this, (void*)&other);

            // Discard current stream's resources if it's still active
            if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
                _discard_all_remaining_records();
            }

            owner_session_ = other.owner_session_;
            query_id_ = other.query_id_;
            raw_record_buffer_ = std::move(other.raw_record_buffer_);
            field_names_ptr_cache_ = std::move(other.field_names_ptr_cache_);
            run_summary_typed_ = std::move(other.run_summary_typed_);
            final_summary_typed_ = std::move(other.final_summary_typed_);
            failure_details_raw_ = std::move(other.failure_details_raw_);
            server_has_more_records_ = other.server_has_more_records_;
            initial_server_has_more_records_ = other.initial_server_has_more_records_;
            stream_fully_consumed_or_discarded_ = other.stream_fully_consumed_or_discarded_;
            stream_failed_ = other.stream_failed_;
            failure_reason_ = other.failure_reason_;
            failure_message_ = std::move(other.failure_message_);
            is_first_pull_attempt_ = other.is_first_pull_attempt_;
            bolt_version_cache_ = other.bolt_version_cache_;
            utc_patch_active_cache_ = other.utc_patch_active_cache_;
            server_address_cache_ = std::move(other.server_address_cache_);
            database_name_cache_ = std::move(other.database_name_cache_);

            other.owner_session_ = nullptr;  // Invalidate other
            other.stream_fully_consumed_or_discarded_ = true;
            other.stream_failed_ = true;
        }
        return *this;
    }

    const std::vector<std::string>& BoltResultStream::field_names() const {
        static const std::vector<std::string> empty_names_singleton;
        return field_names_ptr_cache_ ? *field_names_ptr_cache_ : empty_names_singleton;
    }

    void BoltResultStream::_set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details) {
        if (stream_failed_ && failure_reason_ != boltprotocol::BoltError::SUCCESS) {
            // Already in a more specific failure state, don't override with a potentially less specific one unless reason is new.
            // However, allow updating message if new details are provided.
            if (!detailed_message.empty() && failure_message_.find(detailed_message) == std::string::npos) {
                failure_message_ += "; Additional detail: " + detailed_message;
            }
            if (details.has_value() && failure_details_raw_.metadata.empty()) {  // Only update raw details if not already set
                failure_details_raw_ = *details;
            }
            return;
        }
        stream_failed_ = true;
        failure_reason_ = reason;
        failure_message_ = std::move(detailed_message);

        if (details.has_value()) {
            failure_details_raw_ = *details;
        } else {
            failure_details_raw_.metadata.clear();  // Ensure it's clear
            if (!failure_message_.empty() && reason != boltprotocol::BoltError::SUCCESS) {
                // Create a minimal failure detail from the message
                failure_details_raw_.metadata["message"] = boltprotocol::Value(failure_message_);
            }
        }
        stream_fully_consumed_or_discarded_ = true;  // A failed stream is considered consumed

        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->warn("[ResultStreamLC {}] Failure state set. Reason: {} ({}), Msg: {}", (void*)this, static_cast<int>(reason), error::bolt_error_to_string(reason), failure_message_);
        }
    }

    // New private helper to update final_summary_typed_
    void BoltResultStream::_update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary) {
        final_summary_typed_ = ResultSummary(std::move(pull_or_discard_raw_summary), bolt_version_cache_, utc_patch_active_cache_, server_address_cache_, database_name_cache_);
    }

}  // namespace neo4j_bolt_transport// Source/result_stream_state.cpp
// This file is intentionally left empty or can be removed from the build
// if its only purpose was to define methods now inlined in result_stream.h
// (has_failed, get_failure_reason, get_failure_message, get_failure_details).

// #include "neo4j_bolt_transport/result_stream.h"
// namespace neo4j_bolt_transport {} // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/result_summary.h"

#include <iostream>  // For potential debug

namespace neo4j_bolt_transport {

    // Helper to safely get a string from a Bolt Value
    std::optional<std::string> get_string_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<std::string>(val)) {
            return std::get<std::string>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get an int64 from a Bolt Value
    std::optional<int64_t> get_int64_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<int64_t>(val)) {
            return std::get<int64_t>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get a bool from a Bolt Value
    std::optional<bool> get_bool_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<bool>(val)) {
            return std::get<bool>(val);
        }
        return std::nullopt;
    }

    ResultSummary::ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active, const std::string& srv_address, const std::optional<std::string>& db_name_from_session)
        : raw_params_(std::move(server_summary_params)), server_address_(srv_address) {
        // Determine effective database name
        auto db_it = raw_params_.metadata.find("db");
        if (db_it != raw_params_.metadata.end()) {
            if (auto db_str = get_string_val(db_it->second)) {
                database_name_ = *db_str;
            }
        }
        if (database_name_.empty() && db_name_from_session.has_value()) {
            database_name_ = *db_name_from_session;
        }
        if (database_name_.empty()) {
            // Fallback if not in summary and not in session (e.g. system db for older Neo4j)
            database_name_ = "system";  // Or "" if that's preferred for default
        }

        parse_metadata(bolt_version, utc_patch_active);
    }

    void ResultSummary::parse_query_type(const boltprotocol::Value& type_val_variant) {
        if (auto type_str_opt = get_string_val(type_val_variant)) {
            const std::string& type_str = *type_str_opt;
            if (type_str == "r")
                query_type_ = QueryType::READ_ONLY;
            else if (type_str == "rw")
                query_type_ = QueryType::READ_WRITE;
            else if (type_str == "w")
                query_type_ = QueryType::WRITE_ONLY;
            else if (type_str == "s")
                query_type_ = QueryType::SCHEMA_WRITE;
            else
                query_type_ = QueryType::UNKNOWN;
        }
    }

    void ResultSummary::parse_counters(const boltprotocol::Value& counters_val_variant) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant)) {
            const auto& counters_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant);
            if (counters_map_ptr) {
                const auto& m = counters_map_ptr->pairs;
                auto get_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_int64_val(it->second).value_or(0);
                    }
                    return int64_t{0};
                };
                auto get_bool_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_bool_val(it->second).value_or(false);
                    }
                    return false;
                };

                counters_.nodes_created = get_counter("nodes-created");
                counters_.nodes_deleted = get_counter("nodes-deleted");
                counters_.relationships_created = get_counter("relationships-created");
                counters_.relationships_deleted = get_counter("relationships-deleted");
                counters_.properties_set = get_counter("properties-set");
                counters_.labels_added = get_counter("labels-added");
                counters_.labels_removed = get_counter("labels-removed");
                counters_.indexes_added = get_counter("indexes-added");
                counters_.indexes_removed = get_counter("indexes-removed");
                counters_.constraints_added = get_counter("constraints-added");
                counters_.constraints_removed = get_counter("constraints-removed");
                counters_.system_updates = get_counter("system-updates");                         // Bolt 4.3+
                counters_.contains_system_updates = get_bool_counter("contains-system-updates");  // Bolt 5.0+

                // contains-updates logic:
                // True if any of the specific counters > 0 OR if "contains-updates" is explicitly true
                counters_.contains_updates = (counters_.nodes_created > 0 || counters_.nodes_deleted > 0 || counters_.relationships_created > 0 || counters_.relationships_deleted > 0 || counters_.properties_set > 0 || counters_.labels_added > 0 || counters_.labels_removed > 0 ||
                                              counters_.indexes_added > 0 || counters_.indexes_removed > 0 || counters_.constraints_added > 0 || counters_.constraints_removed > 0);
                // If server provides "contains-updates", respect it
                auto it_contains_updates = m.find("contains-updates");
                if (it_contains_updates != m.end()) {
                    if (auto b_val = get_bool_val(it_contains_updates->second)) {
                        counters_.contains_updates = *b_val;
                    }
                }

                if (counters_.system_updates > 0 && !counters_.contains_system_updates) {
                    // if system_updates > 0, contains_system_updates should be true.
                    // This might indicate an older server version or an inconsistency.
                    // For safety, set contains_system_updates if system_updates is positive.
                    counters_.contains_system_updates = true;
                }
            }
        }
    }

    void ResultSummary::parse_notifications(const boltprotocol::Value& notifications_val_variant, const boltprotocol::versions::Version& bolt_version) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant);
            if (list_ptr) {
                notifications_.reserve(list_ptr->elements.size());
                for (const auto& item_val : list_ptr->elements) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(item_val)) {
                        const auto& map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(item_val);
                        if (map_ptr) {
                            ServerNotification notif;
                            const auto& m = map_ptr->pairs;
                            auto find_str = [&](const std::string& key) -> std::optional<std::string> {
                                auto it = m.find(key);
                                if (it != m.end()) return get_string_val(it->second);
                                return std::nullopt;
                            };

                            notif.code = find_str("code").value_or("");
                            notif.title = find_str("title").value_or("");
                            notif.description = find_str("description").value_or("");
                            notif.severity = find_str("severity").value_or("");  // Bolt 4.1+
                            if (bolt_version.major > 5 || (bolt_version.major == 5 && bolt_version.minor >= 2)) {
                                notif.category = find_str("category").value_or("");
                            }

                            auto pos_it = m.find("position");
                            if (pos_it != m.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second)) {
                                const auto& pos_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second);
                                if (pos_map_ptr) notif.position = pos_map_ptr->pairs;
                            }
                            notifications_.push_back(std::move(notif));
                        }
                    }
                }
            }
        }
    }

    void ResultSummary::parse_metadata(const boltprotocol::versions::Version& bolt_version, bool /*utc_patch_active*/) {
        // Extract common fields
        auto t_start_it = raw_params_.metadata.find("t_first");  // Time to first record (RUN response) or available (PULL/DISCARD response)
        if (t_start_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_start_it->second)) {
                result_available_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto t_end_it = raw_params_.metadata.find("t_last");  // Time to last record (PULL/DISCARD response)
        if (t_end_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_end_it->second)) {
                result_consumed_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto type_it = raw_params_.metadata.find("type");
        if (type_it != raw_params_.metadata.end()) {
            parse_query_type(type_it->second);
        }

        auto counters_it = raw_params_.metadata.find("stats");
        if (counters_it != raw_params_.metadata.end()) {
            parse_counters(counters_it->second);
        }

        auto notifications_it = raw_params_.metadata.find("notifications");
        if (notifications_it != raw_params_.metadata.end()) {
            parse_notifications(notifications_it->second, bolt_version);
        }

        // Plan and Profile parsing would go here if implemented
        // auto plan_it = raw_params_.metadata.find("plan");
        // if (plan_it != raw_params_.metadata.end()) { ... parse plan ... }
        // auto profile_it = raw_params_.metadata.find("profile"); // or "profiled-plan"
        // if (profile_it != raw_params_.metadata.end()) { ... parse profile ... }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _get_server_address_for_session: 获取会话的服务器地址，可能会使用路由
    std::pair<boltprotocol::BoltError, routing::ServerAddress> Neo4jBoltTransport::_get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint) {
        if (config_.logger) {
            config_.logger->trace(
                "[AddrSelect] 获取服务器地址, 数据库: '{}', 角色提示: {}, 模拟用户: '{}'", params.database_name.value_or("<默认>"), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), params.impersonated_user.value_or("<无>"));
        }

        // 如果未启用客户端路由，或者使用的是直接的 bolt:// 方案
        if (!config_.client_side_routing_enabled || parsed_initial_uri_.scheme == "bolt" || parsed_initial_uri_.scheme == "bolt+s" || parsed_initial_uri_.scheme == "bolt+ssc") {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[AddrSelect] 无可用主机用于直接连接。");
                return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            }
            // 对于直接连接，使用URI中的第一个主机
            const auto& host_port = parsed_initial_uri_.hosts_with_ports.front();
            routing::ServerAddress resolved_address(host_port.first, host_port.second);

            // 应用自定义地址解析器（如果提供）
            if (config_.server_address_resolver) {
                routing::ServerAddress original_address = resolved_address;
                resolved_address = config_.server_address_resolver(original_address);
                if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                    config_.logger->debug("[AddrSelect] 直接连接地址已解析: {} -> {}", original_address.to_string(), resolved_address.to_string());
                }
            }
            if (config_.logger) config_.logger->debug("[AddrSelect] 直接连接，使用地址: {}", resolved_address.to_string());
            return {boltprotocol::BoltError::SUCCESS, resolved_address};
        }

        // --- 需要路由 ---
        // 确定用于路由的数据库名称。对于 neo4j:// 方案，空数据库名通常指默认集群/数据库，
        // 或者需要先连接到 system 数据库获取集群信息。
        // 驱动通常会为每个 (database_name, impersonated_user) 组合维护一个路由表。
        std::string db_name_for_routing_key = params.database_name.value_or("");

        // 尝试获取或刷新路由表
        std::shared_ptr<routing::RoutingTable> routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);

        if (!routing_table) {
            if (config_.logger) config_.logger->error("[AddrSelect] 无法获取或刷新数据库 '{}' 的路由表 (模拟用户: '{}')", db_name_for_routing_key, params.impersonated_user.value_or("<无>"));
            return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 或者更具体的路由错误
        }

        // 从路由表中选择一个服务器
        // 尝试多次，因为表可能在两次调用之间变得陈旧，或者选中的服务器刚好失效
        int attempts = 0;
        const int max_selection_attempts = config_.routing_max_retry_attempts > 0 ? config_.routing_max_retry_attempts : 3;  // 至少尝试1次

        while (attempts < max_selection_attempts) {
            attempts++;
            if (routing_table->is_stale() && attempts > 1) {  // 如果不是第一次尝试且表已过时
                if (config_.logger) config_.logger->info("[AddrSelect] 路由表 '{}' 在选择期间已过时，第 {} 次尝试刷新。", routing_table->get_database_context_key(), attempts);
                // 重新获取/刷新路由表
                routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);
                if (!routing_table) {
                    if (config_.logger) config_.logger->error("[AddrSelect] 路由表 '{}' 刷新失败。", db_name_for_routing_key);
                    return {boltprotocol::BoltError::NETWORK_ERROR, {}};
                }
            }

            std::optional<routing::ServerAddress> server_address_opt = routing_table->get_server(role_hint);

            if (server_address_opt) {
                routing::ServerAddress resolved_address = *server_address_opt;
                // 应用自定义地址解析器
                if (config_.server_address_resolver) {
                    routing::ServerAddress original_address = resolved_address;
                    resolved_address = config_.server_address_resolver(original_address);
                    if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                        config_.logger->debug("[AddrSelect] 路由选定地址已解析: {} -> {}", original_address.to_string(), resolved_address.to_string());
                    }
                }
                if (config_.logger) config_.logger->info("[AddrSelect] 选定服务器地址: {} (角色: {}), 尝试次数: {}", resolved_address.to_string(), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), attempts);
                return {boltprotocol::BoltError::SUCCESS, resolved_address};
            } else {
                if (config_.logger) config_.logger->warn("[AddrSelect] 第 {} 次尝试: 路由表 '{}' 中没有找到角色 {} 的可用服务器。", attempts, routing_table->get_database_context_key(), static_cast<int>(role_hint));
                if (attempts < max_selection_attempts) {
                    routing_table->mark_as_stale();  // 强制下次迭代时刷新
                                                     // 可以选择在这里短暂 sleep，或者让上层（如连接获取）处理重试
                }
            }
        }  // end while attempts

        if (config_.logger) config_.logger->error("[AddrSelect] 多次尝试后，路由表 '{}' 中仍无法为角色 {} 找到服务器。", routing_table->get_database_context_key(), static_cast<int>(role_hint));
        return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 或者 "No suitable server found"
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能用于日志
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 当连接到某个服务器失败时，或服务器返回特定的可路由错误时，调用此函数
    void Neo4jBoltTransport::_handle_routing_failure(const routing::ServerAddress& failed_address,
                                                     const std::string& database_context_key) {  // database_context_key 用于定位正确的路由表

        if (!config_.client_side_routing_enabled) {
            return;  // 如果路由未启用，则不执行任何操作
        }

        if (config_.logger) {
            config_.logger->info("[RoutingFail] 处理路由失败: 地址 {}, 上下文键 {}", failed_address.to_string(), database_context_key);
        }

        std::lock_guard<std::mutex> lock(routing_table_mutex_);
        auto it = routing_tables_.find(database_context_key);
        if (it != routing_tables_.end()) {
            std::shared_ptr<routing::RoutingTable> table = it->second;
            if (table) {
                table->forget_server(failed_address);  // 从路由表中移除失败的服务器
                // 忘记服务器后，路由表可能会变得不健康（例如，没有可用的writer了）
                // RoutingTable::forget_server 内部可能会调用 mark_as_stale()
                // 如果需要更主动的刷新，可以在这里调用 table->mark_as_stale();
                if (config_.logger) {
                    config_.logger->debug("[RoutingFail] 从路由表 '{}' 中移除了地址 {}。", database_context_key, failed_address.to_string());
                    if (table->is_stale()) {
                        config_.logger->info("[RoutingFail] 路由表 '{}' 在移除地址后被标记为过时。", database_context_key);
                    }
                }
            }
        } else {
            if (config_.logger) {
                config_.logger->warn("[RoutingFail] 未找到上下文键为 '{}' 的路由表来处理失败。", database_context_key);
            }
        }
    }

}  // namespace neo4j_bolt_transport#include <chrono>  // For std::chrono::seconds default TTL

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 可能需要用于日志
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 静态辅助函数，已在 pool_core.cpp 中定义，这里为保持独立性可重新声明或包含一个通用头文件
    // static std::string make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
    //     std::string db_part = database_name.empty() ? "system" : database_name;
    //     if (impersonated_user && !impersonated_user->empty()) {
    //         return db_part + "@" + *impersonated_user;
    //     }
    //     return db_part;
    // }
    // ^^^ 如果这个函数在多个 .cpp 文件中需要，最好放到一个共享的辅助头文件中，或者作为 Neo4jBoltTransport 的私有静态成员。
    // 为简单起见，暂时假设它在 neo4j_bolt_transport_pool_core.cpp 中定义的版本可以被链接器找到，
    // 或者直接在 Neo4jBoltTransport 类中定义它。
    // 这里我们直接在类作用域外（或在一个辅助命名空间）定义它，假设它是一个全局辅助函数。
    // (在实际项目中，会放到一个 util.h 或类似文件中)
    namespace detail {  // 使用一个内部命名空间避免冲突
        std::string make_routing_context_key_for_manager(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
            std::string db_part = database_name.empty() ? "system" : database_name;
            if (impersonated_user && !impersonated_user->empty()) {
                return db_part + "@" + *impersonated_user;
            }
            return db_part;
        }
    }  // namespace detail

    // 获取或创建（如果不存在）并可能刷新路由表
    std::shared_ptr<routing::RoutingTable> Neo4jBoltTransport::_get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string context_key = detail::make_routing_context_key_for_manager(database_name, impersonated_user);
        std::shared_ptr<routing::RoutingTable> table;
        std::vector<routing::ServerAddress> initial_routers_for_this_context;  // 用于刷新

        {  // 作用域锁保护 routing_tables_ 的访问
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            auto it = routing_tables_.find(context_key);
            if (it != routing_tables_.end()) {
                table = it->second;
            } else {
                // 从配置中获取此上下文的默认 TTL (例如，300秒)
                // 注意: config_.routing_table_default_ttl_seconds (如果添加了这个配置项)
                unsigned int default_ttl_seconds = 300;
                // if (config_.routing_table_default_ttl_seconds.has_value()) {
                //    default_ttl_seconds = *config_.routing_table_default_ttl_seconds;
                // }
                table = std::make_shared<routing::RoutingTable>(context_key, std::chrono::seconds(default_ttl_seconds));
                routing_tables_[context_key] = table;
                if (config_.logger) config_.logger->info("[RoutingMgr] 为上下文 '{}' 创建了新的路由表实例 (默认TTL: {}s)。", context_key, default_ttl_seconds);
            }
        }  // 解锁 routing_table_mutex_

        // 确定用于获取此上下文路由表的初始路由器
        // 优先级：1. 配置覆盖 specific_context_key 2. 配置覆盖 "default" 或 "" key 3. 从主URI解析
        bool initial_routers_found = false;
        if (config_.initial_router_addresses_override.count(context_key)) {
            initial_routers_for_this_context = config_.initial_router_addresses_override.at(context_key);
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了配置中覆盖的初始路由器。", context_key);
        }

        if (!initial_routers_found) {
            // 尝试通用的初始路由器配置 (例如，用户可能只配置了一组全局初始路由器)
            std::string generic_initial_router_key = "";  // 或者一个特殊的配置键
            if (config_.initial_router_addresses_override.count(generic_initial_router_key)) {
                initial_routers_for_this_context = config_.initial_router_addresses_override.at(generic_initial_router_key);
                if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
                if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了通用的初始路由器配置。", context_key);
            }
        }

        if (!initial_routers_found && !parsed_initial_uri_.hosts_with_ports.empty() && parsed_initial_uri_.is_routing_scheme) {
            for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                initial_routers_for_this_context.emplace_back(hp.first, hp.second);
            }
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr] 上下文 '{}' 使用了从主URI解析的初始路由器。", context_key);
        }

        if (!initial_routers_found) {
            if (config_.logger) config_.logger->error("[RoutingMgr] 无法确定用于刷新上下文 '{}' 的初始路由器。", context_key);
            // table->mark_as_stale(); // 确保它被标记为过时
            return nullptr;  // 无法刷新，返回空指针或当前的（可能是过时的）表
        }

        // 如果表已过期，则尝试刷新它
        // 使用一个更细粒度的锁或原子标志来避免在刷新时阻塞其他对此表的请求可能更好，但目前简化处理
        if (table->is_stale()) {
            if (config_.logger) config_.logger->info("[RoutingMgr] 路由表 '{}' 已过期或从未更新，尝试刷新。", context_key);

            // _fetch_and_update_routing_table 内部会连接到路由器并发送 ROUTE 消息
            boltprotocol::BoltError refresh_err = _fetch_and_update_routing_table(table, initial_routers_for_this_context, database_name, impersonated_user);

            if (refresh_err != boltprotocol::BoltError::SUCCESS) {
                if (config_.logger) config_.logger->error("[RoutingMgr] 刷新路由表 '{}' 失败，错误: {}", context_key, static_cast<int>(refresh_err));
                // 保留旧表（可能是空的或过期的），调用者需要处理
                // 或者，如果刷新失败意味着我们无法信任当前表，则返回nullptr
                return nullptr;  // 表示刷新失败
            }
            if (config_.logger) config_.logger->info("[RoutingMgr] 路由表 '{}' 刷新成功。", context_key);
        } else {
            if (config_.logger) config_.logger->trace("[RoutingMgr] 路由表 '{}' 仍然有效，无需刷新。", context_key);
        }
        return table;
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/routing/routing_table.h"

#include <algorithm>  // For std::remove

namespace neo4j_bolt_transport {
    namespace routing {

        RoutingTable::RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds)
            : database_context_key_(std::move(db_context_key)),
              last_updated_time_(std::chrono::steady_clock::time_point::min()),  // Stale by default
              ttl_(ttl_seconds) {
        }

        std::optional<ServerAddress> RoutingTable::get_server(ServerRole role) {
            std::lock_guard<std::mutex> lock(mutex_);
            if (is_stale()) {
                return std::nullopt;
            }

            std::vector<ServerAddress>* server_list = nullptr;
            std::atomic<std::size_t>* index_ptr = nullptr;

            switch (role) {
                case ServerRole::ROUTER:
                    server_list = &routers_;
                    index_ptr = &next_router_index_;
                    break;
                case ServerRole::READER:
                    server_list = &readers_;
                    index_ptr = &next_reader_index_;
                    break;
                case ServerRole::WRITER:
                    server_list = &writers_;
                    index_ptr = &next_writer_index_;
                    break;
            }

            if (!server_list || server_list->empty()) {
                return std::nullopt;
            }

            std::size_t current_index = index_ptr->fetch_add(1, std::memory_order_relaxed);
            return (*server_list)[current_index % server_list->size()];
        }

        boltprotocol::BoltError RoutingTable::update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds) {
            std::lock_guard<std::mutex> lock(mutex_);

            // It's crucial that ROUTE message provides absolute lists, not diffs.
            routers_ = new_routers;
            readers_ = new_readers;
            writers_ = new_writers;
            ttl_ = new_ttl_seconds;
            last_updated_time_ = std::chrono::steady_clock::now();

            next_reader_index_ = 0;
            next_writer_index_ = 0;
            next_router_index_ = 0;  // Reset router index as well

            if (routers_.empty() && (readers_.empty() || writers_.empty())) {
                // A routing table must have routers, or if it's a single-instance-like scenario
                // (no explicit routers), it must at least have readers and writers.
                // If all are empty after an update, it's problematic.
                mark_as_stale();                                         // Mark as stale to force re-fetch or error out
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;  // Or a more specific routing error
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        bool RoutingTable::is_stale() const {
            // No lock needed for reading const members or time_point if access is atomic enough,
            // but ttl_ could change. For safety, or if ttl_ wasn't const, use lock.
            // Here, last_updated_time_ is std::chrono, reads are usually atomic. ttl_ is const after construction until update.
            // For simplicity with mutex_:
            // std::lock_guard<std::mutex> lock(mutex_);
            if (last_updated_time_ == std::chrono::steady_clock::time_point::min()) return true;  // Never updated
            return std::chrono::steady_clock::now() > (last_updated_time_ + ttl_);
        }

        void RoutingTable::mark_as_stale() {
            std::lock_guard<std::mutex> lock(mutex_);
            last_updated_time_ = std::chrono::steady_clock::time_point::min();
        }

        const std::vector<ServerAddress>& RoutingTable::get_routers() const {
            std::lock_guard<std::mutex> lock(mutex_);
            return routers_;
        }

        void RoutingTable::forget_server(const ServerAddress& address) {
            std::lock_guard<std::mutex> lock(mutex_);
            auto remove_addr = [&](std::vector<ServerAddress>& vec) {
                vec.erase(std::remove(vec.begin(), vec.end(), address), vec.end());
            };
            remove_addr(routers_);
            remove_addr(readers_);
            remove_addr(writers_);

            // If forgetting a server makes a critical list empty, table might become stale faster
            if ((database_context_key_ != "system" && (readers_.empty() || writers_.empty())) || routers_.empty()) {
                // For simplicity, just mark stale. More complex logic could try other servers first.
                mark_as_stale();
            }
        }

    }  // namespace routing
}  // namespace neo4j_bolt_transport#include "boltprotocol/message_serialization.h"  // For ROUTE message
#include "boltprotocol/packstream_reader.h"      // For parsing ROUTE response
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 核心的路由表获取和更新逻辑
    boltprotocol::BoltError Neo4jBoltTransport::_fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update,
                                                                                const std::vector<routing::ServerAddress>& routers_to_try,
                                                                                const std::string& database_name_hint,                       // 数据库名称，用于ROUTE消息的参数
                                                                                const std::optional<std::string>& impersonated_user_hint) {  // 模拟用户，用于ROUTE消息

        if (routers_to_try.empty()) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: 没有提供路由器地址。");
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }
        if (!table_to_update) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: table_to_update 为空。");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        boltprotocol::RouteMessageParams route_params;
        // Bolt 4.3-4.4: route_params.routing_table_context (通常为空map)
        // Bolt 5.0+:  route_params.routing_table_context (可包含db, imp_user等)
        // 这里的 routing_table_context 是发送给服务器的，服务器用它来帮助确定它应该返回哪些地址（例如，在NAT后面）
        // 它通常是空的，或者包含客户端连接到此路由器的信息。
        // Neo4j Java驱动通常发送空map作为ROUTE请求的第一个参数（routing_context）。
        route_params.routing_table_context = {};  // 通常为空
        route_params.bookmarks = {};              // 通常在获取路由表时不传递书签

        // 确定ROUTE消息的格式版本
        boltprotocol::versions::Version version_for_route_message = boltprotocol::versions::V5_0;  // 默认使用较新版本
        if (!config_.preferred_bolt_versions.empty()) {
            // 使用驱动配置的最高优先级的 Bolt 版本来序列化 ROUTE 消息
            // 假设连接到的路由器能够理解这个版本
            version_for_route_message = config_.preferred_bolt_versions.front();
        }

        if (version_for_route_message >= boltprotocol::versions::Version(4, 4)) {  // Bolt 4.4+
            route_params.extra_for_v44_plus = std::map<std::string, boltprotocol::Value>();
            if (!database_name_hint.empty()) {
                (*route_params.extra_for_v44_plus)["db"] = database_name_hint;
            }
            // impersonated_user_hint 仅在 Bolt 5.1+ 的 ROUTE 消息中被正式支持于 extra map
            if (impersonated_user_hint.has_value() && !impersonated_user_hint->empty() && version_for_route_message >= boltprotocol::versions::Version(5, 1)) {
                (*route_params.extra_for_v44_plus)["imp_user"] = *impersonated_user_hint;
            }
        } else if (version_for_route_message == boltprotocol::versions::Version(4, 3)) {  // Bolt 4.3
            if (!database_name_hint.empty()) {
                route_params.db_name_for_v43 = database_name_hint;
            }
        } else {
            if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 消息格式不支持 Bolt 版本 {}.{}。", (int)version_for_route_message.major, (int)version_for_route_message.minor);
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
        }

        std::vector<uint8_t> route_payload;
        boltprotocol::PackStreamWriter writer(route_payload);
        boltprotocol::BoltError err = boltprotocol::serialize_route_message(route_params, writer, version_for_route_message);
        if (err != boltprotocol::BoltError::SUCCESS) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] 序列化 ROUTE 消息失败: {}", static_cast<int>(err));
            table_to_update->mark_as_stale();
            return err;
        }

        boltprotocol::SuccessMessageParams success_meta;
        boltprotocol::FailureMessageParams failure_meta;

        for (const auto& router_address_orig : routers_to_try) {
            if (closing_.load(std::memory_order_acquire)) return boltprotocol::BoltError::UNKNOWN_ERROR;  // 驱动正在关闭

            routing::ServerAddress router_address = router_address_orig;
            if (config_.server_address_resolver) {  // 应用地址解析器
                router_address = config_.server_address_resolver(router_address_orig);
            }

            if (config_.logger) config_.logger->debug("[RoutingFetcher] 尝试从路由器 {} (原始: {}) 获取路由表, 目标数据库: '{}'", router_address.to_string(), router_address_orig.to_string(), database_name_hint);

            // 为 HELLO 消息准备路由上下文，这应该是客户端连接到此特定路由器时所使用的地址。
            std::map<std::string, boltprotocol::Value> hello_routing_ctx;
            hello_routing_ctx["address"] = router_address.to_string();  // 发送解析后的地址

            internal::BoltConnectionConfig conn_conf = _create_physical_connection_config(router_address, hello_routing_ctx);
            auto temp_conn_logger = config_.get_or_create_logger("RouteConn");  // 单独的logger实例
            auto temp_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(conn_conf), io_context_, temp_conn_logger);

            if (temp_conn->establish() == boltprotocol::BoltError::SUCCESS) {
                // 检查协商的 Bolt 版本是否与序列化 ROUTE 消息时使用的版本兼容
                if (temp_conn->get_bolt_version() < boltprotocol::versions::Version(4, 3)) {
                    if (config_.logger) config_.logger->warn("[RoutingFetcher] 路由器 {} 使用的 Bolt 版本过低 ({}.{})，不支持现代 ROUTE 消息。", router_address.to_string(), (int)temp_conn->get_bolt_version().major, (int)temp_conn->get_bolt_version().minor);
                    temp_conn->terminate(true);
                    continue;  // 尝试下一个路由器
                }
                // 如果版本不匹配到需要重新序列化的程度，这里会更复杂。
                // 简单假设：如果连接成功，则尝试发送已序列化的ROUTE消息。

                boltprotocol::BoltError route_send_err = temp_conn->send_request_receive_summary(route_payload, success_meta, failure_meta);
                temp_conn->terminate(true);  // 关闭临时连接

                if (route_send_err == boltprotocol::BoltError::SUCCESS && temp_conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                    auto rt_it = success_meta.metadata.find("rt");
                    if (rt_it != success_meta.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second)) {
                        const auto& rt_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second);
                        if (rt_map_ptr) {
                            const auto& rt_data = rt_map_ptr->pairs;
                            long long ttl_val_ll = 0;
                            std::vector<routing::ServerAddress> new_routers, new_readers, new_writers;

                            auto ttl_data_it = rt_data.find("ttl");
                            if (ttl_data_it != rt_data.end() && std::holds_alternative<int64_t>(ttl_data_it->second)) {
                                ttl_val_ll = std::get<int64_t>(ttl_data_it->second);
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中缺少 'ttl' 字段或类型不正确。");
                                // 可以设置一个默认值或标记错误
                            }
                            std::chrono::seconds ttl_val = std::chrono::seconds(ttl_val_ll > 0 ? ttl_val_ll : 300);  // 默认300s

                            auto servers_data_it = rt_data.find("servers");
                            if (servers_data_it != rt_data.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second)) {
                                const auto& servers_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second);
                                if (servers_list_ptr) {
                                    for (const auto& server_item_val : servers_list_ptr->elements) {
                                        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val)) {
                                            const auto& server_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val);
                                            if (server_map_ptr) {
                                                std::string role_str;
                                                std::vector<std::string> addresses_str_list;

                                                auto role_it = server_map_ptr->pairs.find("role");
                                                if (role_it != server_map_ptr->pairs.end() && std::holds_alternative<std::string>(role_it->second)) {
                                                    role_str = std::get<std::string>(role_it->second);
                                                }

                                                auto addrs_it = server_map_ptr->pairs.find("addresses");
                                                if (addrs_it != server_map_ptr->pairs.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second)) {
                                                    const auto& addrs_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second);
                                                    if (addrs_list_ptr) {
                                                        for (const auto& addr_val : addrs_list_ptr->elements) {
                                                            if (std::holds_alternative<std::string>(addr_val)) {
                                                                addresses_str_list.push_back(std::get<std::string>(addr_val));
                                                            }
                                                        }
                                                    }
                                                }

                                                auto parse_host_port = [&](const std::string& addr_str) -> std::optional<routing::ServerAddress> {
                                                    // 移除可能的方案前缀 (bolt://, neo4j:// etc.)
                                                    std::string clean_addr_str = addr_str;
                                                    size_t scheme_end = clean_addr_str.find("://");
                                                    if (scheme_end != std::string::npos) {
                                                        clean_addr_str = clean_addr_str.substr(scheme_end + 3);
                                                    }

                                                    size_t colon_pos = clean_addr_str.rfind(':');
                                                    if (colon_pos == std::string::npos || colon_pos == 0 || colon_pos == clean_addr_str.length() - 1) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher] 地址 '{}' 格式无效 (缺少端口或格式错误)", addr_str);
                                                        return std::nullopt;
                                                    }
                                                    try {
                                                        std::string host_part = clean_addr_str.substr(0, colon_pos);
                                                        // 移除 IPv6 地址的方括号
                                                        if (host_part.length() > 2 && host_part.front() == '[' && host_part.back() == ']') {
                                                            host_part = host_part.substr(1, host_part.length() - 2);
                                                        }
                                                        if (host_part.empty()) {
                                                            if (config_.logger) config_.logger->warn("[RoutingFetcher] 地址 '{}' 解析后主机部分为空", addr_str);
                                                            return std::nullopt;
                                                        }

                                                        uint16_t port = static_cast<uint16_t>(std::stoul(clean_addr_str.substr(colon_pos + 1)));
                                                        return routing::ServerAddress{host_part, port};
                                                    } catch (const std::exception& e) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher] 解析地址 '{}' 端口失败: {}", addr_str, e.what());
                                                        return std::nullopt;
                                                    }
                                                };

                                                std::vector<routing::ServerAddress>* target_list_ptr = nullptr;
                                                if (role_str == "ROUTE")
                                                    target_list_ptr = &new_routers;
                                                else if (role_str == "READ")
                                                    target_list_ptr = &new_readers;
                                                else if (role_str == "WRITE")
                                                    target_list_ptr = &new_writers;

                                                if (target_list_ptr) {
                                                    for (const auto& addr_str : addresses_str_list) {
                                                        if (auto sa_opt = parse_host_port(addr_str)) {
                                                            target_list_ptr->push_back(*sa_opt);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中 'servers' 字段丢失或类型不正确。");
                                }
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 响应中缺少 'rt' 字段或类型不正确。");
                                // 服务器可能返回了错误，但 send_request_receive_summary 认为协议级别是成功的
                                // 这种情况下，temp_conn->get_last_error_code() 可能不是 SUCCESS
                                if (temp_conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE 消息的服务器响应指示错误: {}", temp_conn->get_last_error_message());
                                    // 标记为失败并尝试下一个路由器
                                } else {
                                    // 这是一个真正的协议格式问题
                                    table_to_update->mark_as_stale();
                                    return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
                                }
                            }
                            // 成功解析并获得了新的服务器列表
                            boltprotocol::BoltError update_err = table_to_update->update(new_routers, new_readers, new_writers, ttl_val);
                            if (update_err == boltprotocol::BoltError::SUCCESS) {
                                if (config_.logger) {
                                    config_.logger->info(
                                        "[RoutingFetcher] 路由表 '{}' 已成功从 {} 更新。Routers: {}, Readers: {}, Writers: {}, TTL: {}s", table_to_update->get_database_context_key(), router_address.to_string(), new_routers.size(), new_readers.size(), new_writers.size(), ttl_val.count());
                                }
                            } else {
                                if (config_.logger) config_.logger->error("[RoutingFetcher] 更新路由表对象失败，尽管从服务器获取了数据。");
                            }
                            return update_err;  // 返回更新结果
                        }  // success_meta.metadata.find("rt")
                    }  // temp_conn->get_last_error_code() == SUCCESS
                }  // route_send_err == SUCCESS

                // 如果 route_send_err != SUCCESS 或 temp_conn->get_last_error_code() != SUCCESS
                if (config_.logger) {
                    config_.logger->warn(
                        "[RoutingFetcher] 向路由器 {} 发送 ROUTE 消息失败。内部错误: {}, 服务器错误: {} (消息: {})", router_address.to_string(), error::bolt_error_to_string(route_send_err), error::bolt_error_to_string(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
                }
                // 不需要特别处理，循环会尝试下一个路由器

            } else {  // temp_conn->establish() failed
                if (config_.logger) config_.logger->warn("[RoutingFetcher] 无法建立到路由器 {} (原始: {}) 的临时连接。错误: {}, 消息: {}", router_address.to_string(), router_address_orig.to_string(), static_cast<int>(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
            }
            // 如果到此路由器失败，则尝试下一个
        }

        if (config_.logger) config_.logger->error("[RoutingFetcher] 尝试了所有 {} 个路由器，但无法获取路由表 '{}'。", routers_to_try.size(), table_to_update->get_database_context_key());
        table_to_update->mark_as_stale();               // 标记为过时，因为刷新失败
        return boltprotocol::BoltError::NETWORK_ERROR;  // 或者更具体的 "Routing information unavailable"
    }

}  // namespace neo4j_bolt_transport#include <chrono>    // For std::chrono::milliseconds
#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "boltprotocol/message_serialization.h"  // For serialize_..._message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // <--- 添加这一行
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // --- Explicit Transaction Methods ---
    std::pair<boltprotocol::BoltError, std::string> SessionHandle::begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "begin_transaction");
        if (!conn) {
            return conn_check_result;
        }
        auto logger = conn->get_logger();  // conn is valid here

        if (in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to begin transaction while already in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot begin transaction; already in an explicit transaction."};
        }

        boltprotocol::BeginMessageParams params;
        params.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) {
            params.db = session_params_.database_name;
        }
        if (session_params_.impersonated_user.has_value()) {
            params.imp_user = session_params_.impersonated_user;
        }

        // Access mode (Bolt 5.0+)
        if (!(conn->get_bolt_version() < boltprotocol::versions::V5_0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                params.other_extra_fields["mode"] = std::string("r");
            }
        }

        if (tx_metadata.has_value()) {
            params.tx_metadata = *tx_metadata;
        }
        if (tx_timeout_opt.has_value()) {
            params.tx_timeout = static_cast<int64_t>(tx_timeout_opt.value().count());
        }

        std::vector<uint8_t> begin_payload_bytes;
        boltprotocol::PackStreamWriter writer(begin_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_begin_message(params, writer, conn->get_bolt_version());
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("BEGIN serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(begin_payload_bytes, success_meta_raw, failure_meta_raw);

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                in_explicit_transaction_ = true;
                current_transaction_query_id_.reset();
                if (logger) {
                    logger->info("[SessionTX {}] Transaction started. DB: '{}', Mode: '{}', Timeout: {}ms, Meta: {}",
                                 conn->get_id(),
                                 params.db.value_or("<default>"),
                                 (session_params_.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"),
                                 params.tx_timeout.has_value() ? std::to_string(params.tx_timeout.value()) : "N/A",
                                 params.tx_metadata.has_value() && !params.tx_metadata.value().empty() ? "Yes" : "No");
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string server_fail_msg = error::format_server_failure(failure_meta_raw);
                std::string msg = error::format_error_message("BEGIN failed on server", conn->get_last_error_code(), server_fail_msg);
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("BEGIN send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::commit_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "commit_transaction");
        if (!conn) return conn_check_result;
        auto logger = conn->get_logger();  // conn is valid here

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to commit transaction while not in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot commit: not in an explicit transaction."};
        }

        std::vector<uint8_t> commit_payload_bytes;
        boltprotocol::PackStreamWriter writer(commit_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_commit_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("COMMIT serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(commit_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                auto it_bookmark = success_meta_raw.metadata.find("bookmark");
                if (it_bookmark != success_meta_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                } else {
                    if (logger) logger->trace("[SessionTX {}] COMMIT successful but no bookmark returned (Bolt version: {}.{}).", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                    update_bookmarks({});
                }
                if (logger) {
                    logger->info("[SessionTX {}] Transaction committed. New bookmark: {}", conn->get_id(), current_bookmarks_.empty() ? "<none>" : current_bookmarks_[0]);
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("COMMIT failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("COMMIT send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::rollback_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "rollback_transaction (pre-check)");

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (conn)
            logger = conn->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)  // transport_manager_ is checked
            logger = transport_manager_->get_config().logger;

        if (!in_explicit_transaction_) {
            if (logger) logger->trace("[SessionTX {}] Rollback called when not in an explicit transaction. No-op.", (conn ? conn->get_id() : 0));
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        if (!conn) {
            std::string msg = "Rollback attempt with no valid connection while in TX: " + conn_check_result.second;
            if (logger) logger->warn("[SessionTX Rollback] {}", msg);
            _invalidate_session_due_to_connection_error(conn_check_result.first, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {conn_check_result.first, msg};
        }

        std::vector<uint8_t> rollback_payload_bytes;
        boltprotocol::PackStreamWriter writer(rollback_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_rollback_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("ROLLBACK serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(rollback_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                if (logger) {
                    logger->info("[SessionTX {}] Transaction rolled back.", conn->get_id());
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("ROLLBACK failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("ROLLBACK send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 调试用
#include <utility>   // For std::move

#include "neo4j_bolt_transport/config/session_parameters.h"          // For config::SessionParameters
#include "neo4j_bolt_transport/error/neo4j_error_util.h"             // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // For internal::BoltPhysicalConnection
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"               // For Neo4jBoltTransport access
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    SessionHandle::SessionHandle(Neo4jBoltTransport* transport_mgr, internal::BoltPhysicalConnection::PooledConnection conn_ptr, config::SessionParameters params_val)
        : transport_manager_(transport_mgr), connection_(std::move(conn_ptr)), session_params_(std::move(params_val)), current_bookmarks_(session_params_.initial_bookmarks) {  // 从会话参数初始化书签

        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // 安全访问 logger
            drv_logger = transport_manager_->get_config().logger;
        }

        if (!transport_manager_) {
            connection_is_valid_ = false;
            is_closed_ = true;
            if (drv_logger) drv_logger->error("[SessionLC] SessionHandle created without a valid transport manager.");
            // connection_ 此时为 nullptr，_release_connection_to_pool 不会做任何事
            return;
        }

        std::shared_ptr<spdlog::logger> conn_logger = nullptr;
        if (connection_ && connection_->get_logger()) {
            conn_logger = connection_->get_logger();
        } else if (drv_logger) {
            conn_logger = drv_logger;  // 后备
        }

        if (!connection_ || !connection_->is_ready_for_queries()) {
            boltprotocol::BoltError last_err = connection_ ? connection_->get_last_error_code() : boltprotocol::BoltError::NETWORK_ERROR;
            std::string last_err_msg = connection_ ? connection_->get_last_error_message() : "Connection pointer null or not ready at SessionHandle construction.";

            if (conn_logger) conn_logger->warn("[SessionLC {}] Connection not ready at SessionHandle construction. Error: {}, Msg: {}", connection_ ? connection_->get_id() : 0, static_cast<int>(last_err), last_err_msg);
            _invalidate_session_due_to_connection_error(last_err, "SessionHandle construction: " + last_err_msg);
            _release_connection_to_pool(false);  // 释放可能坏掉的连接
        } else {
            connection_->mark_as_used();
            if (conn_logger) conn_logger->debug("[SessionLC {}] SessionHandle constructed with ready connection.", connection_->get_id());
        }
    }

    SessionHandle::~SessionHandle() {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] SessionHandle destructing. Closed: {}, InTx: {}", (connection_ ? connection_->get_id() : 0), is_closed_, in_explicit_transaction_);
        close();  // 确保所有资源都被正确关闭和释放
    }

    SessionHandle::SessionHandle(SessionHandle&& other) noexcept
        : transport_manager_(other.transport_manager_),
          connection_(std::move(other.connection_)),
          session_params_(std::move(other.session_params_)),
          in_explicit_transaction_(other.in_explicit_transaction_),
          current_transaction_query_id_(other.current_transaction_query_id_),
          current_bookmarks_(std::move(other.current_bookmarks_)),
          is_closed_(other.is_closed_),
          connection_is_valid_(other.connection_is_valid_) {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->trace("[SessionLC {}] SessionHandle move constructed from old SessionHandle.", (connection_ ? connection_->get_id() : 0));

        other.transport_manager_ = nullptr;  // other 现在无效
        other.is_closed_ = true;
        other.connection_is_valid_ = false;
    }

    SessionHandle& SessionHandle::operator=(SessionHandle&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = nullptr;
            if (connection_ && connection_->get_logger())
                logger = connection_->get_logger();
            else if (transport_manager_ && transport_manager_->get_config().logger)
                logger = transport_manager_->get_config().logger;
            if (logger) logger->trace("[SessionLC {}] SessionHandle move assigning from other SessionHandle.", (connection_ ? connection_->get_id() : 0));

            close();  // 首先关闭当前会话

            transport_manager_ = other.transport_manager_;
            connection_ = std::move(other.connection_);
            session_params_ = std::move(other.session_params_);
            in_explicit_transaction_ = other.in_explicit_transaction_;
            current_transaction_query_id_ = other.current_transaction_query_id_;
            current_bookmarks_ = std::move(other.current_bookmarks_);
            is_closed_ = other.is_closed_;
            connection_is_valid_ = other.connection_is_valid_;

            other.transport_manager_ = nullptr;  // other 现在无效
            other.is_closed_ = true;
            other.connection_is_valid_ = false;
        }
        return *this;
    }

    void SessionHandle::_release_connection_to_pool(bool mark_healthy) {
        if (connection_ && transport_manager_) {
            std::shared_ptr<spdlog::logger> logger = connection_->get_logger();  // 优先使用连接的logger
            uint64_t conn_id = connection_->get_id();
            if (logger) logger->trace("[SessionLC conn_id={}] Releasing connection to pool. Healthy: {}", conn_id, mark_healthy && connection_is_valid_);
            transport_manager_->release_connection(std::move(connection_), mark_healthy && connection_is_valid_);
            // connection_ 现在为 nullptr
        }
        connection_is_valid_ = false;  // 释放后，会话不再拥有有效连接
    }

    void SessionHandle::close() {
        if (is_closed_) {
            return;
        }

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] Closing SessionHandle. InTx: {}", (connection_ ? connection_->get_id() : 0), in_explicit_transaction_);

        if (in_explicit_transaction_ && connection_is_valid_ && connection_ && connection_->is_ready_for_queries()) {
            if (logger) logger->info("[SessionLC {}] Rolling back active transaction during close.", connection_->get_id());
            rollback_transaction();  // 这会将 in_explicit_transaction_ 设为 false
        }
        _release_connection_to_pool(connection_is_valid_);  // 根据当前连接的有效性状态释放
        is_closed_ = true;
    }

    void SessionHandle::_invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message) {
        connection_is_valid_ = false;
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            logger->warn("[SessionLC {}] Session invalidated due to connection error. Code: {} ({}), Context: {}",
                         (connection_ ? connection_->get_id() : 0),
                         static_cast<int>(error),
                         error::bolt_error_to_string(error),  // 添加错误码的字符串表示
                         context_message);
        }
    }

    internal::BoltPhysicalConnection* SessionHandle::_get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed_) {
            out_err_pair = {boltprotocol::BoltError::INVALID_ARGUMENT, "Operation on closed session: " + operation_context};
            if (drv_logger) drv_logger->warn("[SessionOp] {}", out_err_pair.second);
            return nullptr;
        }
        if (!connection_is_valid_ || !connection_) {
            out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "No valid connection for operation: " + operation_context};
            std::shared_ptr<spdlog::logger> log_to_use = (connection_ && connection_->get_logger()) ? connection_->get_logger() : drv_logger;
            if (log_to_use) log_to_use->warn("[SessionOp conn_id={}] {}", (connection_ ? connection_->get_id() : 0), out_err_pair.second);
            return nullptr;
        }

        if (!connection_->is_ready_for_queries()) {
            out_err_pair = {connection_->get_last_error_code(), connection_->get_last_error_message()};
            if (out_err_pair.first == boltprotocol::BoltError::SUCCESS) {  // 如果 is_ready 为 false 但上次错误是 SUCCESS，则有问题
                out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "Connection reported not ready for queries despite no specific error."};
            }
            std::string context_msg_full = operation_context + " (connection not ready: " + out_err_pair.second + ")";
            _invalidate_session_due_to_connection_error(out_err_pair.first, context_msg_full);  // 传递更详细的上下文
            if (connection_->get_logger()) connection_->get_logger()->warn("[SessionOp conn_id={}] {}", connection_->get_id(), context_msg_full);
            return nullptr;
        }

        connection_->mark_as_used();
        out_err_pair = {boltprotocol::BoltError::SUCCESS, ""};
        return connection_.get();
    }

    const std::vector<std::string>& SessionHandle::get_last_bookmarks() const {
        return current_bookmarks_;
    }

    void SessionHandle::update_bookmarks(const std::vector<std::string>& new_bookmarks) {
        if (is_closed_) return;
        current_bookmarks_ = new_bookmarks;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            std::string bookmarks_str;
            if (new_bookmarks.empty()) {
                bookmarks_str = "<empty>";
            } else {
                for (size_t i = 0; i < new_bookmarks.size(); ++i) {
                    bookmarks_str += new_bookmarks[i] + (i == new_bookmarks.size() - 1 ? "" : ", ");
                }
            }
            logger->trace("[SessionLC {}] Bookmarks updated to: [{}]", (connection_ ? connection_->get_id() : 0), bookmarks_str);
        }
    }

}  // namespace neo4j_bolt_transport#include <utility>  // For std::move

#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionWork typedef
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        // Note: The mode_hint (AccessMode::READ) is passed to _execute_transaction_work_internal.
        // That internal function will temporarily set session_params_.default_access_mode
        // for the duration of the managed transaction.
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::READ, tx_metadata, tx_timeout);
    }

    TransactionWorkResult SessionHandle::execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::WRITE, tx_metadata, tx_timeout);
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <chrono>     // For std::chrono::milliseconds
#include <iostream>   // 调试用
#include <thread>     // For std::this_thread::sleep_for
#include <utility>    // For std::move

#include "neo4j_bolt_transport/config/transport_config.h"  // For retry config access
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"       // For transport_manager_ to get config
#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionContext definition
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::_execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // Check transport_manager_
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed()) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Session is closed, cannot execute transaction work.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Session is closed, cannot execute transaction work."};
        }
        if (in_explicit_transaction_) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Cannot start managed transaction; an explicit transaction is already active.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot start managed transaction; an explicit transaction is already active."};
        }

        uint32_t max_retry_time_ms = 30000;
        uint32_t current_delay_ms = 1000;
        uint32_t max_delay_ms = 60000;
        double multiplier = 2.0;

        if (transport_manager_) {
            const auto& driver_conf = transport_manager_->get_config();
            max_retry_time_ms = driver_conf.max_transaction_retry_time_ms;
            current_delay_ms = driver_conf.transaction_retry_delay_initial_ms > 0 ? driver_conf.transaction_retry_delay_initial_ms : 1000;
            max_delay_ms = driver_conf.transaction_retry_delay_max_ms > 0 ? driver_conf.transaction_retry_delay_max_ms : 60000;
            multiplier = driver_conf.transaction_retry_delay_multiplier > 1 ? static_cast<double>(driver_conf.transaction_retry_delay_multiplier) : 2.0;
        }

        auto overall_deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(max_retry_time_ms);
        TransactionWorkResult last_attempt_result = {boltprotocol::BoltError::UNKNOWN_ERROR, "Transaction work did not complete successfully within retry budget."};
        int attempt_count = 0;

        config::AccessMode original_session_access_mode = session_params_.default_access_mode;
        session_params_.default_access_mode = mode_hint;

        while (std::chrono::steady_clock::now() < overall_deadline) {
            attempt_count++;
            std::shared_ptr<spdlog::logger> current_op_logger = drv_logger;

            std::pair<boltprotocol::BoltError, std::string> conn_check_for_log;
            internal::BoltPhysicalConnection* temp_conn_for_log_check = _get_valid_connection_for_operation(conn_check_for_log, "managed_tx_log_setup");
            if (temp_conn_for_log_check && temp_conn_for_log_check->get_logger()) {
                current_op_logger = temp_conn_for_log_check->get_logger();
            }

            if (current_op_logger) {
                current_op_logger->debug("[SessionTX Managed][Attempt {}] Starting transaction work (Mode: {}).", attempt_count, (mode_hint == config::AccessMode::READ ? "READ" : "WRITE"));
            }

            std::pair<boltprotocol::BoltError, std::string> pre_begin_conn_check;
            if (!_get_valid_connection_for_operation(pre_begin_conn_check, "managed_tx_pre_begin")) {
                last_attempt_result = {pre_begin_conn_check.first, "Managed TX: Connection unavailable before BEGIN (Attempt " + std::to_string(attempt_count) + "): " + pre_begin_conn_check.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                bool is_retryable_failure = (pre_begin_conn_check.first == boltprotocol::BoltError::NETWORK_ERROR || pre_begin_conn_check.first == boltprotocol::BoltError::HANDSHAKE_FAILED);  // More specific retry conditions
                if (is_retryable_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection unavailability before BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    // If connection was invalidated, _release_connection_to_pool would have been called.
                    // Next iteration _get_valid_connection_for_operation will try to get a new one if pool manager is used.
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            auto begin_res = begin_transaction(tx_metadata, tx_timeout_opt);
            if (begin_res.first != boltprotocol::BoltError::SUCCESS) {
                bool is_retryable_begin_failure = (begin_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                last_attempt_result = {begin_res.first, "Managed TX: Failed to begin (Attempt " + std::to_string(attempt_count) + "): " + begin_res.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                if (is_retryable_begin_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            if (connection_ && connection_->get_logger()) current_op_logger = connection_->get_logger();

            TransactionContext tx_context(*this);
            TransactionWorkResult work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "User work lambda not called."};

            try {
                work_res = work(tx_context);
            } catch (const std::exception& e) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Exception from user transaction work: " + std::string(e.what())};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Exception in user work: {}", e.what());
            } catch (...) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Unknown exception from user transaction work."};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Unknown exception in user work.");
            }

            if (!connection_is_valid_) {
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Connection became invalid during user work. Last conn error code: {}", connection_ ? static_cast<int>(connection_->get_last_error_code()) : -1);
                work_res = {boltprotocol::BoltError::NETWORK_ERROR, "Connection lost during transaction work execution."};
                rollback_transaction();
                last_attempt_result = work_res;
                if (std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection loss in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                } else {
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            }

            if (work_res.first == boltprotocol::BoltError::SUCCESS) {
                auto commit_res = commit_transaction();
                if (commit_res.first == boltprotocol::BoltError::SUCCESS) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Transaction work committed successfully.");
                    session_params_.default_access_mode = original_session_access_mode;
                    return {boltprotocol::BoltError::SUCCESS, ""};
                } else {
                    last_attempt_result = {commit_res.first, "Managed TX: Commit failed (Attempt " + std::to_string(attempt_count) + "): " + commit_res.second};
                    if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);
                    bool is_commit_retryable = (commit_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                    // Potentially check for specific Neo4j error codes from commit_res.second if available
                    if (is_commit_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                        if (current_op_logger) current_op_logger->info("[SessionTX Managed] COMMIT failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                        std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                        current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                        continue;
                    }
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            } else {  // User lambda returned error
                auto rollback_res = rollback_transaction();
                if (rollback_res.first != boltprotocol::BoltError::SUCCESS && connection_is_valid_ && current_op_logger) {
                    current_op_logger->warn("[SessionTX Managed] Rollback failed after work error ('{}'): {}", work_res.second, rollback_res.second);
                }
                last_attempt_result = work_res;
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Work failed (Attempt {}): {}", attempt_count, work_res.second);
                bool is_work_error_retryable = (work_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                // Potentially check for specific Neo4j error codes for retry
                if (is_work_error_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Work failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }
        }

        if (drv_logger) {
            drv_logger->warn("[SessionTX Managed] Transaction work failed after all {} retries or timeout. Last error: {}", attempt_count, last_attempt_result.second);
        }
        session_params_.default_access_mode = original_session_access_mode;
        return last_attempt_result;
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"  // For serialize_run_message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // Required for transport_manager_ access
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> SessionHandle::run_query(const std::string& cypher,
                                                                                                                           const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                           const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        boltprotocol::SuccessMessageParams run_summary_raw;
        boltprotocol::FailureMessageParams run_failure_details_raw;
        std::pair<boltprotocol::BoltError, std::string> prepare_result = {boltprotocol::BoltError::SUCCESS, ""};
        std::optional<int64_t> qid_for_stream;
        bool server_can_have_more_records_after_run = false;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string current_server_address = "unknown_server:0";
        boltprotocol::versions::Version current_bolt_version(0, 0);
        bool current_utc_patch_active = false;

        std::pair<boltprotocol::BoltError, std::string> conn_check_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_pair, "run_query (initial check)");

        if (conn) {
            logger = conn->get_logger();
            current_server_address = conn->get_config().target_host + ":" + std::to_string(conn->get_config().target_port);
            current_bolt_version = conn->get_bolt_version();
            current_utc_patch_active = conn->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (!conn) {
            prepare_result = conn_check_pair;
            if (logger) logger->warn("[SessionExec] run_query: Connection unavailable. Error: {}, Msg: {}", static_cast<int>(prepare_result.first), prepare_result.second);
        } else {
            std::optional<std::map<std::string, boltprotocol::Value>> metadata_to_pass;
            std::optional<std::chrono::milliseconds> timeout_to_pass;

            if (tx_config_overrides.has_value()) {
                metadata_to_pass = tx_config_overrides->metadata;
                timeout_to_pass = tx_config_overrides->timeout;
            } else {  // Use defaults from TransportConfig if no overrides
                if (transport_manager_ && transport_manager_->get_config().explicit_transaction_timeout_default_ms > 0 && !is_in_transaction()) {
                    timeout_to_pass = std::chrono::milliseconds(transport_manager_->get_config().explicit_transaction_timeout_default_ms);
                }
            }

            if (is_in_transaction()) {
                if (metadata_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_metadata_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                if (timeout_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_timeout_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                // For explicit TX, RUN does not take metadata/timeout. Those are on BEGIN.
                prepare_result = _prepare_explicit_tx_run(cypher, parameters, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = current_transaction_query_id_;  // Set by _prepare_explicit_tx_run
                    server_can_have_more_records_after_run = true;
                }
            } else {  // Auto-commit
                prepare_result = _prepare_auto_commit_run(cypher, parameters, metadata_to_pass, timeout_to_pass, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = std::nullopt;
                    auto it_qid = run_summary_raw.metadata.find("qid");
                    if (it_qid != run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                        qid_for_stream = std::get<int64_t>(it_qid->second);
                    }
                    server_can_have_more_records_after_run = true;
                }
            }
        }

        std::shared_ptr<std::vector<std::string>> fields_ptr = std::make_shared<std::vector<std::string>>();
        auto it_fields = run_summary_raw.metadata.find("fields");
        if (it_fields != run_summary_raw.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
            if (list_ptr) {
                fields_ptr->reserve(list_ptr->elements.size());
                for (const auto& field_val : list_ptr->elements) {
                    if (std::holds_alternative<std::string>(field_val)) {
                        fields_ptr->push_back(std::get<std::string>(field_val));
                    }
                }
            }
        }

        if (logger && prepare_result.first == boltprotocol::BoltError::SUCCESS) {
            logger->debug("[SessionExec] run_query successful prep. Fields: {}. QID for stream: {}", fields_ptr->size(), qid_for_stream.has_value() ? std::to_string(qid_for_stream.value()) : "none");
        }

        auto result_stream = std::make_unique<BoltResultStream>(this,
                                                                qid_for_stream,
                                                                std::move(run_summary_raw),
                                                                fields_ptr,
                                                                std::vector<boltprotocol::RecordMessageParams>{},
                                                                server_can_have_more_records_after_run,
                                                                current_bolt_version,
                                                                current_utc_patch_active,
                                                                current_server_address,
                                                                session_params_.database_name,
                                                                prepare_result.first,
                                                                prepare_result.second,
                                                                (prepare_result.first != boltprotocol::BoltError::SUCCESS ? std::make_optional(run_failure_details_raw) : std::nullopt));

        return {std::move(prepare_result), std::move(result_stream)};
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> SessionHandle::run_query_and_consume(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                   const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string srv_addr_cache = "unknown_server:0";
        boltprotocol::versions::Version bolt_ver_cache(0, 0);
        bool utc_patch_cache = false;

        if (connection_) {
            if (connection_->get_logger()) logger = connection_->get_logger();
            srv_addr_cache = connection_->get_config().target_host + ":" + std::to_string(connection_->get_config().target_port);
            bolt_ver_cache = connection_->get_bolt_version();
            utc_patch_cache = connection_->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume starting for cypher: {:.30}...", cypher);

        auto [initial_err_pair, result_stream_ptr] = run_query(cypher, parameters, tx_config_overrides);  // Pass overrides

        if (initial_err_pair.first != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: run_query failed initially. Error: {}, Msg: {}", static_cast<int>(initial_err_pair.first), initial_err_pair.second);
            if (result_stream_ptr) {
                boltprotocol::SuccessMessageParams params_copy = result_stream_ptr->get_run_summary().raw_params();
                return {initial_err_pair, ResultSummary(std::move(params_copy), bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
            }
            return {initial_err_pair, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        if (!result_stream_ptr) {
            if (logger) logger->error("[SessionExec] run_query_and_consume: Internal error - run_query succeeded but returned null stream.");
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, "Null result stream post run_query."}, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        auto [consume_err_code, consume_err_msg, final_summary_typed] = result_stream_ptr->consume();

        if (consume_err_code != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: stream consume failed. Error: {}, Msg: {}", static_cast<int>(consume_err_code), consume_err_msg);
            return {{consume_err_code, std::move(consume_err_msg)}, std::move(final_summary_typed)};
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume successful.");

        if (!connection_is_valid_) {
            boltprotocol::BoltError conn_last_err = boltprotocol::BoltError::NETWORK_ERROR;
            std::string conn_last_msg = "Connection lost during operation.";
            if (connection_ && connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                conn_last_err = connection_->get_last_error_code();
                conn_last_msg = connection_->get_last_error_message();
                if (logger) logger->warn("[SessionExec] run_query_and_consume: Connection became invalid. Last conn error: {}", conn_last_msg);
            } else if (logger) {
                logger->warn("[SessionExec] run_query_and_consume: Connection became invalid (no specific error).");
            }
            return {{conn_last_err, conn_last_msg}, std::move(final_summary_typed)};
        }
        return {{boltprotocol::BoltError::SUCCESS, ""}, std::move(final_summary_typed)};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::run_query_without_result(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        auto [err_pair_outer, summary_typed] = run_query_and_consume(cypher, parameters, tx_config_overrides);  // Pass overrides
        return err_pair_outer;
    }
}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_auto_commit_run(const std::string& cypher,
                                                                                            const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,
                                                                                            const std::optional<std::chrono::milliseconds>& tx_timeout,
                                                                                            boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                            boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_auto_commit_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;
        run_p.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) run_p.db = session_params_.database_name;
        if (session_params_.impersonated_user.has_value()) run_p.imp_user = session_params_.impersonated_user;

        // Compare with a constructed Version object for Bolt 5.0
        if (conn->get_bolt_version() < boltprotocol::versions::Version(5, 0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                run_p.mode = "r";
            }
        }

        if (tx_metadata.has_value()) {
            run_p.tx_metadata = tx_metadata.value();
        }
        if (tx_timeout.has_value()) {
            run_p.tx_timeout = static_cast<int64_t>(tx_timeout.value().count());
        }

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_writer(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_writer, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger)
            logger->trace(
                "[SessionStream {}] Sending auto-commit RUN. Cypher: {:.30}, Timeout: {}ms, Meta: {}", conn->get_id(), cypher, run_p.tx_timeout.has_value() ? std::to_string(run_p.tx_timeout.value()) : "N/A", run_p.tx_metadata.has_value() && !run_p.tx_metadata.value().empty() ? "Yes" : "No");

        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }
        if (conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Auto-commit RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }

        if (logger) logger->trace("[SessionStream {}] Auto-commit RUN successful, got its summary.", conn->get_id());
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_explicit_tx_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionStream {}] _prepare_explicit_tx_run called when not in transaction.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot run query in explicit TX mode; not in transaction."};
        }

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_w(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_w, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending explicit TX RUN. Cypher: {:.30}", conn->get_id(), cypher);
        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            current_transaction_query_id_.reset();
            // Compare with a constructed Version object for Bolt 4.0
            if (!(conn->get_bolt_version() < boltprotocol::versions::Version(4, 0))) {  // If Bolt version is >= 4.0
                auto it_qid = out_run_summary_raw.metadata.find("qid");
                if (it_qid != out_run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                    current_transaction_query_id_ = std::get<int64_t>(it_qid->second);
                    if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful, qid: {}.", conn->get_id(), *current_transaction_query_id_);
                } else {
                    if (logger) logger->warn("[SessionStream {}] Missing qid in RUN SUCCESS for explicit transaction (Bolt version {}.{}). Subsequent PULL/DISCARD may need to be implicit.", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                }
            } else {
                if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful (Bolt < 4.0, no qid expected from RUN).", conn->get_id());
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Explicit TX RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_pull_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::PullMessageParams pull_p;
        pull_p.n = n;
        pull_p.qid = qid;

        std::vector<uint8_t> pull_payload_bytes;
        boltprotocol::PackStreamWriter writer(pull_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_pull_message(pull_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending PULL (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;

        auto record_processor = [&](boltprotocol::MessageTag /*tag*/, const std::vector<uint8_t>& rec_payload, internal::BoltPhysicalConnection& /*connection_ref*/) {
            boltprotocol::RecordMessageParams rec;
            boltprotocol::PackStreamReader r(rec_payload);
            if (boltprotocol::deserialize_record_message(r, rec) == boltprotocol::BoltError::SUCCESS) {
                out_records.push_back(std::move(rec));
                return boltprotocol::BoltError::SUCCESS;
            }
            if (logger) logger->error("[SessionStream {}] Failed to deserialize RECORD message during PULL.", conn->get_id());
            return boltprotocol::BoltError::DESERIALIZATION_ERROR;
        };

        err = conn->send_request_receive_stream(pull_payload_bytes, record_processor, out_pull_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL stream processing", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_pull_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_pull_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after PULL: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after PULL, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) {
                bool has_more = false;
                auto it_has_more = out_pull_summary_raw.metadata.find("has_more");
                if (it_has_more != out_pull_summary_raw.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more = std::get<bool>(it_has_more->second);
                }
                logger->trace("[SessionStream {}] PULL successful. Records received: {}. HasMore: {}", conn->get_id(), out_records.size(), has_more);
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("PULL server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_discard_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::DiscardMessageParams discard_p;
        discard_p.n = n;
        discard_p.qid = qid;

        std::vector<uint8_t> discard_payload_bytes;
        boltprotocol::PackStreamWriter writer(discard_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_discard_message(discard_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending DISCARD (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;
        err = conn->send_request_receive_summary(discard_payload_bytes, out_discard_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_discard_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_discard_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after DISCARD: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after DISCARD, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) logger->trace("[SessionStream {}] DISCARD successful.", conn->get_id());
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("DISCARD server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/uri/uri_parser.h"

#include <algorithm>  // For std::transform, std::remove_if
#include <cctype>     // For std::tolower, std::isspace
#include <stdexcept>  // For std::stoi, std::stoul exceptions

namespace neo4j_bolt_transport {
    namespace uri {

        // Basic URL decoding (handles %XY and +)
        static std::string url_decode_component(const std::string& encoded) {
            std::string decoded;
            decoded.reserve(encoded.length());
            for (size_t i = 0; i < encoded.length(); ++i) {
                if (encoded[i] == '%' && i + 2 < encoded.length()) {
                    try {
                        std::string hex = encoded.substr(i + 1, 2);
                        char c = static_cast<char>(std::stoi(hex, nullptr, 16));
                        decoded += c;
                        i += 2;
                    } catch (const std::invalid_argument&) {  // Not a hex number
                        decoded += '%';                       // Treat as literal '%'
                    } catch (const std::out_of_range&) {      // Hex value too large for char
                        decoded += '%';                       // Treat as literal '%'
                    }
                } else if (encoded[i] == '+') {
                    decoded += ' ';
                } else {
                    decoded += encoded[i];
                }
            }
            return decoded;
        }

        // Helper to trim leading/trailing whitespace
        static std::string trim_whitespace(const std::string& s) {
            auto first = std::find_if_not(s.begin(), s.end(), [](unsigned char c) {
                return std::isspace(c);
            });
            if (first == s.end()) return "";  // String is all whitespace
            auto last = std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {
                            return std::isspace(c);
                        }).base();
            return std::string(first, last);
        }

        boltprotocol::BoltError UriParser::parse(const std::string& uri_string, ParsedUri& out_parsed_uri) {
            out_parsed_uri = {};  // Reset
            out_parsed_uri.input_uri = uri_string;

            if (uri_string.empty()) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 1. Scheme
            size_t scheme_end_pos = uri_string.find("://");
            if (scheme_end_pos == std::string::npos || scheme_end_pos == 0) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            out_parsed_uri.scheme = uri_string.substr(0, scheme_end_pos);
            std::transform(out_parsed_uri.scheme.begin(), out_parsed_uri.scheme.end(), out_parsed_uri.scheme.begin(), [](unsigned char c) {
                return std::tolower(c);
            });

            std::string remaining_uri = uri_string.substr(scheme_end_pos + 3);
            if (remaining_uri.empty() || remaining_uri[0] == '/' || remaining_uri[0] == '?') {  // Authority must exist
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 2. Authority (and userinfo within it)
            size_t authority_terminator_pos = remaining_uri.find_first_of("/?");
            std::string authority_part_full = remaining_uri.substr(0, authority_terminator_pos);

            std::string path_and_query_part;
            if (authority_terminator_pos != std::string::npos) {
                path_and_query_part = remaining_uri.substr(authority_terminator_pos);
            }

            // Userinfo (username:password@)
            size_t userinfo_terminator_pos = authority_part_full.find('@');
            std::string host_port_list_str = authority_part_full;

            if (userinfo_terminator_pos != std::string::npos) {
                std::string userinfo_str = authority_part_full.substr(0, userinfo_terminator_pos);
                host_port_list_str = authority_part_full.substr(userinfo_terminator_pos + 1);
                if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host missing after @

                size_t password_delim_pos = userinfo_str.find(':');
                if (password_delim_pos != std::string::npos) {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str.substr(0, password_delim_pos));
                    out_parsed_uri.password_from_uri = url_decode_component(userinfo_str.substr(password_delim_pos + 1));
                } else {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str);
                }
            }
            if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host(s) part is mandatory

            // Parse host(s) and port(s)
            // Host part can be a comma-separated list for routing schemes
            size_t current_token_pos = 0;
            while (current_token_pos < host_port_list_str.length()) {
                size_t next_host_separator = host_port_list_str.find(',', current_token_pos);
                std::string current_host_port_token = trim_whitespace(host_port_list_str.substr(current_token_pos, next_host_separator - current_token_pos));
                if (current_host_port_token.empty()) {  // Handles cases like ",," or leading/trailing commas
                    if (next_host_separator == std::string::npos) break;
                    current_token_pos = next_host_separator + 1;
                    continue;
                }

                std::string current_host_str;
                uint16_t current_port_val = 0;  // Default based on scheme later if not specified here

                size_t port_separator_pos = current_host_port_token.rfind(':');
                size_t ipv6_bracket_end_pos = current_host_port_token.rfind(']');

                if (port_separator_pos != std::string::npos && (ipv6_bracket_end_pos == std::string::npos || port_separator_pos > ipv6_bracket_end_pos)) {
                    // Port is specified
                    current_host_str = trim_whitespace(current_host_port_token.substr(0, port_separator_pos));
                    std::string port_str = trim_whitespace(current_host_port_token.substr(port_separator_pos + 1));
                    if (port_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port num missing after ':'
                    try {
                        unsigned long p_val = std::stoul(port_str);
                        if (p_val == 0 || p_val > 65535) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Invalid port range
                        current_port_val = static_cast<uint16_t>(p_val);
                    } catch (const std::exception&) {                      // std::invalid_argument or std::out_of_range
                        return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port not a number or out of range
                    }
                } else {
                    // No port specified for this token
                    current_host_str = current_host_port_token;
                }

                // Remove IPv6 brackets if present
                if (current_host_str.length() >= 2 && current_host_str.front() == '[' && current_host_str.back() == ']') {
                    current_host_str = current_host_str.substr(1, current_host_str.length() - 2);
                }
                if (current_host_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host cannot be empty

                out_parsed_uri.hosts_with_ports.emplace_back(current_host_str, current_port_val);

                if (next_host_separator == std::string::npos) break;
                current_token_pos = next_host_separator + 1;
            }
            if (out_parsed_uri.hosts_with_ports.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // No valid host found

            // 3. Query Parameters (Path component is usually ignored or used for specific DB in some drivers, simplified here)
            if (!path_and_query_part.empty()) {
                size_t query_start_pos = path_and_query_part.find('?');
                if (query_start_pos != std::string::npos) {
                    std::string query_string = path_and_query_part.substr(query_start_pos + 1);
                    size_t current_param_pos = 0;
                    while (current_param_pos < query_string.length()) {
                        size_t next_amp_pos = query_string.find('&', current_param_pos);
                        std::string param_pair_str = query_string.substr(current_param_pos, next_amp_pos - current_param_pos);
                        size_t eq_pos = param_pair_str.find('=');
                        if (eq_pos != std::string::npos) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str.substr(0, eq_pos)));
                            std::string value = trim_whitespace(url_decode_component(param_pair_str.substr(eq_pos + 1)));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = value;
                        } else if (!param_pair_str.empty()) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = "";
                        }
                        if (next_amp_pos == std::string::npos) break;
                        current_param_pos = next_amp_pos + 1;
                    }
                }
            }

            // Apply scheme-specific logic and default ports
            uint16_t default_port_for_scheme = 0;

            if (out_parsed_uri.scheme == "bolt") {
                out_parsed_uri.tls_enabled_by_scheme = false;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "bolt+s") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "bolt+ssc") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = false;  // Routing table will dictate TLS for resolved servers
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+s") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+ssc") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else {
                return boltprotocol::BoltError::INVALID_ARGUMENT;  // Unknown scheme
            }

            // Apply default port if any host_with_port has port 0
            for (auto& host_port_pair : out_parsed_uri.hosts_with_ports) {
                if (host_port_pair.second == 0) {
                    if (default_port_for_scheme == 0) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Scheme needs explicit port
                    host_port_pair.second = default_port_for_scheme;
                }
            }

            out_parsed_uri.is_valid = true;
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace uri
}  // namespace neo4j_bolt_transport