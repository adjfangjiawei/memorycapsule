file(GLOB_RECURSE NEO4J_BOLT_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(Neo4jBoltTransport ${NEO4J_BOLT_TRANSPORT_SOURCE})

target_include_directories(Neo4jBoltTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(Neo4jBoltTransport PUBLIC Boost::asio Boost::system)
target_link_libraries(Neo4jBoltTransport PUBLIC Protocol)
target_compile_definitions(Neo4jBoltTransport PUBLIC SPDLOG_USE_STD_FORMAT)
target_link_libraries(Neo4jBoltTransport
    PUBLIC
    spdlog::spdlog_header_only
)#ifndef NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H
#define NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H

#include <map>
#include <memory>  // For std::shared_ptr for field_names
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/bolt_structure_types.h"
#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {

    class BoltRecord {
      public:
        // Constructor takes rvalue refs to move data if possible.
        // field_names_ptr is shared because multiple records from the same result stream share it.
        BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> field_names_ptr);

        BoltRecord(const BoltRecord&) = delete;  // Typically records are not copied once created
        BoltRecord& operator=(const BoltRecord&) = delete;
        BoltRecord(BoltRecord&&) noexcept = default;
        BoltRecord& operator=(BoltRecord&&) noexcept = default;

        // Access by index
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(size_t index) const;

        // Access by name
        std::pair<boltprotocol::BoltError, boltprotocol::Value> get(const std::string& field_name) const;

        // Typed access by index
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(size_t index) const;

        // Typed access by name
        template <typename T>
        std::pair<boltprotocol::BoltError, T> get_as(const std::string& field_name) const;

        // Typed access for Bolt Structures (Node, Relationship, etc.)
        // These require the Bolt version for correct deserialization of version-dependent fields.
        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(size_t index,
                                                                                  const boltprotocol::versions::Version& bolt_version,
                                                                                  bool utc_patch_active_for_4_4 = false  // Relevant for DateTime types in Bolt 4.4
        ) const;

        template <typename T_BoltStructure>
        std::pair<boltprotocol::BoltError, T_BoltStructure> get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) const;

        size_t field_count() const noexcept {
            return fields_.size();
        }
        const std::vector<std::string>& field_names() const;  // Returns empty if no names available

      private:
        std::vector<boltprotocol::Value> fields_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_;  // Pointer to shared field names
        // Optional: Cache field name to index map for faster named lookups if records are long-lived
        // mutable std::optional<std::map<std::string, size_t>> field_name_to_index_cache_;
        // const std::map<std::string, size_t>& get_field_name_map() const;
    };

    // --- Template Implementations for BoltRecord ---
    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(size_t index) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T{}};
        }
        if (std::holds_alternative<T>(value_result.second)) {
            try {
                return {boltprotocol::BoltError::SUCCESS, std::get<T>(value_result.second)};
            } catch (const std::bad_variant_access&) {                         // Should not happen if holds_alternative is true
                return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
            }
        }
        // Special case for int64_t, allow conversion from other integral types if safe (e.g. int32_t -> int64_t)
        // This requires more complex logic or a dedicated conversion utility.
        // For now, strict type match.
        return {boltprotocol::BoltError::DESERIALIZATION_ERROR, T{}};  // Type mismatch
    }

    template <typename T>
    std::pair<boltprotocol::BoltError, T> BoltRecord::get_as(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // No field names available
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T{}};  // Field name not found
        }
        return get_as<T>(static_cast<size_t>(index));
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(size_t index, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        auto value_result = get(index);
        if (value_result.first != boltprotocol::BoltError::SUCCESS) {
            return {value_result.first, T_BoltStructure{}};
        }

        T_BoltStructure typed_struct;
        boltprotocol::BoltError conversion_err;

        // Use the value_to_typed_struct that takes version and patch info
        if constexpr (std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTime> || std::is_same_v<T_BoltStructure, boltprotocol::BoltDateTimeZoneId> || std::is_same_v<T_BoltStructure, boltprotocol::BoltNode> || std::is_same_v<T_BoltStructure, boltprotocol::BoltRelationship> ||
                      std::is_same_v<T_BoltStructure, boltprotocol::BoltUnboundRelationship> || std::is_same_v<T_BoltStructure, boltprotocol::BoltPath>) {
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct, bolt_version, utc_patch_active_for_4_4);
        } else {  // For types like BoltDate, BoltTime that don't need version for deserialization
            conversion_err = boltprotocol::value_to_typed_struct(value_result.second, typed_struct);
        }

        if (conversion_err != boltprotocol::BoltError::SUCCESS) {
            return {conversion_err, T_BoltStructure{}};
        }
        return {boltprotocol::BoltError::SUCCESS, typed_struct};
    }

    template <typename T_BoltStructure>
    std::pair<boltprotocol::BoltError, T_BoltStructure> BoltRecord::get_bolt_structure_as(const std::string& field_name, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active_for_4_4) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        ptrdiff_t index = -1;
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                index = static_cast<ptrdiff_t>(i);
                break;
            }
        }
        if (index == -1) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, T_BoltStructure{}};
        }
        return get_bolt_structure_as<T_BoltStructure>(static_cast<size_t>(index), bolt_version, utc_patch_active_for_4_4);
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_BOLT_RECORD_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H

#include <map>
#include <optional>
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For boltprotocol::Value

namespace neo4j_bolt_transport {
    namespace config {

        struct NoAuth {};

        struct BasicAuth {
            std::string username;
            std::string password;
            std::optional<std::string> realm;
        };

        struct KerberosAuth {
            std::string base64_ticket;
        };

        struct CustomAuth {
            std::string principal;
            std::string credentials;
            std::optional<std::string> realm;
            std::string scheme;  // The custom scheme name, e.g., "custom_sso"
            std::optional<std::map<std::string, boltprotocol::Value>> parameters;
        };

        struct BearerAuth {
            std::string token;  // The bearer token
        };

        // Variant to hold different authentication types
        using AuthTokenVariant = std::variant<NoAuth, BasicAuth, KerberosAuth, BearerAuth, CustomAuth>;

        // Factory class for creating AuthTokenVariant instances easily
        class AuthTokens {
          public:
            AuthTokens() = delete;  // Static factory methods only

            static AuthTokenVariant none();
            static AuthTokenVariant basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm = std::nullopt);
            static AuthTokenVariant kerberos(const std::string& base64_ticket);
            static AuthTokenVariant bearer(const std::string& token);
            static AuthTokenVariant custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters = std::nullopt);
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_AUTH_TOKEN_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"

namespace neo4j_bolt_transport {
    namespace config {

        enum class AccessMode { READ, WRITE };

        struct SessionParameters {
            std::optional<std::string> database_name;
            AccessMode default_access_mode = AccessMode::WRITE;
            std::vector<std::string> initial_bookmarks;
            std::optional<std::string> impersonated_user;

            // Default number of records to fetch in each PULL message.
            // -1 typically means "fetch all remaining".
            // Drivers often have a default like 1000.
            int64_t default_fetch_size = 1000;

            SessionParameters() = default;

            static SessionParameters for_database(const std::string& db_name) {
                SessionParameters p;
                p.database_name = db_name;
                return p;
            }

            SessionParameters& with_database(const std::string& db_name) {
                database_name = db_name;
                return *this;
            }
            SessionParameters& with_default_access_mode(AccessMode mode) {
                default_access_mode = mode;
                return *this;
            }
            SessionParameters& with_bookmarks(const std::vector<std::string>& new_bookmarks) {
                initial_bookmarks = new_bookmarks;
                return *this;
            }
            SessionParameters& with_impersonated_user(const std::string& user) {
                impersonated_user = user;
                return *this;
            }
            SessionParameters& with_fetch_size(int64_t size) {
                default_fetch_size = size;
                return *this;
            }
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_SESSION_PARAMETERS_H#ifndef NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H

#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <set>  // For set of ServerAddress
#include <string>
#include <vector>

#include "auth_token.h"
#include "boltprotocol/message_defs.h"
#include "neo4j_bolt_transport/routing/server_address.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace neo4j_bolt_transport {

    namespace uri {
        struct ParsedUri;
    }

    namespace config {

        struct TransportConfig {
            std::string uri_string;
            AuthTokenVariant auth_token = AuthTokens::none();
            std::string user_agent_override;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info;

            enum class EncryptionStrategy { NEGOTIATE_FROM_URI_SCHEME, FORCE_PLAINTEXT, FORCE_ENCRYPTED_SYSTEM_CERTS, FORCE_ENCRYPTED_TRUST_ALL_CERTS, FORCE_ENCRYPTED_CUSTOM_CERTS };
            EncryptionStrategy encryption_strategy = EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            std::size_t max_connection_pool_size = 100;
            uint32_t connection_acquisition_timeout_ms = 60000;  // Timeout for acquiring a connection from the pool
            uint32_t max_connection_lifetime_ms = 3600000;       // Max lifetime of a pooled connection
            uint32_t idle_timeout_ms = 600000;                   // Max idle time for a pooled connection
            uint32_t idle_time_before_health_check_ms = 30000;   // Idle time after which a health check (ping) is performed before reuse

            // Socket level timeouts
            uint32_t tcp_connect_timeout_ms = 5000;  // Timeout for establishing the TCP connection
            uint32_t socket_read_timeout_ms = 0;     // Timeout for socket read operations (0 = system default/infinite)
            uint32_t socket_write_timeout_ms = 0;    // Timeout for socket write operations (0 = system default/infinite)
            bool tcp_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;

            // Bolt protocol level timeouts
            uint32_t hello_timeout_ms = 15000;   // Timeout for HELLO message exchange
            uint32_t goodbye_timeout_ms = 5000;  // Timeout for GOODBYE message exchange (if sent)

            // Transaction related configurations
            uint32_t max_transaction_retry_time_ms = 30000;  // Max total time for retrying a managed transaction
            uint32_t transaction_retry_delay_initial_ms = 1000;
            uint32_t transaction_retry_delay_multiplier = 2;
            uint32_t transaction_retry_delay_max_ms = 60000;
            uint32_t explicit_transaction_timeout_default_ms = 0;  // Default timeout for explicit transactions if not specified per-transaction (0 = server default)

            // --- Routing ---
            bool client_side_routing_enabled = true;
            uint32_t routing_table_refresh_ttl_margin_ms = 5000;
            uint32_t routing_max_retry_attempts = 3;
            std::function<routing::ServerAddress(const routing::ServerAddress&)> server_address_resolver;
            std::map<std::string, std::vector<routing::ServerAddress>> initial_router_addresses_override;

            // --- Bolt Protocol ---
            std::vector<boltprotocol::versions::Version> preferred_bolt_versions;

            // --- Logging ---
            std::shared_ptr<spdlog::logger> logger;
            spdlog::level::level_enum log_level = spdlog::level::info;

            TransportConfig(const std::string& uri_str = "bolt://localhost:7687");
            TransportConfig();

            boltprotocol::BoltError apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri);
            void prepare_agent_strings(const std::string& default_transport_name_version = "Neo4jBoltTransportCpp/0.6.0");  // Version bump

            std::shared_ptr<spdlog::logger> get_or_create_logger(const std::string& logger_name = "Neo4jBoltTransport");
        };

    }  // namespace config
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_CONFIG_TRANSPORT_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H
#define NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H

#include <optional>
#include <string>

#include "boltprotocol/message_defs.h"  // For BoltError and FailureMessageParams

namespace neo4j_bolt_transport {
    namespace error {

        // Creates a detailed error message string from FailureMessageParams
        inline std::string format_server_failure(const boltprotocol::FailureMessageParams& failure_params) {
            std::string server_code = "Unknown.Error";
            std::string server_message = "An error occurred on the server.";

            auto extract_string_from_value = [](const boltprotocol::Value& val) -> std::optional<std::string> {
                if (std::holds_alternative<std::string>(val)) {
                    return std::get<std::string>(val);
                }
                return std::nullopt;
            };

            auto it_code = failure_params.metadata.find("neo4j_code");  // Bolt 5.7+
            if (it_code == failure_params.metadata.end() || !extract_string_from_value(it_code->second).has_value()) {
                it_code = failure_params.metadata.find("code");  // Legacy
            }
            if (it_code != failure_params.metadata.end()) {
                if (auto code_opt = extract_string_from_value(it_code->second)) {
                    server_code = *code_opt;
                }
            }

            auto it_msg = failure_params.metadata.find("message");
            if (it_msg != failure_params.metadata.end()) {
                if (auto msg_opt = extract_string_from_value(it_msg->second)) {
                    server_message = *msg_opt;
                }
            }

            return "[" + server_code + "] " + server_message;
        }

        // Converts BoltError enum to a human-readable string (basic version)
        inline std::string bolt_error_to_string(boltprotocol::BoltError err_code) {
            switch (err_code) {
                case boltprotocol::BoltError::SUCCESS:
                    return "SUCCESS";
                case boltprotocol::BoltError::UNKNOWN_ERROR:
                    return "UNKNOWN_ERROR";
                case boltprotocol::BoltError::INVALID_ARGUMENT:
                    return "INVALID_ARGUMENT";
                case boltprotocol::BoltError::SERIALIZATION_ERROR:
                    return "SERIALIZATION_ERROR";
                case boltprotocol::BoltError::DESERIALIZATION_ERROR:
                    return "DESERIALIZATION_ERROR";
                case boltprotocol::BoltError::INVALID_MESSAGE_FORMAT:
                    return "INVALID_MESSAGE_FORMAT";
                case boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION:
                    return "UNSUPPORTED_PROTOCOL_VERSION";
                case boltprotocol::BoltError::NETWORK_ERROR:
                    return "NETWORK_ERROR";
                case boltprotocol::BoltError::HANDSHAKE_FAILED:
                    return "HANDSHAKE_FAILED";
                // ... add all other BoltError codes ...
                default:
                    return "UNRECOGNIZED_BOLT_ERROR (" + std::to_string(static_cast<int>(err_code)) + ")";
            }
        }

        // Combines a BoltError with a context message and potentially a server failure message
        inline std::string format_error_message(const std::string& context, boltprotocol::BoltError err_code, const std::optional<std::string>& server_failure_detail = std::nullopt) {
            std::string msg = context + ": " + bolt_error_to_string(err_code) + " (code " + std::to_string(static_cast<int>(err_code)) + ")";
            if (server_failure_detail && !server_failure_detail->empty()) {
                msg += "; Server detail: " + *server_failure_detail;
            }
            return msg;
        }

    }  // namespace error
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ERROR_NEO4J_ERROR_UTIL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H

#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <memory>  // For std::weak_ptr
#include <string>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version

namespace neo4j_bolt_transport {
    namespace internal {

        // Represents an established, active asynchronous stream and its parameters.
        // Ownership of the stream object is held by this context.
        struct ActiveAsyncStreamContext {
            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> stream;

            boltprotocol::versions::Version negotiated_bolt_version;
            std::string server_agent_string;
            std::string server_connection_id;
            bool utc_patch_active = false;
            bool encryption_was_used = false;

            ActiveAsyncStreamContext(std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> s, boltprotocol::versions::Version bv, std::string sa, std::string cid, bool utc, bool enc_used)
                : stream(std::move(s)), negotiated_bolt_version(bv), server_agent_string(std::move(sa)), server_connection_id(std::move(cid)), utc_patch_active(utc), encryption_was_used(enc_used) {
            }

            explicit ActiveAsyncStreamContext(boost::asio::io_context& ioc) : stream(boost::asio::ip::tcp::socket(ioc)) {
            }
            ActiveAsyncStreamContext() = delete;

            ActiveAsyncStreamContext(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext& operator=(const ActiveAsyncStreamContext&) = delete;
            ActiveAsyncStreamContext(ActiveAsyncStreamContext&&) = default;
            ActiveAsyncStreamContext& operator=(ActiveAsyncStreamContext&&) = default;

            boost::asio::any_io_executor get_executor() {
                return std::visit(
                    [](auto& s) {
                        return s.get_executor();
                    },
                    stream);
            }
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_TYPES_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/ip/tcp.hpp>      // For socket type in template
#include <boost/asio/ssl/stream.hpp>  // For ssl::stream type in template
#include <chrono>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

// Forward declaration of BoltPhysicalConnection to avoid full include here
namespace neo4j_bolt_transport {
    namespace internal {
        class BoltPhysicalConnection;  // Forward declaration
    }
}  // namespace neo4j_bolt_transport

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Adapter to dispatch read/write operations (declaration only)
            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op);

            // Timeout wrapper template function (declaration only)
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(  // Renamed to avoid conflict with previous attempts
                BoltPhysicalConnection* conn_obj_ptr,
                Stream& stream,
                BufferType buffers,
                std::chrono::milliseconds timeout_duration,
                const std::string& operation_name,
                bool is_read_operation);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

// Include the implementation file for templates at the end of the header
#include "async_utils.tpp"  // Or async_utils_inl.h

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_H// No include guard needed in .tpp as it's included by a .h with a guard

#include "boltprotocol/bolt_errors_versions.h"                       // For BoltError
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // Full definition needed for implementation

// Boost ASIO includes for implementation details
#include <spdlog/spdlog.h>

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            // Definition for dispatch_read_write_operation
            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op) {
                if (is_read_op) {
                    return boost::asio::async_read(stream, buffers, std::forward<CompletionToken>(token));
                } else {
                    return boost::asio::async_write(stream, buffers, std::forward<CompletionToken>(token));
                }
            }

            // Definition for async_io_with_timeout
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(  // Matches declaration
                BoltPhysicalConnection* conn_obj_ptr,
                Stream& stream,
                BufferType buffers,
                std::chrono::milliseconds timeout_duration,
                const std::string& operation_name,
                bool is_read_operation) {
                if (!conn_obj_ptr) {
                    co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                }
                // Now we can safely access BoltPhysicalConnection members
                std::shared_ptr<spdlog::logger> logger = conn_obj_ptr->get_logger();
                boost::system::error_code ec;
                std::size_t bytes_transferred = 0;

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtil {}] {} on closed stream (conn id {}).", operation_name, conn_obj_ptr->get_id());
                    // conn_obj_ptr->_mark_as_defunct(...); // Can now call this
                    co_return {boltprotocol::BoltError::NETWORK_ERROR, 0};
                }

                if (timeout_duration.count() <= 0) {  // No timeout
                    try {
                        bytes_transferred = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, ec), is_read_operation);
                    } catch (const boost::system::system_error& e_sys) {
                        ec = e_sys.code();
                        if (logger) logger->error("[AsyncUtil {}] Exception in {} (no timeout, conn id {}): {}", operation_name, conn_obj_ptr->get_id(), e_sys.what());
                    }
                    if (ec) {
                        if (logger) logger->warn("[AsyncUtil {}] {} failed (no timeout, conn id {}): {}", operation_name, conn_obj_ptr->get_id(), ec.message());
                        conn_obj_ptr->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, operation_name + " failed (no timeout): " + ec.message());
                        co_return {conn_obj_ptr->get_last_error_code(), 0};
                    }
                    co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                }

                boost::asio::steady_timer timer(stream.get_executor());
                timer.expires_after(timeout_duration);

                std::optional<std::pair<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        std::size_t temp_bytes = 0;
                        try {
                            temp_bytes = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec), is_read_operation);
                        } catch (const boost::system::system_error& e_sys) {
                            temp_ec = e_sys.code();
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = {{temp_ec, temp_bytes}};
                            boost::system::error_code cancel_timer_ec_ignored;  // Error code for cancel is usually ignored
                            timer.cancel();                                     // Correct: no error_code parameter
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {temp_ec};
                            if (temp_ec != boost::asio::error::operation_aborted) {
                                boost::system::error_code cancel_io_ec;
                                stream.lowest_layer().cancel(cancel_io_ec);
                                if (logger && cancel_io_ec) logger->trace("[AsyncUtil {}] {} socket cancel (due to timeout) returned: {}", operation_name, conn_obj_ptr->get_id(), cancel_io_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(stream.get_executor(), boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    ec = io_result_opt.value().first;
                    bytes_transferred = io_result_opt.value().second;
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    ec = boost::asio::error::timed_out;
                    if (logger) logger->warn("[AsyncUtil {}] {} timed out after {}ms (conn id {}).", operation_name, timeout_duration.count(), conn_obj_ptr->get_id());
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        ec = boost::asio::error::fault;
                        if (logger) logger->error("[AsyncUtil {}] {} logic error: Timer aborted but no I/O result (conn id {}).", operation_name, conn_obj_ptr->get_id());
                    }
                } else {
                    ec = boost::asio::error::fault;
                    if (logger) logger->error("[AsyncUtil {}] {} unexpected fallthrough in timeout logic (conn id {}).", operation_name, conn_obj_ptr->get_id());
                }

                if (ec) {
                    if (logger && ec != boost::asio::error::operation_aborted) {
                        logger->warn("[AsyncUtil {}] {} failed (conn id {}): {}", operation_name, conn_obj_ptr->get_id(), ec.message());
                    }
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;

                    if (ec != boost::asio::error::operation_aborted || !io_result_opt.has_value() || io_result_opt.value().first) {
                        conn_obj_ptr->_mark_as_defunct(mapped_error, operation_name + " failed: " + ec.message());
                        co_return {conn_obj_ptr->get_last_error_code(), 0};
                    } else {
                        co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                    }
                }
                co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport// Include/neo4j_bolt_transport/internal/async_utils_decl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H

#include <boost/asio/awaitable.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <chrono>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"  // Depend on the interface

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op);

            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(IAsyncContextCallbacks* callbacks,  // Uses the interface
                                                                                                          Stream& stream,
                                                                                                          BufferType buffers,
                                                                                                          std::chrono::milliseconds timeout_duration,
                                                                                                          const std::string& operation_name,
                                                                                                          bool is_read_operation);

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#include "async_utils_impl.h"

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_DECL_H// Include/neo4j_bolt_transport/internal/async_utils_impl.h
#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H

// We don't include bolt_physical_connection.h here anymore.
// All interaction is through IAsyncContextCallbacks.
#include <spdlog/spdlog.h>  // For logger implementation

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/read.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/write.hpp>
#include <optional>

#include "neo4j_bolt_transport/internal/i_async_context_callbacks.h"

namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {

            template <typename Stream, typename BufferSequence, typename CompletionToken>
            auto dispatch_read_write_operation(Stream& stream, BufferSequence buffers, CompletionToken&& token, bool is_read_op) {
                if (is_read_op) {
                    return boost::asio::async_read(stream, buffers, std::forward<CompletionToken>(token));
                } else {
                    return boost::asio::async_write(stream, buffers, std::forward<CompletionToken>(token));
                }
            }

            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout(IAsyncContextCallbacks* callbacks,  // Uses the interface
                                                                                                          Stream& stream,
                                                                                                          BufferType buffers,
                                                                                                          std::chrono::milliseconds timeout_duration,
                                                                                                          const std::string& operation_name,
                                                                                                          bool is_read_operation) {
                if (!callbacks) {  // Check if callbacks pointer is valid
                    // Cannot log here as we don't have a logger from callbacks
                    return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};  // Or throw
                }
                std::shared_ptr<spdlog::logger> logger = callbacks->get_logger();
                boost::system::error_code ec;
                std::size_t bytes_transferred = 0;

                if (!stream.lowest_layer().is_open()) {
                    if (logger) logger->error("[AsyncUtil {}] {} on closed stream (obj id {}).", operation_name, callbacks->get_id_for_logging());
                    co_return {boltprotocol::BoltError::NETWORK_ERROR, 0};
                }

                if (timeout_duration.count() <= 0) {
                    try {
                        bytes_transferred = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, ec), is_read_operation);
                    } catch (const boost::system::system_error& e_sys) {
                        ec = e_sys.code();
                        if (logger) logger->error("[AsyncUtil {}] Exception in {} (no timeout, obj id {}): {}", operation_name, callbacks->get_id_for_logging(), e_sys.what());
                    }
                    if (ec) {
                        if (logger) logger->warn("[AsyncUtil {}] {} failed (no timeout, obj id {}): {}", operation_name, callbacks->get_id_for_logging(), ec.message());
                        callbacks->mark_as_defunct_from_async(boltprotocol::BoltError::NETWORK_ERROR, operation_name + " failed (no timeout): " + ec.message());
                        co_return {callbacks->get_last_error_code_from_async(), 0};
                    }
                    co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                }

                boost::asio::steady_timer timer(stream.get_executor());
                timer.expires_after(timeout_duration);

                std::optional<std::pair<boost::system::error_code, std::size_t>> io_result_opt;
                std::optional<boost::system::error_code> timer_result_opt;

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        std::size_t temp_bytes = 0;
                        try {
                            temp_bytes = co_await dispatch_read_write_operation(stream, buffers, boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec), is_read_operation);
                        } catch (const boost::system::system_error& e_sys) {
                            temp_ec = e_sys.code();
                        }
                        if (!timer_result_opt.has_value()) {
                            io_result_opt = {{temp_ec, temp_bytes}};
                            timer.cancel();
                        }
                        co_return;
                    },
                    boost::asio::detached);

                boost::asio::co_spawn(
                    stream.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code temp_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, temp_ec));
                        if (!io_result_opt.has_value()) {
                            timer_result_opt = {temp_ec};
                            if (temp_ec != boost::asio::error::operation_aborted) {
                                boost::system::error_code cancel_io_ec;
                                stream.lowest_layer().cancel(cancel_io_ec);
                                if (logger && cancel_io_ec) logger->trace("[AsyncUtil {}] {} socket cancel (due to timeout) returned: {}", operation_name, callbacks->get_id_for_logging(), cancel_io_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);

                while (!io_result_opt.has_value() && !timer_result_opt.has_value()) {
                    co_await boost::asio::post(stream.get_executor(), boost::asio::use_awaitable);
                }

                if (io_result_opt.has_value()) {
                    ec = io_result_opt.value().first;
                    bytes_transferred = io_result_opt.value().second;
                } else if (timer_result_opt.has_value() && timer_result_opt.value() != boost::asio::error::operation_aborted) {
                    ec = boost::asio::error::timed_out;
                    if (logger) logger->warn("[AsyncUtil {}] {} timed out after {}ms (obj id {}).", operation_name, timeout_duration.count(), callbacks->get_id_for_logging());
                } else if (timer_result_opt.has_value() && timer_result_opt.value() == boost::asio::error::operation_aborted) {
                    if (!io_result_opt.has_value()) {
                        ec = boost::asio::error::fault;
                        if (logger) logger->error("[AsyncUtil {}] {} logic error: Timer aborted but no I/O result (obj id {}).", operation_name, callbacks->get_id_for_logging());
                    }
                } else {
                    ec = boost::asio::error::fault;
                    if (logger) logger->error("[AsyncUtil {}] {} unexpected fallthrough in timeout logic (obj id {}).", operation_name, callbacks->get_id_for_logging());
                }

                if (ec) {
                    if (logger && ec != boost::asio::error::operation_aborted) {
                        logger->warn("[AsyncUtil {}] {} failed (obj id {}): {}", operation_name, callbacks->get_id_for_logging(), ec.message());
                    }
                    boltprotocol::BoltError mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    if (ec == boost::asio::error::eof)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;
                    else if (ec == boost::asio::error::timed_out)
                        mapped_error = boltprotocol::BoltError::NETWORK_ERROR;

                    if (ec != boost::asio::error::operation_aborted || !io_result_opt.has_value() || io_result_opt.value().first) {
                        callbacks->mark_as_defunct_from_async(mapped_error, operation_name + " failed: " + ec.message());
                        co_return {callbacks->get_last_error_code_from_async(), 0};
                    } else {
                        co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
                    }
                }
                co_return {boltprotocol::BoltError::SUCCESS, bytes_transferred};
            }

        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_ASYNC_UTILS_IMPL_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"                     // For Value, Version
#include "neo4j_bolt_transport/config/transport_config.h"  // For AuthTokenVariant, EncryptionStrategy

namespace neo4j_bolt_transport {
    namespace internal {

        struct BoltConnectionConfig {
            std::string target_host;
            uint16_t target_port;

            config::AuthTokenVariant auth_token;
            std::string user_agent_for_hello;
            boltprotocol::HelloMessageParams::BoltAgentInfo bolt_agent_info_for_hello;

            bool encryption_enabled = false;
            config::TransportConfig::EncryptionStrategy resolved_encryption_strategy = config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME;
            std::vector<std::string> trusted_certificates_pem_files;
            std::optional<std::string> client_certificate_pem_file;
            std::optional<std::string> client_private_key_pem_file;
            std::optional<std::string> client_private_key_password;
            bool hostname_verification_enabled = true;

            uint32_t tcp_connect_timeout_ms = 5000;
            uint32_t socket_read_timeout_ms = 0;   // Added
            uint32_t socket_write_timeout_ms = 0;  // Added
            bool socket_keep_alive_enabled = true;
            bool tcp_no_delay_enabled = true;
            uint32_t bolt_handshake_timeout_ms = 10000;
            uint32_t hello_timeout_ms = 15000;   // Added
            uint32_t goodbye_timeout_ms = 5000;  // Added

            std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_context;
            std::optional<std::vector<boltprotocol::versions::Version>> preferred_bolt_versions;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_CONNECTION_CONFIG_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H

#include <atomic>
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl/context.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "bolt_connection_config.h"
#include "boltprotocol/chunking.h"   // Should not be needed here if chunking methods are on this class
#include "boltprotocol/handshake.h"  // For boltprotocol::perform_handshake (sync)
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "neo4j_bolt_transport/internal/async_types.h"  // Include ActiveAsyncStreamContext
#include "spdlog/spdlog.h"

// Forward declare the template function from async_utils.h for friending
namespace neo4j_bolt_transport {
    namespace internal {
        namespace async_utils {
            template <typename Stream, typename BufferType>
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_io_with_timeout_impl(BoltPhysicalConnection* conn_obj_ptr, Stream& stream, BufferType buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name, bool is_read_operation);
        }  // namespace async_utils
    }  // namespace internal
}  // namespace neo4j_bolt_transport

namespace neo4j_bolt_transport {

    class SessionHandle;

    namespace internal {

        class BoltPhysicalConnection : public std::enable_shared_from_this<BoltPhysicalConnection> {  // Added enable_shared_from_this
          public:
            using PooledConnection = std::unique_ptr<BoltPhysicalConnection>;
            enum class InternalState {
                FRESH,
                TCP_CONNECTING,
                ASYNC_TCP_CONNECTING,
                TCP_CONNECTED,
                SSL_CONTEXT_SETUP,
                SSL_HANDSHAKING,
                ASYNC_SSL_HANDSHAKING,
                SSL_HANDSHAKEN,
                BOLT_HANDSHAKING,
                ASYNC_BOLT_HANDSHAKING,
                BOLT_HANDSHAKEN,
                HELLO_AUTH_SENT,
                ASYNC_HELLO_AUTH_SENT,
                READY,
                STREAMING,
                AWAITING_SUMMARY,
                FAILED_SERVER_REPORTED,
                DEFUNCT
            };

            BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr);
            ~BoltPhysicalConnection();

            BoltPhysicalConnection(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection& operator=(const BoltPhysicalConnection&) = delete;
            BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept;
            BoltPhysicalConnection& operator=(BoltPhysicalConnection&& other) noexcept;

            // --- Synchronous API ---
            boltprotocol::BoltError establish();
            boltprotocol::BoltError terminate(bool send_goodbye = true);
            boltprotocol::BoltError ping(std::chrono::milliseconds timeout);
            bool is_ready_for_queries() const;
            bool is_defunct() const;
            boltprotocol::BoltError get_last_error_code() const {
                return last_error_code_;
            }
            std::string get_last_error_message() const {
                return last_error_message_;
            }
            uint64_t get_id() const {
                return id_;
            }
            const boltprotocol::versions::Version& get_bolt_version() const {
                return negotiated_bolt_version_;
            }
            bool is_utc_patch_active() const {
                return utc_patch_active_;
            }
            const std::string& get_server_agent() const {
                return server_agent_string_;
            }
            const std::string& get_connection_id() const {
                return server_assigned_conn_id_;
            }
            const BoltConnectionConfig& get_config() const {
                return conn_config_;
            }
            std::shared_ptr<spdlog::logger> get_logger() const {
                return logger_;
            }
            boost::asio::io_context& get_io_context() {
                return io_context_ref_;
            }
            std::chrono::steady_clock::time_point get_creation_timestamp() const {
                return creation_timestamp_;
            }
            std::chrono::steady_clock::time_point get_last_used_timestamp() const {
                return last_used_timestamp_.load(std::memory_order_relaxed);
            }
            void mark_as_used();
            bool is_encrypted() const;

            using MessageHandler = std::function<boltprotocol::BoltError(boltprotocol::MessageTag tag, const std::vector<uint8_t>& payload, BoltPhysicalConnection& connection)>;
            boltprotocol::BoltError send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure);
            boltprotocol::BoltError perform_reset();
            boltprotocol::BoltError perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success);
            boltprotocol::BoltError perform_logoff(boltprotocol::SuccessMessageParams& out_success);

            // --- Asynchronous API ---
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> establish_async();

            // Public async messaging methods removed from here. They will operate on ActiveAsyncStreamContext.
            // terminate_async and ping_async are kept as placeholders but their utility on a non-stream-owning object is limited.
            boost::asio::awaitable<boltprotocol::BoltError> terminate_async(bool send_goodbye = true);
            boost::asio::awaitable<boltprotocol::BoltError> ping_async(std::chrono::milliseconds timeout);

            // Made public for async_utils helper, or make helper a friend
            void _mark_as_defunct(boltprotocol::BoltError reason, const std::string& message = "");

          private:
            friend class neo4j_bolt_transport::SessionHandle;
            // Friend declaration for the template function in async_utils namespace
            template <typename Stream, typename BufferType>
            friend boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> async_utils::async_io_with_timeout_impl(
                BoltPhysicalConnection* conn_obj_ptr, Stream& stream, BufferType buffers, std::chrono::milliseconds timeout_duration, const std::string& operation_name, bool is_read_operation);

            // --- Synchronous Connection Stages ---
            boltprotocol::BoltError _stage_tcp_connect();
            boltprotocol::BoltError _stage_ssl_context_setup();
            boltprotocol::BoltError _stage_ssl_handshake();
            boltprotocol::BoltError _stage_bolt_handshake();
            boltprotocol::BoltError _stage_send_hello_and_initial_auth();

            // --- Asynchronous Connection Stages ---
            boost::asio::awaitable<boltprotocol::BoltError> _stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket&>& stream, std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref,  // Pass by ref
                                                                                        std::chrono::milliseconds timeout);
            boost::asio::awaitable<boltprotocol::BoltError> _stage_send_hello_and_initial_auth_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref);  // Pass by ref

            void _prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const;
            boltprotocol::BoltError _execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure);
            // _execute_logon_message_async was primarily for use by perform_logon_async.
            // Since perform_logon_async (public) is removed, this internal one might also be re-evaluated
            // or become part of _stage_send_hello_and_initial_auth_async if Bolt >= 5.1.
            // For now, keep its signature matching previous, but its utility is reduced.
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> _execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                        std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref  // Pass by ref
            );

            // Low-level I/O (Synchronous)
            boltprotocol::BoltError _write_to_active_sync_stream(const uint8_t* data, size_t size);
            boltprotocol::BoltError _read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read);

            // Low-level I/O (Asynchronous)
            boost::asio::awaitable<boltprotocol::BoltError> _write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                          const std::vector<uint8_t>& data);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                                                            size_t size_to_read);

            // Chunking (Synchronous)
            boltprotocol::BoltError _send_chunked_payload_sync(const std::vector<uint8_t>& payload);
            boltprotocol::BoltError _receive_chunked_payload_sync(std::vector<uint8_t>& out_payload);

            // Chunking (Asynchronous)
            boost::asio::awaitable<boltprotocol::BoltError> _send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                        std::vector<uint8_t> payload);
            boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> _receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref  // Pass by ref
            );

            boltprotocol::BoltError _peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const;

            void _reset_resources_and_state(bool called_from_destructor = false);
            void _update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta);
            void _update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta);
            boltprotocol::BoltError _classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta);
            // _mark_as_defunct moved to public for friend helper, keep private section clean if desired
            std::string _get_current_state_as_string() const;

            uint64_t id_;
            BoltConnectionConfig conn_config_;
            boost::asio::io_context& io_context_ref_;
            std::shared_ptr<spdlog::logger> logger_;

            std::unique_ptr<boost::asio::ip::tcp::socket> owned_socket_for_sync_plain_;
            std::unique_ptr<boost::asio::ip::tcp::iostream> plain_iostream_wrapper_;
            std::unique_ptr<boost::asio::ssl::context> ssl_context_sync_;
            std::unique_ptr<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ssl_stream_sync_;

            std::atomic<InternalState> current_state_;
            // These are results of a connection attempt, not state of an "active" connection object
            boltprotocol::versions::Version negotiated_bolt_version_;
            std::string server_agent_string_;
            std::string server_assigned_conn_id_;  // This is the one from HELLO/LOGON success
            bool utc_patch_active_ = false;

            std::chrono::steady_clock::time_point creation_timestamp_;
            std::atomic<std::chrono::steady_clock::time_point> last_used_timestamp_;

            boltprotocol::BoltError last_error_code_ = boltprotocol::BoltError::SUCCESS;
            std::string last_error_message_;

            static std::atomic<uint64_t> next_connection_id_counter_;
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_BOLT_PHYSICAL_CONNECTION_H#ifndef NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H
#define NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H

#include <cstdint>  // For uint64_t
#include <memory>
#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "spdlog/fwd.h"                         // Forward declaration for spdlog::logger

namespace neo4j_bolt_transport {
    namespace internal {

        class IAsyncContextCallbacks {
          public:
            virtual ~IAsyncContextCallbacks() = default;

            virtual std::shared_ptr<spdlog::logger> get_logger() const = 0;
            virtual uint64_t get_id_for_logging() const = 0;                                                          // Renamed to avoid conflict if BoltPhysicalConnection has get_id() with different semantics
            virtual void mark_as_defunct_from_async(boltprotocol::BoltError reason, const std::string& message) = 0;  // Specific name for async context
            virtual boltprotocol::BoltError get_last_error_code_from_async() const = 0;                               // Specific name
        };

    }  // namespace internal
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_INTERNAL_I_ASYNC_CONTEXT_CALLBACKS_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H

#include <atomic>
#include <boost/asio/executor_work_guard.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/asio/steady_timer.hpp>  // For eviction_timer_
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include "config/transport_config.h"
#include "internal/bolt_physical_connection.h"
#include "routing/routing_table.h"
#include "routing/server_address.h"
#include "session_handle.h"
#include "uri/parsed_uri.h"

//  Boost.Asio include
// #include <boost/asio/co_spawn.hpp>
// #include <boost/asio/detached.hpp>
// #include <boost/asio/awaitable.hpp>

namespace neo4j_bolt_transport {

    namespace config {
        struct SessionParameters;
    }
    class AsyncSessionHandle;  // 

    class Neo4jBoltTransport {
      public:
        explicit Neo4jBoltTransport(config::TransportConfig config);
        ~Neo4jBoltTransport();

        Neo4jBoltTransport(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport& operator=(const Neo4jBoltTransport&) = delete;
        Neo4jBoltTransport(Neo4jBoltTransport&&) = delete;
        Neo4jBoltTransport& operator=(Neo4jBoltTransport&&) = delete;

        // --- Synchronous API ---
        boltprotocol::BoltError verify_connectivity();
        std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> acquire_session(const config::SessionParameters& params);
        void close();

        const config::TransportConfig& get_config() const {
            return config_;
        }
        boost::asio::io_context& get_io_context() {
            return io_context_;
        }

        void release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy = true);

        // --- Asynchronous API () ---
        //  boost::asio::awaitable<...>
        // AsyncSessionHandle
        //  AsyncSessionHandle 
        // boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
        // acquire_async_session(const config::SessionParameters& params);

      private:
        // ---  ---
        std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> _acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        // boost::asio::awaitable<std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection>>
        // _acquire_async_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint);

        std::pair<boltprotocol::BoltError, routing::ServerAddress> _get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint);
        std::shared_ptr<routing::RoutingTable> _get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user);
        boltprotocol::BoltError _fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update, const std::vector<routing::ServerAddress>& initial_routers_for_context, const std::string& database_name_hint, const std::optional<std::string>& impersonated_user_hint);
        void _handle_routing_failure(const routing::ServerAddress& failed_address, const std::string& database_context_key);

        void _evict_stale_connections_task();
        internal::BoltConnectionConfig _create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const;

        // 
        static std::string _make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user);

        config::TransportConfig config_;
        uri::ParsedUri parsed_initial_uri_;

        boost::asio::io_context io_context_;
        std::unique_ptr<std::thread> io_thread_;
        bool own_io_thread_ = false;
        std::unique_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> work_guard_;

        std::deque<internal::BoltPhysicalConnection::PooledConnection> idle_connections_;
        std::size_t total_connections_currently_pooled_ = 0;
        std::size_t total_connections_ever_created_ = 0;
        std::mutex pool_mutex_;
        std::condition_variable pool_condition_;
        std::atomic<bool> closing_{false};

        std::string finalized_user_agent_;
        boltprotocol::HelloMessageParams::BoltAgentInfo finalized_bolt_agent_info_;

        std::map<std::string, std::shared_ptr<routing::RoutingTable>> routing_tables_;
        std::mutex routing_table_mutex_;

        std::unique_ptr<boost::asio::steady_timer> eviction_timer_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_BOLT_TRANSPORT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H

#include <functional>  // For std::function
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For Value, SuccessMessageParams, FailureMessageParams
// BoltRecord and BoltResultStream are needed for the 'run' method's return type
#include "bolt_record.h"
#include "result_stream.h"

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // TransactionContext is passed to user-provided transaction functions (lambdas).
    // It provides methods to execute queries within the scope of the managed transaction.
    class TransactionContext {
      public:
        // Constructor taking a non-owning pointer to the SessionHandle that manages this transaction.
        // The SessionHandle must outlive the TransactionContext.
        explicit TransactionContext(SessionHandle& session);
        virtual ~TransactionContext() = default;  // Good practice for base classes if inherited

        // Executes a query within the current transaction.
        // Returns a pair: { {Error, ErrorMsg}, ResultStreamUniquePtr }.
        // The ResultStream unique_ptr is null if an error occurred before streaming could start.
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters = {}  // Default empty parameters
        );

        // Executes a query and consumes its result, returning only the summary.
        // Useful for DML statements (CREATE, MERGE, DELETE, SET).
        // Returns {Error, ErrorMsg}. out_summary and out_failure are populated.
        std::pair<boltprotocol::BoltError, std::string> run_consume(const std::string& cypher,
                                                                    const std::map<std::string, boltprotocol::Value>& parameters,  // No default for params here
                                                                    boltprotocol::SuccessMessageParams& out_summary,
                                                                    boltprotocol::FailureMessageParams& out_failure);

        // Note: A full-fledged TransactionContext in official drivers often mirrors
        // many methods of the Session object (like run, commit, rollback, close).
        // However, for the managed transaction function pattern, the Session handles
        // commit/rollback/close based on the lambda's outcome.
        // If we want the lambda to have more control, these methods could be added here,
        // and they would signal the Session to perform the action.
        // For now, we keep it to query execution.

        // boltprotocol::BoltError commit(); // Example: Signals the managing Session to commit
        // boltprotocol::BoltError rollback(); // Example: Signals the managing Session to rollback
        // bool is_open() const; // Example: Checks if the underlying transaction is still active

      private:
        SessionHandle& owner_session_;  // Non-owning reference to the session managing the transaction
    };

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return a TransactionWorkResult indicating success or application-level failure.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_CONTEXT_H#ifndef NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H
#define NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H

#include <functional>
#include <string>
#include <utility>  // For std::pair

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError

namespace neo4j_bolt_transport {

    // Forward declare TransactionContext (defined in neo4j_transaction_context.h)
    class TransactionContext;

    // Result type for transaction work: error code and detailed message string.
    using TransactionWorkResult = std::pair<boltprotocol::BoltError, std::string>;

    // Type for user-provided lambda to execute within a transaction.
    // It receives a TransactionContext to perform database operations.
    // It should return SUCCESS if work is done, or an error code + message if app logic fails.
    using TransactionWork = std::function<TransactionWorkResult(TransactionContext& tx)>;

    // REMOVED conflicting TransactionContext class definition from here.
    // The primary definition is in neo4j_transaction_context.h

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_NEO4J_TRANSACTION_WORK_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H
#define NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H

#include <deque>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "bolt_record.h"
#include "boltprotocol/message_defs.h"
#include "result_summary.h"  // <--- NEW

namespace neo4j_bolt_transport {

    class SessionHandle;  // Forward declaration

    class BoltResultStream {
      public:
        // Constructor now takes initial raw summary and connection info for typed summary
        BoltResultStream(SessionHandle* session,
                         std::optional<int64_t> query_id_for_streaming,
                         boltprotocol::SuccessMessageParams run_summary_params,  // Raw params from RUN
                         std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                         std::vector<boltprotocol::RecordMessageParams> initial_records,
                         bool server_might_have_more,
                         const boltprotocol::versions::Version& bolt_version,          // For ResultSummary
                         bool utc_patch_active,                                        // For ResultSummary
                         const std::string& server_address_for_summary,                // For ResultSummary
                         const std::optional<std::string>& database_name_for_summary,  // For ResultSummary
                         boltprotocol::BoltError initial_error = boltprotocol::BoltError::SUCCESS,
                         const std::string& initial_error_message = "",
                         const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details = std::nullopt);

        ~BoltResultStream();

        BoltResultStream(const BoltResultStream&) = delete;
        BoltResultStream& operator=(const BoltResultStream&) = delete;
        BoltResultStream(BoltResultStream&& other) noexcept;
        BoltResultStream& operator=(BoltResultStream&& other) noexcept;

        std::pair<boltprotocol::BoltError, std::string> has_next(bool& out_has_next);
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> next();
        std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> single();  // <--- NEW

        std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> list_all();
        std::tuple<boltprotocol::BoltError, std::string, ResultSummary> consume();  // <--- MODIFIED to return typed ResultSummary

        const ResultSummary& get_run_summary() const {
            return run_summary_typed_;
        }  // <--- MODIFIED
        const ResultSummary& get_final_summary() const {
            return final_summary_typed_;
        }  // <--- MODIFIED (after full consumption/discard)

        bool is_fully_consumed_or_failed() const;
        bool has_failed() const;
        boltprotocol::BoltError get_failure_reason() const;
        const std::string& get_failure_message() const;
        const boltprotocol::FailureMessageParams& get_failure_details() const;  // For raw server failure
        const std::vector<std::string>& field_names() const;

      private:
        friend class SessionHandle;
        friend class TransactionContext;

        std::pair<boltprotocol::BoltError, std::string> _fetch_more_records(int64_t n);
        std::pair<boltprotocol::BoltError, std::string> _discard_all_remaining_records();
        void _set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details = std::nullopt);
        void _update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary);

        SessionHandle* owner_session_;
        std::optional<int64_t> query_id_;

        std::deque<boltprotocol::RecordMessageParams> raw_record_buffer_;
        std::shared_ptr<const std::vector<std::string>> field_names_ptr_cache_;

        ResultSummary run_summary_typed_;    // Summary from RUN message (available immediately)
        ResultSummary final_summary_typed_;  // Summary from final PULL/DISCARD (available after consumption)
                                             // This needs careful initialization.

        boltprotocol::FailureMessageParams failure_details_raw_;  // Store raw failure

        bool server_has_more_records_ = false;
        bool initial_server_has_more_records_ = false;
        bool stream_fully_consumed_or_discarded_ = false;
        bool stream_failed_ = false;
        boltprotocol::BoltError failure_reason_ = boltprotocol::BoltError::SUCCESS;
        std::string failure_message_;
        bool is_first_pull_attempt_ = true;

        // For ResultSummary creation
        boltprotocol::versions::Version bolt_version_cache_;
        bool utc_patch_active_cache_;
        std::string server_address_cache_;
        std::optional<std::string> database_name_cache_;
    };

    // Inline simple getters
    inline bool BoltResultStream::is_fully_consumed_or_failed() const {
        return stream_fully_consumed_or_discarded_ || stream_failed_;
    }
    inline bool BoltResultStream::has_failed() const {
        return stream_failed_;
    }
    inline boltprotocol::BoltError BoltResultStream::get_failure_reason() const {
        return failure_reason_;
    }
    inline const std::string& BoltResultStream::get_failure_message() const {
        return failure_message_;
    }
    inline const boltprotocol::FailureMessageParams& BoltResultStream::get_failure_details() const {
        return failure_details_raw_;
    }

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_STREAM_H#ifndef NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H
#define NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For SuccessMessageParams, Value, Version

namespace neo4j_bolt_transport {

    // Forward declarations for Plan, ProfiledPlan, Notification if they become complex classes
    // struct Plan;
    // struct ProfiledPlan;
    // struct Notification;

    struct QueryCounters {
        int64_t nodes_created = 0;
        int64_t nodes_deleted = 0;
        int64_t relationships_created = 0;
        int64_t relationships_deleted = 0;
        int64_t properties_set = 0;
        int64_t labels_added = 0;
        int64_t labels_removed = 0;
        int64_t indexes_added = 0;
        int64_t indexes_removed = 0;
        int64_t constraints_added = 0;
        int64_t constraints_removed = 0;
        bool contains_updates = false;
        bool contains_system_updates = false;
        int64_t system_updates = 0;

        QueryCounters() = default;
    };

    enum class QueryType { UNKNOWN, READ_ONLY, READ_WRITE, WRITE_ONLY, SCHEMA_WRITE };

    // Simplified notification structure
    struct ServerNotification {
        std::string code;
        std::string title;
        std::string description;
        std::optional<std::map<std::string, boltprotocol::Value>> position;  // e.g., {"offset": <int>, "line": <int>, "column": <int>}
        std::string severity;                                                // e.g., "WARNING", "INFORMATION"
        std::string category;                                                // e.g., "HINT", "UNRECOGNIZED" (Bolt 5.2+)

        ServerNotification() = default;
    };

    class ResultSummary {
      public:
        // Constructor takes the raw success message params and connection info
        ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params,
                      const boltprotocol::versions::Version& bolt_version,
                      bool utc_patch_active,
                      const std::string& server_address,                            // Address of the server that executed the query
                      const std::optional<std::string>& database_name_from_session  // DB name from session config
        );

        const boltprotocol::SuccessMessageParams& raw_params() const {
            return raw_params_;
        }

        QueryType query_type() const {
            return query_type_;
        }
        const QueryCounters& counters() const {
            return counters_;
        }

        const std::string& server_address() const {
            return server_address_;
        }
        const std::string& database_name() const {
            return database_name_;
        }  // Effective DB name for the query

        std::optional<std::chrono::milliseconds> result_available_after() const {
            return result_available_after_ms_;
        }
        std::optional<std::chrono::milliseconds> result_consumed_after() const {
            return result_consumed_after_ms_;
        }

        const std::vector<ServerNotification>& notifications() const {
            return notifications_;
        }

        // std::optional<Plan> plan() const; // TODO if Plan parsing is added
        // std::optional<ProfiledPlan> profiled_plan() const; // TODO if ProfiledPlan parsing is added

      private:
        void parse_metadata(const boltprotocol::versions::Version& bolt_version, bool utc_patch_active);
        void parse_query_type(const boltprotocol::Value& type_val);
        void parse_counters(const boltprotocol::Value& counters_val);
        void parse_notifications(const boltprotocol::Value& notifications_val, const boltprotocol::versions::Version& bolt_version);

        boltprotocol::SuccessMessageParams raw_params_;
        QueryType query_type_ = QueryType::UNKNOWN;
        QueryCounters counters_;
        std::vector<ServerNotification> notifications_;

        std::string server_address_;  // Server that executed the query
        std::string database_name_;   // Effective database for the query

        std::optional<std::chrono::milliseconds> result_available_after_ms_;
        std::optional<std::chrono::milliseconds> result_consumed_after_ms_;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_RESULT_SUMMARY_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H

#include <atomic>
#include <chrono>
#include <mutex>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError (used in status)
#include "server_address.h"

namespace neo4j_bolt_transport {
    namespace routing {

        enum class ServerRole { ROUTER, READER, WRITER };

        class RoutingTable {
          public:
            RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds);

            // Tries to get a server for the given role.
            // Returns nullopt if no suitable server or table is stale.
            std::optional<ServerAddress> get_server(ServerRole role);

            // Updates the table with new data from a ROUTE message response.
            // Returns BoltError::SUCCESS or an error code if parsing fails.
            boltprotocol::BoltError update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds);

            bool is_stale() const;
            void mark_as_stale();  // Forcefully mark as stale, e.g., after a connection error

            const std::string& get_database_context_key() const {
                return database_context_key_;
            }
            const std::vector<ServerAddress>& get_routers() const;

            // Remove a server from all lists (e.g., if it becomes unreachable)
            void forget_server(const ServerAddress& address);

          private:
            std::string database_context_key_;  // e.g., "mydatabase@user" or "system"
            std::vector<ServerAddress> routers_;
            std::vector<ServerAddress> readers_;
            std::vector<ServerAddress> writers_;

            std::chrono::steady_clock::time_point last_updated_time_;
            std::chrono::seconds ttl_;

            std::atomic<std::size_t> next_reader_index_ = 0;
            std::atomic<std::size_t> next_writer_index_ = 0;
            std::atomic<std::size_t> next_router_index_ = 0;  // For trying different routers

            mutable std::mutex mutex_;  // Protects access to server lists and indices
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_ROUTING_TABLE_H#ifndef NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H
#define NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H

#include <cstdint>
#include <functional>  // For std::hash
#include <string>

namespace neo4j_bolt_transport {
    namespace routing {

        struct ServerAddress {
            std::string host;
            std::uint16_t port;

            ServerAddress(std::string h = "", std::uint16_t p = 0) : host(std::move(h)), port(p) {
            }

            bool operator==(const ServerAddress& other) const {
                return host == other.host && port == other.port;
            }

            bool operator<(const ServerAddress& other) const {
                if (host != other.host) {
                    return host < other.host;
                }
                return port < other.port;
            }

            std::string to_string() const {
                return host + ":" + std::to_string(port);
            }
        };

    }  // namespace routing
}  // namespace neo4j_bolt_transport

namespace std {
    template <>
    struct hash<neo4j_bolt_transport::routing::ServerAddress> {
        size_t operator()(const neo4j_bolt_transport::routing::ServerAddress& addr) const noexcept {
            size_t h1 = std::hash<std::string>{}(addr.host);
            size_t h2 = std::hash<std::uint16_t>{}(addr.port);
            return h1 ^ (h2 << 1);  // Basic combination
        }
    };
}  // namespace std

#endif  // NEO4J_BOLT_TRANSPORT_ROUTING_SERVER_ADDRESS_H#ifndef NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H
#define NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H

#include <chrono>
#include <deque>
#include <map>  // For parameters
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "config/session_parameters.h"
#include "internal/bolt_physical_connection.h"
#include "neo4j_transaction_work.h"
#include "result_stream.h"  // Includes ResultSummary transitively

namespace neo4j_bolt_transport {

    class Neo4jBoltTransport;  // Forward declaration

    struct TransactionConfigOverrides {  // New struct for clarity
        std::optional<std::map<std::string, boltprotocol::Value>> metadata;
        std::optional<std::chrono::milliseconds> timeout;
    };

    class SessionHandle {
      public:
        SessionHandle(Neo4jBoltTransport* transport_manager, internal::BoltPhysicalConnection::PooledConnection connection, config::SessionParameters params);
        ~SessionHandle();

        SessionHandle(const SessionHandle&) = delete;
        SessionHandle& operator=(const SessionHandle&) = delete;
        SessionHandle(SessionHandle&& other) noexcept;
        SessionHandle& operator=(SessionHandle&& other) noexcept;

        // --- Explicit Transaction Management ---
        std::pair<boltprotocol::BoltError, std::string> begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt,
                                                                          const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt  // Already present
        );
        std::pair<boltprotocol::BoltError, std::string> commit_transaction();
        std::pair<boltprotocol::BoltError, std::string> rollback_transaction();
        bool is_in_transaction() const {
            return in_explicit_transaction_;
        }

        // --- Managed Transaction Functions ---
        TransactionWorkResult execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);
        TransactionWorkResult execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata = std::nullopt, const std::optional<std::chrono::milliseconds>& tx_timeout = std::nullopt);

        // --- Query Execution (Auto-commit transactions) ---
        std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> run_query(const std::string& cypher,
                                                                                                                const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                                                const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> run_query_and_consume(const std::string& cypher,
                                                                                                        const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                        const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        std::pair<boltprotocol::BoltError, std::string> run_query_without_result(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters = {},
                                                                                 const std::optional<TransactionConfigOverrides>& tx_config_overrides = std::nullopt  // Replaced tx_metadata_override
        );

        const std::vector<std::string>& get_last_bookmarks() const;
        void update_bookmarks(const std::vector<std::string>& new_bookmarks);

        void close();
        bool is_closed() const {
            return is_closed_;
        }
        bool is_connection_valid() const {
            return connection_is_valid_;
        }

        friend class BoltResultStream;
        friend class TransactionContext;

      private:
        std::pair<boltprotocol::BoltError, std::string> _prepare_auto_commit_run(const std::string& cypher,
                                                                                 const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                 const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,  // Kept for RunMessageParams
                                                                                 const std::optional<std::chrono::milliseconds>& tx_timeout,                    // Kept for RunMessageParams
                                                                                 boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                 boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw);

        std::pair<boltprotocol::BoltError, std::string> _stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw);
        std::pair<boltprotocol::BoltError, std::string> _stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw);

        void _release_connection_to_pool(bool mark_healthy = true);
        void _invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message);
        internal::BoltPhysicalConnection* _get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context);

        TransactionWorkResult _execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout);

        Neo4jBoltTransport* transport_manager_;
        internal::BoltPhysicalConnection::PooledConnection connection_;
        config::SessionParameters session_params_;

        bool in_explicit_transaction_ = false;
        std::optional<int64_t> current_transaction_query_id_;

        std::vector<std::string> current_bookmarks_;
        bool is_closed_ = false;
        bool connection_is_valid_ = true;
    };

}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_SESSION_HANDLE_H#ifndef NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H
#define NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H

#include <cstdint>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace neo4j_bolt_transport {
    namespace uri {

        // Holds the deconstructed parts of a Neo4j connection URI.
        struct ParsedUri {
            std::string input_uri;
            std::string scheme;

            // For non-routing schemes, hosts will contain one entry.
            // For routing schemes (neo4j://, neo4j+s://), hosts can contain multiple seed router addresses.
            std::vector<std::pair<std::string, uint16_t>> hosts_with_ports;

            // Userinfo extracted from URI (if present)
            std::optional<std::string> username_from_uri;
            std::optional<std::string> password_from_uri;

            // Query parameters from the URI
            std::map<std::string, std::string> query_parameters;

            // Interpretation of the scheme
            bool is_valid = false;
            bool is_routing_scheme = false;
            bool tls_enabled_by_scheme = false;
            enum class SchemeTrustStrategy {
                NONE,            // e.g. bolt, neo4j (depends on server default or further config)
                SYSTEM_CAS,      // e.g. bolt+s, neo4j+s
                TRUST_ALL_CERTS  // e.g. bolt+ssc, neo4j+ssc (discouraged)
            };
            SchemeTrustStrategy trust_strategy_hint = SchemeTrustStrategy::NONE;

            // Standard default ports
            static constexpr uint16_t DEFAULT_BOLT_PORT = 7687;
            // Neo4j typically uses the same port for TLS-enabled Bolt (server-side config)
            static constexpr uint16_t DEFAULT_BOLTS_PORT = 7687;
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_PARSED_URI_H#ifndef NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H
#define NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H

#include <string>

#include "boltprotocol/bolt_errors_versions.h"  // For BoltError
#include "parsed_uri.h"

namespace neo4j_bolt_transport {
    namespace uri {

        class UriParser {
          public:
            UriParser() = delete;  // Static methods only

            // Parses the given URI string and populates the ParsedUri struct.
            // Returns BoltError::SUCCESS on success, or an error code if parsing fails.
            static boltprotocol::BoltError parse(const std::string& uri_string, ParsedUri& out_parsed_uri);
        };

    }  // namespace uri
}  // namespace neo4j_bolt_transport

#endif  // NEO4J_BOLT_TRANSPORT_URI_URI_PARSER_H#include "neo4j_bolt_transport/bolt_record.h"

namespace neo4j_bolt_transport {

    BoltRecord::BoltRecord(std::vector<boltprotocol::Value>&& fields_data, std::shared_ptr<const std::vector<std::string>> names_ptr) : fields_(std::move(fields_data)), field_names_ptr_(std::move(names_ptr)) {
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(size_t index) const {
        if (index >= fields_.size()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Or a more specific "IndexOutOfBounds"
        }
        // Return a copy of the Value, or handle lifetime if Value contains non-copyable shared_ptrs carefully.
        // std::variant copy semantics should handle this correctly.
        return {boltprotocol::BoltError::SUCCESS, fields_[index]};
    }

    std::pair<boltprotocol::BoltError, boltprotocol::Value> BoltRecord::get(const std::string& field_name) const {
        if (!field_names_ptr_ || field_names_ptr_->empty()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // No field names available
        }
        // Could optimize with a cached map if records are accessed by name frequently
        for (size_t i = 0; i < field_names_ptr_->size(); ++i) {
            if ((*field_names_ptr_)[i] == field_name) {
                if (i < fields_.size()) {  // Should always be true if names match fields
                    return {boltprotocol::BoltError::SUCCESS, fields_[i]};
                } else {
                    // This indicates an internal inconsistency (more names than fields)
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
            }
        }
        return {boltprotocol::BoltError::INVALID_ARGUMENT, nullptr};  // Field name not found
    }

    const std::vector<std::string>& BoltRecord::field_names() const {
        static const std::vector<std::string> empty_field_names;  // For returning if no names ptr
        if (field_names_ptr_) {
            return *field_names_ptr_;
        }
        return empty_field_names;
    }

    // Template method implementations are in the header due to template instantiation.

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/auth_token.h"

namespace neo4j_bolt_transport {
    namespace config {

        AuthTokenVariant AuthTokens::none() {
            return NoAuth{};
        }

        AuthTokenVariant AuthTokens::basic(const std::string& username, const std::string& password, const std::optional<std::string>& realm) {
            return BasicAuth{username, password, realm};
        }

        AuthTokenVariant AuthTokens::kerberos(const std::string& base64_ticket) {
            return KerberosAuth{base64_ticket};
        }

        AuthTokenVariant AuthTokens::bearer(const std::string& token) {
            return BearerAuth{token};
        }

        AuthTokenVariant AuthTokens::custom(const std::string& principal, const std::string& credentials, const std::optional<std::string>& realm, const std::string& scheme, const std::optional<std::map<std::string, boltprotocol::Value>>& parameters) {
            return CustomAuth{principal, credentials, realm, scheme, parameters};
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/transport_config.h"

#include <iostream>

#include "boltprotocol/bolt_errors_versions.h"  // For default versions
#include "neo4j_bolt_transport/uri/parsed_uri.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {
    namespace config {

        TransportConfig::TransportConfig(const std::string& a_uri_string) : uri_string(a_uri_string.empty() ? "bolt://localhost:7687" : a_uri_string) {
            uri::ParsedUri parsed_uri_info;
            if (uri::UriParser::parse(uri_string, parsed_uri_info) == boltprotocol::BoltError::SUCCESS) {
                apply_parsed_uri_settings(parsed_uri_info);
            } else {
                if (logger) {
                    logger->error("Failed to parse URI '{}' during TransportConfig construction. Using defaults where possible.", uri_string);
                } else {
                    std::cerr << "Error: Failed to parse URI '" << uri_string << "' during TransportConfig construction." << std::endl;
                }
            }
            if (preferred_bolt_versions.empty()) {
                preferred_bolt_versions = boltprotocol::versions::get_default_proposed_versions();
            }
            prepare_agent_strings();          // Call prepare_agent_strings before get_or_create_logger
            logger = get_or_create_logger();  // Ensure logger is initialized
        }

        TransportConfig::TransportConfig() : TransportConfig("bolt://localhost:7687") {
        }

        boltprotocol::BoltError TransportConfig::apply_parsed_uri_settings(const uri::ParsedUri& parsed_uri) {
            if (!parsed_uri.is_valid) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            if (encryption_strategy == EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME) {
                if (parsed_uri.tls_enabled_by_scheme) {
                    if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::SYSTEM_CAS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    } else if (parsed_uri.trust_strategy_hint == uri::ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS) {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS;
                    } else {
                        encryption_strategy = EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS;
                    }
                } else {
                    encryption_strategy = EncryptionStrategy::FORCE_PLAINTEXT;
                }
            }

            if (!parsed_uri.is_routing_scheme) {
                client_side_routing_enabled = false;
            }

            if (std::holds_alternative<NoAuth>(auth_token)) {
                if (parsed_uri.username_from_uri.has_value()) {
                    auth_token = AuthTokens::basic(parsed_uri.username_from_uri.value(), parsed_uri.password_from_uri.value_or(""), std::nullopt);
                }
            }

            if (client_side_routing_enabled && initial_router_addresses_override.empty() && !parsed_uri.hosts_with_ports.empty()) {
                std::string initial_context_key = parsed_uri.scheme + "://";
                if (!parsed_uri.hosts_with_ports.empty()) {
                    initial_context_key += parsed_uri.hosts_with_ports.front().first;  // Simplified context key
                }

                std::vector<routing::ServerAddress> initial_routers;
                for (const auto& host_port_pair : parsed_uri.hosts_with_ports) {
                    initial_routers.emplace_back(host_port_pair.first, host_port_pair.second);
                }
                initial_router_addresses_override[initial_context_key] = initial_routers;
            }

            auto it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout");  // Renamed in spec sometimes
            if (it_conn_timeout == parsed_uri.query_parameters.end()) {                     // try alternative name
                it_conn_timeout = parsed_uri.query_parameters.find("connection_timeout_ms");
            }
            if (it_conn_timeout != parsed_uri.query_parameters.end()) {
                try {
                    tcp_connect_timeout_ms = static_cast<uint32_t>(std::stoul(it_conn_timeout->second));
                } catch (const std::exception&) { /* ignore invalid param */
                }
            }

            auto it_max_retry_time = parsed_uri.query_parameters.find("max_transaction_retry_time");
            if (it_max_retry_time != parsed_uri.query_parameters.end()) {
                try {
                    // Assuming time is in ms if specified like "15s" or "15000ms" this needs parsing logic
                    // For simplicity, assume it's just ms for now if it's a number
                    max_transaction_retry_time_ms = static_cast<uint32_t>(std::stoul(it_max_retry_time->second));
                } catch (const std::exception&) { /* ignore */
                }
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        void TransportConfig::prepare_agent_strings(const std::string& default_transport_name_version) {
            if (bolt_agent_info.product.empty()) {
                bolt_agent_info.product = default_transport_name_version;
            }
        }

        std::shared_ptr<spdlog::logger> TransportConfig::get_or_create_logger(const std::string& logger_name) {
            if (logger) {
                logger->set_level(log_level);
                return logger;
            }
            auto default_logger = spdlog::get(logger_name);
            if (!default_logger) {
                try {
                    default_logger = spdlog::stdout_color_mt(logger_name);                            // Or any other default sink
                    default_logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%n] [tid %t] %v");  // Added thread id
                    default_logger->set_level(log_level);
                } catch (const spdlog::spdlog_ex& ex) {
                    std::cerr << "Logger (" << logger_name << ") initialization failed: " << ex.what() << std::endl;
                    return nullptr;  // Or throw
                }
            } else {
                default_logger->set_level(log_level);
            }
            return default_logger;
        }

    }  // namespace config
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // For MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_send_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref,  // Pass by ref
                                                                                                            std::vector<uint8_t> payload) {                                                                                            // Take payload by value

            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async send chunked payload on defunct connection.", id_);
                co_return last_error_code_;
            }

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            std::vector<uint8_t> chunk_header_bytes(boltprotocol::CHUNK_HEADER_SIZE);

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);
                std::memcpy(chunk_header_bytes.data(), &chunk_size_be, boltprotocol::CHUNK_HEADER_SIZE);

                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                // Create a vector for the current chunk's data to pass to _write_to_active_async_stream
                // This involves a copy, but ensures data is valid for the async op.
                std::vector<uint8_t> current_chunk_data(data_ptr, data_ptr + chunk_size);
                err = co_await _write_to_active_async_stream(stream_variant_ref, current_chunk_data);
                if (err != boltprotocol::BoltError::SUCCESS) break;

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                std::memcpy(chunk_header_bytes.data(), &zero_chunk_be, boltprotocol::CHUNK_HEADER_SIZE);
                err = co_await _write_to_active_async_stream(stream_variant_ref, chunk_header_bytes);
            }

            co_return err;  // _write_to_active_async_stream calls _mark_as_defunct on error.
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_receive_chunked_payload_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref) {  // Pass by ref
            std::vector<uint8_t> out_payload_vec;
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncChunking {}] Async receive chunked payload on defunct connection.", id_);
                co_return {last_error_code_, {}};
            }

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;
            std::pair<boltprotocol::BoltError, std::vector<uint8_t>> read_result;

            while (true) {
                read_result = co_await _read_from_active_async_stream(stream_variant_ref, boltprotocol::CHUNK_HEADER_SIZE);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& header_bytes = read_result.second;
                if (header_bytes.size() != boltprotocol::CHUNK_HEADER_SIZE) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    _mark_as_defunct(err, "Async receive chunk header: incorrect size read.");
                    break;
                }
                uint16_t chunk_size_be;
                std::memcpy(&chunk_size_be, header_bytes.data(), boltprotocol::CHUNK_HEADER_SIZE);
                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {  // End of message
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Async received chunk larger than max: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->error("[ConnAsyncChunking {}] {}", id_, msg);
                    break;
                }

                read_result = co_await _read_from_active_async_stream(stream_variant_ref, chunk_payload_size);
                err = read_result.first;
                if (err != boltprotocol::BoltError::SUCCESS) break;

                const auto& chunk_data = read_result.second;
                if (chunk_data.size() != chunk_payload_size) {
                    err = boltprotocol::BoltError::NETWORK_ERROR;
                    _mark_as_defunct(err, "Async receive chunk payload: incorrect size read.");
                    break;
                }
                try {
                    out_payload_vec.insert(out_payload_vec.end(), chunk_data.begin(), chunk_data.end());
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory appending async chunk to payload buffer.";
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->critical("[ConnAsyncChunking {}] {}", id_, msg);
                    break;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                co_return {err, {}};
            } else if (total_bytes_read_for_message == 0 && out_payload_vec.empty()) {
                if (logger_) logger_->trace("[ConnAsyncChunking {}] Async received NOOP message.", id_);
            }
            co_return {boltprotocol::BoltError::SUCCESS, std::move(out_payload_vec)};
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>            // For std::min with chunking
#include <boost/asio/post.hpp>  // For yielding in timeout helper
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>  // For std::memcpy
#include <iostream>
#include <optional>  // For std::optional in timeout helper
#include <variant>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_utils.h"  // Include the async_utils header
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_write_to_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, const std::vector<uint8_t>& data) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async write on defunct connection.", id_);
                co_return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (data.empty()) {
                co_return boltprotocol::BoltError::SUCCESS;
            }

            std::chrono::milliseconds timeout(conn_config_.socket_write_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Write {} bytes. Timeout: {}ms", id_, data.size(), timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async write: stream_ptr in variant is null.", id_);
                        co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // Pass 'this' as BoltPhysicalConnection* for the first argument of async_io_with_timeout_impl
                    co_return co_await async_utils::async_io_with_timeout_impl(this, *stream_ptr, boost::asio::buffer(data), timeout, "Async Write", false);
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                // _mark_as_defunct is called within async_utils::async_io_with_timeout_impl if ec is set
                co_return last_error_code_;
            }
            if (result.second != data.size()) {
                std::string msg = "Partial async write. Expected " + std::to_string(data.size()) + ", wrote " + std::to_string(result.second);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", id_, msg);
                co_return last_error_code_;
            }
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::vector<uint8_t>>> BoltPhysicalConnection::_read_from_active_async_stream(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& stream_variant_ref, size_t size_to_read) {
            if (is_defunct()) {
                if (logger_) logger_->warn("[ConnAsyncIO {}] Async read on defunct connection.", id_);
                co_return {last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, {}};
            }
            if (size_to_read == 0) {
                co_return {boltprotocol::BoltError::SUCCESS, {}};
            }

            std::vector<uint8_t> buffer_vec(size_to_read);
            std::chrono::milliseconds timeout(conn_config_.socket_read_timeout_ms);
            if (logger_) logger_->trace("[ConnAsyncIO {}] Async Read {} bytes. Timeout: {}ms", id_, size_to_read, timeout.count());

            std::pair<boltprotocol::BoltError, std::size_t> result;
            result = co_await std::visit(
                [&](auto* stream_ptr) -> boost::asio::awaitable<std::pair<boltprotocol::BoltError, std::size_t>> {
                    if (!stream_ptr) {
                        if (logger_) logger_->error("[ConnAsyncIO {}] Async read: stream_ptr in variant is null.", id_);
                        co_return {boltprotocol::BoltError::INVALID_ARGUMENT, 0};
                    }
                    // Pass 'this' as BoltPhysicalConnection*
                    co_return co_await async_utils::async_io_with_timeout_impl(this, *stream_ptr, boost::asio::buffer(buffer_vec), timeout, "Async Read", true);
                },
                stream_variant_ref);

            if (result.first != boltprotocol::BoltError::SUCCESS) {
                co_return {last_error_code_, {}};
            }
            if (result.second < size_to_read) {
                std::string msg = "Incomplete async read. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(result.second);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnAsyncIO {}] {}", id_, msg);
                co_return {last_error_code_, {}};
            }
            co_return {boltprotocol::BoltError::SUCCESS, std::move(buffer_vec)};
        }
    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <iostream>
#include <variant>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_prepare_logon_params_from_config(boltprotocol::LogonMessageParams& out_params) const {
            out_params.auth_tokens.clear();
            std::visit(
                [&](auto&& arg) {
                    using T = std::decay_t<decltype(arg)>;
                    if constexpr (std::is_same_v<T, config::BasicAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("basic");
                        out_params.auth_tokens["principal"] = arg.username;
                        out_params.auth_tokens["credentials"] = arg.password;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                    } else if constexpr (std::is_same_v<T, config::BearerAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("bearer");
                        out_params.auth_tokens["credentials"] = arg.token;
                    } else if constexpr (std::is_same_v<T, config::KerberosAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("kerberos");
                        out_params.auth_tokens["credentials"] = arg.base64_ticket;
                    } else if constexpr (std::is_same_v<T, config::CustomAuth>) {
                        out_params.auth_tokens["scheme"] = arg.scheme;
                        out_params.auth_tokens["principal"] = arg.principal;
                        out_params.auth_tokens["credentials"] = arg.credentials;
                        if (arg.realm) out_params.auth_tokens["realm"] = *arg.realm;
                        if (arg.parameters) {
                            for (const auto& pair : *arg.parameters) {
                                if (pair.first != "scheme" && pair.first != "principal" && pair.first != "credentials" && pair.first != "realm") {
                                    out_params.auth_tokens[pair.first] = pair.second;
                                }
                            }
                        }
                    } else if constexpr (std::is_same_v<T, config::NoAuth>) {
                        out_params.auth_tokens["scheme"] = std::string("none");
                    }
                },
                conn_config_.auth_token);
        }

        boltprotocol::BoltError BoltPhysicalConnection::_execute_logon_message(const boltprotocol::LogonMessageParams& params, boltprotocol::SuccessMessageParams& out_success, boltprotocol::FailureMessageParams& out_failure) {
            InternalState state_before_logon = current_state_.load();
            if (state_before_logon != InternalState::HELLO_AUTH_SENT && state_before_logon != InternalState::READY && state_before_logon != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, "LOGON executed in invalid state: " + _get_current_state_as_string());
                if (logger_) logger_->error("[ConnAuth {}] LOGON in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }

            std::vector<uint8_t> logon_payload;
            boltprotocol::PackStreamWriter ps_writer(logon_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnAuth {}] Sending LOGON message (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            err = send_request_receive_summary(logon_payload, out_success, out_failure);

            if (err == boltprotocol::BoltError::SUCCESS) {
                if (last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                    _update_metadata_from_logon_success(out_success);
                    if (current_state_.load() != InternalState::DEFUNCT) {
                        current_state_.store(InternalState::READY);
                    }
                    if (logger_) logger_->info("[ConnAuth {}] LOGON successful.", id_);
                } else {
                    if (logger_) logger_->warn("[ConnAuth {}] LOGON server response not SUCCESS. Code: {}, Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                }
            } else {
                if (logger_) logger_->error("[ConnAuth {}] LOGON message send/receive summary failed. Error: {}", id_, static_cast<int>(err));
            }
            return last_error_code_;
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logon(const boltprotocol::LogonMessageParams& logon_params, boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGON message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }

            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::READY && current_s != InternalState::BOLT_HANDSHAKEN) {
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, "perform_logon called in invalid state " + _get_current_state_as_string());
                if (logger_) logger_->warn("[ConnAuth {}] perform_logon in invalid state {}", id_, _get_current_state_as_string());
                return last_error_code_;
            }
            mark_as_used();

            boltprotocol::FailureMessageParams ignored_failure_details;
            return _execute_logon_message(logon_params, out_success, ignored_failure_details);
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_logoff(boltprotocol::SuccessMessageParams& out_success) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                last_error_code_ = boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
                last_error_message_ = "LOGOFF message not supported in Bolt version < 5.1";
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, last_error_message_);
                return last_error_code_;
            }
            if (!is_ready_for_queries()) {
                std::string msg = "perform_logoff called when connection not ready. Current state: " + _get_current_state_as_string();
                if (logger_) logger_->warn("[ConnAuth {}] {}", id_, msg);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuth {}] Performing LOGOFF.", id_);

            std::vector<uint8_t> logoff_payload;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuth {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                return last_error_code_;
            }

            boltprotocol::FailureMessageParams ignored_failure_details;
            err = send_request_receive_summary(logoff_payload, out_success, ignored_failure_details);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->info("[ConnAuth {}] LOGOFF successful.", id_);
                if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {  // Pre-5.1, LOGOFF means state goes back to HELLO_AUTH_SENT (if HELLO was used for auth)
                    current_state_.store(InternalState::HELLO_AUTH_SENT);
                } else {  // Bolt 5.1+, LOGOFF returns to BOLT_HANDSHAKEN (or ASYNC_BOLT_HANDSHAKEN) state
                    current_state_.store(InternalState::BOLT_HANDSHAKEN);
                }
            } else {
                if (logger_) logger_->warn("[ConnAuth {}] LOGOFF failed. Error: {}, Server Msg: {}", id_, static_cast<int>(err), last_error_message_);
            }
            return last_error_code_;
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::_execute_logon_message_async(boltprotocol::LogonMessageParams params,
                                                                                                                                                            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref  // Pass by ref
        ) {
            if (logger_) logger_->debug("[ConnAuthAsync {}] Executing LOGON message async (scheme: {}).", id_, params.auth_tokens.count("scheme") ? std::get<std::string>(params.auth_tokens.at("scheme")) : "unknown");

            // Check if the variant holds a valid stream pointer
            bool stream_valid = std::visit(
                [](auto* stream_ptr) {
                    return stream_ptr != nullptr && stream_ptr->lowest_layer().is_open();
                },
                async_stream_variant_ref);
            if (!stream_valid) {
                if (logger_) logger_->error("[ConnAuthAsync {}] _execute_logon_message_async: No valid async stream provided.", id_);
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "_execute_logon_message_async: No valid async stream provided.");
                co_return {last_error_code_, {}};
            }

            std::vector<uint8_t> logon_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logon_payload_storage);

            boltprotocol::BoltError err = boltprotocol::serialize_logon_message(params, ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Async LOGON serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGON serialization failed: {}", id_, static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            // Send LOGON and receive summary (placeholder for send_request_receive_summary_async)
            auto [send_err, chunk_send_result] = co_await _send_chunked_payload_async(async_stream_variant_ref, std::move(logon_payload_storage));
            if (send_err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON send failed: {}", id_, static_cast<int>(send_err));
                // _mark_as_defunct should be called by _send_chunked_payload_async
                co_return {last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;  // Not directly used in return but needed for deserialize
            boltprotocol::BoltError summary_err = boltprotocol::BoltError::UNKNOWN_ERROR;

            // Loop to receive summary, skipping NOOPs
            while (true) {
                auto [recv_err, response_payload] = co_await _receive_chunked_payload_async(async_stream_variant_ref);
                if (recv_err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGON receive summary failed: {}", id_, static_cast<int>(recv_err));
                    summary_err = last_error_code_;  // _receive_chunked_payload_async marks defunct
                    break;
                }
                if (response_payload.empty()) {  // NOOP
                    if (logger_) logger_->trace("[ConnAuthAsync {}] Received NOOP while awaiting LOGON summary.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                boltprotocol::BoltError peek_err = _peek_message_tag(response_payload, tag);
                if (peek_err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(peek_err, "Async LOGON: Failed to peek tag for summary response.");
                    summary_err = last_error_code_;
                    break;
                }

                boltprotocol::PackStreamReader reader(response_payload);
                if (tag == boltprotocol::MessageTag::SUCCESS) {
                    summary_err = boltprotocol::deserialize_success_message(reader, success_meta);
                    if (summary_err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(summary_err, "Async LOGON: Failed to deserialize SUCCESS summary.");
                        summary_err = last_error_code_;
                    }
                    // else last_error_code_ remains/becomes SUCCESS
                    break;
                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    boltprotocol::BoltError deser_fail_err = boltprotocol::deserialize_failure_message(reader, failure_meta);
                    if (deser_fail_err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(deser_fail_err, "Async LOGON: Failed to deserialize FAILURE summary.");
                        summary_err = last_error_code_;
                    } else {
                        summary_err = _classify_and_set_server_failure(failure_meta);  // This sets last_error_code_
                    }
                    break;
                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    // IGNORED for LOGON is unexpected and likely an error condition or server misbehavior.
                    // Treat as failure.
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Received IGNORED instead of SUCCESS/FAILURE.");
                    summary_err = last_error_code_;
                    break;
                } else {
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Async LOGON: Unexpected message tag " + std::to_string(static_cast<int>(tag)) + " for summary.");
                    summary_err = last_error_code_;
                    break;
                }
            }

            if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                _update_metadata_from_logon_success(success_meta);
                if (current_state_.load() != InternalState::DEFUNCT) {
                    current_state_.store(InternalState::ASYNC_READY);  // Or READY if not distinguishing
                }
                if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGON successful.", id_);
                co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            } else {
                if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGON server response not SUCCESS. Final Error: {}, Server/Conn Msg: {}", id_, static_cast<int>(last_error_code_), last_error_message_);
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logon_async(boltprotocol::LogonMessageParams logon_params) {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async: LOGON not supported in Bolt < 5.1", id_);
                co_return std::make_pair(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, boltprotocol::SuccessMessageParams{});
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::ASYNC_HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN && current_s != InternalState::ASYNC_BOLT_HANDSHAKEN &&  // Added ASYNC_BOLT_HANDSHAKEN
                current_s != InternalState::READY && current_s != InternalState::ASYNC_READY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logon_async in invalid state {}", id_, _get_current_state_as_string());
                co_return std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, boltprotocol::SuccessMessageParams{});
            }
            mark_as_used();

            // CRITICAL: This method needs access to the *active asynchronous stream*
            // that was established by establish_async. This is now passed as a parameter to _execute_logon_message_async.
            // The caller (e.g., establish_async or a higher-level async session object) must provide this.
            // For now, this method cannot directly call _execute_logon_message_async without it.
            // This implies perform_logon_async needs to be called from a context that has the ActiveAsyncStreamContext.

            if (logger_) logger_->error("[ConnAuthAsync {}] perform_logon_async cannot be called directly on BoltPhysicalConnection without an active async stream context. This method should be part of an async flow that manages the stream.", id_);
            co_return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            // Example of how it might be called if stream was available:
            // ActiveAsyncStreamContext& active_ctx = ... get from somewhere ...
            // co_return co_await _execute_logon_message_async(std::move(logon_params), active_ctx.stream_variant_ref_for_internal_use_only_or_similar);
        }

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, boltprotocol::SuccessMessageParams>> BoltPhysicalConnection::perform_logoff_async() {
            if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async: LOGOFF not supported in Bolt < 5.1", id_);
                co_return std::make_pair(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, boltprotocol::SuccessMessageParams{});
            }
            InternalState current_s = current_state_.load();
            if (current_s != InternalState::READY && current_s != InternalState::ASYNC_READY && current_s != InternalState::ASYNC_STREAMING && current_s != InternalState::ASYNC_AWAITING_SUMMARY) {
                if (logger_) logger_->warn("[ConnAuthAsync {}] perform_logoff_async called when not ready. State: {}", id_, _get_current_state_as_string());
                co_return std::make_pair(last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR, boltprotocol::SuccessMessageParams{});
            }
            mark_as_used();
            if (logger_) logger_->debug("[ConnAuthAsync {}] Performing LOGOFF async.", id_);

            // Similar to perform_logon_async, this needs an active async stream.
            if (logger_) logger_->error("[ConnAuthAsync {}] perform_logoff_async cannot be called directly on BoltPhysicalConnection without an active async stream context.", id_);
            co_return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};

            // Placeholder for actual implementation if stream context were available:
            /*
            ActiveAsyncStreamContext& active_ctx = ... ; // Get from context
            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& active_async_stream_variant_ref = active_ctx.stream_variant_ref_for_internal_use_only_or_similar;

            std::vector<uint8_t> logoff_payload_storage;
            boltprotocol::PackStreamWriter ps_writer(logoff_payload_storage);
            boltprotocol::BoltError err = boltprotocol::serialize_logoff_message(ps_writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Async LOGOFF serialization failed.");
                if (logger_) logger_->error("[ConnAuthAsync {}] LOGOFF serialization failed: {}", id_, static_cast<int>(err));
                co_return std::make_pair(last_error_code_, boltprotocol::SuccessMessageParams{});
            }

            // Send LOGOFF and receive summary
            auto [send_err, chunk_send_result] = co_await _send_chunked_payload_async(active_async_stream_variant_ref, std::move(logoff_payload_storage));
             if (send_err != boltprotocol::BoltError::SUCCESS) {
                 if (logger_) logger_->error("[ConnAuthAsync {}] Async LOGOFF send failed: {}", id_, static_cast<int>(send_err));
                 co_return {last_error_code_, {}};
            }

            boltprotocol::SuccessMessageParams success_meta;
            // ... similar receive summary logic as _execute_logon_message_async ...
            // (Receive, peek tag, deserialize SUCCESS/FAILURE)

            // if (summary_err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
            //     if (logger_) logger_->info("[ConnAuthAsync {}] Async LOGOFF successful.", id_);
            //     if (negotiated_bolt_version_ < boltprotocol::versions::V5_1) {
            //          current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            //     } else {
            //          current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);
            //     }
            //     co_return std::make_pair(boltprotocol::BoltError::SUCCESS, success_meta);
            // } else {
            //     boltprotocol::BoltError final_err = last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : summary_err;
            //     if (logger_) logger_->warn("[ConnAuthAsync {}] Async LOGOFF failed. SummaryExchangeError: {}, FinalConnError: {}, Server Msg: {}", id_, static_cast<int>(summary_err), static_cast<int>(last_error_code_), last_error_message_);
            //     co_return std::make_pair(final_err, boltprotocol::SuccessMessageParams{});
            // }
            */
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // For initial logger checks
#include <utility>   // For std::move

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        std::atomic<uint64_t> BoltPhysicalConnection::next_connection_id_counter_(0);

        BoltPhysicalConnection::BoltPhysicalConnection(BoltConnectionConfig config, boost::asio::io_context& io_ctx, std::shared_ptr<spdlog::logger> logger_ptr)
            : id_(next_connection_id_counter_++),
              conn_config_(std::move(config)),
              io_context_ref_(io_ctx),
              logger_(logger_ptr),  // Directly use passed logger
              current_state_(InternalState::FRESH),
              negotiated_bolt_version_(0, 0),
              creation_timestamp_(std::chrono::steady_clock::now()) {
            if (!logger_) {  // Fallback if a null logger was somehow passed
                std::cerr << "Warning: BoltPhysicalConnection " << id_ << " created with a null logger." << std::endl;
                // Optionally create a default emergency logger here if critical
            }

            last_used_timestamp_.store(creation_timestamp_, std::memory_order_relaxed);
            if (logger_) {
                logger_->debug("[ConnConstruct {}] Constructed. Target: {}:{}", id_, conn_config_.target_host, conn_config_.target_port);
            }
        }

        BoltPhysicalConnection::~BoltPhysicalConnection() {
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destructing. Current state: {}", id_, _get_current_state_as_string());
            }
            // Ensure resources are cleaned up. terminate(false) handles most of it.
            // _reset_resources_and_state(true) is a fallback if terminate wasn't called or state is already DEFUNCT/FRESH.
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::DEFUNCT && current_s != InternalState::FRESH) {
                terminate(false);  // Don't send GOODBYE from destructor
            } else {
                // If already defunct or fresh, still ensure resources are reset, especially if construction failed partway.
                _reset_resources_and_state(true);  // called_from_destructor = true
            }
            if (logger_) {
                logger_->debug("[ConnDestruct {}] Destruction complete.", id_);
            }
        }

        BoltPhysicalConnection::BoltPhysicalConnection(BoltPhysicalConnection&& other) noexcept
            : id_(other.id_),
              conn_config_(std::move(other.conn_config_)),
              io_context_ref_(other.io_context_ref_),
              logger_(std::move(other.logger_)),  // Move the logger
              owned_socket_for_sync_plain_(std::move(other.owned_socket_for_sync_plain_)),
              plain_iostream_wrapper_(std::move(other.plain_iostream_wrapper_)),
              ssl_context_sync_(std::move(other.ssl_context_sync_)),
              ssl_stream_sync_(std::move(other.ssl_stream_sync_)),
              // current_state_ is atomic, needs load/store
              negotiated_bolt_version_(other.negotiated_bolt_version_),
              server_agent_string_(std::move(other.server_agent_string_)),
              server_assigned_conn_id_(std::move(other.server_assigned_conn_id_)),
              utc_patch_active_(other.utc_patch_active_),
              creation_timestamp_(other.creation_timestamp_),
              // last_used_timestamp_ is atomic
              last_error_code_(other.last_error_code_),
              last_error_message_(std::move(other.last_error_message_)) {
            current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
            last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);

            // Invalidate 'other' to prevent double resource management
            other.id_ = static_cast<uint64_t>(-1);  // Mark as moved-from
            other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
            // Logger in 'other' is now nullptr due to move.
            // other's unique_ptrs are now nullptr due to move.

            if (logger_) {
                logger_->trace("[ConnMoveConstruct {}] Move constructed from (now defunct) old connection {}.", id_, other.id_);
            }
        }

        BoltPhysicalConnection& BoltPhysicalConnection::operator=(BoltPhysicalConnection&& other) noexcept {
            if (this != &other) {
                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assigning from old ID {}. Current state before: {}", id_, other.id_, _get_current_state_as_string());
                }
                // Properly terminate current connection's resources before overwriting
                InternalState current_s_before_assign = current_state_.load(std::memory_order_relaxed);
                if (current_s_before_assign != InternalState::DEFUNCT && current_s_before_assign != InternalState::FRESH) {
                    terminate(false);  // Gracefully terminate self if active
                } else {
                    _reset_resources_and_state(false);  // Clean up if FRESH but resources might exist
                }

                id_ = other.id_;
                conn_config_ = std::move(other.conn_config_);
                // io_context_ref_ is a reference, assumed to be compatible and not changed.
                logger_ = std::move(other.logger_);

                owned_socket_for_sync_plain_ = std::move(other.owned_socket_for_sync_plain_);
                plain_iostream_wrapper_ = std::move(other.plain_iostream_wrapper_);
                ssl_context_sync_ = std::move(other.ssl_context_sync_);
                ssl_stream_sync_ = std::move(other.ssl_stream_sync_);

                current_state_.store(other.current_state_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                negotiated_bolt_version_ = other.negotiated_bolt_version_;
                server_agent_string_ = std::move(other.server_agent_string_);
                server_assigned_conn_id_ = std::move(other.server_assigned_conn_id_);
                utc_patch_active_ = other.utc_patch_active_;
                creation_timestamp_ = other.creation_timestamp_;
                last_used_timestamp_.store(other.last_used_timestamp_.load(std::memory_order_relaxed), std::memory_order_relaxed);
                last_error_code_ = other.last_error_code_;
                last_error_message_ = std::move(other.last_error_message_);

                // Invalidate 'other'
                other.id_ = static_cast<uint64_t>(-1);
                other.current_state_.store(InternalState::DEFUNCT, std::memory_order_relaxed);
                // Logger in 'other' is now nullptr.
                // other's unique_ptrs are now nullptr.

                if (logger_) {
                    logger_->trace("[ConnMoveAssign {}] Move assignment complete.", id_);
                }
            }
            return *this;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <variant>

#include "boltprotocol/handshake.h"                       // For boltprotocol::perform_handshake
#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_bolt_handshake() {
            InternalState expected_prev_state;
            bool is_ssl = conn_config_.encryption_enabled;

            if (is_ssl) {
                expected_prev_state = InternalState::SSL_HANDSHAKEN;
                if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] SSL stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            } else {
                expected_prev_state = InternalState::TCP_CONNECTED;
                if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream not ready for Bolt handshake.");
                    if (logger_) logger_->error("[ConnBoltHS {}] Plain stream not ready for Bolt handshake. State: {}", id_, _get_current_state_as_string());
                    return last_error_code_;
                }
            }

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state) {
                std::string msg = "Bolt handshake (sync) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            current_state_.store(InternalState::BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHS {}] Performing (sync) Bolt handshake.", id_);

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for handshake.");
                if (logger_) logger_->error("[ConnBoltHS {}] No Bolt versions to propose.", id_);
                return last_error_code_;
            }

            // perform_handshake is synchronous and uses the stream's blocking operations.
            // Timeout for this synchronous operation is harder to implement directly here
            // unless perform_handshake itself supports it, or we wrap its stream.
            // The bolt_handshake_timeout_ms from config is more of a hint for the overall stage.
            boltprotocol::BoltError err;
            if (is_ssl) {
                // Pass the underlying SSL stream to perform_handshake
                // perform_handshake expects a reference to a stream type that has read/write/flush.
                // boost::asio::ssl::stream directly supports this.
                err = boltprotocol::perform_handshake(*ssl_stream_sync_, proposed_versions, negotiated_bolt_version_);
            } else {
                // plain_iostream_wrapper_ is a std::iostream compatible type
                err = boltprotocol::perform_handshake(*plain_iostream_wrapper_, proposed_versions, negotiated_bolt_version_);
            }

            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Sync Bolt handshake failed: " + error::bolt_error_to_string(err);
                _mark_as_defunct(err, msg);  // perform_handshake does not call _mark_as_defunct
                if (logger_) logger_->error("[ConnBoltHS {}] {}", id_, msg);
                return last_error_code_;
            }
            if (logger_) logger_->debug("[ConnBoltHS {}] Sync Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);

            current_state_.store(InternalState::BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_bolt_handshake_async(std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>& async_stream_variant_ref,  // Pass by ref
                                                                                                            std::chrono::milliseconds timeout) {
            // Determine expected previous state based on whether the stream is SSL or plain
            bool is_ssl_stream = std::holds_alternative<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*>(async_stream_variant_ref);
            InternalState expected_prev_state = is_ssl_stream ? InternalState::SSL_HANDSHAKEN : InternalState::TCP_CONNECTED;
            // Note: These states (SSL_HANDSHAKEN, TCP_CONNECTED) might need async equivalents if we differentiate strictly
            // e.g. ASYNC_SSL_HANDSHAKEN, ASYNC_TCP_CONNECTED. For now, assume they are set by prior async stages.

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != expected_prev_state && !(is_ssl_stream && current_s == InternalState::ASYNC_SSL_HANDSHAKING) &&  // Allow if just finished async SSL HS
                !(!is_ssl_stream && current_s == InternalState::ASYNC_TCP_CONNECTING)) {                                      // Allow if just finished async TCP connect
                std::string msg = "Bolt handshake (async) called in unexpected state: " + _get_current_state_as_string() + ". Expected: " + (is_ssl_stream ? "SSL_HANDSHAKEN" : "TCP_CONNECTED");
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Performing (async) Bolt handshake. Timeout: {}ms", id_, timeout.count());

            std::vector<boltprotocol::versions::Version> proposed_versions;
            if (conn_config_.preferred_bolt_versions.has_value() && !conn_config_.preferred_bolt_versions.value().empty()) {
                proposed_versions = conn_config_.preferred_bolt_versions.value();
            } else {
                proposed_versions = boltprotocol::versions::get_default_proposed_versions();
            }

            if (proposed_versions.empty()) {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "No Bolt versions to propose for async handshake.");
                if (logger_) logger_->error("[ConnBoltHSAsync {}] No Bolt versions to propose.", id_);
                co_return last_error_code_;
            }

            // This would be the truly async version. For now, it's a placeholder.
            // It requires implementing boltprotocol::perform_handshake_async or similar.
            // Here, we'll implement the handshake steps directly using _write_to_active_async_stream and _read_from_active_async_stream.

            // 1. Send proposed versions
            std::vector<uint8_t> handshake_bytes;
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0x60);
            handshake_bytes.push_back(0xB0);
            handshake_bytes.push_back(0x17);  // Bolt Magic
            for (const auto& version : proposed_versions) {
                handshake_bytes.push_back(version.minor);
                handshake_bytes.push_back(version.major);
                handshake_bytes.push_back(0);  // No patch range
                handshake_bytes.push_back(0);  // No patch range
            }
            // Fill remaining to 20 bytes if fewer than 4 versions proposed
            while (handshake_bytes.size() < 20) {
                handshake_bytes.push_back(0);
            }

            boltprotocol::BoltError err = co_await _write_to_active_async_stream(async_stream_variant_ref, handshake_bytes);
            if (err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to send proposed versions: " + error::bolt_error_to_string(err);
                _mark_as_defunct(err, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            // 2. Receive negotiated version (4 bytes)
            auto [read_err, negotiated_version_bytes] = co_await _read_from_active_async_stream(async_stream_variant_ref, 4);
            if (read_err != boltprotocol::BoltError::SUCCESS) {
                std::string msg = "Async Bolt handshake: failed to read negotiated version: " + error::bolt_error_to_string(read_err);
                // _read_from_active_async_stream already calls _mark_as_defunct
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (negotiated_version_bytes.size() != 4) {
                std::string msg = "Async Bolt handshake: received incorrect size for negotiated version.";
                _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            negotiated_bolt_version_.patch = 0;  // Assume no patch for now
            negotiated_bolt_version_.minor = negotiated_version_bytes[1];
            negotiated_bolt_version_.major = negotiated_version_bytes[0];
            // Bytes 2 and 3 are usually 0 unless patch ranges are used by server.

            bool version_supported = false;
            for (const auto& proposed : proposed_versions) {
                if (proposed.major == negotiated_bolt_version_.major && proposed.minor == negotiated_bolt_version_.minor) {
                    version_supported = true;
                    break;
                }
            }

            if (negotiated_bolt_version_.major == 0 && negotiated_bolt_version_.minor == 0) {  // Server rejected all versions
                std::string msg = "Async Bolt handshake: Server rejected all proposed Bolt versions (responded with 0.0).";
                _mark_as_defunct(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (!version_supported) {  // Server picked a version we didn't propose or understand.
                std::string msg = "Async Bolt handshake: Server chose an unsupported Bolt version: " + negotiated_bolt_version_.to_string();
                _mark_as_defunct(boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION, msg);
                if (logger_) logger_->error("[ConnBoltHSAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            if (logger_) logger_->debug("[ConnBoltHSAsync {}] Async Bolt handshake successful. Negotiated version: {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ip/tcp.hpp>      // For tcp::socket for establish_async
#include <boost/asio/ssl/stream.hpp>  // For ssl::stream for establish_async
#include <variant>                    // For std::variant in establish_async

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/async_types.h"  // For ActiveAsyncStreamContext
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// Note: Full implementation of async methods depends on robust async I/O and chunking,
// and careful management of the async stream's lifecycle.

namespace neo4j_bolt_transport {
    namespace internal {

        boost::asio::awaitable<std::pair<boltprotocol::BoltError, ActiveAsyncStreamContext>> BoltPhysicalConnection::establish_async() {
            InternalState expected_fresh = InternalState::FRESH;
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::ASYNC_TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::ASYNC_READY || current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCAsync {}] Establish_async called but connection is already READY.", id_);
                    // Need to reconstruct ActiveAsyncStreamContext if already ready and returning success
                    // This part is tricky as the stream is not stored in BoltPhysicalConnection directly for async.
                    // For now, assume if READY, something else holds the stream. This path is problematic for this function's return type.
                    // Let's assume for now if it's READY, it's an error to call establish_async again on this object
                    // without a proper way to retrieve the existing async stream.
                    // Or, return a default/empty ActiveAsyncStreamContext on success if already ready.
                    // A better approach is to manage the ActiveAsyncStreamContext lifecycle outside BoltPhysicalConnection (e.g., in a session object).
                    // For now, if it's READY, we can't return a valid ActiveAsyncStreamContext from here.
                    std::string msg = "Establish_async called but connection is already READY. Cannot provide a new ActiveAsyncStreamContext.";
                    if (logger_) logger_->warn("[ConnLCAsync {}] {}", id_, msg);
                    _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);  // Mark as error for now
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                std::string msg = "Establish_async called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCAsync {}] {}", id_, msg);
                co_return {(current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR, ActiveAsyncStreamContext(io_context_ref_)};
            }

            if (logger_) logger_->info("[ConnLCAsync {}] Establishing (async) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);

            _reset_resources_and_state(false);  // Reset synchronous resources first
            current_state_.store(InternalState::ASYNC_TCP_CONNECTING, std::memory_order_relaxed);

            // The async stream (socket or ssl::stream) will be owned by the returned ActiveAsyncStreamContext.
            // Create the socket that will eventually be moved into the variant.
            boost::asio::ip::tcp::socket temp_socket(io_context_ref_);
            boltprotocol::BoltError err = boltprotocol::BoltError::UNKNOWN_ERROR;

            err = co_await _stage_tcp_connect_async(temp_socket, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async TCP connect stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);                               // Reset to allow retry
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};  // last_error_code_ set by _stage_tcp_connect_async
            }
            // State should be TCP_CONNECTED (or ASYNC_TCP_CONNECTED) if _stage_tcp_connect_async sets it.

            std::variant<boost::asio::ip::tcp::socket, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> final_stream_variant(std::move(temp_socket));  // Start with plain socket
            bool encryption_used_for_context = false;

            if (conn_config_.encryption_enabled) {
                encryption_used_for_context = true;
                // SSL Context setup is mostly synchronous
                err = _stage_ssl_context_setup();  // Sets up ssl_context_sync_
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }

                // Move the socket into an SSL stream
                // The original socket is in the variant, extract and move it.
                boost::asio::ip::tcp::socket plain_socket_for_ssl = std::get<boost::asio::ip::tcp::socket>(std::move(final_stream_variant));
                boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket_stream(std::move(plain_socket_for_ssl), *ssl_context_sync_);
                current_state_.store(InternalState::ASYNC_SSL_HANDSHAKING);

                err = co_await _stage_ssl_handshake_async(ssl_socket_stream, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
                if (err != boltprotocol::BoltError::SUCCESS) {
                    if (logger_) logger_->error("[ConnLCAsync {}] Async SSL handshake stage failed: {}", id_, error::bolt_error_to_string(err));
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
                }
                final_stream_variant = std::move(ssl_socket_stream);  // Move SSL stream into variant
                current_state_.store(InternalState::SSL_HANDSHAKEN);
            }

            // Create a pointer-based variant for internal stage calls
            std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> active_async_stream_ptr_variant;
            if (std::holds_alternative<boost::asio::ip::tcp::socket>(final_stream_variant)) {
                active_async_stream_ptr_variant = &std::get<boost::asio::ip::tcp::socket>(final_stream_variant);
            } else {
                active_async_stream_ptr_variant = &std::get<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(final_stream_variant);
            }

            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKING);
            err = co_await _stage_bolt_handshake_async(active_async_stream_ptr_variant, std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms));
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async Bolt handshake stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            current_state_.store(InternalState::ASYNC_BOLT_HANDSHAKEN);

            current_state_.store(InternalState::ASYNC_HELLO_AUTH_SENT);
            err = co_await _stage_send_hello_and_initial_auth_async(active_async_stream_ptr_variant);
            if (err != boltprotocol::BoltError::SUCCESS) {
                if (logger_) logger_->error("[ConnLCAsync {}] Async HELLO/Auth stage failed: {}", id_, error::bolt_error_to_string(err));
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }
            // _stage_send_hello_and_initial_auth_async should set state to ASYNC_READY or READY

            if (current_state_.load(std::memory_order_relaxed) != InternalState::ASYNC_READY && current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Async connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCAsync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                co_return {last_error_code_, ActiveAsyncStreamContext(io_context_ref_)};
            }

            mark_as_used();
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCAsync {}] Async Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);

            ActiveAsyncStreamContext async_context(std::move(final_stream_variant), negotiated_bolt_version_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_, encryption_used_for_context);
            co_return {boltprotocol::BoltError::SUCCESS, std::move(async_context)};
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::terminate_async(bool send_goodbye) {
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);
            if (logger_) {
                std::string prev_state_str = "UNKNOWN";  // Placeholder for previous state string
                // This is a bit complex because _get_current_state_as_string() reads the *current* atomic state.
                // For logging previous_state, you'd need a switch or map.
                // For simplicity, just log that termination is happening.
                logger_->debug("[ConnLCAsync {}] Terminating (async). Previous state was {}. Send goodbye: {}", id_, static_cast<int>(previous_state), send_goodbye);
            }

            if (previous_state == InternalState::DEFUNCT) {
                _reset_resources_and_state(false);  // Ensure sync resources are clean
                co_return boltprotocol::BoltError::SUCCESS;
            }

            // Async GOODBYE would require the active async stream.
            // This is problematic if establish_async doesn't make the stream persist with the object.
            // This function, as part of BoltPhysicalConnection, typically won't have the ActiveAsyncStreamContext
            // unless it's passed in or managed differently. For now, this part is a placeholder.
            if (send_goodbye && previous_state >= InternalState::ASYNC_BOLT_HANDSHAKEN && previous_state < InternalState::DEFUNCT && !(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {
                if (logger_) logger_->trace("[ConnLCAsync {}] Async GOODBYE logic placeholder: Requires active async stream. This will not be sent.", id_);
                // To send GOODBYE, this function would need the ActiveAsyncStreamContext.
                // For example:
                // if (active_async_context_is_available) {
                //    std::variant<boost::asio::ip::tcp::socket*, boost::asio::ssl::stream<boost::asio::ip::tcp::socket>*> stream_ptr_variant;
                //    // ... get stream_ptr_variant from active_async_context ...
                //    std::vector<uint8_t> goodbye_payload;
                //    boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                //    if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                //        co_await _send_chunked_payload_async(stream_ptr_variant, std::move(goodbye_payload));
                //    }
                //    // Then close the stream in ActiveAsyncStreamContext
                // }
            }

            _reset_resources_and_state(false);  // Clean up sync resources. Async resources are managed by their coroutines/ActiveAsyncStreamContext.
            co_return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::ping_async(std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnLCAsync {}] Pinging (async) connection (via async RESET). Timeout hint: {}ms", id_, timeout.count());
            // This requires perform_reset_async to be fully implemented.
            // For now, it's a placeholder. True async ping would need the ActiveAsyncStreamContext.
            if (logger_) logger_->error("[ConnLCAsync {}] ping_async is a placeholder and requires an active async stream context to perform a true async RESET.", id_);
            co_return boltprotocol::BoltError::UNKNOWN_ERROR;  // Placeholder
            // To implement:
            // ActiveAsyncStreamContext& active_ctx = ... get from somewhere ...
            // co_return co_await perform_reset_async_with_context(active_ctx, timeout);
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <openssl/ssl.h>  // For SSL_get_shutdown, SSL_RECEIVED_SHUTDOWN, SSL_SENT_SHUTDOWN (needed by _reset_resources_and_state)

#include <boost/asio/ip/tcp.hpp>  // For socket::shutdown_both

#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        void BoltPhysicalConnection::_reset_resources_and_state(bool called_from_destructor) {
            // This function is critical for cleaning up resources.
            // It's called from establish() before new attempt, terminate(), destructor, and move assignment.

            // 1. Close SSL stream (if exists and open)
            if (ssl_stream_sync_) {
                boost::system::error_code ec_ssl_shutdown, ec_tcp_close;
                if (ssl_stream_sync_->lowest_layer().is_open()) {
                    // Attempt graceful SSL shutdown only if not already shut down by peer.
                    // SSL_get_shutdown checks SSL state.
                    if (!(SSL_get_shutdown(ssl_stream_sync_->native_handle()) & (SSL_RECEIVED_SHUTDOWN | SSL_SENT_SHUTDOWN))) {
                        try {
                            ssl_stream_sync_->shutdown(ec_ssl_shutdown);                                                                                                     // Graceful SSL shutdown
                            if (logger_ && ec_ssl_shutdown && ec_ssl_shutdown != boost::asio::error::eof && ec_ssl_shutdown != boost::asio::ssl::error::stream_truncated) {  // EOF/truncated is common on close
                                logger_->trace("[ConnReset {}] SSL shutdown error: {}", id_, ec_ssl_shutdown.message());
                            }
                        } catch (const boost::system::system_error& e) {
                            if (logger_) logger_->trace("[ConnReset {}] Exception during SSL stream shutdown: {}", id_, e.what());
                        }
                    }
                    // Close the underlying socket
                    try {
                        ssl_stream_sync_->lowest_layer().close(ec_tcp_close);
                        if (logger_ && ec_tcp_close) {
                            logger_->trace("[ConnReset {}] SSL lowest_layer close error: {}", id_, ec_tcp_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during SSL lowest_layer close: {}", id_, e.what());
                    }
                }
                ssl_stream_sync_.reset();  // Release the unique_ptr
            }

            // 2. Reset SSL context (if exists)
            if (ssl_context_sync_) {
                ssl_context_sync_.reset();
            }

            // 3. Close plain iostream wrapper (if exists, it owns its socket if not SSL)
            if (plain_iostream_wrapper_) {
                // Destroying iostream wrapper will close its associated socket if it has one.
                plain_iostream_wrapper_.reset();
            }

            // 4. Close the raw owned socket (if it still exists and wasn't moved to iostream/ssl_stream)
            if (owned_socket_for_sync_plain_) {
                if (owned_socket_for_sync_plain_->is_open()) {
                    boost::system::error_code ec_shutdown, ec_close;
                    try {
                        owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_shutdown);
                        if (logger_ && ec_shutdown) {
                            logger_->trace("[ConnReset {}] Plain socket shutdown error: {}", id_, ec_shutdown.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket shutdown: {}", id_, e.what());
                    }
                    try {
                        owned_socket_for_sync_plain_->close(ec_close);
                        if (logger_ && ec_close) {
                            logger_->trace("[ConnReset {}] Plain socket close error: {}", id_, ec_close.message());
                        }
                    } catch (const boost::system::system_error& e) {
                        if (logger_) logger_->trace("[ConnReset {}] Exception during plain socket close: {}", id_, e.what());
                    }
                }
                owned_socket_for_sync_plain_.reset();
            }

            // 5. Reset Bolt protocol specific state
            negotiated_bolt_version_ = boltprotocol::versions::Version(0, 0);
            server_agent_string_.clear();
            server_assigned_conn_id_.clear();
            utc_patch_active_ = false;

            // 6. Reset error state, unless in destructor of an already defunct connection
            //    or if we want to preserve the "original sin" error.
            //    For a full reset to FRESH for reuse, error should be cleared.
            if (!called_from_destructor || current_state_.load(std::memory_order_relaxed) != InternalState::DEFUNCT) {
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
            }

            // 7. Set state to FRESH, unless in destructor and already DEFUNCT (don't revive it)
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (!called_from_destructor || current_s != InternalState::DEFUNCT) {
                current_state_.store(InternalState::FRESH, std::memory_order_relaxed);
            }

            if (logger_) logger_->trace("[ConnReset {}] Resources and state reset. Current state for reuse (if not dtor): {}", id_, _get_current_state_as_string());
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <vector>

#include "boltprotocol/message_serialization.h"           // For serialize_goodbye_message
#include "boltprotocol/packstream_writer.h"               // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::establish() {
            InternalState expected_fresh = InternalState::FRESH;
            // Attempt to transition from FRESH. If already connecting/ready/defunct, handle appropriately.
            if (!current_state_.compare_exchange_strong(expected_fresh, InternalState::TCP_CONNECTING, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                InternalState current_s = current_state_.load(std::memory_order_relaxed);
                if (current_s == InternalState::READY) {
                    if (logger_) logger_->debug("[ConnLCSync {}] Establish called but connection is already READY.", id_);
                    return boltprotocol::BoltError::SUCCESS;
                }
                // If trying to establish on a connection that's in an intermediate async state, or defunct.
                std::string msg = "Establish (sync) called in invalid state: " + _get_current_state_as_string() + ". Expected FRESH.";
                if (logger_) logger_->warn("[ConnLCSync {}] {}", id_, msg);
                // If it's defunct, return its last error. Otherwise, it's an unexpected state.
                return (current_s == InternalState::DEFUNCT) ? last_error_code_ : boltprotocol::BoltError::UNKNOWN_ERROR;
            }

            if (logger_) logger_->info("[ConnLCSync {}] Establishing (sync) connection to {}:{}", id_, conn_config_.target_host, conn_config_.target_port);

            // Critical: Reset resources and state *before* attempting to connect.
            // This ensures that if establish() is called on an object that failed a previous attempt
            // (and was thus reset to FRESH but might have lingering handles if reset wasn't perfect),
            // it starts truly fresh.
            _reset_resources_and_state(false);
            // After _reset_resources_and_state, current_state_ is FRESH. We are now proceeding to connect.
            current_state_.store(InternalState::TCP_CONNECTING, std::memory_order_relaxed);

            boltprotocol::BoltError err = _stage_tcp_connect();
            if (err != boltprotocol::BoltError::SUCCESS) {
                // _stage_tcp_connect calls _mark_as_defunct and _reset_resources_and_state on failure,
                // then sets state to FRESH.
                return last_error_code_;  // Return the error that _stage_tcp_connect set.
            }

            if (conn_config_.encryption_enabled) {
                err = _stage_ssl_context_setup();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
                err = _stage_ssl_handshake();
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                    return last_error_code_;
                }
            }

            err = _stage_bolt_handshake();
            if (err != boltprotocol::BoltError::SUCCESS) {
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            // _stage_send_hello_and_initial_auth handles setting state to READY on success
            // or FAILED_SERVER_REPORTED/DEFUNCT on failure.
            err = _stage_send_hello_and_initial_auth();
            if (err != boltprotocol::BoltError::SUCCESS) {
                // If HELLO/auth failed, connection is not READY. It might be FAILED_SERVER_REPORTED or DEFUNCT.
                // We want to ensure it's reset to FRESH if it's intended for reuse after this failure.
                // However, _mark_as_defunct (called by stages on error) already sets DEFUNCT.
                // _reset_resources_and_state is then called by terminate or destructor.
                // If we want `establish` to leave it FRESH on failure for immediate retry:
                if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                    _reset_resources_and_state(false);
                    current_state_.store(InternalState::FRESH);
                }
                return last_error_code_;
            }

            // Final check: if all stages reported SUCCESS but state is not READY, something is wrong.
            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                std::string msg = "Sync connection did not reach READY state after successful establish sequence. Final state: " + _get_current_state_as_string();
                if (logger_) logger_->error("[ConnLCSync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                _reset_resources_and_state(false);
                current_state_.store(InternalState::FRESH);
                return last_error_code_;
            }

            mark_as_used();  // Mark as used upon successful establishment
            // last_error_code_ should be SUCCESS if we reach here and state is READY
            if (last_error_code_ != boltprotocol::BoltError::SUCCESS && logger_) {
                logger_->warn("[ConnLCSync {}] Established but last_error_code_ is {}. Overriding to SUCCESS as state is READY.", id_, static_cast<int>(last_error_code_));
            }
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->info("[ConnLCSync {}] Sync Connection established and ready. Bolt version: {}.{}. Server: {}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor, server_agent_string_);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::terminate(bool send_goodbye) {
            // Atomically set state to DEFUNCT and get the previous state.
            InternalState previous_state = current_state_.exchange(InternalState::DEFUNCT, std::memory_order_acq_rel);

            // Log after exchanging state to show "Terminating" message with the new DEFUNCT state,
            // but refer to previous_state for logic regarding sending GOODBYE.
            if (logger_)
                logger_->debug("[ConnLCSync {}] Terminating (sync). Previous state was {}. Send goodbye: {}",
                               id_,
                               (previous_state == InternalState::DEFUNCT ? "already DEFUNCT" : _get_current_state_as_string()),  // Use a string for previous_state for clarity
                               send_goodbye);

            if (previous_state == InternalState::DEFUNCT) {
                if (logger_) logger_->trace("[ConnLCSync {}] Already defunct, ensuring resources are clean.", id_);
                _reset_resources_and_state(false);        // Ensure cleanup even if already marked defunct
                return boltprotocol::BoltError::SUCCESS;  // Or return last_error_code_ if that's more appropriate
            }

            // Attempt to send GOODBYE only if connection was in a state where it's meaningful
            // and not already DEFUNCT.
            if (send_goodbye && previous_state >= InternalState::BOLT_HANDSHAKEN &&  // Must have at least completed Bolt handshake
                previous_state < InternalState::DEFUNCT) {                           // And not have been defunct before this call

                if (!(negotiated_bolt_version_ < boltprotocol::versions::Version(3, 0))) {  // GOODBYE for Bolt 3.0+
                    bool can_send = false;
                    if (conn_config_.encryption_enabled) {
                        can_send = ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();
                    } else {
                        can_send = plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
                    }

                    if (can_send) {
                        if (logger_) logger_->trace("[ConnLCSync {}] Attempting to send GOODBYE.", id_);
                        std::vector<uint8_t> goodbye_payload;
                        boltprotocol::PackStreamWriter ps_writer(goodbye_payload);
                        if (boltprotocol::serialize_goodbye_message(ps_writer) == boltprotocol::BoltError::SUCCESS) {
                            // _send_chunked_payload_sync will use _write_to_active_sync_stream
                            // It will also call _mark_as_defunct on its own errors, but state is already DEFUNCT.
                            boltprotocol::BoltError goodbye_err = _send_chunked_payload_sync(goodbye_payload);
                            if (goodbye_err != boltprotocol::BoltError::SUCCESS && logger_) {
                                // Log the GOODBYE error, but the connection is being terminated anyway.
                                logger_->warn("[ConnLCSync {}] Sending GOODBYE failed: {}", id_, error::bolt_error_to_string(goodbye_err));
                            } else if (logger_ && goodbye_err == boltprotocol::BoltError::SUCCESS) {
                                logger_->trace("[ConnLCSync {}] GOODBYE message sent.", id_);
                            }
                        }
                    } else {
                        if (logger_) logger_->trace("[ConnLCSync {}] Cannot send GOODBYE (stream not ready or Bolt version too low). Previous state was {}.", id_, (int)previous_state);
                    }
                } else {
                    if (logger_) logger_->trace("[ConnLCSync {}] GOODBYE not applicable for Bolt version {}.{}", id_, (int)negotiated_bolt_version_.major, (int)negotiated_bolt_version_.minor);
                }
            }

            _reset_resources_and_state(false);        // Clean up all sync resources
            return boltprotocol::BoltError::SUCCESS;  // Terminate itself is successful in cleaning up.
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds timeout) {
            // Timeout parameter is for the overall ping operation.
            // perform_reset internally calls send_request_receive_summary, which uses synchronous IO
            // without explicit per-operation timeouts other than TCP level.
            // A true ping timeout would require more complex handling or async mechanisms.
            // For now, timeout is informational.
            if (logger_) logger_->debug("[ConnLCSync {}] Pinging (sync) connection (via RESET). Timeout hint: {}ms", id_, timeout.count());

            // perform_reset itself will mark_as_used.
            // It will also set connection state appropriately (READY on success, DEFUNCT on failure).
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>
#include <vector>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_peek_message_tag(const std::vector<uint8_t>& payload, boltprotocol::MessageTag& out_tag) const {
            if (payload.empty()) {
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
            }
            boltprotocol::PackStreamReader temp_reader(payload);
            uint8_t raw_tag_byte = 0;
            uint32_t num_fields = 0;

            boltprotocol::BoltError peek_err = boltprotocol::peek_message_structure_header(temp_reader, raw_tag_byte, num_fields);
            if (peek_err != boltprotocol::BoltError::SUCCESS) {
                return peek_err;
            }
            out_tag = static_cast<boltprotocol::MessageTag>(raw_tag_byte);
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_summary(const std::vector<uint8_t>& request_payload, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s != InternalState::READY && current_s != InternalState::HELLO_AUTH_SENT && current_s != InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_summary called in invalid state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);  // Corrected
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);

            std::vector<uint8_t> response_payload;
            while (true) {
                err = _receive_chunked_payload_sync(response_payload);  // Corrected
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }
                if (!response_payload.empty()) break;
                if (logger_) logger_->trace("[ConnMsg {}] Received NOOP while awaiting summary.", id_);
            }

            boltprotocol::MessageTag tag;
            err = _peek_message_tag(response_payload, tag);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "Failed to peek tag for summary response.");
                return last_error_code_;
            }

            boltprotocol::PackStreamReader reader(response_payload);
            if (tag == boltprotocol::MessageTag::SUCCESS) {
                err = boltprotocol::deserialize_success_message(reader, out_summary);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize SUCCESS summary.");
                    return last_error_code_;
                }
                if (current_state_.load(std::memory_order_relaxed) == InternalState::AWAITING_SUMMARY) {
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                }
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_.clear();
                return boltprotocol::BoltError::SUCCESS;

            } else if (tag == boltprotocol::MessageTag::FAILURE) {
                err = boltprotocol::deserialize_failure_message(reader, out_failure);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize FAILURE summary.");
                    return last_error_code_;
                }
                return _classify_and_set_server_failure(out_failure);

            } else if (tag == boltprotocol::MessageTag::IGNORED) {
                err = boltprotocol::deserialize_ignored_message(reader);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to deserialize IGNORED summary.");
                    return last_error_code_;
                }
                out_failure.metadata.clear();
                out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = boltprotocol::BoltError::SUCCESS;
                last_error_message_ = "Operation ignored by server.";
                return boltprotocol::BoltError::SUCCESS;

            } else {
                _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag for summary: " + std::to_string(static_cast<int>(tag)));
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::send_request_receive_stream(const std::vector<uint8_t>& request_payload, MessageHandler record_handler, boltprotocol::SuccessMessageParams& out_summary, boltprotocol::FailureMessageParams& out_failure) {
            out_summary.metadata.clear();
            out_failure.metadata.clear();

            if (!is_ready_for_queries()) {
                if (logger_) logger_->warn("[ConnMsg {}] send_request_receive_stream called when not ready. State: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            mark_as_used();

            boltprotocol::BoltError err = _send_chunked_payload_sync(request_payload);  // Corrected
            if (err != boltprotocol::BoltError::SUCCESS) {
                return last_error_code_;
            }

            current_state_.store(InternalState::STREAMING, std::memory_order_relaxed);

            while (true) {
                std::vector<uint8_t> response_payload;
                err = _receive_chunked_payload_sync(response_payload);  // Corrected
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return last_error_code_;
                }

                if (response_payload.empty()) {
                    if (logger_) logger_->trace("[ConnMsg {}] Received NOOP during stream.", id_);
                    continue;
                }

                boltprotocol::MessageTag tag;
                err = _peek_message_tag(response_payload, tag);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    _mark_as_defunct(err, "Failed to peek tag during streaming.");
                    return last_error_code_;
                }

                if (tag == boltprotocol::MessageTag::RECORD) {
                    if (record_handler) {
                        err = record_handler(tag, response_payload, *this);
                        if (err != boltprotocol::BoltError::SUCCESS) {
                            std::string msg = "Record handler returned error: " + error::bolt_error_to_string(err);
                            _mark_as_defunct(err, msg);
                            return last_error_code_;
                        }
                    } else {
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, "Received RECORD but no handler provided.");
                        return last_error_code_;
                    }
                } else if (tag == boltprotocol::MessageTag::SUCCESS) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_success_message(reader, out_summary);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize SUCCESS summary in stream.");
                        return last_error_code_;
                    }
                    current_state_.store(InternalState::READY, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_.clear();
                    return boltprotocol::BoltError::SUCCESS;

                } else if (tag == boltprotocol::MessageTag::FAILURE) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_failure_message(reader, out_failure);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize FAILURE summary in stream.");
                        return last_error_code_;
                    }
                    return _classify_and_set_server_failure(out_failure);

                } else if (tag == boltprotocol::MessageTag::IGNORED) {
                    current_state_.store(InternalState::AWAITING_SUMMARY, std::memory_order_relaxed);
                    boltprotocol::PackStreamReader reader(response_payload);
                    err = boltprotocol::deserialize_ignored_message(reader);
                    if (err != boltprotocol::BoltError::SUCCESS) {
                        _mark_as_defunct(err, "Failed to deserialize IGNORED summary in stream.");
                        return last_error_code_;
                    }
                    out_failure.metadata.clear();
                    out_failure.metadata["code"] = boltprotocol::Value("Neo.ClientError.Request.Ignored");
                    out_failure.metadata["message"] = boltprotocol::Value("Request was ignored by the server.");
                    current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                    last_error_code_ = boltprotocol::BoltError::SUCCESS;
                    last_error_message_ = "Operation ignored by server.";
                    return boltprotocol::BoltError::SUCCESS;

                } else {
                    _mark_as_defunct(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Unexpected message tag in stream: " + std::to_string(static_cast<int>(tag)));
                    return last_error_code_;
                }
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::perform_reset() {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT || current_s < InternalState::BOLT_HANDSHAKEN) {
                if (logger_) logger_->warn("[ConnMsg {}] perform_reset called in unsuitable state: {}", id_, _get_current_state_as_string());
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (logger_) logger_->debug("[ConnMsg {}] Performing RESET...", id_);
            mark_as_used();

            std::vector<uint8_t> reset_payload_bytes;
            boltprotocol::PackStreamWriter writer(reset_payload_bytes);
            boltprotocol::BoltError err = boltprotocol::serialize_reset_message(writer);
            if (err != boltprotocol::BoltError::SUCCESS) {
                _mark_as_defunct(err, "RESET serialization failed.");
                return last_error_code_;
            }

            boltprotocol::SuccessMessageParams success_meta;
            boltprotocol::FailureMessageParams failure_meta;

            err = send_request_receive_summary(reset_payload_bytes, success_meta, failure_meta);

            if (err == boltprotocol::BoltError::SUCCESS && last_error_code_ == boltprotocol::BoltError::SUCCESS) {
                current_state_.store(InternalState::READY, std::memory_order_relaxed);
                if (logger_) logger_->info("[ConnMsg {}] RESET successful. Connection is READY.", id_);
                return boltprotocol::BoltError::SUCCESS;
            } else {
                if (logger_) logger_->error("[ConnMsg {}] RESET failed. Error: {}, Last Conn Error Code: {}, Msg: {}", id_, static_cast<int>(err), static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_;
            }
        }

        boltprotocol::BoltError BoltPhysicalConnection::ping(std::chrono::milliseconds /*timeout_placeholder*/) {
            if (logger_) logger_->debug("[ConnMsg {}] Pinging connection (via RESET)...", id_);
            return perform_reset();
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/ssl.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_context_setup() {
            if (!conn_config_.encryption_enabled) {
                // Not an error, just means SSL is not configured for this connection.
                if (logger_) logger_->debug("[ConnSSLCTX {}] SSL encryption not enabled, skipping context setup.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            // Ensure TCP is connected before setting up SSL context
            if (current_state_.load(std::memory_order_relaxed) != InternalState::TCP_CONNECTED) {
                std::string msg = "SSL context setup called but TCP not connected. Current state: " + _get_current_state_as_string();
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_CONTEXT_SETUP, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLCTX {}] Setting up SSL context.", id_);

            try {
                ssl_context_sync_ = std::make_unique<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12_client);
                boost::system::error_code ec_ssl_setup;

                // Determine verification strategy based on resolved_encryption_strategy
                switch (conn_config_.resolved_encryption_strategy) {
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_none, ec_ssl_setup);
                        if (logger_ && !ec_ssl_setup) logger_->warn("[ConnSSLCTX {}] SSL configured to TRUST_ALL_CERTIFICATES (verify_none). THIS IS INSECURE.", id_);
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_SYSTEM_CERTS:
                        ssl_context_sync_->set_default_verify_paths(ec_ssl_setup);
                        if (!ec_ssl_setup) {
                            ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_CUSTOM_CERTS:
                        ssl_context_sync_->set_verify_mode(boost::asio::ssl::verify_peer, ec_ssl_setup);  // Peer verification is a must for custom CAs
                        if (!ec_ssl_setup) {
                            if (conn_config_.trusted_certificates_pem_files.empty() && logger_) {
                                logger_->warn("[ConnSSLCTX {}] SSL configured for custom CAs but no CA certificate files provided. Verification will likely fail.", id_);
                            }
                            for (const auto& cert_path : conn_config_.trusted_certificates_pem_files) {
                                ssl_context_sync_->load_verify_file(cert_path, ec_ssl_setup);
                                if (ec_ssl_setup) {
                                    if (logger_) logger_->error("[ConnSSLCTX {}] Failed to load custom CA certificate file '{}': {}", id_, cert_path, ec_ssl_setup.message());
                                    break;  // Stop on first error
                                }
                                if (logger_) logger_->debug("[ConnSSLCTX {}] Successfully loaded custom CA certificate file: {}", id_, cert_path);
                            }
                        }
                        break;
                    case config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT:            // Should have been caught by encryption_enabled check
                    case config::TransportConfig::EncryptionStrategy::NEGOTIATE_FROM_URI_SCHEME:  // Should have been resolved earlier
                    default:
                        std::string msg = "Invalid or unresolved encryption strategy for SSL context setup: " + std::to_string(static_cast<int>(conn_config_.resolved_encryption_strategy));
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                }

                if (ec_ssl_setup) {  // Check error from verify_mode or load_verify_file
                    std::string msg = "SSL context verification setup failed: " + ec_ssl_setup.message();
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);  // Or more specific SSL error
                    if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Client certificate authentication (mTLS)
                if (conn_config_.client_certificate_pem_file.has_value()) {
                    if (!conn_config_.client_private_key_pem_file.has_value()) {
                        std::string msg = "Client certificate provided, but client private key is missing.";
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client certificate: {}", id_, conn_config_.client_certificate_pem_file.value());
                    ssl_context_sync_->use_certificate_chain_file(conn_config_.client_certificate_pem_file.value(), ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client certificate chain file '" + conn_config_.client_certificate_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }

                    if (logger_) logger_->debug("[ConnSSLCTX {}] Attempting to load client private key: {}", id_, conn_config_.client_private_key_pem_file.value());
                    if (conn_config_.client_private_key_password.has_value() && !conn_config_.client_private_key_password.value().empty()) {
                        ssl_context_sync_->set_password_callback(
                            [pwd = conn_config_.client_private_key_password.value()](std::size_t /*max_length*/, boost::asio::ssl::context_base::password_purpose /*purpose*/) {
                                return pwd;
                            },
                            ec_ssl_setup);
                        if (ec_ssl_setup) {
                            std::string msg = "Failed to set password callback for client private key: " + ec_ssl_setup.message();
                            _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                            if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    }
                    ssl_context_sync_->use_private_key_file(conn_config_.client_private_key_pem_file.value(), boost::asio::ssl::context::pem, ec_ssl_setup);
                    if (ec_ssl_setup) {
                        std::string msg = "Failed to load client private key file '" + conn_config_.client_private_key_pem_file.value() + "': " + ec_ssl_setup.message();
                        _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                        if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                        return last_error_code_;
                    }
                    if (logger_) logger_->info("[ConnSSLCTX {}] Client certificate and private key loaded successfully for mTLS.", id_);
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL context setup: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {  // Catch other standard exceptions like std::bad_alloc
                std::string msg = "Standard exception during SSL context setup: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLCTX {}] {}", id_, msg);
                return last_error_code_;
            }

            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLCTX {}] SSL context setup complete.", id_);
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/redirect_error.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/asio/ssl/host_name_verification.hpp>  // For host_name_verification
#include <boost/asio/steady_timer.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/error_code.hpp>
#include <iostream>

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// For OpenSSL specific calls if needed (SNI, error details)
#include <openssl/err.h>  // For ERR_get_error, ERR_error_string_n
#include <openssl/ssl.h>  // For SSL_set_tlsext_host_name

namespace neo4j_bolt_transport {
    namespace internal {

        // Re-declare or include the helper if it's made common
        template <typename AsyncOperation>
        boost::system::error_code run_with_timeout_sync_internal_hs(  // Renamed to avoid conflict if it stays local
            boost::asio::io_context& io_ctx,
            std::chrono::milliseconds timeout_duration,
            AsyncOperation op,
            std::shared_ptr<spdlog::logger> logger,
            uint64_t conn_id,
            const std::string& op_name,
            boost::asio::ssl::stream<boost::asio::ip::tcp::socket>* stream_to_cancel_on_timeout = nullptr) {
            boost::system::error_code result_ec = boost::asio::error::would_block;
            std::atomic<bool> operation_completed_flag{false};

            boost::asio::co_spawn(
                io_ctx,
                [&]() -> boost::asio::awaitable<void> {
                    boost::system::error_code op_ec;
                    try {
                        co_await op(op_ec);
                    } catch (const boost::system::system_error& e) {
                        op_ec = e.code();
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                    } catch (const std::exception& e) {
                        op_ec = boost::asio::error::fault;
                        if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                    }
                    result_ec = op_ec;
                    operation_completed_flag.store(true, std::memory_order_release);
                    co_return;
                },
                boost::asio::detached);

            boost::asio::steady_timer timer(io_ctx);
            bool timed_out_flag = false;

            if (timeout_duration.count() > 0) {
                timer.expires_after(timeout_duration);
                timer.async_wait([&](const boost::system::error_code& ec_timer) {
                    if (ec_timer != boost::asio::error::operation_aborted) {
                        if (!operation_completed_flag.load(std::memory_order_acquire)) {
                            if (logger) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timed out.", conn_id, op_name);
                            timed_out_flag = true;
                            result_ec = boost::asio::error::timed_out;
                            if (stream_to_cancel_on_timeout && stream_to_cancel_on_timeout->lowest_layer().is_open()) {
                                boost::system::error_code cancel_ec;
                                // For SSL stream, cancelling the lowest layer is usually the way for handshake
                                stream_to_cancel_on_timeout->lowest_layer().cancel(cancel_ec);
                                if (logger && cancel_ec) logger->warn("[ConnAsyncUtilHS {}] Op '{}' timeout socket cancel error: {}", conn_id, op_name, cancel_ec.message());
                            }
                            operation_completed_flag.store(true, std::memory_order_release);
                        }
                    }
                });
            }

            io_ctx.restart();
            while (!operation_completed_flag.load(std::memory_order_acquire)) {
                if (io_ctx.stopped()) {
                    if (logger) logger->warn("[ConnAsyncUtilHS {}] io_context stopped during op '{}'.", conn_id, op_name);
                    if (!timed_out_flag) result_ec = boost::asio::error::interrupted;
                    break;
                }
                io_ctx.poll_one();
                if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                    std::this_thread::yield();
                }
            }
            timer.cancel();
            return result_ec;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_stage_ssl_handshake() {
            if (!conn_config_.encryption_enabled) {
                // This stage is skipped if encryption is not enabled.
                if (logger_) logger_->debug("[ConnSSLHS {}] SSL encryption not enabled, skipping handshake.", id_);
                return boltprotocol::BoltError::SUCCESS;
            }
            if (current_state_.load(std::memory_order_relaxed) != InternalState::SSL_CONTEXT_SETUP) {
                std::string msg = "SSL handshake called in unexpected state: " + _get_current_state_as_string() + ". Expected SSL_CONTEXT_SETUP.";
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }
            // owned_socket_for_sync_plain_ should have been connected in _stage_tcp_connect
            // and ssl_context_sync_ should have been set up in _stage_ssl_context_setup.
            if (!ssl_context_sync_ || !owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                std::string msg = "SSL handshake attempted without a valid SSL context or a connected TCP socket.";
                _mark_as_defunct(boltprotocol::BoltError::INVALID_ARGUMENT, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKING, std::memory_order_relaxed);
            if (logger_) logger_->debug("[ConnSSLHS {}] Performing SSL handshake for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, conn_config_.bolt_handshake_timeout_ms);

            try {
                // Create the SSL stream, taking ownership of the socket
                ssl_stream_sync_ = std::make_unique<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>>(std::move(*owned_socket_for_sync_plain_), *ssl_context_sync_);
                owned_socket_for_sync_plain_.reset();  // Socket ownership transferred

                // Set SNI (Server Name Indication) and hostname verification
                if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                    // Set SNI hostname for TLS extension
                    if (!SSL_set_tlsext_host_name(ssl_stream_sync_->native_handle(), conn_config_.target_host.c_str())) {
                        boost::system::error_code sni_ec(static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category());
                        // SNI failure is usually not fatal for the handshake itself but might lead to cert validation issues.
                        if (logger_) logger_->warn("[ConnSSLHS {}] Failed to set SNI extension for host {}: {}. Handshake will proceed.", id_, conn_config_.target_host, sni_ec.message());
                    } else {
                        if (logger_) logger_->trace("[ConnSSLHS {}] SNI hostname set to: {}", id_, conn_config_.target_host);
                    }

                    // Set the verify callback for hostname verification.
                    ssl_stream_sync_->set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
                    if (logger_) logger_->trace("[ConnSSLHS {}] Hostname verification enabled for: {}", id_, conn_config_.target_host);
                } else {
                    if (logger_) logger_->debug("[ConnSSLHS {}] Hostname verification skipped (disabled or trust_all_certs).", id_);
                }

                // Perform the SSL handshake
                boost::system::error_code handshake_ec;
                auto handshake_op = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    try {
                        co_await ssl_stream_sync_->async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    } catch (const boost::system::system_error& e) {
                        op_ec_ref = e.code();
                    }
                    co_return;
                };

                handshake_ec = run_with_timeout_sync_internal_hs(io_context_ref_,
                                                                 std::chrono::milliseconds(conn_config_.bolt_handshake_timeout_ms),  // Using bolt_handshake_timeout_ms
                                                                 handshake_op,
                                                                 logger_,
                                                                 id_,
                                                                 "SSL Handshake",
                                                                 ssl_stream_sync_.get());

                if (handshake_ec) {
                    std::string msg;
                    if (handshake_ec == boost::asio::error::timed_out) {
                        msg = "SSL handshake timed out for host " + conn_config_.target_host + " after " + std::to_string(conn_config_.bolt_handshake_timeout_ms) + "ms.";
                    } else {
                        msg = "SSL handshake failed for host " + conn_config_.target_host + ": " + handshake_ec.message();
                        // Append OpenSSL error details if available
                        unsigned long openssl_err_code = ERR_get_error();  // Get last OpenSSL error
                        while (openssl_err_code != 0) {                    // Loop if there are multiple errors in the queue
                            char err_buf[256];
                            ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                            msg += " (OpenSSL: " + std::string(err_buf) + ")";
                            openssl_err_code = ERR_get_error();  // Get next error
                        }
                    }
                    _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                    if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                    return last_error_code_;
                }

            } catch (const boost::system::system_error& e) {
                std::string msg = "ASIO system error during SSL handshake: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {
                std::string msg = "Standard exception during SSL handshake: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnSSLHS {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::SSL_HANDSHAKEN, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnSSLHS {}] SSL handshake successful for {}.", id_, conn_config_.target_host);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_ssl_handshake_async(boost::asio::ssl::stream<boost::asio::ip::tcp::socket&>& stream_ref,  // Pass stream by reference
                                                                                                           std::chrono::milliseconds timeout) {
            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Performing SSL handshake async for host {} (Timeout: {}ms)...", id_, conn_config_.target_host, timeout.count());
            boost::system::error_code ec;

            // SNI and hostname verification setup
            if (conn_config_.hostname_verification_enabled && conn_config_.resolved_encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_ENCRYPTED_TRUST_ALL_CERTS) {
                if (!SSL_set_tlsext_host_name(stream_ref.native_handle(), conn_config_.target_host.c_str())) {
                    if (logger_) logger_->warn("[ConnSSLHSAsync {}] Failed to set SNI (async) for host {}", id_, conn_config_.target_host);
                }
                stream_ref.set_verify_callback(boost::asio::ssl::host_name_verification(conn_config_.target_host));
            }

            boost::asio::steady_timer timer(co_await boost::asio::this_coro::executor);
            std::atomic<bool> handshake_timed_out{false};
            std::atomic<bool> handshake_completed{false};

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                boost::asio::co_spawn(
                    co_await boost::asio::this_coro::executor,
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {
                            if (!handshake_completed.load(std::memory_order_acquire)) {
                                handshake_timed_out.store(true, std::memory_order_release);
                                boost::system::error_code cancel_ec;
                                stream_ref.lowest_layer().cancel(cancel_ec);  // Cancel underlying socket
                                if (logger_) logger_->warn("[ConnSSLHSAsync {}] SSL handshake async timed out, lowest_layer cancelled (ec: {}).", id_, cancel_ec.message());
                            }
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            // Perform handshake
            co_await stream_ref.async_handshake(boost::asio::ssl::stream_base::client, boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            handshake_completed.store(true, std::memory_order_release);
            if (timeout.count() > 0) {
                timer.cancel();
            }

            if (ec) {
                std::string msg;
                if (handshake_timed_out.load(std::memory_order_acquire) || ec == boost::asio::error::operation_aborted) {
                    msg = "Async SSL handshake for host " + conn_config_.target_host + " timed out or was cancelled.";
                    ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async SSL handshake failed: " + ec.message();
                    unsigned long openssl_err_code = ERR_get_error();
                    while (openssl_err_code != 0) {
                        char err_buf[256];
                        ERR_error_string_n(openssl_err_code, err_buf, sizeof(err_buf));
                        msg += " (OpenSSL: " + std::string(err_buf) + ")";
                        openssl_err_code = ERR_get_error();
                    }
                }
                if (logger_) logger_->error("[ConnSSLHSAsync {}] {}", id_, msg);
                _mark_as_defunct(boltprotocol::BoltError::HANDSHAKE_FAILED, msg);
                co_return boltprotocol::BoltError::HANDSHAKE_FAILED;
            }

            if (logger_) logger_->debug("[ConnSSLHSAsync {}] Async SSL handshake successful.", id_);
            current_state_.store(InternalState::SSL_HANDSHAKEN);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error::bolt_error_to_string
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        // _update_metadata_from_hello_success:  HELLO 
        void BoltPhysicalConnection::_update_metadata_from_hello_success(const boltprotocol::SuccessMessageParams& meta) {
            auto it_server = meta.metadata.find("server");
            if (it_server != meta.metadata.end() && std::holds_alternative<std::string>(it_server->second)) {
                server_agent_string_ = std::get<std::string>(it_server->second);
            } else {
                server_agent_string_.clear();  // 
            }

            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                server_assigned_conn_id_ = std::get<std::string>(it_conn_id->second);
            } else {
                server_assigned_conn_id_.clear();
            }

            //  UTC  (patch_bolt)
            utc_patch_active_ = false;  //  false
            // Bolt 4.3  4.4  patch_bolt  UTC
            if (negotiated_bolt_version_ == boltprotocol::versions::Version(4, 3) || negotiated_bolt_version_ == boltprotocol::versions::Version(4, 4)) {
                auto it_patch = meta.metadata.find("patch_bolt");
                if (it_patch != meta.metadata.end()) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second)) {
                        auto list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_patch->second);
                        if (list_ptr) {
                            for (const auto& val : list_ptr->elements) {
                                if (std::holds_alternative<std::string>(val)) {
                                    if (std::get<std::string>(val) == "utc") {
                                        utc_patch_active_ = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Bolt 5.0  UTC UTC
            if (negotiated_bolt_version_ >= boltprotocol::versions::Version(5, 0)) {
                utc_patch_active_ = true;
            }

            if (logger_) logger_->debug("[ConnState {}] Metadata updated from HELLO. Server: '{}', ConnId: '{}', UTC Patch Active: {}", id_, server_agent_string_, server_assigned_conn_id_, utc_patch_active_);
        }

        // _update_metadata_from_logon_success:  LOGON 
        void BoltPhysicalConnection::_update_metadata_from_logon_success(const boltprotocol::SuccessMessageParams& meta) {
            // LOGON  "connection_id"
            auto it_conn_id = meta.metadata.find("connection_id");
            if (it_conn_id != meta.metadata.end() && std::holds_alternative<std::string>(it_conn_id->second)) {
                std::string new_conn_id = std::get<std::string>(it_conn_id->second);
                if (server_assigned_conn_id_ != new_conn_id && logger_) {
                    logger_->debug("[ConnState {}] Connection ID changed by LOGON from '{}' to '{}'", id_, server_assigned_conn_id_, new_conn_id);
                }
                server_assigned_conn_id_ = new_conn_id;
            }
            // LOGON  server agent  patch_bolt  HELLO 
            if (logger_) logger_->debug("[ConnState {}] Metadata updated from LOGON. ConnId: '{}'", id_, server_assigned_conn_id_);
        }

        // _classify_and_set_server_failure:  FAILURE 
        boltprotocol::BoltError BoltPhysicalConnection::_classify_and_set_server_failure(const boltprotocol::FailureMessageParams& meta) {
            std::string neo4j_code = "Unknown.Error";
            std::string message = "An unspecified error occurred on the server.";

            auto extract_string_from_map = [&](const std::string& key) -> std::optional<std::string> {
                auto it = meta.metadata.find(key);
                if (it != meta.metadata.end() && std::holds_alternative<std::string>(it->second)) {
                    return std::get<std::string>(it->second);
                }
                return std::nullopt;
            };

            // Neo4j  (Bolt 5.1+)
            if (auto code_opt = extract_string_from_map("neo4j_code")) {
                neo4j_code = *code_opt;
            } else if (auto legacy_code_opt = extract_string_from_map("code")) {  //  "code"
                neo4j_code = *legacy_code_opt;
            }

            if (auto msg_opt = extract_string_from_map("message")) {
                message = *msg_opt;
            }

            std::string full_error_message = "Server error: [" + neo4j_code + "] " + message;

            // 
            // 
            boltprotocol::BoltError classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;
            InternalState next_state = InternalState::FAILED_SERVER_REPORTED;  // 

            if (neo4j_code.find("TransientError") != std::string::npos || neo4j_code.find("DatabaseUnavailable") != std::string::npos || neo4j_code.find("NotALeader") != std::string::npos || neo4j_code.find("ForbiddenOnReadOnlyDatabase") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::NETWORK_ERROR;  // /
                // next_state  FAILED_SERVER_REPORTED/
            } else if (neo4j_code.find("ClientError.Security") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::HANDSHAKE_FAILED;  // /
                next_state = InternalState::DEFUNCT;                                // 
            } else if (neo4j_code.find("ClientError.Statement") != std::string::npos) {
                classified_error_code = boltprotocol::BoltError::INVALID_ARGUMENT;  // 
                // next_state  FAILED_SERVER_REPORTED
            } else if (neo4j_code.find("ClientError.Transaction") != std::string::npos) {
                // 
                classified_error_code = boltprotocol::BoltError::UNKNOWN_ERROR;  // 
                // next_state  FAILED_SERVER_REPORTED
            } else {
                // 
                // next_state  FAILED_SERVER_REPORTED
            }

            // _mark_as_defunct  DEFUNCT
            if (next_state == InternalState::DEFUNCT) {
                _mark_as_defunct(classified_error_code, full_error_message);
            } else {
                //  DEFUNCT  FAILED_SERVER_REPORTED
                current_state_.store(InternalState::FAILED_SERVER_REPORTED, std::memory_order_relaxed);
                last_error_code_ = classified_error_code;
                last_error_message_ = full_error_message;
            }

            if (logger_) logger_->warn("[ConnState {}] Server reported failure. Code: '{}', Msg: '{}'. Classified as: {}, Next state: {}", id_, neo4j_code, message, error::bolt_error_to_string(last_error_code_), _get_current_state_as_string());
            return last_error_code_;  // 
        }

        // _mark_as_defunct: 
        void BoltPhysicalConnection::_mark_as_defunct(boltprotocol::BoltError reason, const std::string& message) {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            // 
            if (current_s == InternalState::DEFUNCT && last_error_code_ != boltprotocol::BoltError::SUCCESS && reason == last_error_code_) {
                if (!message.empty() && last_error_message_.find(message) == std::string::npos) {
                    last_error_message_ += "; Additional info: " + message;
                }
                return;  // 
            }

            current_state_.store(InternalState::DEFUNCT, std::memory_order_acq_rel);  //  acquire/release 
            last_error_code_ = reason;
            last_error_message_ = message;

            if (logger_) {
                logger_->error("[ConnState {}] Marked as DEFUNCT. Reason: {} ({}), Message: {}", id_, static_cast<int>(reason), error::bolt_error_to_string(reason), message);
            }
        }

        // _get_current_state_as_string: 
        std::string BoltPhysicalConnection::_get_current_state_as_string() const {
            switch (current_state_.load(std::memory_order_relaxed)) {
                case InternalState::FRESH:
                    return "FRESH";
                case InternalState::TCP_CONNECTING:
                    return "TCP_CONNECTING";
                case InternalState::TCP_CONNECTED:
                    return "TCP_CONNECTED";
                case InternalState::SSL_CONTEXT_SETUP:
                    return "SSL_CONTEXT_SETUP";
                case InternalState::SSL_HANDSHAKING:
                    return "SSL_HANDSHAKING";
                case InternalState::SSL_HANDSHAKEN:
                    return "SSL_HANDSHAKEN";
                case InternalState::BOLT_HANDSHAKING:
                    return "BOLT_HANDSHAKING";
                case InternalState::BOLT_HANDSHAKEN:
                    return "BOLT_HANDSHAKEN";
                case InternalState::HELLO_AUTH_SENT:
                    return "HELLO_AUTH_SENT";
                case InternalState::READY:
                    return "READY";
                case InternalState::STREAMING:
                    return "STREAMING";
                case InternalState::AWAITING_SUMMARY:
                    return "AWAITING_SUMMARY";
                case InternalState::FAILED_SERVER_REPORTED:
                    return "FAILED_SERVER_REPORTED";
                case InternalState::DEFUNCT:
                    return "DEFUNCT";
                default:
                    return "UNKNOWN_STATE_" + std::to_string(static_cast<int>(current_state_.load(std::memory_order_relaxed)));
            }
        }

        // is_ready_for_queries: 
        bool BoltPhysicalConnection::is_ready_for_queries() const {
            if (current_state_.load(std::memory_order_relaxed) != InternalState::READY) {
                return false;
            }
            // 
            if (conn_config_.encryption_enabled) {
                return ssl_stream_sync_ && ssl_stream_sync_->lowest_layer().is_open();  //  _sync_ 
            } else {
                return plain_iostream_wrapper_ && plain_iostream_wrapper_->good();
            }
        }

        // is_defunct: 
        bool BoltPhysicalConnection::is_defunct() const {
            InternalState current_s = current_state_.load(std::memory_order_relaxed);
            if (current_s == InternalState::DEFUNCT) {
                return true;
            }
            //  DEFUNCT
            if (current_s > InternalState::FRESH && current_s < InternalState::DEFUNCT) {  // 
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {  //  _sync_ 
                        // (const_cast<BoltPhysicalConnection*>(this))->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream found closed unexpectedly.");
                        return true;
                    }
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        // (const_cast<BoltPhysicalConnection*>(this))->_mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain stream found bad unexpectedly.");
                        return true;
                    }
                }
            }
            return false;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host
#include "boltprotocol/message_defs.h"             // For MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_send_chunked_payload_sync(const std::vector<uint8_t>& payload) {
            if (is_defunct()) return last_error_code_;

            const uint8_t* data_ptr = payload.data();
            size_t remaining_size = payload.size();
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (remaining_size > 0) {
                uint16_t chunk_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(boltprotocol::MAX_CHUNK_PAYLOAD_SIZE)));
                uint16_t chunk_size_be = boltprotocol::detail::host_to_be(chunk_size);

                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    // _write_to_active_sync_stream already logs and marks defunct
                    return err;
                }

                err = _write_to_active_sync_stream(data_ptr, chunk_size);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    return err;
                }

                data_ptr += chunk_size;
                remaining_size -= chunk_size;
            }

            // Send end-of-message marker (zero-size chunk)
            if (err == boltprotocol::BoltError::SUCCESS) {
                uint16_t zero_chunk_be = 0;
                err = _write_to_active_sync_stream(reinterpret_cast<const uint8_t*>(&zero_chunk_be), boltprotocol::CHUNK_HEADER_SIZE);
            }

            return err;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_receive_chunked_payload_sync(std::vector<uint8_t>& out_payload) {
            out_payload.clear();
            if (is_defunct()) return last_error_code_;

            size_t total_bytes_read_for_message = 0;
            boltprotocol::BoltError err = boltprotocol::BoltError::SUCCESS;

            while (true) {
                uint16_t chunk_size_be = 0;
                size_t bytes_read_header = 0;
                err = _read_from_active_sync_stream(reinterpret_cast<uint8_t*>(&chunk_size_be), boltprotocol::CHUNK_HEADER_SIZE, bytes_read_header);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();  // Ensure out_payload is clear on error
                    return err;
                }

                uint16_t chunk_payload_size = boltprotocol::detail::be_to_host(chunk_size_be);

                if (chunk_payload_size == 0) {  // End of message
                    break;
                }
                if (chunk_payload_size > boltprotocol::MAX_CHUNK_PAYLOAD_SIZE) {
                    err = boltprotocol::BoltError::CHUNK_TOO_LARGE;
                    std::string msg = "Received chunk larger than max allowed size: " + std::to_string(chunk_payload_size);
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->error("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t current_payload_offset = out_payload.size();
                try {
                    out_payload.resize(current_payload_offset + chunk_payload_size);
                } catch (const std::bad_alloc&) {
                    err = boltprotocol::BoltError::OUT_OF_MEMORY;
                    std::string msg = "Out of memory resizing payload buffer for chunk.";
                    _mark_as_defunct(err, msg);
                    if (logger_) logger_->critical("[ConnSyncChunking {}] {}", id_, msg);
                    out_payload.clear();
                    return err;
                }

                size_t bytes_read_payload = 0;
                err = _read_from_active_sync_stream(out_payload.data() + current_payload_offset, chunk_payload_size, bytes_read_payload);
                if (err != boltprotocol::BoltError::SUCCESS) {
                    out_payload.clear();
                    return err;
                }
                total_bytes_read_for_message += chunk_payload_size;
            }

            if (total_bytes_read_for_message == 0 && out_payload.empty()) {  // Received only an EOM marker
                if (logger_) logger_->trace("[ConnSyncChunking {}] Received NOOP message (empty payload from chunks).", id_);
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <boost/asio/read.hpp>
#include <boost/asio/write.hpp>
#include <cstring>   // For errno with iostream
#include <iostream>  // For std::ios_base::failure

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
// No boltprotocol includes needed here as these are pure ASIO/iostream operations

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_write_to_active_sync_stream(const uint8_t* data, size_t size) {
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Write attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            boost::system::error_code ec;
            size_t bytes_written = 0;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Write {} bytes", id_, size);
                    bytes_written = boost::asio::write(*ssl_stream_sync_, boost::asio::buffer(data, size), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for write.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for write.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Write {} bytes via iostream", id_, size);
                    plain_iostream_wrapper_->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
                    if (plain_iostream_wrapper_->fail()) {
                        // Try to get a more specific error if possible, otherwise assume generic stream error
                        // For iostreams, fail() doesn't directly give a boost::system::error_code in the same way.
                        // We might need to rely on errno or a generic error.
                        int stream_errno = errno;  // POSIX errno
                        ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EPIPE /*Broken pipe is common*/, boost::system::system_category());
                    } else {
                        bytes_written = size;  // Assume full write if no fail bit
                        plain_iostream_wrapper_->flush();
                        if (plain_iostream_wrapper_->fail()) {
                            int stream_errno_flush = errno;
                            ec = boost::system::error_code(stream_errno_flush != 0 ? stream_errno_flush : EPIPE, boost::system::system_category());
                        }
                    }
                }
            } catch (const boost::system::system_error& e) {  // Catches ASIO errors
                ec = e.code();
                std::string msg = "ASIO system error during sync write: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {  // Catches iostream errors if exceptions are enabled
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO /*Generic I/O error*/, boost::system::system_category());
                std::string msg = "iostream failure during sync write: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg = "Sync write to stream failed: " + ec.message();
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            if (bytes_written != size) {
                // This case is less likely with boost::asio::write which tries to write all.
                // For iostream, if fail() wasn't set, we assume full write. More robust checking might be needed
                // if partial writes without failbit are possible for plain_iostream_wrapper_.
                std::string msg = "Partial sync write to stream. Expected " + std::to_string(size) + ", wrote " + std::to_string(bytes_written);
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

        boltprotocol::BoltError BoltPhysicalConnection::_read_from_active_sync_stream(uint8_t* buffer, size_t size_to_read, size_t& bytes_read) {
            bytes_read = 0;
            if (is_defunct()) {
                if (logger_) logger_->error("[ConnSyncIO {}] Read attempt on defunct connection. LastError: {} ({})", id_, static_cast<int>(last_error_code_), last_error_message_);
                return last_error_code_ != boltprotocol::BoltError::SUCCESS ? last_error_code_ : boltprotocol::BoltError::NETWORK_ERROR;
            }
            if (size_to_read == 0) return boltprotocol::BoltError::SUCCESS;  // Nothing to read

            boost::system::error_code ec;

            try {
                if (conn_config_.encryption_enabled) {
                    if (!ssl_stream_sync_ || !ssl_stream_sync_->lowest_layer().is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "SSL stream not open or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] SSL stream not open or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] SSL Read {} bytes", id_, size_to_read);
                    // boost::asio::read ensures all bytes are read or an error (like EOF) occurs.
                    bytes_read = boost::asio::read(*ssl_stream_sync_, boost::asio::buffer(buffer, size_to_read), ec);
                } else {
                    if (!plain_iostream_wrapper_ || !plain_iostream_wrapper_->good()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Plain iostream wrapper not good or null for read.");
                        if (logger_) logger_->error("[ConnSyncIO {}] Plain iostream wrapper not good or null for read.", id_);
                        return last_error_code_;
                    }
                    if (logger_) logger_->trace("[ConnSyncIO {}] Plain Read {} bytes via iostream", id_, size_to_read);
                    plain_iostream_wrapper_->read(reinterpret_cast<char*>(buffer), static_cast<std::streamsize>(size_to_read));
                    bytes_read = static_cast<size_t>(plain_iostream_wrapper_->gcount());

                    if (bytes_read < size_to_read) {  // If not all bytes were read
                        if (plain_iostream_wrapper_->eof()) {
                            ec = boost::asio::error::eof;  // End of file reached before all bytes read
                        } else if (plain_iostream_wrapper_->fail()) {
                            int stream_errno = errno;
                            ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                        } else {
                            // Should not happen if gcount() < size_to_read and no fail/eof bits are set, but defensive.
                            ec = boost::asio::error::fault;  // Unexpected: not enough bytes but no error state
                        }
                    }
                    // If bytes_read == size_to_read, no error from iostream perspective for this read call.
                }
            } catch (const boost::system::system_error& e) {
                ec = e.code();
                std::string msg = "ASIO system error during sync read: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::ios_base::failure& e) {
                int stream_errno = errno;
                ec = boost::system::error_code(stream_errno != 0 ? stream_errno : EIO, boost::system::system_category());
                std::string msg = "iostream failure during sync read: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }

            if (ec) {
                std::string msg;
                if (ec == boost::asio::error::eof) {
                    msg = "Sync read from stream failed: EOF reached prematurely. Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                } else {
                    msg = "Sync read from stream failed: " + ec.message() + ". Read " + std::to_string(bytes_read) + "/" + std::to_string(size_to_read);
                }
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            // This check is crucial. boost::asio::read guarantees full read or error.
            // For iostream, we check gcount().
            if (bytes_read < size_to_read) {
                std::string msg = "Incomplete sync read from stream. Expected " + std::to_string(size_to_read) + ", got " + std::to_string(bytes_read) + ". No specific stream error reported.";
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);  // Treat as error
                if (logger_) logger_->error("[ConnSyncIO {}] {}", id_, msg);
                return last_error_code_;
            }
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <boost/asio/co_spawn.hpp>  // For co_spawn in sync connect helper
#include <boost/asio/connect.hpp>   // For boost::asio::async_connect with endpoint sequence
#include <boost/asio/detached.hpp>  // For detached in sync connect helper
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/redirect_error.hpp>  // For redirect_error
#include <boost/asio/steady_timer.hpp>    // For timeout in sync connect helper
#include <thread>                         // For std::this_thread::yield in sync connect helper

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"

// Helper function for synchronous connect with timeout (copied from your earlier version)
// This should ideally be in a common utility or made static within this file if only used here.
namespace {  // Anonymous namespace
    template <typename AsyncOperation>
    boost::system::error_code run_sync_op_with_timeout_tcp(  // Renamed to avoid conflicts
        boost::asio::io_context& io_ctx,
        std::chrono::milliseconds timeout_duration,
        AsyncOperation op,  // This lambda captures the socket by reference
        std::shared_ptr<spdlog::logger> logger,
        uint64_t conn_id,
        const std::string& op_name,
        boost::asio::ip::tcp::socket* socket_to_cancel_on_timeout) {
        boost::system::error_code result_ec = boost::asio::error::would_block;  // Default to an in-progress code
        std::atomic<bool> operation_completed_flag{false};

        // Launch the operation as a coroutine on the io_context
        boost::asio::co_spawn(
            io_ctx,
            [&]() -> boost::asio::awaitable<void> {
                boost::system::error_code op_ec_local;
                try {
                    co_await op(op_ec_local);  // The lambda 'op' itself is awaitable or wraps an awaitable
                } catch (const boost::system::system_error& e) {
                    op_ec_local = e.code();
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught system_error: {}", conn_id, op_name, e.what());
                } catch (const std::exception& e) {
                    op_ec_local = boost::asio::error::fault;  // Generic error
                    if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' caught exception: {}", conn_id, op_name, e.what());
                }
                result_ec = op_ec_local;
                operation_completed_flag.store(true, std::memory_order_release);
                co_return;
            },
            boost::asio::detached);

        boost::asio::steady_timer timer(io_ctx);
        bool timed_out_flag = false;

        if (timeout_duration.count() > 0) {
            timer.expires_after(timeout_duration);
            timer.async_wait([&, logger, conn_id, op_name, socket_to_cancel_on_timeout]  // Capture logger etc.
                             (const boost::system::error_code& ec_timer) {
                                 if (ec_timer != boost::asio::error::operation_aborted) {              // Timer wasn't cancelled
                                     if (!operation_completed_flag.load(std::memory_order_acquire)) {  // Op still running
                                         if (logger) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timed out.", conn_id, op_name);
                                         timed_out_flag = true;
                                         result_ec = boost::asio::error::timed_out;
                                         if (socket_to_cancel_on_timeout && socket_to_cancel_on_timeout->is_open()) {
                                             boost::system::error_code cancel_ec;
                                             socket_to_cancel_on_timeout->cancel(cancel_ec);  // Attempt to cancel the socket operation
                                             if (logger && cancel_ec) logger->warn("[ConnAsyncUtilTCP {}] Op '{}' timeout socket cancel error: {}", conn_id, op_name, cancel_ec.message());
                                         }
                                         operation_completed_flag.store(true, std::memory_order_release);  // Mark as completed (due to timeout)
                                     }
                                 }
                             });
        }

        // Run the io_context until the operation completes or times out.
        // This loop is for a synchronous call that internally uses async mechanisms.
        io_ctx.restart();  // Ensure io_context is not stopped
        while (!operation_completed_flag.load(std::memory_order_acquire)) {
            if (io_ctx.stopped()) {
                if (logger) logger->warn("[ConnAsyncUtilTCP {}] io_context stopped during op '{}' before completion.", conn_id, op_name);
                if (!timed_out_flag && result_ec == boost::asio::error::would_block) {  // If not timed out and still 'would_block'
                    result_ec = boost::asio::error::interrupted;                        // Or some other appropriate error
                }
                break;
            }
            io_ctx.poll_one();  // Process one handler
            // If still not completed and io_context might have no more work temporarily (e.g. in a tight loop after poll_one returns 0)
            if (!operation_completed_flag.load(std::memory_order_acquire) && io_ctx.stopped()) {
                std::this_thread::yield();  // Yield to other threads if any, or just to break busy wait.
                io_ctx.restart();           // Restart if it stopped because of no work
            }
        }
        timer.cancel();  // Cancel timer if it hasn't fired (op completed first)
        return result_ec;
    }
}  // anonymous namespace

namespace neo4j_bolt_transport {
    namespace internal {

        boltprotocol::BoltError BoltPhysicalConnection::_stage_tcp_connect() {
            // Reset any previous socket/stream state for synchronous operations
            if (plain_iostream_wrapper_) plain_iostream_wrapper_.reset();
            if (ssl_stream_sync_) ssl_stream_sync_.reset();  // Should be reset if we are re-doing TCP connect
            if (owned_socket_for_sync_plain_ && owned_socket_for_sync_plain_->is_open()) {
                boost::system::error_code ignored_ec;
                try {
                    owned_socket_for_sync_plain_->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
                    owned_socket_for_sync_plain_->close(ignored_ec);
                } catch (...) { /* Ignore errors during cleanup */
                }
            }
            owned_socket_for_sync_plain_ = std::make_unique<boost::asio::ip::tcp::socket>(io_context_ref_);
            // current_state_ should already be TCP_CONNECTING or ASYNC_TCP_CONNECTING when this is called by establish/establish_async

            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, conn_config_.tcp_connect_timeout_ms);

            boost::system::error_code ec;
            try {
                boost::asio::ip::tcp::resolver resolver(io_context_ref_);
                // Resolve can throw if host is malformed, though async_resolve is often preferred for non-blocking.
                // For sync, resolve directly is fine.
                boost::asio::ip::tcp::resolver::results_type endpoints = resolver.resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), ec);

                if (ec) {
                    std::string msg = "DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }
                if (endpoints.empty()) {
                    std::string msg = "DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Define the connect operation as a lambda for the timeout helper
                auto connect_op_lambda = [&](boost::system::error_code& op_ec_ref) -> boost::asio::awaitable<void> {
                    // This lambda is itself a coroutine because it co_awaits.
                    // It will be run by co_spawn within run_sync_op_with_timeout_tcp.
                    co_await boost::asio::async_connect(*owned_socket_for_sync_plain_, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, op_ec_ref));
                    co_return;
                };

                ec = run_sync_op_with_timeout_tcp(io_context_ref_, std::chrono::milliseconds(conn_config_.tcp_connect_timeout_ms), connect_op_lambda, logger_, id_, "Sync TCP Connect", owned_socket_for_sync_plain_.get());

                if (ec) {
                    std::string msg;
                    if (ec == boost::asio::error::timed_out) {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out after " + std::to_string(conn_config_.tcp_connect_timeout_ms) + "ms.";
                    } else {
                        msg = "Sync TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                    }
                    _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                    if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                    return last_error_code_;
                }

                // Set socket options
                if (conn_config_.socket_keep_alive_enabled) {
                    boost::system::error_code keep_alive_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                    if (keep_alive_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                    }
                }
                if (conn_config_.tcp_no_delay_enabled) {
                    boost::system::error_code no_delay_ec;
                    owned_socket_for_sync_plain_->set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                    if (no_delay_ec && logger_) {
                        logger_->warn("[ConnTCP {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                    }
                }

                // If not using SSL, wrap the socket in an iostream
                if (!conn_config_.encryption_enabled) {
                    if (!owned_socket_for_sync_plain_ || !owned_socket_for_sync_plain_->is_open()) {
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, "Socket not open for plain stream wrapper after connect.");
                        if (logger_) logger_->error("[ConnTCP {}] Socket not open for plain iostream wrapper post-connect.", id_);
                        return last_error_code_;
                    }
                    try {
                        // Pass the socket by rvalue reference to transfer ownership to iostream
                        plain_iostream_wrapper_ = std::make_unique<boost::asio::ip::tcp::iostream>(std::move(*owned_socket_for_sync_plain_));
                        owned_socket_for_sync_plain_.reset();  // Socket is now owned by iostream_wrapper_
                        if (!plain_iostream_wrapper_->good()) {
                            std::string msg = "Failed to initialize plain iostream wrapper after TCP connect (stream not good).";
                            _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                            if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                            return last_error_code_;
                        }
                    } catch (const std::exception& e) {  // Catch potential exceptions from iostream constructor
                        std::string msg = "Exception creating plain iostream wrapper: " + std::string(e.what());
                        _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                        if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                        return last_error_code_;
                    }
                }
                // If SSL is enabled, owned_socket_for_sync_plain_ remains and will be used by _stage_ssl_handshake

            } catch (const boost::system::system_error& e) {  // Catch errors from resolver.resolve or socket options
                std::string msg = "ASIO system error during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            } catch (const std::exception& e) {  // Catch other std exceptions
                std::string msg = "Standard exception during sync TCP connect stage: " + std::string(e.what());
                _mark_as_defunct(boltprotocol::BoltError::UNKNOWN_ERROR, msg);
                if (logger_) logger_->error("[ConnTCP {}] {}", id_, msg);
                return last_error_code_;
            }

            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCP {}] Sync TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            return boltprotocol::BoltError::SUCCESS;
        }

        boost::asio::awaitable<boltprotocol::BoltError> BoltPhysicalConnection::_stage_tcp_connect_async(boost::asio::ip::tcp::socket& socket,  // Takes a reference to an existing socket
                                                                                                         std::chrono::milliseconds timeout) {
            // current_state_ should be ASYNC_TCP_CONNECTING, set by establish_async
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP Connecting to {}:{} (Timeout: {}ms)", id_, conn_config_.target_host, conn_config_.target_port, timeout.count());

            boost::system::error_code ec;
            boost::asio::ip::tcp::resolver resolver(socket.get_executor());  // Use socket's executor

            auto endpoints = co_await resolver.async_resolve(conn_config_.target_host, std::to_string(conn_config_.target_port), boost::asio::redirect_error(boost::asio::use_awaitable, ec));
            if (ec) {
                std::string msg = "Async DNS resolution failed for " + conn_config_.target_host + ": " + ec.message();
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }
            if (endpoints.empty()) {
                std::string msg = "Async DNS resolution for " + conn_config_.target_host + " returned no endpoints.";
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            boost::asio::steady_timer timer(socket.get_executor());
            bool timed_out = false;

            if (timeout.count() > 0) {
                timer.expires_after(timeout);
                // Start a separate coroutine for the timer that cancels the connect op
                boost::asio::co_spawn(
                    socket.get_executor(),
                    [&]() -> boost::asio::awaitable<void> {
                        boost::system::error_code timer_ec;
                        co_await timer.async_wait(boost::asio::redirect_error(boost::asio::use_awaitable, timer_ec));
                        if (timer_ec != boost::asio::error::operation_aborted) {  // Timer expired
                            timed_out = true;
                            boost::system::error_code cancel_ec;
                            socket.cancel(cancel_ec);  // Cancel the connect operation
                            if (logger_ && cancel_ec) logger_->trace("[ConnTCPAsync {}] Connect op socket cancel returned: {}", id_, cancel_ec.message());
                        }
                        co_return;
                    },
                    boost::asio::detached);
            }

            co_await boost::asio::async_connect(socket, endpoints, boost::asio::redirect_error(boost::asio::use_awaitable, ec));

            if (timeout.count() > 0) {
                timer.cancel();  // If connect finished (with or without error), cancel the timer
            }

            if (ec) {
                std::string msg;
                if (timed_out || ec == boost::asio::error::operation_aborted /*due to timer cancel*/) {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " timed out or was cancelled.";
                    // Ensure ec reflects timeout if timed_out is true, even if cancel caused a different ec
                    if (timed_out) ec = boost::asio::error::timed_out;
                } else {
                    msg = "Async TCP connect to " + conn_config_.target_host + ":" + std::to_string(conn_config_.target_port) + " failed: " + ec.message();
                }
                _mark_as_defunct(boltprotocol::BoltError::NETWORK_ERROR, msg);
                if (logger_) logger_->error("[ConnTCPAsync {}] {}", id_, msg);
                co_return last_error_code_;
            }

            // Set socket options (same as sync version)
            if (conn_config_.socket_keep_alive_enabled) {
                boost::system::error_code keep_alive_ec;
                socket.set_option(boost::asio::socket_base::keep_alive(true), keep_alive_ec);
                if (keep_alive_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set SO_KEEPALIVE: {}", id_, keep_alive_ec.message());
                }
            }
            if (conn_config_.tcp_no_delay_enabled) {
                boost::system::error_code no_delay_ec;
                socket.set_option(boost::asio::ip::tcp::no_delay(true), no_delay_ec);
                if (no_delay_ec && logger_) {
                    logger_->warn("[ConnTCPAsync {}] Failed to set TCP_NODELAY: {}", id_, no_delay_ec.message());
                }
            }

            // Unlike sync, we don't wrap in iostream here. The raw socket (or later SSL stream) is used.
            current_state_.store(InternalState::TCP_CONNECTED, std::memory_order_relaxed);  // Or ASYNC_TCP_CONNECTED if differentiating
            last_error_code_ = boltprotocol::BoltError::SUCCESS;
            last_error_message_.clear();
            if (logger_) logger_->debug("[ConnTCPAsync {}] Async TCP connection established to {}:{}.", id_, conn_config_.target_host, conn_config_.target_port);
            co_return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace internal
}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 

#include "boltprotocol/bolt_errors_versions.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/uri/uri_parser.h"

namespace neo4j_bolt_transport {

    // Static private helper method definition
    std::string Neo4jBoltTransport::_make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string db_part = database_name.empty() ? "system" : database_name;
        if (impersonated_user && !impersonated_user->empty()) {
            return db_part + "@" + *impersonated_user;
        }
        return db_part;
    }

    Neo4jBoltTransport::Neo4jBoltTransport(config::TransportConfig a_config) : config_(std::move(a_config)) {
        if (!config_.logger) {
            config_.logger = config_.get_or_create_logger();
            if (!config_.logger) {
                std::cerr << "CRITICAL ERROR: Logger creation/retrieval failed during Neo4jBoltTransport initialization!" << std::endl;
                throw std::runtime_error("Logger initialization failed for Neo4jBoltTransport.");
            }
        }

        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initializing with URI: '{}'", config_.uri_string);

        if (uri::UriParser::parse(config_.uri_string, parsed_initial_uri_) != boltprotocol::BoltError::SUCCESS) {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty()) {
                if (config_.logger) config_.logger->error("[TransportLC] URI '{}' parsing failed and no initial router override provided. Routing may not work.", config_.uri_string);
            } else if (config_.logger) {
                config_.logger->warn("[TransportLC] URI '{}' parsing failed, but routing is disabled or initial router override is provided.", config_.uri_string);
            }
        } else {
            if (config_.client_side_routing_enabled && config_.initial_router_addresses_override.empty() && parsed_initial_uri_.is_routing_scheme && !parsed_initial_uri_.hosts_with_ports.empty()) {
                std::vector<routing::ServerAddress> initial_routers_from_uri;
                for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                    initial_routers_from_uri.emplace_back(hp.first, hp.second);
                }
                std::string default_context_key = _make_routing_context_key("", std::nullopt);
                config_.initial_router_addresses_override[default_context_key] = initial_routers_from_uri;
                if (config_.logger) config_.logger->info("[TransportLC] Set {} initial routers from URI for context '{}'.", initial_routers_from_uri.size(), default_context_key);
            }
        }

        config_.prepare_agent_strings();
        finalized_user_agent_ = config_.user_agent_override.empty() ? config_.bolt_agent_info.product : config_.user_agent_override;
        finalized_bolt_agent_info_ = config_.bolt_agent_info;

        if (io_context_.stopped()) {
            io_context_.restart();
        }
        work_guard_ = std::make_unique<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(boost::asio::make_work_guard(io_context_));

        if (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0) {
            eviction_timer_ = std::make_unique<boost::asio::steady_timer>(io_context_);

            uint32_t first_eviction_delay_ms = 10000;
            if (config_.idle_timeout_ms > 0) {
                first_eviction_delay_ms = config_.idle_timeout_ms / 2;
            } else if (config_.max_connection_lifetime_ms > 0) {
                first_eviction_delay_ms = config_.max_connection_lifetime_ms / 4;
            }
            first_eviction_delay_ms = std::max(1000u, first_eviction_delay_ms);

            eviction_timer_->expires_after(std::chrono::milliseconds(first_eviction_delay_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec_lambda) {
                if (ec_lambda != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->info("[TransportLC] Connection eviction task scheduled in {}ms.", first_eviction_delay_ms);
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport initialized.");
    }

    Neo4jBoltTransport::~Neo4jBoltTransport() {
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destructing.");
        close();
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport destruction complete.");
    }

    void Neo4jBoltTransport::close() {
        bool already_closing = closing_.exchange(true);
        if (already_closing) {
            if (config_.logger) config_.logger->debug("[TransportLC] Close already called or in progress.");
            return;
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closing...");

        if (eviction_timer_) {
            try {
                std::size_t cancelled_count = eviction_timer_->cancel();  // No error_code parameter
                if (config_.logger) {
                    config_.logger->trace("[TransportLC] Eviction timer cancelled {} pending operations.", cancelled_count);
                }
            } catch (const boost::system::system_error& e) {
                if (config_.logger) {
                    config_.logger->warn("[TransportLC] Exception during eviction_timer_.cancel(): {}", e.what());
                }
            }
            eviction_timer_.reset();
            if (config_.logger) config_.logger->trace("[TransportLC] Eviction timer reset.");
        }

        {
            std::lock_guard<std::mutex> lock(pool_mutex_);
            if (config_.logger) config_.logger->debug("[TransportLC] Terminating {} idle connections.", idle_connections_.size());
            for (auto& conn_ptr : idle_connections_) {
                if (conn_ptr) {
                    conn_ptr->terminate(true);
                }
            }
            idle_connections_.clear();
            total_connections_currently_pooled_ = 0;
        }
        pool_condition_.notify_all();

        {
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            routing_tables_.clear();
            if (config_.logger) config_.logger->debug("[TransportLC] Routing tables cleared.");
        }

        if (work_guard_) {
            work_guard_->reset();
        }
        if (!io_context_.stopped()) {
            io_context_.stop();
        }

        if (own_io_thread_ && io_thread_ && io_thread_->joinable()) {
            if (config_.logger) config_.logger->debug("[TransportLC] Joining IO thread...");
            try {
                io_thread_->join();
                if (config_.logger) config_.logger->debug("[TransportLC] IO thread joined.");
            } catch (const std::system_error& e) {
                if (config_.logger) config_.logger->error("[TransportLC] Error joining IO thread: {}", e.what());
            }
        }
        if (config_.logger) config_.logger->info("[TransportLC] Neo4jBoltTransport closed.");
    }

    boltprotocol::BoltError Neo4jBoltTransport::verify_connectivity() {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[TransportVerify] Attempting to verify connectivity on a closing transport.");
            return boltprotocol::BoltError::UNKNOWN_ERROR;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Verifying connectivity...");

        routing::ServerAddress address_to_verify;
        bool use_routing_for_verify = config_.client_side_routing_enabled && (parsed_initial_uri_.scheme != "bolt" && parsed_initial_uri_.scheme != "bolt+s" && parsed_initial_uri_.scheme != "bolt+ssc");

        if (use_routing_for_verify) {
            auto [addr_err, router_addr] = _get_server_address_for_session(config::SessionParameters{}.with_database("system"), routing::ServerRole::ROUTER);
            if (addr_err != boltprotocol::BoltError::SUCCESS || router_addr.host.empty()) {
                if (config_.logger) config_.logger->warn("[TransportVerify] Failed to get a router address for verification. Error: {}. Falling back to initial URI if possible.", neo4j_bolt_transport::error::bolt_error_to_string(addr_err));
                if (!parsed_initial_uri_.hosts_with_ports.empty()) {
                    const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
                    address_to_verify = routing::ServerAddress(hp.first, hp.second);
                    if (config_.logger) config_.logger->debug("[TransportVerify] Using direct address from URI for verification: {}", address_to_verify.to_string());
                } else {
                    if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No router available and no direct address in URI.");
                    return boltprotocol::BoltError::NETWORK_ERROR;
                }
            } else {
                address_to_verify = router_addr;
            }
        } else {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: No direct address in URI for non-routing scheme.");
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            const auto& hp = parsed_initial_uri_.hosts_with_ports.front();
            address_to_verify = routing::ServerAddress(hp.first, hp.second);
        }

        if (address_to_verify.host.empty()) {
            if (config_.logger) config_.logger->error("[TransportVerify] Connectivity verification failed: Final address to verify is empty.");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        routing::ServerAddress resolved_address_to_verify = address_to_verify;
        if (config_.server_address_resolver) {
            resolved_address_to_verify = config_.server_address_resolver(address_to_verify);
        }

        if (config_.logger) config_.logger->debug("[TransportVerify] Attempting to acquire connection to {} (resolved from {}) for verification.", resolved_address_to_verify.to_string(), address_to_verify.to_string());

        auto [conn_err, conn] = _acquire_pooled_connection(resolved_address_to_verify, std::nullopt);

        if (conn_err != boltprotocol::BoltError::SUCCESS || !conn) {
            if (config_.logger) config_.logger->error("[TransportVerify] Failed to acquire connection to {} for verification. Error: {}", resolved_address_to_verify.to_string(), neo4j_bolt_transport::error::bolt_error_to_string(conn_err));
            return conn_err;
        }

        if (config_.logger) config_.logger->info("[TransportVerify] Connectivity to {} verified successfully (connection {} acquired).", resolved_address_to_verify.to_string(), conn->get_id());
        release_connection(std::move(conn), true);
        return boltprotocol::BoltError::SUCCESS;
    }

    internal::BoltConnectionConfig Neo4jBoltTransport::_create_physical_connection_config(const routing::ServerAddress& target_address, const std::optional<std::map<std::string, boltprotocol::Value>>& routing_context_for_hello) const {
        internal::BoltConnectionConfig physical_conf;
        physical_conf.target_host = target_address.host;
        physical_conf.target_port = target_address.port;
        physical_conf.auth_token = config_.auth_token;
        physical_conf.user_agent_for_hello = finalized_user_agent_;
        physical_conf.bolt_agent_info_for_hello = finalized_bolt_agent_info_;

        physical_conf.resolved_encryption_strategy = config_.encryption_strategy;
        if (config_.encryption_strategy != config::TransportConfig::EncryptionStrategy::FORCE_PLAINTEXT) {
            physical_conf.encryption_enabled = true;
            physical_conf.trusted_certificates_pem_files = config_.trusted_certificates_pem_files;
            physical_conf.client_certificate_pem_file = config_.client_certificate_pem_file;
            physical_conf.client_private_key_pem_file = config_.client_private_key_pem_file;
            physical_conf.client_private_key_password = config_.client_private_key_password;
            physical_conf.hostname_verification_enabled = config_.hostname_verification_enabled;
        } else {
            physical_conf.encryption_enabled = false;
        }

        physical_conf.tcp_connect_timeout_ms = config_.tcp_connect_timeout_ms;
        physical_conf.socket_read_timeout_ms = config_.socket_read_timeout_ms;
        physical_conf.socket_write_timeout_ms = config_.socket_write_timeout_ms;
        physical_conf.socket_keep_alive_enabled = config_.tcp_keep_alive_enabled;
        physical_conf.tcp_no_delay_enabled = config_.tcp_no_delay_enabled;
        physical_conf.bolt_handshake_timeout_ms = config_.hello_timeout_ms;  // Note: This was hello_timeout_ms, perhaps should be a dedicated handshake_timeout_ms in TransportConfig?
        physical_conf.hello_timeout_ms = config_.hello_timeout_ms;
        physical_conf.goodbye_timeout_ms = config_.goodbye_timeout_ms;

        if (routing_context_for_hello.has_value()) {
            physical_conf.hello_routing_context = routing_context_for_hello;
        }

        if (!config_.preferred_bolt_versions.empty()) {
            physical_conf.preferred_bolt_versions = config_.preferred_bolt_versions;
        }

        if (config_.logger) {
            std::string preferred_versions_str = "default";
            if (physical_conf.preferred_bolt_versions.has_value() && !physical_conf.preferred_bolt_versions->empty()) {
                preferred_versions_str.clear();
                for (const auto& v : physical_conf.preferred_bolt_versions.value()) {
                    preferred_versions_str += v.to_string() + " ";
                }
            }
            config_.logger->trace("[TransportLC] Created physical connection config: Host={}, Port={}, Enc={}, Strategy={}, ReadTimeout={}, WriteTimeout={}, HelloTimeout={}, TCPNoDelay={}, HelloRoutingCtx={}, PreferredBoltVersions=[{}]",
                                  physical_conf.target_host,
                                  physical_conf.target_port,
                                  physical_conf.encryption_enabled,
                                  static_cast<int>(physical_conf.resolved_encryption_strategy),
                                  physical_conf.socket_read_timeout_ms,
                                  physical_conf.socket_write_timeout_ms,
                                  physical_conf.hello_timeout_ms,
                                  physical_conf.tcp_no_delay_enabled,
                                  physical_conf.hello_routing_context.has_value() ? "Yes" : "No",
                                  preferred_versions_str);
        }
        return physical_conf;
    }

}  // namespace neo4j_bolt_transport#include <algorithm>
#include <chrono>
#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _acquire_pooled_connection:  ** 
    // 
    std::pair<boltprotocol::BoltError, internal::BoltPhysicalConnection::PooledConnection> Neo4jBoltTransport::_acquire_pooled_connection(const routing::ServerAddress& target_address, const std::optional<std::string>& database_name_hint /**/) {
        if (closing_.load(std::memory_order_acquire)) {
            if (config_.logger) config_.logger->warn("[PoolCore]  transport  {} ", target_address.to_string());
            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
        }

        std::unique_lock<std::mutex> lock(pool_mutex_);
        auto start_time = std::chrono::steady_clock::now();

        while (true) {
            // 1.  target_address 
            for (auto it = idle_connections_.begin(); it != idle_connections_.end(); /* manual increment */) {
                internal::BoltPhysicalConnection::PooledConnection& conn_ptr_ref = *it;

                if (conn_ptr_ref->get_config().target_host == target_address.host && conn_ptr_ref->get_config().target_port == target_address.port) {
                    internal::BoltPhysicalConnection::PooledConnection conn_to_check = std::move(conn_ptr_ref);
                    it = idle_connections_.erase(it);  // 
                    total_connections_currently_pooled_--;

                    bool healthy = true;
                    std::string unhealthy_reason;

                    if (conn_to_check->is_defunct()) {
                        healthy = false;
                        unhealthy_reason = "is_defunct";
                    } else if (config_.max_connection_lifetime_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms))) {
                        healthy = false;
                        unhealthy_reason = "exceeded max lifetime";
                    } else if (config_.idle_time_before_health_check_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - conn_to_check->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_time_before_health_check_ms))) {
                        if (config_.logger) config_.logger->trace("[PoolCore]  {} ( {})  (ping)", conn_to_check->get_id(), target_address.to_string());

                        lock.unlock();
                        boltprotocol::BoltError ping_err = conn_to_check->ping(std::chrono::milliseconds(config_.tcp_connect_timeout_ms));
                        lock.lock();

                        if (closing_.load(std::memory_order_acquire)) {
                            if (config_.logger) config_.logger->warn("[PoolCore] Ping  transport ");
                            if (conn_to_check) conn_to_check->terminate(false);
                            total_connections_ever_created_--;
                            return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                        }

                        if (ping_err != boltprotocol::BoltError::SUCCESS) {
                            healthy = false;
                            unhealthy_reason = "ping failed (" + error::bolt_error_to_string(ping_err) + ")";
                        } else {
                            if (config_.logger) config_.logger->trace("[PoolCore]  {} ( {}) ping ", conn_to_check->get_id(), target_address.to_string());
                        }
                    }

                    if (healthy) {
                        if (config_.logger) config_.logger->debug("[PoolCore]  {}  {} (: '{}')", conn_to_check->get_id(), target_address.to_string(), database_name_hint.value_or("<>"));
                        conn_to_check->mark_as_used();
                        return {boltprotocol::BoltError::SUCCESS, std::move(conn_to_check)};
                    } else {
                        if (config_.logger) config_.logger->info("[PoolCore] / {} ( {}) (: {}).", (conn_to_check ? conn_to_check->get_id() : 0), target_address.to_string(), unhealthy_reason);
                        if (conn_to_check) conn_to_check->terminate(false);
                        total_connections_ever_created_--;
                        //  idle_connections_  ( erase )
                        // it = idle_connections_.erase(it)  it++
                        continue;
                    }
                }
                ++it;  // 
            }

            // 2.  target_address 
            if (total_connections_ever_created_ < config_.max_connection_pool_size) {
                std::optional<std::map<std::string, boltprotocol::Value>> hello_routing_ctx_opt;
                if (config_.client_side_routing_enabled) {
                    std::map<std::string, boltprotocol::Value> ctx_map;
                    ctx_map["address"] = target_address.to_string();  // HELLO 
                    hello_routing_ctx_opt = ctx_map;
                }

                internal::BoltConnectionConfig physical_conn_conf = _create_physical_connection_config(target_address, hello_routing_ctx_opt);
                std::shared_ptr<spdlog::logger> conn_logger = config_.get_or_create_logger("BoltConnection");

                lock.unlock();
                if (config_.logger) config_.logger->debug("[PoolCore]  {}  (: '{}')", target_address.to_string(), database_name_hint.value_or("<>"));

                auto new_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(physical_conn_conf), io_context_, conn_logger);
                boltprotocol::BoltError establish_err = new_conn->establish();
                lock.lock();

                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore] Transport ");
                    if (new_conn) new_conn->terminate(false);
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }

                if (establish_err == boltprotocol::BoltError::SUCCESS) {
                    if (config_.logger) config_.logger->info("[PoolCore]  {}  {} ", target_address.to_string(), new_conn->get_id());
                    total_connections_ever_created_++;
                    new_conn->mark_as_used();
                    return {boltprotocol::BoltError::SUCCESS, std::move(new_conn)};
                } else {
                    if (config_.logger) config_.logger->error("[PoolCore]  {} : {} ({})", target_address.to_string(), static_cast<int>(establish_err), new_conn ? new_conn->get_last_error_message() : error::bolt_error_to_string(establish_err));
                    //  ** 
                    // 
                    return {establish_err, nullptr};
                }
            }

            // 3. 
            auto time_waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time);
            auto remaining_timeout_ms = std::chrono::milliseconds(config_.connection_acquisition_timeout_ms) - time_waited;

            if (remaining_timeout_ms <= std::chrono::milliseconds(0)) {
                if (config_.logger) config_.logger->error("[PoolCore]  {}  (: {})", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // TODO: 
            }

            if (config_.logger) {
                config_.logger->trace("[PoolCore]  ({}/{}) {}ms  {} ",
                                      total_connections_ever_created_,
                                      config_.max_connection_pool_size,  //  ever_created 
                                      remaining_timeout_ms.count(),
                                      target_address.to_string());
            }

            if (pool_condition_.wait_for(lock, remaining_timeout_ms, [this] {
                    return closing_.load(std::memory_order_relaxed) || !idle_connections_.empty();  // 
                })) {
                if (closing_.load(std::memory_order_acquire)) {
                    if (config_.logger) config_.logger->warn("[PoolCore]  transport ");
                    return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};
                }
                if (config_.logger) config_.logger->trace("[PoolCore]  transport ");
            } else {
                if (config_.logger) config_.logger->error("[PoolCore]  {}  wait_for  (: {})", target_address.to_string(), config_.max_connection_pool_size);
                return {boltprotocol::BoltError::UNKNOWN_ERROR, nullptr};  // 
            }
            // 
        }
    }

    void Neo4jBoltTransport::release_connection(internal::BoltPhysicalConnection::PooledConnection connection, bool mark_as_healthy) {
        if (!connection) return;

        bool transport_is_closing = closing_.load(std::memory_order_acquire);
        uint64_t conn_id = connection->get_id();
        routing::ServerAddress conn_target(connection->get_config().target_host, connection->get_config().target_port);

        if (transport_is_closing) {
            if (config_.logger) config_.logger->debug("[PoolCore]  transport  {} ( {}), ", conn_id, conn_target.to_string());
            connection->terminate(false);  //  GOODBYE
            // total_connections_ever_created_ 
            //  total_connections_ever_created_
            std::lock_guard<std::mutex> lock(pool_mutex_);
            total_connections_ever_created_ = std::max(0, (int)total_connections_ever_created_ - 1);  // 
            return;
        }

        std::lock_guard<std::mutex> lock(pool_mutex_);

        if (!mark_as_healthy || connection->is_defunct()) {
            if (config_.logger) config_.logger->info("[PoolCore] / {} ( {}), : {}, : {}", conn_id, conn_target.to_string(), mark_as_healthy, connection->is_defunct());
            connection->terminate(false);
            total_connections_ever_created_--;
            pool_condition_.notify_one();
            return;
        }

        bool should_retire_due_to_age = false;
        if (config_.max_connection_lifetime_ms > 0) {
            auto age = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - connection->get_creation_timestamp());
            if (age.count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                should_retire_due_to_age = true;
                if (config_.logger) config_.logger->info("[PoolCore]  {} ( {}) ", conn_id, conn_target.to_string());
            }
        }

        // max_connection_pool_size 
        // 
        // max_connection_pool_size  total_connections_ever_created_ 
        // total_connections_currently_pooled_ 
        if (should_retire_due_to_age || total_connections_currently_pooled_ >= config_.max_connection_pool_size) {
            if (config_.logger) config_.logger->debug("[PoolCore]  {} ( {}): {}, : {}, (): {}", conn_id, conn_target.to_string(), should_retire_due_to_age, total_connections_currently_pooled_, config_.max_connection_pool_size);
            connection->terminate(true);  //  GOODBYE
            total_connections_ever_created_--;
            pool_condition_.notify_one();
        } else {
            if (config_.logger) config_.logger->debug("[PoolCore]  {} ( {}) : {}", conn_id, conn_target.to_string(), total_connections_currently_pooled_);
            connection->mark_as_used();  // 
            idle_connections_.push_back(std::move(connection));
            total_connections_currently_pooled_++;
            pool_condition_.notify_one();
        }
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::remove_if
#include <chrono>
#include <iostream>  // 

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    void Neo4jBoltTransport::_evict_stale_connections_task() {
        if (closing_.load(std::memory_order_acquire)) return;

        if (config_.logger) config_.logger->trace("[PoolEvictor] ...");

        std::unique_lock<std::mutex> lock(pool_mutex_);
        if (closing_.load(std::memory_order_acquire)) return;  // 

        auto now = std::chrono::steady_clock::now();
        int evicted_count = 0;

        auto it_remove = std::remove_if(idle_connections_.begin(), idle_connections_.end(), [&](const internal::BoltPhysicalConnection::PooledConnection& conn_ptr) {
            if (!conn_ptr) return true;  // 

            bool evict = false;
            std::string reason;
            routing::ServerAddress conn_target(conn_ptr->get_config().target_host, conn_ptr->get_config().target_port);

            if (config_.max_connection_lifetime_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_creation_timestamp()).count() > static_cast<long long>(config_.max_connection_lifetime_ms)) {
                    evict = true;
                    reason = "";
                }
            }
            if (!evict && config_.idle_timeout_ms > 0) {
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - conn_ptr->get_last_used_timestamp()).count() > static_cast<long long>(config_.idle_timeout_ms)) {
                    evict = true;
                    reason = "";
                }
            }
            if (!evict && conn_ptr->is_defunct()) {  // 
                evict = true;
                reason = "";
            }

            if (evict) {
                if (config_.logger) config_.logger->info("[PoolEvictor]  {} ( {}) : {}.", conn_ptr->get_id(), conn_target.to_string(), reason);
                conn_ptr->terminate(false);  //  GOODBYE
                return true;                 // 
            }
            return false;  // 
        });

        evicted_count = std::distance(it_remove, idle_connections_.end());
        if (evicted_count > 0) {
            idle_connections_.erase(it_remove, idle_connections_.end());
            total_connections_currently_pooled_ -= evicted_count;
            total_connections_ever_created_ -= evicted_count;
            if (config_.logger) config_.logger->debug("[PoolEvictor]  {} : {}. : {}", evicted_count, total_connections_currently_pooled_, total_connections_ever_created_);
            pool_condition_.notify_all();  // 
        }
        lock.unlock();  // 

        //  ( transport )
        if (!closing_.load(std::memory_order_acquire) && eviction_timer_ && (config_.idle_timeout_ms > 0 || config_.max_connection_lifetime_ms > 0)) {
            // 1
            uint32_t next_check_interval_ms = 10000;  // 10
            if (config_.idle_timeout_ms > 0 && config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = std::min(config_.idle_timeout_ms, config_.max_connection_lifetime_ms);
            } else if (config_.idle_timeout_ms > 0) {
                next_check_interval_ms = config_.idle_timeout_ms;
            } else if (config_.max_connection_lifetime_ms > 0) {
                next_check_interval_ms = config_.max_connection_lifetime_ms;
            }
            next_check_interval_ms = std::max(1000u, next_check_interval_ms / 2);

            eviction_timer_->expires_after(std::chrono::milliseconds(next_check_interval_ms));
            eviction_timer_->async_wait([this](const boost::system::error_code& ec) {
                if (ec != boost::asio::error::operation_aborted && !closing_.load(std::memory_order_relaxed)) {
                    _evict_stale_connections_task();
                }
            });
            if (config_.logger) config_.logger->trace("[PoolEvictor]  {}ms ", next_check_interval_ms);
        } else if (config_.logger) {
            config_.logger->trace("[PoolEvictor]  (transport/)");
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/config/session_parameters.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"
#include "neo4j_bolt_transport/session_handle.h"
// #include "neo4j_bolt_transport/async_session_handle.h" // 
#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"

namespace neo4j_bolt_transport {

    // --- Neo4jBoltTransport - acquire_session () ---
    std::pair<std::pair<boltprotocol::BoltError, std::string>, SessionHandle> Neo4jBoltTransport::acquire_session(const config::SessionParameters& params) {
        if (closing_.load(std::memory_order_acquire)) {
            std::string err_msg = " transport ";
            if (config_.logger) config_.logger->warn("[SessionAcq] {}", err_msg);
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->debug("[SessionAcq] : '{}', : {}", params.database_name.value_or("<>"), (params.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"));

        routing::ServerRole role_hint = (params.default_access_mode == config::AccessMode::READ) ? routing::ServerRole::READER : routing::ServerRole::WRITER;

        auto [addr_err, target_server_address] = _get_server_address_for_session(params, role_hint);

        if (addr_err != boltprotocol::BoltError::SUCCESS || target_server_address.host.empty()) {
            std::string err_msg = " (DB: " + params.database_name.value_or("<>") + ", : " + (role_hint == routing::ServerRole::READER ? "R" : "W") + "): " + error::bolt_error_to_string(addr_err);
            if (!target_server_address.host.empty()) {
                err_msg += " (: " + target_server_address.to_string() + ")";
            }
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);
            return {{addr_err, err_msg}, SessionHandle(this, nullptr, params)};
        }

        auto [conn_err_code, pooled_conn] = _acquire_pooled_connection(target_server_address, params.database_name);

        if (conn_err_code != boltprotocol::BoltError::SUCCESS || !pooled_conn) {
            std::string err_msg = " " + target_server_address.to_string() + " : (" + error::bolt_error_to_string(conn_err_code) + ")";
            if (config_.logger) config_.logger->error("[SessionAcq] {}", err_msg);

            if (config_.client_side_routing_enabled && conn_err_code == boltprotocol::BoltError::NETWORK_ERROR) {
                std::string db_name_for_routing_key = params.database_name.value_or("");
                //  Neo4jBoltTransport 
                _handle_routing_failure(target_server_address, Neo4jBoltTransport::_make_routing_context_key(db_name_for_routing_key, params.impersonated_user));
            }
            return {{conn_err_code, err_msg}, SessionHandle(this, nullptr, params)};
        }

        if (config_.logger) config_.logger->info("[SessionAcq]  {}  {}", pooled_conn->get_id(), target_server_address.to_string());
        return {{boltprotocol::BoltError::SUCCESS, ""}, SessionHandle(this, std::move(pooled_conn), params)};
    }

    // acquire_async_session 
    /*
    boost::asio::awaitable<std::pair<std::pair<boltprotocol::BoltError, std::string>, AsyncSessionHandle>>
    Neo4jBoltTransport::acquire_async_session(const config::SessionParameters& params) {
        // ... () ...
        if (config_.logger) config_.logger->debug("[SessionAcqAsync]  ()");
        co_return std::make_pair(std::make_pair(boltprotocol::BoltError::UNKNOWN_ERROR, "Async session acquisition not implemented."), AsyncSessionHandle(this, nullptr, params));
    }
    */

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/neo4j_transaction_context.h"

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionContext::TransactionContext(SessionHandle& session) : owner_session_(session) {
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> TransactionContext::run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters) {
        if (!owner_session_.is_in_transaction()) {
            std::string err_msg = "TransactionContext::run called, but SessionHandle is not in an active explicit transaction.";
            boltprotocol::SuccessMessageParams dummy_run_summary_raw;
            auto dummy_field_names = std::make_shared<const std::vector<std::string>>();
            std::vector<boltprotocol::RecordMessageParams> empty_records;

            //  BoltResultStream 
            std::string server_addr = "unknown_server";
            boltprotocol::versions::Version bolt_ver(0, 0);
            bool utc_patch = false;
            if (owner_session_.connection_ && owner_session_.connection_->is_ready_for_queries()) {  // 
                server_addr = owner_session_.connection_->get_config().target_host + ":" + std::to_string(owner_session_.connection_->get_config().target_port);
                bolt_ver = owner_session_.connection_->get_bolt_version();
                utc_patch = owner_session_.connection_->is_utc_patch_active();
            }

            // 
            auto failed_stream = std::make_unique<BoltResultStream>(&owner_session_,
                                                                    std::nullopt,
                                                                    std::move(dummy_run_summary_raw),
                                                                    dummy_field_names,
                                                                    std::move(empty_records),
                                                                    false,  // server_might_have_more
                                                                    bolt_ver,
                                                                    utc_patch,
                                                                    server_addr,
                                                                    owner_session_.session_params_.database_name,  // session_params_  SessionHandle 
                                                                    boltprotocol::BoltError::INVALID_ARGUMENT,     // initial_error
                                                                    err_msg,                                       // initial_error_message
                                                                    std::nullopt                                   // initial_failure_details
            );
            // failed_stream->_set_failure_state(boltprotocol::BoltError::INVALID_ARGUMENT, err_msg); // 

            return {{boltprotocol::BoltError::INVALID_ARGUMENT, err_msg}, std::move(failed_stream)};
        }
        return owner_session_.run_query(cypher, parameters, std::nullopt);
    }

    // SessionHandle  run_consume  run_query_and_consume ResultSummary
    // TransactionContext::run_consume 
    //  SuccessMessageParams  FailureMessageParams
    //  SessionHandle  TransactionContext  ResultSummary 
    //  TransactionContext::run_consume 
    //  SessionHandle  run_query_and_get_raw_summary 
    //
    //  TransactionContext::run_consume  run_query  consume ResultSummary 
    //  SessionHandle  consume 
    //
    //  TransactionContext::run_consume  ResultSummary
    // SessionHandle 
    //
    //  TransactionContext::run_consume  SessionHandle::run_query_and_consume 
    // 
    //
    // **1:  TransactionContext::run_consume  ()**
    // std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary>
    // TransactionContext::run_consume(const std::string& cypher,
    //                                 const std::map<std::string, boltprotocol::Value>& parameters) {
    //     if (!owner_session_.is_in_transaction()) {
    //         // ...  ResultSummary ...
    //         return {{boltprotocol::BoltError::INVALID_ARGUMENT, "Not in transaction"}, ResultSummary(...)};
    //     }
    //     return owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);
    // }

    // **2:  ()**
    std::pair<boltprotocol::BoltError, std::string> TransactionContext::run_consume(const std::string& cypher,
                                                                                    const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                    boltprotocol::SuccessMessageParams& out_summary_raw,  // 
                                                                                    boltprotocol::FailureMessageParams& out_failure_raw) {
        if (!owner_session_.is_in_transaction()) {
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "TransactionContext::run_consume called, but SessionHandle is not in an active explicit transaction."};
        }

        //  SessionHandle  run_query_and_consume
        auto [err_pair, result_summary_typed] = owner_session_.run_query_and_consume(cypher, parameters, std::nullopt);

        //  ResultSummary 
        out_summary_raw = result_summary_typed.raw_params();  //  ResultSummary  raw_params()
                                                              //  ResultSummary 

        if (err_pair.first != boltprotocol::BoltError::SUCCESS) {
            //  ResultStream  out_failure_raw
            // BoltResultStream *stream_ptr_for_failure = nullptr; // 
            // if (stream_ptr_for_failure && stream_ptr_for_failure->has_failed()){
            //    out_failure_raw = stream_ptr_for_failure->get_failure_details();
            // } else {
            out_failure_raw.metadata["message"] = boltprotocol::Value(err_pair.second);
            // }
        } else {
            out_failure_raw.metadata.clear();  // 
        }
        return err_pair;
    }

}  // namespace neo4j_bolt_transport#include <iostream>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::tuple<boltprotocol::BoltError, std::string, ResultSummary> BoltResultStream::consume() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consuming stream.", (void*)this);

        if (stream_failed_) {
            // If failed, final_summary_typed_ might not be meaningful or might be from RUN.
            // Return run_summary_typed_ or a default-constructed ResultSummary if even that is bad.
            // For now, return existing final_summary_typed_ which should be default/run summary.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }
        if (stream_fully_consumed_or_discarded_) {
            return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
        }

        auto discard_result_pair = _discard_all_remaining_records();  // This will update final_summary_typed_ internally via _update_final_summary

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            // _set_failure_state was called by _discard_all_remaining_records
            // final_summary_typed_ might reflect the RUN summary in this case.
            return {failure_reason_, failure_message_, final_summary_typed_};
        }

        // Update session bookmarks from the final summary for auto-commit sessions.
        // This happens only if consume was successful and it was an auto-commit query.
        if (owner_session_ && !owner_session_->is_in_transaction() && !stream_failed_) {
            auto it_bookmark = final_summary_typed_.raw_params().metadata.find("bookmark");
            if (it_bookmark != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                owner_session_->update_bookmarks({std::get<std::string>(it_bookmark->second)});
            } else {
                if (failure_reason_ == boltprotocol::BoltError::SUCCESS) {  // Only clear if server operation was success
                    owner_session_->update_bookmarks({});
                }
            }
        }
        if (logger) logger->trace("[ResultStreamCONSUME {}] Consume successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", final_summary_typed_};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 
#include <utility>   // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_fetch_more_records(int64_t n) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            std::string msg = "Fetch records: Invalid session or connection.";
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, msg);
            if (logger) logger->warn("[ResultStreamFETCH {}] {}", (void*)this, msg);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || (stream_fully_consumed_or_discarded_ && !is_first_pull_attempt_)) {
            if (logger) logger->trace("[ResultStreamFETCH {}] Already failed or consumed. Failed: {}, Consumed: {}, FirstPull: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_, is_first_pull_attempt_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::UNKNOWN_ERROR, failure_message_};
        }

        if (logger) logger->trace("[ResultStreamFETCH {}] Fetching {} records. QID: {}", (void*)this, n, (query_id_ ? std::to_string(*query_id_) : "auto"));

        std::vector<boltprotocol::RecordMessageParams> fetched_records;
        boltprotocol::SuccessMessageParams current_pull_summary_raw;  //  _stream_pull_records 

        std::optional<int64_t> qid_for_this_pull = query_id_;

        //  SessionHandle 
        auto pull_result_pair = owner_session_->_stream_pull_records(qid_for_this_pull, n, fetched_records, current_pull_summary_raw);
        is_first_pull_attempt_ = false;  //  PULL

        if (pull_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            //  PULL 
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != pull_result_pair.first) {  // 
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    // temp_fail.metadata["code"] = ... ( BoltPhysicalConnection  Neo4j )
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(pull_result_pair.first, pull_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamFETCH {}] _stream_pull_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(pull_result_pair.first), pull_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        // PULL  SUCCESS 
        _update_final_summary(std::move(current_pull_summary_raw));  //  final_summary_typed_

        for (auto& rec : fetched_records) {
            raw_record_buffer_.push_back(std::move(rec));
        }

        //  final_summary_typed_  has_more
        auto it_has_more = final_summary_typed_.raw_params().metadata.find("has_more");
        if (it_has_more != final_summary_typed_.raw_params().metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
            server_has_more_records_ = std::get<bool>(it_has_more->second);
        } else {
            server_has_more_records_ = false;  //  PULL  "has_more"
        }

        if (!server_has_more_records_ && raw_record_buffer_.empty()) {
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamFETCH {}] Fetched {}. Buffer: {}. ServerMore: {}", (void*)this, fetched_records.size(), raw_record_buffer_.size(), server_has_more_records_);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::_discard_all_remaining_records() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discarding. QID: {}", (void*)this, (query_id_ ? std::to_string(*query_id_) : "auto"));

        if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Discard: Invalid session/connection.");
            if (logger) logger->warn("[ResultStreamDISCARD {}] Invalid session/connection.", (void*)this);
            return {failure_reason_, failure_message_};
        }
        if (stream_failed_ || stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamDISCARD {}] Already failed or consumed. Failed: {}, Consumed: {}", (void*)this, stream_failed_, stream_fully_consumed_or_discarded_);
            return {failure_reason_ != boltprotocol::BoltError::SUCCESS ? failure_reason_ : boltprotocol::BoltError::SUCCESS, failure_message_};
        }

        raw_record_buffer_.clear();  // 

        //  DISCARD
        // server_has_more_records_  PULL/DISCARD  has_more 
        // initial_server_has_more_records_  RUN  has_more 
        // is_first_pull_attempt_  PULL  DISCARD
        bool needs_server_discard = false;
        if (is_first_pull_attempt_) {  // PULL/DISCARD
            needs_server_discard = initial_server_has_more_records_;
        } else {  // PULL/DISCARD
            needs_server_discard = server_has_more_records_;
        }

        if (!needs_server_discard) {
            stream_fully_consumed_or_discarded_ = true;
            // RUN  consume RUN 
            // final_summary_typed_  run_summary_typed_
            // _update_final_summary  run_summary  final_summary
            // PULLfinal_summary_typed_ PULL
            if (is_first_pull_attempt_) {
                //  final_summary_typed_  run_summary_typed_ 
                // _update_final_summary(boltprotocol::SuccessMessageParams(run_summary_typed_.raw_params()));
                //  final_summary_typed_  run_summary_typed_ 
            }
            if (logger) logger->trace("[ResultStreamDISCARD {}] No records on server to discard. FirstPull: {}, InitialServerMore: {}, CurrentServerMore: {}", (void*)this, is_first_pull_attempt_, initial_server_has_more_records_, server_has_more_records_);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        //  DISCARD
        boltprotocol::SuccessMessageParams discard_summary_raw;  // 
        std::optional<int64_t> qid_for_discard = query_id_;

        auto discard_result_pair = owner_session_->_stream_discard_records(qid_for_discard, -1, discard_summary_raw);
        is_first_pull_attempt_ = false;              //  PULL/DISCARD
        stream_fully_consumed_or_discarded_ = true;  // DISCARD 

        if (discard_result_pair.first != boltprotocol::BoltError::SUCCESS) {
            std::optional<boltprotocol::FailureMessageParams> fail_details;
            if (owner_session_ && owner_session_->connection_ && owner_session_->connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                if (owner_session_->connection_->get_last_error_code() != discard_result_pair.first) {
                    boltprotocol::FailureMessageParams temp_fail;
                    temp_fail.metadata["message"] = boltprotocol::Value(owner_session_->connection_->get_last_error_message());
                    fail_details = temp_fail;
                }
            }
            _set_failure_state(discard_result_pair.first, discard_result_pair.second, fail_details);
            if (logger) logger->warn("[ResultStreamDISCARD {}] _stream_discard_records failed. Error: {}, Msg: {}", (void*)this, static_cast<int>(discard_result_pair.first), discard_result_pair.second);
            return {failure_reason_, failure_message_};
        }

        _update_final_summary(std::move(discard_summary_raw));  //  final_summary_typed_
        server_has_more_records_ = false;                       // DISCARD 
        if (logger) logger->trace("[ResultStreamDISCARD {}] Discard successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // ... (has_next ) ...
    std::pair<boltprotocol::BoltError, std::string> BoltResultStream::has_next(bool& out_has_next) {
        out_has_next = false;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream already failed. Reason: {}", (void*)this, static_cast<int>(failure_reason_));
            return {failure_reason_, failure_message_};
        }
        if (stream_fully_consumed_or_discarded_) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Stream fully consumed/discarded.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, ""};
        }
        if (!raw_record_buffer_.empty()) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Records in buffer.", (void*)this);
            out_has_next = true;
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        bool effectively_has_more_on_server = is_first_pull_attempt_ ? initial_server_has_more_records_ : server_has_more_records_;

        if (!effectively_has_more_on_server) {
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, server indicates no more records.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
            //  final_summary_typed_ 
            //  run_summary_typed_  PULL 
            //  PULL/DISCARD RUN final_summary  run_summary
            if (is_first_pull_attempt_) {
                //  final_summary_typed_  run_summary_typed_ 
                //  BoltResultStream final_summary_typed_  run_summary_params_raw 
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        int64_t fetch_n = 1000;  // 
        if (owner_session_ && owner_session_->session_params_.default_fetch_size != 0) {
            fetch_n = (owner_session_->session_params_.default_fetch_size > 0 || owner_session_->session_params_.default_fetch_size == -1) ? owner_session_->session_params_.default_fetch_size : 1000;
        }

        if (logger) logger->trace("[ResultStreamITER {}] has_next: Buffer empty, attempting to fetch {} records.", (void*)this, fetch_n);
        auto fetch_result = _fetch_more_records(fetch_n);  //  final_summary_typed_

        if (fetch_result.first != boltprotocol::BoltError::SUCCESS) {
            return fetch_result;  // _fetch_more_records 
        }

        out_has_next = !raw_record_buffer_.empty();
        if (!out_has_next && !server_has_more_records_) {  // 
            if (logger) logger->trace("[ResultStreamITER {}] has_next: Fetched, buffer still empty, PULL confirms no more.", (void*)this);
            stream_fully_consumed_or_discarded_ = true;
        }
        if (logger) logger->trace("[ResultStreamITER {}] has_next: After fetch, out_has_next={}", (void*)this, out_has_next);
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::next() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        bool has_more = false;
        auto has_next_res_pair = has_next(has_more);  // has_next_res_pair  std::pair

        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);  //  pair 

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            return {err_code_has_next, std::move(err_msg_has_next), std::nullopt};
        }
        if (!has_more) {
            if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};
            if (logger) logger->trace("[ResultStreamITER {}] next: No more records.", (void*)this);
            return {boltprotocol::BoltError::SUCCESS, "No more records in stream.", std::nullopt};
        }

        if (raw_record_buffer_.empty() && !stream_failed_) {
            _set_failure_state(boltprotocol::BoltError::UNKNOWN_ERROR, "Internal error: has_next() was true but buffer is empty and not failed.");
            if (logger) logger->error("[ResultStreamITER {}] next: Internal error - has_next true but buffer empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }
        if (stream_failed_) return {failure_reason_, failure_message_, std::nullopt};

        boltprotocol::RecordMessageParams raw_record_params = std::move(raw_record_buffer_.front());
        raw_record_buffer_.pop_front();

        if (logger) logger->trace("[ResultStreamITER {}] next: Popped one record. Buffer size: {}", (void*)this, raw_record_buffer_.size());

        BoltRecord record(std::move(raw_record_params.fields), field_names_ptr_cache_);
        return {boltprotocol::BoltError::SUCCESS, "", std::make_optional<BoltRecord>(std::move(record))};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::optional<BoltRecord>> BoltResultStream::single() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] single() called.", (void*)this);

        auto next_result_tuple = next();  //  next()
        boltprotocol::BoltError err_code_next = std::get<0>(next_result_tuple);
        std::string err_msg_next = std::get<1>(std::move(next_result_tuple));
        std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_result_tuple));

        if (err_code_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error from first next(): {}.", (void*)this, err_msg_next);
            return {err_code_next, std::move(err_msg_next), std::nullopt};
        }
        if (!record_opt.has_value()) {
            if (stream_failed_) {  //  next()  has_next() -> _fetch_more_records() 
                if (logger) logger->trace("[ResultStreamITER {}] single(): No record, stream failed. Reason: {}.", (void*)this, failure_message_);
                return {failure_reason_, failure_message_, std::nullopt};
            }
            //  next() 
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but stream was empty.");
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, stream empty.", (void*)this);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        // 
        bool has_more_records = false;
        auto has_next_res_pair = has_next(has_more_records);
        boltprotocol::BoltError err_code_has_next = has_next_res_pair.first;
        std::string err_msg_has_next = std::move(has_next_res_pair.second);

        if (err_code_has_next != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Error checking for more records after finding one: {}.", (void*)this, err_msg_has_next);
            _set_failure_state(err_code_has_next, "Error checking for subsequent records in single(): " + err_msg_has_next);
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (has_more_records) {
            if (logger) logger->warn("[ResultStreamITER {}] single(): Expected single record, but more found. Discarding rest.", (void*)this);
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamITER {}] single(): Discarding extra records failed: {}", (void*)this, discard_res.second);
            }
            _set_failure_state(boltprotocol::BoltError::INVALID_MESSAGE_FORMAT, "Expected a single record, but found more.");
            return {failure_reason_, failure_message_, std::nullopt};
        }

        if (logger) logger->trace("[ResultStreamITER {}] single() successful.", (void*)this);
        return {boltprotocol::BoltError::SUCCESS, "", std::move(record_opt)};
    }

    std::tuple<boltprotocol::BoltError, std::string, std::vector<BoltRecord>> BoltResultStream::list_all() {
        std::vector<BoltRecord> all_records_converted;
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamITER {}] list_all: Starting.", (void*)this);

        if (stream_failed_) {
            if (logger) logger->trace("[ResultStreamITER {}] list_all: Stream already failed.", (void*)this);
            return {failure_reason_, failure_message_, std::move(all_records_converted)};
        }

        while (true) {
            auto next_res_tuple = next();
            boltprotocol::BoltError err_code = std::get<0>(next_res_tuple);
            std::string err_msg = std::get<1>(std::move(next_res_tuple));                   // 
            std::optional<BoltRecord> record_opt = std::get<2>(std::move(next_res_tuple));  // 

            if (err_code != boltprotocol::BoltError::SUCCESS) {
                if (logger) logger->warn("[ResultStreamITER {}] list_all: Error from next(): {}.", (void*)this, err_msg);
                // 
                return {err_code, std::move(err_msg), std::move(all_records_converted)};
            }
            if (!record_opt.has_value()) {  // 
                if (logger) logger->trace("[ResultStreamITER {}] list_all: End of stream reached by next().", (void*)this);
                break;
            }
            all_records_converted.push_back(std::move(*record_opt));  //  optional  BoltRecord
        }

        if (logger) logger->trace("[ResultStreamITER {}] list_all: Finished. Records: {}", (void*)this, all_records_converted.size());
        return {boltprotocol::BoltError::SUCCESS, "", std::move(all_records_converted)};
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>  // For std::move

#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    BoltResultStream::BoltResultStream(SessionHandle* session,
                                       std::optional<int64_t> query_id_for_streaming,
                                       boltprotocol::SuccessMessageParams run_summary_params_raw,
                                       std::shared_ptr<const std::vector<std::string>> field_names_ptr,
                                       std::vector<boltprotocol::RecordMessageParams> initial_records,
                                       bool server_might_have_more,
                                       const boltprotocol::versions::Version& bolt_version,
                                       bool utc_patch_active,
                                       const std::string& server_address_for_summary,
                                       const std::optional<std::string>& database_name_for_summary,
                                       boltprotocol::BoltError initial_error,
                                       const std::string& initial_error_message,
                                       const std::optional<boltprotocol::FailureMessageParams>& initial_failure_details)
        : owner_session_(session),
          query_id_(query_id_for_streaming),
          field_names_ptr_cache_(std::move(field_names_ptr)),
          // Initialize run_summary_typed_ with a copy of raw params for now
          run_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          // final_summary_typed_ initialized similarly, will be updated by _update_final_summary
          final_summary_typed_(boltprotocol::SuccessMessageParams(run_summary_params_raw), bolt_version, utc_patch_active, server_address_for_summary, database_name_for_summary),
          initial_server_has_more_records_(server_might_have_more),
          server_has_more_records_(server_might_have_more),
          bolt_version_cache_(bolt_version),
          utc_patch_active_cache_(utc_patch_active),
          server_address_cache_(server_address_for_summary),
          database_name_cache_(database_name_for_summary) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;

        for (auto&& rec_param : initial_records) {
            raw_record_buffer_.push_back(std::move(rec_param));
        }

        if (initial_error != boltprotocol::BoltError::SUCCESS) {
            _set_failure_state(initial_error, initial_error_message, initial_failure_details);
        } else if (!owner_session_ || !owner_session_->is_connection_valid()) {
            _set_failure_state(boltprotocol::BoltError::NETWORK_ERROR, "Session or connection invalid at ResultStream creation.");
        }

        // Ensure field_names_ptr_cache_ is populated from run_summary_typed_ if it was null
        if (!field_names_ptr_cache_ || field_names_ptr_cache_->empty()) {
            auto it_fields = run_summary_typed_.raw_params().metadata.find("fields");
            if (it_fields != run_summary_typed_.raw_params().metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
                auto temp_field_names = std::make_shared<std::vector<std::string>>();
                const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
                if (list_ptr) {
                    temp_field_names->reserve(list_ptr->elements.size());
                    for (const auto& field_val : list_ptr->elements) {
                        if (std::holds_alternative<std::string>(field_val)) {
                            temp_field_names->push_back(std::get<std::string>(field_val));
                        }
                    }
                }
                field_names_ptr_cache_ = std::const_pointer_cast<const std::vector<std::string>>(temp_field_names);
            } else {
                field_names_ptr_cache_ = std::make_shared<const std::vector<std::string>>();  // Empty
            }
        }

        if (!stream_failed_) {
            // If no records were pipelined and server RUN summary says no more, then stream is done.
            if (raw_record_buffer_.empty() && !initial_server_has_more_records_) {
                stream_fully_consumed_or_discarded_ = true;
                // final_summary_typed_ is already a copy of run_summary_typed_ here
            }
        }

        // A PULL/DISCARD is needed if: buffer is empty AND server might have more records (initial_server_has_more_records_) AND not failed
        is_first_pull_attempt_ = raw_record_buffer_.empty() && initial_server_has_more_records_ && !stream_failed_;

        if (logger) {
            logger->debug("[ResultStreamLC {}] Created. QID: {}. InitRecs: {}. InitialSrvMore: {}. Failed: {}. FirstPullAttempt: {}", (void*)this, query_id_ ? std::to_string(*query_id_) : "N/A", raw_record_buffer_.size(), initial_server_has_more_records_, stream_failed_, is_first_pull_attempt_);
        }
    }

    BoltResultStream::~BoltResultStream() {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->debug("[ResultStreamLC {}] Destructing. Consumed: {}, Failed: {}", (void*)this, stream_fully_consumed_or_discarded_, stream_failed_);
        }

        if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
            if (logger) logger->trace("[ResultStreamLC {}] Auto-discarding in dtor.", (void*)this);
            // This will update final_summary_typed_
            auto discard_res = _discard_all_remaining_records();
            if (discard_res.first != boltprotocol::BoltError::SUCCESS && logger) {
                logger->warn("[ResultStreamLC {}] Auto-discard in dtor failed: {}", (void*)this, discard_res.second);
            }
        }
    }

    BoltResultStream::BoltResultStream(BoltResultStream&& other) noexcept
        : owner_session_(other.owner_session_),
          query_id_(other.query_id_),
          raw_record_buffer_(std::move(other.raw_record_buffer_)),
          field_names_ptr_cache_(std::move(other.field_names_ptr_cache_)),
          run_summary_typed_(std::move(other.run_summary_typed_)),
          final_summary_typed_(std::move(other.final_summary_typed_)),
          failure_details_raw_(std::move(other.failure_details_raw_)),
          server_has_more_records_(other.server_has_more_records_),
          initial_server_has_more_records_(other.initial_server_has_more_records_),
          stream_fully_consumed_or_discarded_(other.stream_fully_consumed_or_discarded_),
          stream_failed_(other.stream_failed_),
          failure_reason_(other.failure_reason_),
          failure_message_(std::move(other.failure_message_)),
          is_first_pull_attempt_(other.is_first_pull_attempt_),
          bolt_version_cache_(other.bolt_version_cache_),
          utc_patch_active_cache_(other.utc_patch_active_cache_),
          server_address_cache_(std::move(other.server_address_cache_)),
          database_name_cache_(std::move(other.database_name_cache_)) {
        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) logger->trace("[ResultStreamLC {}] Move constructed from ResultStream {}.", (void*)this, (void*)&other);

        other.owner_session_ = nullptr;  // Invalidate other
        other.stream_fully_consumed_or_discarded_ = true;
        other.stream_failed_ = true;  // Mark other as unusable
    }

    BoltResultStream& BoltResultStream::operator=(BoltResultStream&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
            if (logger) logger->trace("[ResultStreamLC {}] Move assigning from ResultStream {}.", (void*)this, (void*)&other);

            // Discard current stream's resources if it's still active
            if (!stream_fully_consumed_or_discarded_ && !stream_failed_ && owner_session_ && owner_session_->is_connection_valid()) {
                _discard_all_remaining_records();
            }

            owner_session_ = other.owner_session_;
            query_id_ = other.query_id_;
            raw_record_buffer_ = std::move(other.raw_record_buffer_);
            field_names_ptr_cache_ = std::move(other.field_names_ptr_cache_);
            run_summary_typed_ = std::move(other.run_summary_typed_);
            final_summary_typed_ = std::move(other.final_summary_typed_);
            failure_details_raw_ = std::move(other.failure_details_raw_);
            server_has_more_records_ = other.server_has_more_records_;
            initial_server_has_more_records_ = other.initial_server_has_more_records_;
            stream_fully_consumed_or_discarded_ = other.stream_fully_consumed_or_discarded_;
            stream_failed_ = other.stream_failed_;
            failure_reason_ = other.failure_reason_;
            failure_message_ = std::move(other.failure_message_);
            is_first_pull_attempt_ = other.is_first_pull_attempt_;
            bolt_version_cache_ = other.bolt_version_cache_;
            utc_patch_active_cache_ = other.utc_patch_active_cache_;
            server_address_cache_ = std::move(other.server_address_cache_);
            database_name_cache_ = std::move(other.database_name_cache_);

            other.owner_session_ = nullptr;  // Invalidate other
            other.stream_fully_consumed_or_discarded_ = true;
            other.stream_failed_ = true;
        }
        return *this;
    }

    const std::vector<std::string>& BoltResultStream::field_names() const {
        static const std::vector<std::string> empty_names_singleton;
        return field_names_ptr_cache_ ? *field_names_ptr_cache_ : empty_names_singleton;
    }

    void BoltResultStream::_set_failure_state(boltprotocol::BoltError reason, std::string detailed_message, const std::optional<boltprotocol::FailureMessageParams>& details) {
        if (stream_failed_ && failure_reason_ != boltprotocol::BoltError::SUCCESS) {
            // Already in a more specific failure state, don't override with a potentially less specific one unless reason is new.
            // However, allow updating message if new details are provided.
            if (!detailed_message.empty() && failure_message_.find(detailed_message) == std::string::npos) {
                failure_message_ += "; Additional detail: " + detailed_message;
            }
            if (details.has_value() && failure_details_raw_.metadata.empty()) {  // Only update raw details if not already set
                failure_details_raw_ = *details;
            }
            return;
        }
        stream_failed_ = true;
        failure_reason_ = reason;
        failure_message_ = std::move(detailed_message);

        if (details.has_value()) {
            failure_details_raw_ = *details;
        } else {
            failure_details_raw_.metadata.clear();  // Ensure it's clear
            if (!failure_message_.empty() && reason != boltprotocol::BoltError::SUCCESS) {
                // Create a minimal failure detail from the message
                failure_details_raw_.metadata["message"] = boltprotocol::Value(failure_message_);
            }
        }
        stream_fully_consumed_or_discarded_ = true;  // A failed stream is considered consumed

        std::shared_ptr<spdlog::logger> logger = (owner_session_ && owner_session_->connection_) ? owner_session_->connection_->get_logger() : nullptr;
        if (logger) {
            logger->warn("[ResultStreamLC {}] Failure state set. Reason: {} ({}), Msg: {}", (void*)this, static_cast<int>(reason), error::bolt_error_to_string(reason), failure_message_);
        }
    }

    // New private helper to update final_summary_typed_
    void BoltResultStream::_update_final_summary(boltprotocol::SuccessMessageParams&& pull_or_discard_raw_summary) {
        final_summary_typed_ = ResultSummary(std::move(pull_or_discard_raw_summary), bolt_version_cache_, utc_patch_active_cache_, server_address_cache_, database_name_cache_);
    }

}  // namespace neo4j_bolt_transport// Source/result_stream_state.cpp
// This file is intentionally left empty or can be removed from the build
// if its only purpose was to define methods now inlined in result_stream.h
// (has_failed, get_failure_reason, get_failure_message, get_failure_details).

// #include "neo4j_bolt_transport/result_stream.h"
// namespace neo4j_bolt_transport {} // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/result_summary.h"

#include <iostream>  // For potential debug

namespace neo4j_bolt_transport {

    // Helper to safely get a string from a Bolt Value
    std::optional<std::string> get_string_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<std::string>(val)) {
            return std::get<std::string>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get an int64 from a Bolt Value
    std::optional<int64_t> get_int64_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<int64_t>(val)) {
            return std::get<int64_t>(val);
        }
        return std::nullopt;
    }

    // Helper to safely get a bool from a Bolt Value
    std::optional<bool> get_bool_val(const boltprotocol::Value& val) {
        if (std::holds_alternative<bool>(val)) {
            return std::get<bool>(val);
        }
        return std::nullopt;
    }

    ResultSummary::ResultSummary(boltprotocol::SuccessMessageParams&& server_summary_params, const boltprotocol::versions::Version& bolt_version, bool utc_patch_active, const std::string& srv_address, const std::optional<std::string>& db_name_from_session)
        : raw_params_(std::move(server_summary_params)), server_address_(srv_address) {
        // Determine effective database name
        auto db_it = raw_params_.metadata.find("db");
        if (db_it != raw_params_.metadata.end()) {
            if (auto db_str = get_string_val(db_it->second)) {
                database_name_ = *db_str;
            }
        }
        if (database_name_.empty() && db_name_from_session.has_value()) {
            database_name_ = *db_name_from_session;
        }
        if (database_name_.empty()) {
            // Fallback if not in summary and not in session (e.g. system db for older Neo4j)
            database_name_ = "system";  // Or "" if that's preferred for default
        }

        parse_metadata(bolt_version, utc_patch_active);
    }

    void ResultSummary::parse_query_type(const boltprotocol::Value& type_val_variant) {
        if (auto type_str_opt = get_string_val(type_val_variant)) {
            const std::string& type_str = *type_str_opt;
            if (type_str == "r")
                query_type_ = QueryType::READ_ONLY;
            else if (type_str == "rw")
                query_type_ = QueryType::READ_WRITE;
            else if (type_str == "w")
                query_type_ = QueryType::WRITE_ONLY;
            else if (type_str == "s")
                query_type_ = QueryType::SCHEMA_WRITE;
            else
                query_type_ = QueryType::UNKNOWN;
        }
    }

    void ResultSummary::parse_counters(const boltprotocol::Value& counters_val_variant) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant)) {
            const auto& counters_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(counters_val_variant);
            if (counters_map_ptr) {
                const auto& m = counters_map_ptr->pairs;
                auto get_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_int64_val(it->second).value_or(0);
                    }
                    return int64_t{0};
                };
                auto get_bool_counter = [&](const std::string& key) {
                    auto it = m.find(key);
                    if (it != m.end()) {
                        return get_bool_val(it->second).value_or(false);
                    }
                    return false;
                };

                counters_.nodes_created = get_counter("nodes-created");
                counters_.nodes_deleted = get_counter("nodes-deleted");
                counters_.relationships_created = get_counter("relationships-created");
                counters_.relationships_deleted = get_counter("relationships-deleted");
                counters_.properties_set = get_counter("properties-set");
                counters_.labels_added = get_counter("labels-added");
                counters_.labels_removed = get_counter("labels-removed");
                counters_.indexes_added = get_counter("indexes-added");
                counters_.indexes_removed = get_counter("indexes-removed");
                counters_.constraints_added = get_counter("constraints-added");
                counters_.constraints_removed = get_counter("constraints-removed");
                counters_.system_updates = get_counter("system-updates");                         // Bolt 4.3+
                counters_.contains_system_updates = get_bool_counter("contains-system-updates");  // Bolt 5.0+

                // contains-updates logic:
                // True if any of the specific counters > 0 OR if "contains-updates" is explicitly true
                counters_.contains_updates = (counters_.nodes_created > 0 || counters_.nodes_deleted > 0 || counters_.relationships_created > 0 || counters_.relationships_deleted > 0 || counters_.properties_set > 0 || counters_.labels_added > 0 || counters_.labels_removed > 0 ||
                                              counters_.indexes_added > 0 || counters_.indexes_removed > 0 || counters_.constraints_added > 0 || counters_.constraints_removed > 0);
                // If server provides "contains-updates", respect it
                auto it_contains_updates = m.find("contains-updates");
                if (it_contains_updates != m.end()) {
                    if (auto b_val = get_bool_val(it_contains_updates->second)) {
                        counters_.contains_updates = *b_val;
                    }
                }

                if (counters_.system_updates > 0 && !counters_.contains_system_updates) {
                    // if system_updates > 0, contains_system_updates should be true.
                    // This might indicate an older server version or an inconsistency.
                    // For safety, set contains_system_updates if system_updates is positive.
                    counters_.contains_system_updates = true;
                }
            }
        }
    }

    void ResultSummary::parse_notifications(const boltprotocol::Value& notifications_val_variant, const boltprotocol::versions::Version& bolt_version) {
        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(notifications_val_variant);
            if (list_ptr) {
                notifications_.reserve(list_ptr->elements.size());
                for (const auto& item_val : list_ptr->elements) {
                    if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(item_val)) {
                        const auto& map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(item_val);
                        if (map_ptr) {
                            ServerNotification notif;
                            const auto& m = map_ptr->pairs;
                            auto find_str = [&](const std::string& key) -> std::optional<std::string> {
                                auto it = m.find(key);
                                if (it != m.end()) return get_string_val(it->second);
                                return std::nullopt;
                            };

                            notif.code = find_str("code").value_or("");
                            notif.title = find_str("title").value_or("");
                            notif.description = find_str("description").value_or("");
                            notif.severity = find_str("severity").value_or("");  // Bolt 4.1+
                            if (bolt_version.major > 5 || (bolt_version.major == 5 && bolt_version.minor >= 2)) {
                                notif.category = find_str("category").value_or("");
                            }

                            auto pos_it = m.find("position");
                            if (pos_it != m.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second)) {
                                const auto& pos_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(pos_it->second);
                                if (pos_map_ptr) notif.position = pos_map_ptr->pairs;
                            }
                            notifications_.push_back(std::move(notif));
                        }
                    }
                }
            }
        }
    }

    void ResultSummary::parse_metadata(const boltprotocol::versions::Version& bolt_version, bool /*utc_patch_active*/) {
        // Extract common fields
        auto t_start_it = raw_params_.metadata.find("t_first");  // Time to first record (RUN response) or available (PULL/DISCARD response)
        if (t_start_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_start_it->second)) {
                result_available_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto t_end_it = raw_params_.metadata.find("t_last");  // Time to last record (PULL/DISCARD response)
        if (t_end_it != raw_params_.metadata.end()) {
            if (auto ms = get_int64_val(t_end_it->second)) {
                result_consumed_after_ms_ = std::chrono::milliseconds(*ms);
            }
        }

        auto type_it = raw_params_.metadata.find("type");
        if (type_it != raw_params_.metadata.end()) {
            parse_query_type(type_it->second);
        }

        auto counters_it = raw_params_.metadata.find("stats");
        if (counters_it != raw_params_.metadata.end()) {
            parse_counters(counters_it->second);
        }

        auto notifications_it = raw_params_.metadata.find("notifications");
        if (notifications_it != raw_params_.metadata.end()) {
            parse_notifications(notifications_it->second, bolt_version);
        }

        // Plan and Profile parsing would go here if implemented
        // auto plan_it = raw_params_.metadata.find("plan");
        // if (plan_it != raw_params_.metadata.end()) { ... parse plan ... }
        // auto profile_it = raw_params_.metadata.find("profile"); // or "profiled-plan"
        // if (profile_it != raw_params_.metadata.end()) { ... parse profile ... }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // _get_server_address_for_session: 
    std::pair<boltprotocol::BoltError, routing::ServerAddress> Neo4jBoltTransport::_get_server_address_for_session(const config::SessionParameters& params, routing::ServerRole role_hint) {
        if (config_.logger) {
            config_.logger->trace(
                "[AddrSelect] , : '{}', : {}, : '{}'", params.database_name.value_or("<>"), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), params.impersonated_user.value_or("<>"));
        }

        //  bolt:// 
        if (!config_.client_side_routing_enabled || parsed_initial_uri_.scheme == "bolt" || parsed_initial_uri_.scheme == "bolt+s" || parsed_initial_uri_.scheme == "bolt+ssc") {
            if (parsed_initial_uri_.hosts_with_ports.empty()) {
                if (config_.logger) config_.logger->error("[AddrSelect] ");
                return {boltprotocol::BoltError::INVALID_ARGUMENT, {}};
            }
            // URI
            const auto& host_port = parsed_initial_uri_.hosts_with_ports.front();
            routing::ServerAddress resolved_address(host_port.first, host_port.second);

            // 
            if (config_.server_address_resolver) {
                routing::ServerAddress original_address = resolved_address;
                resolved_address = config_.server_address_resolver(original_address);
                if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                    config_.logger->debug("[AddrSelect] : {} -> {}", original_address.to_string(), resolved_address.to_string());
                }
            }
            if (config_.logger) config_.logger->debug("[AddrSelect] : {}", resolved_address.to_string());
            return {boltprotocol::BoltError::SUCCESS, resolved_address};
        }

        // ---  ---
        //  neo4j:// /
        //  system 
        //  (database_name, impersonated_user) 
        std::string db_name_for_routing_key = params.database_name.value_or("");

        // 
        std::shared_ptr<routing::RoutingTable> routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);

        if (!routing_table) {
            if (config_.logger) config_.logger->error("[AddrSelect]  '{}'  (: '{}')", db_name_for_routing_key, params.impersonated_user.value_or("<>"));
            return {boltprotocol::BoltError::NETWORK_ERROR, {}};  // 
        }

        // 
        // 
        int attempts = 0;
        const int max_selection_attempts = config_.routing_max_retry_attempts > 0 ? config_.routing_max_retry_attempts : 3;  // 1

        while (attempts < max_selection_attempts) {
            attempts++;
            if (routing_table->is_stale() && attempts > 1) {  // 
                if (config_.logger) config_.logger->info("[AddrSelect]  '{}'  {} ", routing_table->get_database_context_key(), attempts);
                // /
                routing_table = _get_or_fetch_routing_table(db_name_for_routing_key, params.impersonated_user);
                if (!routing_table) {
                    if (config_.logger) config_.logger->error("[AddrSelect]  '{}' ", db_name_for_routing_key);
                    return {boltprotocol::BoltError::NETWORK_ERROR, {}};
                }
            }

            std::optional<routing::ServerAddress> server_address_opt = routing_table->get_server(role_hint);

            if (server_address_opt) {
                routing::ServerAddress resolved_address = *server_address_opt;
                // 
                if (config_.server_address_resolver) {
                    routing::ServerAddress original_address = resolved_address;
                    resolved_address = config_.server_address_resolver(original_address);
                    if (config_.logger && (original_address.host != resolved_address.host || original_address.port != resolved_address.port)) {
                        config_.logger->debug("[AddrSelect] : {} -> {}", original_address.to_string(), resolved_address.to_string());
                    }
                }
                if (config_.logger) config_.logger->info("[AddrSelect] : {} (: {}), : {}", resolved_address.to_string(), (role_hint == routing::ServerRole::READER ? "READER" : (role_hint == routing::ServerRole::WRITER ? "WRITER" : "ROUTER")), attempts);
                return {boltprotocol::BoltError::SUCCESS, resolved_address};
            } else {
                if (config_.logger) config_.logger->warn("[AddrSelect]  {} :  '{}'  {} ", attempts, routing_table->get_database_context_key(), static_cast<int>(role_hint));
                if (attempts < max_selection_attempts) {
                    routing_table->mark_as_stale();  // 
                                                     //  sleep
                }
            }
        }  // end while attempts

        if (config_.logger) config_.logger->error("[AddrSelect]  '{}'  {} ", routing_table->get_database_context_key(), static_cast<int>(role_hint));
        return {boltprotocol::BoltError::NETWORK_ERROR, {}};  //  "No suitable server found"
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 
    void Neo4jBoltTransport::_handle_routing_failure(const routing::ServerAddress& failed_address,
                                                     const std::string& database_context_key) {  // database_context_key 

        if (!config_.client_side_routing_enabled) {
            return;  // 
        }

        if (config_.logger) {
            config_.logger->info("[RoutingFail] :  {},  {}", failed_address.to_string(), database_context_key);
        }

        std::lock_guard<std::mutex> lock(routing_table_mutex_);
        auto it = routing_tables_.find(database_context_key);
        if (it != routing_tables_.end()) {
            std::shared_ptr<routing::RoutingTable> table = it->second;
            if (table) {
                table->forget_server(failed_address);  // 
                // writer
                // RoutingTable::forget_server  mark_as_stale()
                //  table->mark_as_stale();
                if (config_.logger) {
                    config_.logger->debug("[RoutingFail]  '{}'  {}", database_context_key, failed_address.to_string());
                    if (table->is_stale()) {
                        config_.logger->info("[RoutingFail]  '{}' ", database_context_key);
                    }
                }
            }
        } else {
            if (config_.logger) {
                config_.logger->warn("[RoutingFail]  '{}' ", database_context_key);
            }
        }
    }

}  // namespace neo4j_bolt_transport#include <chrono>  // For std::chrono::seconds default TTL

#include "neo4j_bolt_transport/error/neo4j_error_util.h"  // 
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    //  pool_core.cpp 
    // static std::string make_routing_context_key(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
    //     std::string db_part = database_name.empty() ? "system" : database_name;
    //     if (impersonated_user && !impersonated_user->empty()) {
    //         return db_part + "@" + *impersonated_user;
    //     }
    //     return db_part;
    // }
    // ^^^  .cpp  Neo4jBoltTransport 
    //  neo4j_bolt_transport_pool_core.cpp 
    //  Neo4jBoltTransport 
    // 
    // ( util.h )
    namespace detail {  // 
        std::string make_routing_context_key_for_manager(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
            std::string db_part = database_name.empty() ? "system" : database_name;
            if (impersonated_user && !impersonated_user->empty()) {
                return db_part + "@" + *impersonated_user;
            }
            return db_part;
        }
    }  // namespace detail

    // 
    std::shared_ptr<routing::RoutingTable> Neo4jBoltTransport::_get_or_fetch_routing_table(const std::string& database_name, const std::optional<std::string>& impersonated_user) {
        std::string context_key = detail::make_routing_context_key_for_manager(database_name, impersonated_user);
        std::shared_ptr<routing::RoutingTable> table;
        std::vector<routing::ServerAddress> initial_routers_for_this_context;  // 

        {  //  routing_tables_ 
            std::lock_guard<std::mutex> lock(routing_table_mutex_);
            auto it = routing_tables_.find(context_key);
            if (it != routing_tables_.end()) {
                table = it->second;
            } else {
                //  TTL (300)
                // : config_.routing_table_default_ttl_seconds ()
                unsigned int default_ttl_seconds = 300;
                // if (config_.routing_table_default_ttl_seconds.has_value()) {
                //    default_ttl_seconds = *config_.routing_table_default_ttl_seconds;
                // }
                table = std::make_shared<routing::RoutingTable>(context_key, std::chrono::seconds(default_ttl_seconds));
                routing_tables_[context_key] = table;
                if (config_.logger) config_.logger->info("[RoutingMgr]  '{}'  (TTL: {}s)", context_key, default_ttl_seconds);
            }
        }  //  routing_table_mutex_

        // 
        // 1.  specific_context_key 2.  "default"  "" key 3. URI
        bool initial_routers_found = false;
        if (config_.initial_router_addresses_override.count(context_key)) {
            initial_routers_for_this_context = config_.initial_router_addresses_override.at(context_key);
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
        }

        if (!initial_routers_found) {
            //  ()
            std::string generic_initial_router_key = "";  // 
            if (config_.initial_router_addresses_override.count(generic_initial_router_key)) {
                initial_routers_for_this_context = config_.initial_router_addresses_override.at(generic_initial_router_key);
                if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
                if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
            }
        }

        if (!initial_routers_found && !parsed_initial_uri_.hosts_with_ports.empty() && parsed_initial_uri_.is_routing_scheme) {
            for (const auto& hp : parsed_initial_uri_.hosts_with_ports) {
                initial_routers_for_this_context.emplace_back(hp.first, hp.second);
            }
            if (!initial_routers_for_this_context.empty()) initial_routers_found = true;
            if (config_.logger && initial_routers_found) config_.logger->trace("[RoutingMgr]  '{}' URI", context_key);
        }

        if (!initial_routers_found) {
            if (config_.logger) config_.logger->error("[RoutingMgr]  '{}' ", context_key);
            // table->mark_as_stale(); // 
            return nullptr;  // 
        }

        // 
        // 
        if (table->is_stale()) {
            if (config_.logger) config_.logger->info("[RoutingMgr]  '{}' ", context_key);

            // _fetch_and_update_routing_table  ROUTE 
            boltprotocol::BoltError refresh_err = _fetch_and_update_routing_table(table, initial_routers_for_this_context, database_name, impersonated_user);

            if (refresh_err != boltprotocol::BoltError::SUCCESS) {
                if (config_.logger) config_.logger->error("[RoutingMgr]  '{}' : {}", context_key, static_cast<int>(refresh_err));
                // 
                // nullptr
                return nullptr;  // 
            }
            if (config_.logger) config_.logger->info("[RoutingMgr]  '{}' ", context_key);
        } else {
            if (config_.logger) config_.logger->trace("[RoutingMgr]  '{}' ", context_key);
        }
        return table;
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/routing/routing_table.h"

#include <algorithm>  // For std::remove

namespace neo4j_bolt_transport {
    namespace routing {

        RoutingTable::RoutingTable(std::string db_context_key, std::chrono::seconds ttl_seconds)
            : database_context_key_(std::move(db_context_key)),
              last_updated_time_(std::chrono::steady_clock::time_point::min()),  // Stale by default
              ttl_(ttl_seconds) {
        }

        std::optional<ServerAddress> RoutingTable::get_server(ServerRole role) {
            std::lock_guard<std::mutex> lock(mutex_);
            if (is_stale()) {
                return std::nullopt;
            }

            std::vector<ServerAddress>* server_list = nullptr;
            std::atomic<std::size_t>* index_ptr = nullptr;

            switch (role) {
                case ServerRole::ROUTER:
                    server_list = &routers_;
                    index_ptr = &next_router_index_;
                    break;
                case ServerRole::READER:
                    server_list = &readers_;
                    index_ptr = &next_reader_index_;
                    break;
                case ServerRole::WRITER:
                    server_list = &writers_;
                    index_ptr = &next_writer_index_;
                    break;
            }

            if (!server_list || server_list->empty()) {
                return std::nullopt;
            }

            std::size_t current_index = index_ptr->fetch_add(1, std::memory_order_relaxed);
            return (*server_list)[current_index % server_list->size()];
        }

        boltprotocol::BoltError RoutingTable::update(const std::vector<ServerAddress>& new_routers, const std::vector<ServerAddress>& new_readers, const std::vector<ServerAddress>& new_writers, std::chrono::seconds new_ttl_seconds) {
            std::lock_guard<std::mutex> lock(mutex_);

            // It's crucial that ROUTE message provides absolute lists, not diffs.
            routers_ = new_routers;
            readers_ = new_readers;
            writers_ = new_writers;
            ttl_ = new_ttl_seconds;
            last_updated_time_ = std::chrono::steady_clock::now();

            next_reader_index_ = 0;
            next_writer_index_ = 0;
            next_router_index_ = 0;  // Reset router index as well

            if (routers_.empty() && (readers_.empty() || writers_.empty())) {
                // A routing table must have routers, or if it's a single-instance-like scenario
                // (no explicit routers), it must at least have readers and writers.
                // If all are empty after an update, it's problematic.
                mark_as_stale();                                         // Mark as stale to force re-fetch or error out
                return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;  // Or a more specific routing error
            }

            return boltprotocol::BoltError::SUCCESS;
        }

        bool RoutingTable::is_stale() const {
            // No lock needed for reading const members or time_point if access is atomic enough,
            // but ttl_ could change. For safety, or if ttl_ wasn't const, use lock.
            // Here, last_updated_time_ is std::chrono, reads are usually atomic. ttl_ is const after construction until update.
            // For simplicity with mutex_:
            // std::lock_guard<std::mutex> lock(mutex_);
            if (last_updated_time_ == std::chrono::steady_clock::time_point::min()) return true;  // Never updated
            return std::chrono::steady_clock::now() > (last_updated_time_ + ttl_);
        }

        void RoutingTable::mark_as_stale() {
            std::lock_guard<std::mutex> lock(mutex_);
            last_updated_time_ = std::chrono::steady_clock::time_point::min();
        }

        const std::vector<ServerAddress>& RoutingTable::get_routers() const {
            std::lock_guard<std::mutex> lock(mutex_);
            return routers_;
        }

        void RoutingTable::forget_server(const ServerAddress& address) {
            std::lock_guard<std::mutex> lock(mutex_);
            auto remove_addr = [&](std::vector<ServerAddress>& vec) {
                vec.erase(std::remove(vec.begin(), vec.end(), address), vec.end());
            };
            remove_addr(routers_);
            remove_addr(readers_);
            remove_addr(writers_);

            // If forgetting a server makes a critical list empty, table might become stale faster
            if ((database_context_key_ != "system" && (readers_.empty() || writers_.empty())) || routers_.empty()) {
                // For simplicity, just mark stale. More complex logic could try other servers first.
                mark_as_stale();
            }
        }

    }  // namespace routing
}  // namespace neo4j_bolt_transport#include "boltprotocol/message_serialization.h"  // For ROUTE message
#include "boltprotocol/packstream_reader.h"      // For parsing ROUTE response
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"

namespace neo4j_bolt_transport {

    // 
    boltprotocol::BoltError Neo4jBoltTransport::_fetch_and_update_routing_table(std::shared_ptr<routing::RoutingTable> table_to_update,
                                                                                const std::vector<routing::ServerAddress>& routers_to_try,
                                                                                const std::string& database_name_hint,                       // ROUTE
                                                                                const std::optional<std::string>& impersonated_user_hint) {  // ROUTE

        if (routers_to_try.empty()) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: ");
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }
        if (!table_to_update) {
            if (config_.logger) config_.logger->error("[RoutingFetcher] _fetch_and_update_routing_table: table_to_update ");
            return boltprotocol::BoltError::INVALID_ARGUMENT;
        }

        boltprotocol::RouteMessageParams route_params;
        // Bolt 4.3-4.4: route_params.routing_table_context (map)
        // Bolt 5.0+:  route_params.routing_table_context (db, imp_user)
        //  routing_table_context NAT
        // 
        // Neo4j JavamapROUTErouting_context
        route_params.routing_table_context = {};  // 
        route_params.bookmarks = {};              // 

        // ROUTE
        boltprotocol::versions::Version version_for_route_message = boltprotocol::versions::V5_0;  // 
        if (!config_.preferred_bolt_versions.empty()) {
            //  Bolt  ROUTE 
            // 
            version_for_route_message = config_.preferred_bolt_versions.front();
        }

        if (version_for_route_message >= boltprotocol::versions::Version(4, 4)) {  // Bolt 4.4+
            route_params.extra_for_v44_plus = std::map<std::string, boltprotocol::Value>();
            if (!database_name_hint.empty()) {
                (*route_params.extra_for_v44_plus)["db"] = database_name_hint;
            }
            // impersonated_user_hint  Bolt 5.1+  ROUTE  extra map
            if (impersonated_user_hint.has_value() && !impersonated_user_hint->empty() && version_for_route_message >= boltprotocol::versions::Version(5, 1)) {
                (*route_params.extra_for_v44_plus)["imp_user"] = *impersonated_user_hint;
            }
        } else if (version_for_route_message == boltprotocol::versions::Version(4, 3)) {  // Bolt 4.3
            if (!database_name_hint.empty()) {
                route_params.db_name_for_v43 = database_name_hint;
            }
        } else {
            if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  Bolt  {}.{}", (int)version_for_route_message.major, (int)version_for_route_message.minor);
            table_to_update->mark_as_stale();
            return boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION;
        }

        std::vector<uint8_t> route_payload;
        boltprotocol::PackStreamWriter writer(route_payload);
        boltprotocol::BoltError err = boltprotocol::serialize_route_message(route_params, writer, version_for_route_message);
        if (err != boltprotocol::BoltError::SUCCESS) {
            if (config_.logger) config_.logger->error("[RoutingFetcher]  ROUTE : {}", static_cast<int>(err));
            table_to_update->mark_as_stale();
            return err;
        }

        boltprotocol::SuccessMessageParams success_meta;
        boltprotocol::FailureMessageParams failure_meta;

        for (const auto& router_address_orig : routers_to_try) {
            if (closing_.load(std::memory_order_acquire)) return boltprotocol::BoltError::UNKNOWN_ERROR;  // 

            routing::ServerAddress router_address = router_address_orig;
            if (config_.server_address_resolver) {  // 
                router_address = config_.server_address_resolver(router_address_orig);
            }

            if (config_.logger) config_.logger->debug("[RoutingFetcher]  {} (: {}) , : '{}'", router_address.to_string(), router_address_orig.to_string(), database_name_hint);

            //  HELLO 
            std::map<std::string, boltprotocol::Value> hello_routing_ctx;
            hello_routing_ctx["address"] = router_address.to_string();  // 

            internal::BoltConnectionConfig conn_conf = _create_physical_connection_config(router_address, hello_routing_ctx);
            auto temp_conn_logger = config_.get_or_create_logger("RouteConn");  // logger
            auto temp_conn = std::make_unique<internal::BoltPhysicalConnection>(std::move(conn_conf), io_context_, temp_conn_logger);

            if (temp_conn->establish() == boltprotocol::BoltError::SUCCESS) {
                //  Bolt  ROUTE 
                if (temp_conn->get_bolt_version() < boltprotocol::versions::Version(4, 3)) {
                    if (config_.logger) config_.logger->warn("[RoutingFetcher]  {}  Bolt  ({}.{}) ROUTE ", router_address.to_string(), (int)temp_conn->get_bolt_version().major, (int)temp_conn->get_bolt_version().minor);
                    temp_conn->terminate(true);
                    continue;  // 
                }
                // 
                // ROUTE

                boltprotocol::BoltError route_send_err = temp_conn->send_request_receive_summary(route_payload, success_meta, failure_meta);
                temp_conn->terminate(true);  // 

                if (route_send_err == boltprotocol::BoltError::SUCCESS && temp_conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                    auto rt_it = success_meta.metadata.find("rt");
                    if (rt_it != success_meta.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second)) {
                        const auto& rt_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(rt_it->second);
                        if (rt_map_ptr) {
                            const auto& rt_data = rt_map_ptr->pairs;
                            long long ttl_val_ll = 0;
                            std::vector<routing::ServerAddress> new_routers, new_readers, new_writers;

                            auto ttl_data_it = rt_data.find("ttl");
                            if (ttl_data_it != rt_data.end() && std::holds_alternative<int64_t>(ttl_data_it->second)) {
                                ttl_val_ll = std::get<int64_t>(ttl_data_it->second);
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'ttl' ");
                                // 
                            }
                            std::chrono::seconds ttl_val = std::chrono::seconds(ttl_val_ll > 0 ? ttl_val_ll : 300);  // 300s

                            auto servers_data_it = rt_data.find("servers");
                            if (servers_data_it != rt_data.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second)) {
                                const auto& servers_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(servers_data_it->second);
                                if (servers_list_ptr) {
                                    for (const auto& server_item_val : servers_list_ptr->elements) {
                                        if (std::holds_alternative<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val)) {
                                            const auto& server_map_ptr = std::get<std::shared_ptr<boltprotocol::BoltMap>>(server_item_val);
                                            if (server_map_ptr) {
                                                std::string role_str;
                                                std::vector<std::string> addresses_str_list;

                                                auto role_it = server_map_ptr->pairs.find("role");
                                                if (role_it != server_map_ptr->pairs.end() && std::holds_alternative<std::string>(role_it->second)) {
                                                    role_str = std::get<std::string>(role_it->second);
                                                }

                                                auto addrs_it = server_map_ptr->pairs.find("addresses");
                                                if (addrs_it != server_map_ptr->pairs.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second)) {
                                                    const auto& addrs_list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(addrs_it->second);
                                                    if (addrs_list_ptr) {
                                                        for (const auto& addr_val : addrs_list_ptr->elements) {
                                                            if (std::holds_alternative<std::string>(addr_val)) {
                                                                addresses_str_list.push_back(std::get<std::string>(addr_val));
                                                            }
                                                        }
                                                    }
                                                }

                                                auto parse_host_port = [&](const std::string& addr_str) -> std::optional<routing::ServerAddress> {
                                                    //  (bolt://, neo4j:// etc.)
                                                    std::string clean_addr_str = addr_str;
                                                    size_t scheme_end = clean_addr_str.find("://");
                                                    if (scheme_end != std::string::npos) {
                                                        clean_addr_str = clean_addr_str.substr(scheme_end + 3);
                                                    }

                                                    size_t colon_pos = clean_addr_str.rfind(':');
                                                    if (colon_pos == std::string::npos || colon_pos == 0 || colon_pos == clean_addr_str.length() - 1) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}'  ()", addr_str);
                                                        return std::nullopt;
                                                    }
                                                    try {
                                                        std::string host_part = clean_addr_str.substr(0, colon_pos);
                                                        //  IPv6 
                                                        if (host_part.length() > 2 && host_part.front() == '[' && host_part.back() == ']') {
                                                            host_part = host_part.substr(1, host_part.length() - 2);
                                                        }
                                                        if (host_part.empty()) {
                                                            if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}' ", addr_str);
                                                            return std::nullopt;
                                                        }

                                                        uint16_t port = static_cast<uint16_t>(std::stoul(clean_addr_str.substr(colon_pos + 1)));
                                                        return routing::ServerAddress{host_part, port};
                                                    } catch (const std::exception& e) {
                                                        if (config_.logger) config_.logger->warn("[RoutingFetcher]  '{}' : {}", addr_str, e.what());
                                                        return std::nullopt;
                                                    }
                                                };

                                                std::vector<routing::ServerAddress>* target_list_ptr = nullptr;
                                                if (role_str == "ROUTE")
                                                    target_list_ptr = &new_routers;
                                                else if (role_str == "READ")
                                                    target_list_ptr = &new_readers;
                                                else if (role_str == "WRITE")
                                                    target_list_ptr = &new_writers;

                                                if (target_list_ptr) {
                                                    for (const auto& addr_str : addresses_str_list) {
                                                        if (auto sa_opt = parse_host_port(addr_str)) {
                                                            target_list_ptr->push_back(*sa_opt);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'servers' ");
                                }
                            } else {
                                if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE  'rt' ");
                                //  send_request_receive_summary 
                                // temp_conn->get_last_error_code()  SUCCESS
                                if (temp_conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                                    if (config_.logger) config_.logger->warn("[RoutingFetcher] ROUTE : {}", temp_conn->get_last_error_message());
                                    // 
                                } else {
                                    // 
                                    table_to_update->mark_as_stale();
                                    return boltprotocol::BoltError::INVALID_MESSAGE_FORMAT;
                                }
                            }
                            // 
                            boltprotocol::BoltError update_err = table_to_update->update(new_routers, new_readers, new_writers, ttl_val);
                            if (update_err == boltprotocol::BoltError::SUCCESS) {
                                if (config_.logger) {
                                    config_.logger->info(
                                        "[RoutingFetcher]  '{}'  {} Routers: {}, Readers: {}, Writers: {}, TTL: {}s", table_to_update->get_database_context_key(), router_address.to_string(), new_routers.size(), new_readers.size(), new_writers.size(), ttl_val.count());
                                }
                            } else {
                                if (config_.logger) config_.logger->error("[RoutingFetcher] ");
                            }
                            return update_err;  // 
                        }  // success_meta.metadata.find("rt")
                    }  // temp_conn->get_last_error_code() == SUCCESS
                }  // route_send_err == SUCCESS

                //  route_send_err != SUCCESS  temp_conn->get_last_error_code() != SUCCESS
                if (config_.logger) {
                    config_.logger->warn(
                        "[RoutingFetcher]  {}  ROUTE : {}, : {} (: {})", router_address.to_string(), error::bolt_error_to_string(route_send_err), error::bolt_error_to_string(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
                }
                // 

            } else {  // temp_conn->establish() failed
                if (config_.logger) config_.logger->warn("[RoutingFetcher]  {} (: {}) : {}, : {}", router_address.to_string(), router_address_orig.to_string(), static_cast<int>(temp_conn->get_last_error_code()), temp_conn->get_last_error_message());
            }
            // 
        }

        if (config_.logger) config_.logger->error("[RoutingFetcher]  {}  '{}'", routers_to_try.size(), table_to_update->get_database_context_key());
        table_to_update->mark_as_stale();               // 
        return boltprotocol::BoltError::NETWORK_ERROR;  //  "Routing information unavailable"
    }

}  // namespace neo4j_bolt_transport#include <chrono>    // For std::chrono::milliseconds
#include <iostream>  // 
#include <utility>   // For std::move

#include "boltprotocol/message_serialization.h"  // For serialize_..._message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // <--- 
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    // --- Explicit Transaction Methods ---
    std::pair<boltprotocol::BoltError, std::string> SessionHandle::begin_transaction(const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "begin_transaction");
        if (!conn) {
            return conn_check_result;
        }
        auto logger = conn->get_logger();  // conn is valid here

        if (in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to begin transaction while already in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot begin transaction; already in an explicit transaction."};
        }

        boltprotocol::BeginMessageParams params;
        params.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) {
            params.db = session_params_.database_name;
        }
        if (session_params_.impersonated_user.has_value()) {
            params.imp_user = session_params_.impersonated_user;
        }

        // Access mode (Bolt 5.0+)
        if (!(conn->get_bolt_version() < boltprotocol::versions::V5_0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                params.other_extra_fields["mode"] = std::string("r");
            }
        }

        if (tx_metadata.has_value()) {
            params.tx_metadata = *tx_metadata;
        }
        if (tx_timeout_opt.has_value()) {
            params.tx_timeout = static_cast<int64_t>(tx_timeout_opt.value().count());
        }

        std::vector<uint8_t> begin_payload_bytes;
        boltprotocol::PackStreamWriter writer(begin_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_begin_message(params, writer, conn->get_bolt_version());
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("BEGIN serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(begin_payload_bytes, success_meta_raw, failure_meta_raw);

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                in_explicit_transaction_ = true;
                current_transaction_query_id_.reset();
                if (logger) {
                    logger->info("[SessionTX {}] Transaction started. DB: '{}', Mode: '{}', Timeout: {}ms, Meta: {}",
                                 conn->get_id(),
                                 params.db.value_or("<default>"),
                                 (session_params_.default_access_mode == config::AccessMode::READ ? "READ" : "WRITE"),
                                 params.tx_timeout.has_value() ? std::to_string(params.tx_timeout.value()) : "N/A",
                                 params.tx_metadata.has_value() && !params.tx_metadata.value().empty() ? "Yes" : "No");
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string server_fail_msg = error::format_server_failure(failure_meta_raw);
                std::string msg = error::format_error_message("BEGIN failed on server", conn->get_last_error_code(), server_fail_msg);
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("BEGIN send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::commit_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "commit_transaction");
        if (!conn) return conn_check_result;
        auto logger = conn->get_logger();  // conn is valid here

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionTX {}] Attempt to commit transaction while not in one.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot commit: not in an explicit transaction."};
        }

        std::vector<uint8_t> commit_payload_bytes;
        boltprotocol::PackStreamWriter writer(commit_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_commit_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("COMMIT serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(commit_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                auto it_bookmark = success_meta_raw.metadata.find("bookmark");
                if (it_bookmark != success_meta_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                } else {
                    if (logger) logger->trace("[SessionTX {}] COMMIT successful but no bookmark returned (Bolt version: {}.{}).", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                    update_bookmarks({});
                }
                if (logger) {
                    logger->info("[SessionTX {}] Transaction committed. New bookmark: {}", conn->get_id(), current_bookmarks_.empty() ? "<none>" : current_bookmarks_[0]);
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("COMMIT failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("COMMIT send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::rollback_transaction() {
        std::pair<boltprotocol::BoltError, std::string> conn_check_result;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_result, "rollback_transaction (pre-check)");

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (conn)
            logger = conn->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)  // transport_manager_ is checked
            logger = transport_manager_->get_config().logger;

        if (!in_explicit_transaction_) {
            if (logger) logger->trace("[SessionTX {}] Rollback called when not in an explicit transaction. No-op.", (conn ? conn->get_id() : 0));
            return {boltprotocol::BoltError::SUCCESS, ""};
        }

        if (!conn) {
            std::string msg = "Rollback attempt with no valid connection while in TX: " + conn_check_result.second;
            if (logger) logger->warn("[SessionTX Rollback] {}", msg);
            _invalidate_session_due_to_connection_error(conn_check_result.first, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {conn_check_result.first, msg};
        }

        std::vector<uint8_t> rollback_payload_bytes;
        boltprotocol::PackStreamWriter writer(rollback_payload_bytes);
        boltprotocol::BoltError err_code = boltprotocol::serialize_rollback_message(writer);
        if (err_code != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("ROLLBACK serialization", err_code);
            _invalidate_session_due_to_connection_error(err_code, msg);
            in_explicit_transaction_ = false;
            current_transaction_query_id_.reset();
            return {err_code, msg};
        }

        boltprotocol::SuccessMessageParams success_meta_raw;
        boltprotocol::FailureMessageParams failure_meta_raw;
        err_code = conn->send_request_receive_summary(rollback_payload_bytes, success_meta_raw, failure_meta_raw);

        in_explicit_transaction_ = false;
        current_transaction_query_id_.reset();

        if (err_code == boltprotocol::BoltError::SUCCESS) {
            if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
                if (logger) {
                    logger->info("[SessionTX {}] Transaction rolled back.", conn->get_id());
                }
                return {boltprotocol::BoltError::SUCCESS, ""};
            } else {
                std::string msg = error::format_error_message("ROLLBACK failed on server", conn->get_last_error_code(), error::format_server_failure(failure_meta_raw));
                _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
                return {conn->get_last_error_code(), msg};
            }
        }
        std::string msg = error::format_error_message("ROLLBACK send/receive", err_code, conn->get_last_error_message());
        _invalidate_session_due_to_connection_error(err_code, msg);
        return {err_code, msg};
    }

}  // namespace neo4j_bolt_transport#include <iostream>  // 
#include <utility>   // For std::move

#include "neo4j_bolt_transport/config/session_parameters.h"          // For config::SessionParameters
#include "neo4j_bolt_transport/error/neo4j_error_util.h"             // For error formatting
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"  // For internal::BoltPhysicalConnection
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"               // For Neo4jBoltTransport access
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    SessionHandle::SessionHandle(Neo4jBoltTransport* transport_mgr, internal::BoltPhysicalConnection::PooledConnection conn_ptr, config::SessionParameters params_val)
        : transport_manager_(transport_mgr), connection_(std::move(conn_ptr)), session_params_(std::move(params_val)), current_bookmarks_(session_params_.initial_bookmarks) {  // 

        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  //  logger
            drv_logger = transport_manager_->get_config().logger;
        }

        if (!transport_manager_) {
            connection_is_valid_ = false;
            is_closed_ = true;
            if (drv_logger) drv_logger->error("[SessionLC] SessionHandle created without a valid transport manager.");
            // connection_  nullptr_release_connection_to_pool 
            return;
        }

        std::shared_ptr<spdlog::logger> conn_logger = nullptr;
        if (connection_ && connection_->get_logger()) {
            conn_logger = connection_->get_logger();
        } else if (drv_logger) {
            conn_logger = drv_logger;  // 
        }

        if (!connection_ || !connection_->is_ready_for_queries()) {
            boltprotocol::BoltError last_err = connection_ ? connection_->get_last_error_code() : boltprotocol::BoltError::NETWORK_ERROR;
            std::string last_err_msg = connection_ ? connection_->get_last_error_message() : "Connection pointer null or not ready at SessionHandle construction.";

            if (conn_logger) conn_logger->warn("[SessionLC {}] Connection not ready at SessionHandle construction. Error: {}, Msg: {}", connection_ ? connection_->get_id() : 0, static_cast<int>(last_err), last_err_msg);
            _invalidate_session_due_to_connection_error(last_err, "SessionHandle construction: " + last_err_msg);
            _release_connection_to_pool(false);  // 
        } else {
            connection_->mark_as_used();
            if (conn_logger) conn_logger->debug("[SessionLC {}] SessionHandle constructed with ready connection.", connection_->get_id());
        }
    }

    SessionHandle::~SessionHandle() {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] SessionHandle destructing. Closed: {}, InTx: {}", (connection_ ? connection_->get_id() : 0), is_closed_, in_explicit_transaction_);
        close();  // 
    }

    SessionHandle::SessionHandle(SessionHandle&& other) noexcept
        : transport_manager_(other.transport_manager_),
          connection_(std::move(other.connection_)),
          session_params_(std::move(other.session_params_)),
          in_explicit_transaction_(other.in_explicit_transaction_),
          current_transaction_query_id_(other.current_transaction_query_id_),
          current_bookmarks_(std::move(other.current_bookmarks_)),
          is_closed_(other.is_closed_),
          connection_is_valid_(other.connection_is_valid_) {
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->trace("[SessionLC {}] SessionHandle move constructed from old SessionHandle.", (connection_ ? connection_->get_id() : 0));

        other.transport_manager_ = nullptr;  // other 
        other.is_closed_ = true;
        other.connection_is_valid_ = false;
    }

    SessionHandle& SessionHandle::operator=(SessionHandle&& other) noexcept {
        if (this != &other) {
            std::shared_ptr<spdlog::logger> logger = nullptr;
            if (connection_ && connection_->get_logger())
                logger = connection_->get_logger();
            else if (transport_manager_ && transport_manager_->get_config().logger)
                logger = transport_manager_->get_config().logger;
            if (logger) logger->trace("[SessionLC {}] SessionHandle move assigning from other SessionHandle.", (connection_ ? connection_->get_id() : 0));

            close();  // 

            transport_manager_ = other.transport_manager_;
            connection_ = std::move(other.connection_);
            session_params_ = std::move(other.session_params_);
            in_explicit_transaction_ = other.in_explicit_transaction_;
            current_transaction_query_id_ = other.current_transaction_query_id_;
            current_bookmarks_ = std::move(other.current_bookmarks_);
            is_closed_ = other.is_closed_;
            connection_is_valid_ = other.connection_is_valid_;

            other.transport_manager_ = nullptr;  // other 
            other.is_closed_ = true;
            other.connection_is_valid_ = false;
        }
        return *this;
    }

    void SessionHandle::_release_connection_to_pool(bool mark_healthy) {
        if (connection_ && transport_manager_) {
            std::shared_ptr<spdlog::logger> logger = connection_->get_logger();  // logger
            uint64_t conn_id = connection_->get_id();
            if (logger) logger->trace("[SessionLC conn_id={}] Releasing connection to pool. Healthy: {}", conn_id, mark_healthy && connection_is_valid_);
            transport_manager_->release_connection(std::move(connection_), mark_healthy && connection_is_valid_);
            // connection_  nullptr
        }
        connection_is_valid_ = false;  // 
    }

    void SessionHandle::close() {
        if (is_closed_) {
            return;
        }

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) logger->debug("[SessionLC {}] Closing SessionHandle. InTx: {}", (connection_ ? connection_->get_id() : 0), in_explicit_transaction_);

        if (in_explicit_transaction_ && connection_is_valid_ && connection_ && connection_->is_ready_for_queries()) {
            if (logger) logger->info("[SessionLC {}] Rolling back active transaction during close.", connection_->get_id());
            rollback_transaction();  //  in_explicit_transaction_  false
        }
        _release_connection_to_pool(connection_is_valid_);  // 
        is_closed_ = true;
    }

    void SessionHandle::_invalidate_session_due_to_connection_error(boltprotocol::BoltError error, const std::string& context_message) {
        connection_is_valid_ = false;
        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            logger->warn("[SessionLC {}] Session invalidated due to connection error. Code: {} ({}), Context: {}",
                         (connection_ ? connection_->get_id() : 0),
                         static_cast<int>(error),
                         error::bolt_error_to_string(error),  // 
                         context_message);
        }
    }

    internal::BoltPhysicalConnection* SessionHandle::_get_valid_connection_for_operation(std::pair<boltprotocol::BoltError, std::string>& out_err_pair, const std::string& operation_context) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed_) {
            out_err_pair = {boltprotocol::BoltError::INVALID_ARGUMENT, "Operation on closed session: " + operation_context};
            if (drv_logger) drv_logger->warn("[SessionOp] {}", out_err_pair.second);
            return nullptr;
        }
        if (!connection_is_valid_ || !connection_) {
            out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "No valid connection for operation: " + operation_context};
            std::shared_ptr<spdlog::logger> log_to_use = (connection_ && connection_->get_logger()) ? connection_->get_logger() : drv_logger;
            if (log_to_use) log_to_use->warn("[SessionOp conn_id={}] {}", (connection_ ? connection_->get_id() : 0), out_err_pair.second);
            return nullptr;
        }

        if (!connection_->is_ready_for_queries()) {
            out_err_pair = {connection_->get_last_error_code(), connection_->get_last_error_message()};
            if (out_err_pair.first == boltprotocol::BoltError::SUCCESS) {  //  is_ready  false  SUCCESS
                out_err_pair = {boltprotocol::BoltError::NETWORK_ERROR, "Connection reported not ready for queries despite no specific error."};
            }
            std::string context_msg_full = operation_context + " (connection not ready: " + out_err_pair.second + ")";
            _invalidate_session_due_to_connection_error(out_err_pair.first, context_msg_full);  // 
            if (connection_->get_logger()) connection_->get_logger()->warn("[SessionOp conn_id={}] {}", connection_->get_id(), context_msg_full);
            return nullptr;
        }

        connection_->mark_as_used();
        out_err_pair = {boltprotocol::BoltError::SUCCESS, ""};
        return connection_.get();
    }

    const std::vector<std::string>& SessionHandle::get_last_bookmarks() const {
        return current_bookmarks_;
    }

    void SessionHandle::update_bookmarks(const std::vector<std::string>& new_bookmarks) {
        if (is_closed_) return;
        current_bookmarks_ = new_bookmarks;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        if (connection_ && connection_->get_logger())
            logger = connection_->get_logger();
        else if (transport_manager_ && transport_manager_->get_config().logger)
            logger = transport_manager_->get_config().logger;

        if (logger) {
            std::string bookmarks_str;
            if (new_bookmarks.empty()) {
                bookmarks_str = "<empty>";
            } else {
                for (size_t i = 0; i < new_bookmarks.size(); ++i) {
                    bookmarks_str += new_bookmarks[i] + (i == new_bookmarks.size() - 1 ? "" : ", ");
                }
            }
            logger->trace("[SessionLC {}] Bookmarks updated to: [{}]", (connection_ ? connection_->get_id() : 0), bookmarks_str);
        }
    }

}  // namespace neo4j_bolt_transport#include <utility>  // For std::move

#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionWork typedef
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::execute_read_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        // Note: The mode_hint (AccessMode::READ) is passed to _execute_transaction_work_internal.
        // That internal function will temporarily set session_params_.default_access_mode
        // for the duration of the managed transaction.
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::READ, tx_metadata, tx_timeout);
    }

    TransactionWorkResult SessionHandle::execute_write_transaction(TransactionWork work, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout) {
        return _execute_transaction_work_internal(std::move(work), config::AccessMode::WRITE, tx_metadata, tx_timeout);
    }

}  // namespace neo4j_bolt_transport#include <algorithm>  // For std::min
#include <chrono>     // For std::chrono::milliseconds
#include <iostream>   // 
#include <thread>     // For std::this_thread::sleep_for
#include <utility>    // For std::move

#include "neo4j_bolt_transport/config/transport_config.h"  // For retry config access
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"       // For transport_manager_ to get config
#include "neo4j_bolt_transport/neo4j_transaction_context.h"  // For TransactionContext definition
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    TransactionWorkResult SessionHandle::_execute_transaction_work_internal(TransactionWork work, config::AccessMode mode_hint, const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata, const std::optional<std::chrono::milliseconds>& tx_timeout_opt) {
        std::shared_ptr<spdlog::logger> drv_logger = nullptr;
        if (transport_manager_ && transport_manager_->get_config().logger) {  // Check transport_manager_
            drv_logger = transport_manager_->get_config().logger;
        }

        if (is_closed()) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Session is closed, cannot execute transaction work.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Session is closed, cannot execute transaction work."};
        }
        if (in_explicit_transaction_) {
            if (drv_logger) drv_logger->warn("[SessionTX Managed] Cannot start managed transaction; an explicit transaction is already active.");
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot start managed transaction; an explicit transaction is already active."};
        }

        uint32_t max_retry_time_ms = 30000;
        uint32_t current_delay_ms = 1000;
        uint32_t max_delay_ms = 60000;
        double multiplier = 2.0;

        if (transport_manager_) {
            const auto& driver_conf = transport_manager_->get_config();
            max_retry_time_ms = driver_conf.max_transaction_retry_time_ms;
            current_delay_ms = driver_conf.transaction_retry_delay_initial_ms > 0 ? driver_conf.transaction_retry_delay_initial_ms : 1000;
            max_delay_ms = driver_conf.transaction_retry_delay_max_ms > 0 ? driver_conf.transaction_retry_delay_max_ms : 60000;
            multiplier = driver_conf.transaction_retry_delay_multiplier > 1 ? static_cast<double>(driver_conf.transaction_retry_delay_multiplier) : 2.0;
        }

        auto overall_deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(max_retry_time_ms);
        TransactionWorkResult last_attempt_result = {boltprotocol::BoltError::UNKNOWN_ERROR, "Transaction work did not complete successfully within retry budget."};
        int attempt_count = 0;

        config::AccessMode original_session_access_mode = session_params_.default_access_mode;
        session_params_.default_access_mode = mode_hint;

        while (std::chrono::steady_clock::now() < overall_deadline) {
            attempt_count++;
            std::shared_ptr<spdlog::logger> current_op_logger = drv_logger;

            std::pair<boltprotocol::BoltError, std::string> conn_check_for_log;
            internal::BoltPhysicalConnection* temp_conn_for_log_check = _get_valid_connection_for_operation(conn_check_for_log, "managed_tx_log_setup");
            if (temp_conn_for_log_check && temp_conn_for_log_check->get_logger()) {
                current_op_logger = temp_conn_for_log_check->get_logger();
            }

            if (current_op_logger) {
                current_op_logger->debug("[SessionTX Managed][Attempt {}] Starting transaction work (Mode: {}).", attempt_count, (mode_hint == config::AccessMode::READ ? "READ" : "WRITE"));
            }

            std::pair<boltprotocol::BoltError, std::string> pre_begin_conn_check;
            if (!_get_valid_connection_for_operation(pre_begin_conn_check, "managed_tx_pre_begin")) {
                last_attempt_result = {pre_begin_conn_check.first, "Managed TX: Connection unavailable before BEGIN (Attempt " + std::to_string(attempt_count) + "): " + pre_begin_conn_check.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                bool is_retryable_failure = (pre_begin_conn_check.first == boltprotocol::BoltError::NETWORK_ERROR || pre_begin_conn_check.first == boltprotocol::BoltError::HANDSHAKE_FAILED);  // More specific retry conditions
                if (is_retryable_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection unavailability before BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    // If connection was invalidated, _release_connection_to_pool would have been called.
                    // Next iteration _get_valid_connection_for_operation will try to get a new one if pool manager is used.
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            auto begin_res = begin_transaction(tx_metadata, tx_timeout_opt);
            if (begin_res.first != boltprotocol::BoltError::SUCCESS) {
                bool is_retryable_begin_failure = (begin_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                last_attempt_result = {begin_res.first, "Managed TX: Failed to begin (Attempt " + std::to_string(attempt_count) + "): " + begin_res.second};
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);

                if (is_retryable_begin_failure && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying BEGIN in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }

            if (connection_ && connection_->get_logger()) current_op_logger = connection_->get_logger();

            TransactionContext tx_context(*this);
            TransactionWorkResult work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "User work lambda not called."};

            try {
                work_res = work(tx_context);
            } catch (const std::exception& e) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Exception from user transaction work: " + std::string(e.what())};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Exception in user work: {}", e.what());
            } catch (...) {
                work_res = {boltprotocol::BoltError::UNKNOWN_ERROR, "Unknown exception from user transaction work."};
                if (current_op_logger) current_op_logger->error("[SessionTX Managed] Unknown exception in user work.");
            }

            if (!connection_is_valid_) {
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Connection became invalid during user work. Last conn error code: {}", connection_ ? static_cast<int>(connection_->get_last_error_code()) : -1);
                work_res = {boltprotocol::BoltError::NETWORK_ERROR, "Connection lost during transaction work execution."};
                rollback_transaction();
                last_attempt_result = work_res;
                if (std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Retrying entire transaction due to connection loss in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                } else {
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            }

            if (work_res.first == boltprotocol::BoltError::SUCCESS) {
                auto commit_res = commit_transaction();
                if (commit_res.first == boltprotocol::BoltError::SUCCESS) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Transaction work committed successfully.");
                    session_params_.default_access_mode = original_session_access_mode;
                    return {boltprotocol::BoltError::SUCCESS, ""};
                } else {
                    last_attempt_result = {commit_res.first, "Managed TX: Commit failed (Attempt " + std::to_string(attempt_count) + "): " + commit_res.second};
                    if (current_op_logger) current_op_logger->warn("[SessionTX Managed] {}", last_attempt_result.second);
                    bool is_commit_retryable = (commit_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                    // Potentially check for specific Neo4j error codes from commit_res.second if available
                    if (is_commit_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                        if (current_op_logger) current_op_logger->info("[SessionTX Managed] COMMIT failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                        std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                        current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                        continue;
                    }
                    session_params_.default_access_mode = original_session_access_mode;
                    return last_attempt_result;
                }
            } else {  // User lambda returned error
                auto rollback_res = rollback_transaction();
                if (rollback_res.first != boltprotocol::BoltError::SUCCESS && connection_is_valid_ && current_op_logger) {
                    current_op_logger->warn("[SessionTX Managed] Rollback failed after work error ('{}'): {}", work_res.second, rollback_res.second);
                }
                last_attempt_result = work_res;
                if (current_op_logger) current_op_logger->warn("[SessionTX Managed] Work failed (Attempt {}): {}", attempt_count, work_res.second);
                bool is_work_error_retryable = (work_res.first == boltprotocol::BoltError::NETWORK_ERROR || !connection_is_valid_);
                // Potentially check for specific Neo4j error codes for retry
                if (is_work_error_retryable && std::chrono::steady_clock::now() + std::chrono::milliseconds(current_delay_ms) < overall_deadline) {
                    if (current_op_logger) current_op_logger->info("[SessionTX Managed] Work failed retryable, retrying whole TX in {}ms.", current_delay_ms);
                    std::this_thread::sleep_for(std::chrono::milliseconds(current_delay_ms));
                    current_delay_ms = static_cast<uint32_t>(std::min(static_cast<double>(current_delay_ms) * multiplier, static_cast<double>(max_delay_ms)));
                    continue;
                }
                session_params_.default_access_mode = original_session_access_mode;
                return last_attempt_result;
            }
        }

        if (drv_logger) {
            drv_logger->warn("[SessionTX Managed] Transaction work failed after all {} retries or timeout. Last error: {}", attempt_count, last_attempt_result.second);
        }
        session_params_.default_access_mode = original_session_access_mode;
        return last_attempt_result;
    }

}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"  // For serialize_run_message
#include "boltprotocol/packstream_writer.h"      // For PackStreamWriter
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/neo4j_bolt_transport.h"  // Required for transport_manager_ access
#include "neo4j_bolt_transport/result_stream.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<std::pair<boltprotocol::BoltError, std::string>, std::unique_ptr<BoltResultStream>> SessionHandle::run_query(const std::string& cypher,
                                                                                                                           const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                           const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        boltprotocol::SuccessMessageParams run_summary_raw;
        boltprotocol::FailureMessageParams run_failure_details_raw;
        std::pair<boltprotocol::BoltError, std::string> prepare_result = {boltprotocol::BoltError::SUCCESS, ""};
        std::optional<int64_t> qid_for_stream;
        bool server_can_have_more_records_after_run = false;

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string current_server_address = "unknown_server:0";
        boltprotocol::versions::Version current_bolt_version(0, 0);
        bool current_utc_patch_active = false;

        std::pair<boltprotocol::BoltError, std::string> conn_check_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_check_pair, "run_query (initial check)");

        if (conn) {
            logger = conn->get_logger();
            current_server_address = conn->get_config().target_host + ":" + std::to_string(conn->get_config().target_port);
            current_bolt_version = conn->get_bolt_version();
            current_utc_patch_active = conn->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (!conn) {
            prepare_result = conn_check_pair;
            if (logger) logger->warn("[SessionExec] run_query: Connection unavailable. Error: {}, Msg: {}", static_cast<int>(prepare_result.first), prepare_result.second);
        } else {
            std::optional<std::map<std::string, boltprotocol::Value>> metadata_to_pass;
            std::optional<std::chrono::milliseconds> timeout_to_pass;

            if (tx_config_overrides.has_value()) {
                metadata_to_pass = tx_config_overrides->metadata;
                timeout_to_pass = tx_config_overrides->timeout;
            } else {  // Use defaults from TransportConfig if no overrides
                if (transport_manager_ && transport_manager_->get_config().explicit_transaction_timeout_default_ms > 0 && !is_in_transaction()) {
                    timeout_to_pass = std::chrono::milliseconds(transport_manager_->get_config().explicit_transaction_timeout_default_ms);
                }
            }

            if (is_in_transaction()) {
                if (metadata_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_metadata_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                if (timeout_to_pass.has_value() && logger) {
                    logger->trace("[SessionExec] tx_timeout_override provided for RUN in explicit transaction, will be ignored by Bolt protocol for RUN.");
                }
                // For explicit TX, RUN does not take metadata/timeout. Those are on BEGIN.
                prepare_result = _prepare_explicit_tx_run(cypher, parameters, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = current_transaction_query_id_;  // Set by _prepare_explicit_tx_run
                    server_can_have_more_records_after_run = true;
                }
            } else {  // Auto-commit
                prepare_result = _prepare_auto_commit_run(cypher, parameters, metadata_to_pass, timeout_to_pass, run_summary_raw, run_failure_details_raw);
                if (prepare_result.first == boltprotocol::BoltError::SUCCESS) {
                    qid_for_stream = std::nullopt;
                    auto it_qid = run_summary_raw.metadata.find("qid");
                    if (it_qid != run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                        qid_for_stream = std::get<int64_t>(it_qid->second);
                    }
                    server_can_have_more_records_after_run = true;
                }
            }
        }

        std::shared_ptr<std::vector<std::string>> fields_ptr = std::make_shared<std::vector<std::string>>();
        auto it_fields = run_summary_raw.metadata.find("fields");
        if (it_fields != run_summary_raw.metadata.end() && std::holds_alternative<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second)) {
            const auto& list_ptr = std::get<std::shared_ptr<boltprotocol::BoltList>>(it_fields->second);
            if (list_ptr) {
                fields_ptr->reserve(list_ptr->elements.size());
                for (const auto& field_val : list_ptr->elements) {
                    if (std::holds_alternative<std::string>(field_val)) {
                        fields_ptr->push_back(std::get<std::string>(field_val));
                    }
                }
            }
        }

        if (logger && prepare_result.first == boltprotocol::BoltError::SUCCESS) {
            logger->debug("[SessionExec] run_query successful prep. Fields: {}. QID for stream: {}", fields_ptr->size(), qid_for_stream.has_value() ? std::to_string(qid_for_stream.value()) : "none");
        }

        auto result_stream = std::make_unique<BoltResultStream>(this,
                                                                qid_for_stream,
                                                                std::move(run_summary_raw),
                                                                fields_ptr,
                                                                std::vector<boltprotocol::RecordMessageParams>{},
                                                                server_can_have_more_records_after_run,
                                                                current_bolt_version,
                                                                current_utc_patch_active,
                                                                current_server_address,
                                                                session_params_.database_name,
                                                                prepare_result.first,
                                                                prepare_result.second,
                                                                (prepare_result.first != boltprotocol::BoltError::SUCCESS ? std::make_optional(run_failure_details_raw) : std::nullopt));

        return {std::move(prepare_result), std::move(result_stream)};
    }

    std::pair<std::pair<boltprotocol::BoltError, std::string>, ResultSummary> SessionHandle::run_query_and_consume(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                                                   const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        std::shared_ptr<spdlog::logger> logger = nullptr;
        std::string srv_addr_cache = "unknown_server:0";
        boltprotocol::versions::Version bolt_ver_cache(0, 0);
        bool utc_patch_cache = false;

        if (connection_) {
            if (connection_->get_logger()) logger = connection_->get_logger();
            srv_addr_cache = connection_->get_config().target_host + ":" + std::to_string(connection_->get_config().target_port);
            bolt_ver_cache = connection_->get_bolt_version();
            utc_patch_cache = connection_->is_utc_patch_active();
        } else if (transport_manager_ && transport_manager_->get_config().logger) {
            logger = transport_manager_->get_config().logger;
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume starting for cypher: {:.30}...", cypher);

        auto [initial_err_pair, result_stream_ptr] = run_query(cypher, parameters, tx_config_overrides);  // Pass overrides

        if (initial_err_pair.first != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: run_query failed initially. Error: {}, Msg: {}", static_cast<int>(initial_err_pair.first), initial_err_pair.second);
            if (result_stream_ptr) {
                boltprotocol::SuccessMessageParams params_copy = result_stream_ptr->get_run_summary().raw_params();
                return {initial_err_pair, ResultSummary(std::move(params_copy), bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
            }
            return {initial_err_pair, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        if (!result_stream_ptr) {
            if (logger) logger->error("[SessionExec] run_query_and_consume: Internal error - run_query succeeded but returned null stream.");
            return {{boltprotocol::BoltError::UNKNOWN_ERROR, "Null result stream post run_query."}, ResultSummary({}, bolt_ver_cache, utc_patch_cache, srv_addr_cache, session_params_.database_name)};
        }

        auto [consume_err_code, consume_err_msg, final_summary_typed] = result_stream_ptr->consume();

        if (consume_err_code != boltprotocol::BoltError::SUCCESS) {
            if (logger) logger->warn("[SessionExec] run_query_and_consume: stream consume failed. Error: {}, Msg: {}", static_cast<int>(consume_err_code), consume_err_msg);
            return {{consume_err_code, std::move(consume_err_msg)}, std::move(final_summary_typed)};
        }

        if (logger) logger->trace("[SessionExec] run_query_and_consume successful.");

        if (!connection_is_valid_) {
            boltprotocol::BoltError conn_last_err = boltprotocol::BoltError::NETWORK_ERROR;
            std::string conn_last_msg = "Connection lost during operation.";
            if (connection_ && connection_->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
                conn_last_err = connection_->get_last_error_code();
                conn_last_msg = connection_->get_last_error_message();
                if (logger) logger->warn("[SessionExec] run_query_and_consume: Connection became invalid. Last conn error: {}", conn_last_msg);
            } else if (logger) {
                logger->warn("[SessionExec] run_query_and_consume: Connection became invalid (no specific error).");
            }
            return {{conn_last_err, conn_last_msg}, std::move(final_summary_typed)};
        }
        return {{boltprotocol::BoltError::SUCCESS, ""}, std::move(final_summary_typed)};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::run_query_without_result(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<TransactionConfigOverrides>& tx_config_overrides) {  // Updated parameter

        auto [err_pair_outer, summary_typed] = run_query_and_consume(cypher, parameters, tx_config_overrides);  // Pass overrides
        return err_pair_outer;
    }
}  // namespace neo4j_bolt_transport#include <iostream>
#include <utility>

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"
#include "neo4j_bolt_transport/error/neo4j_error_util.h"
#include "neo4j_bolt_transport/internal/bolt_physical_connection.h"
#include "neo4j_bolt_transport/session_handle.h"

namespace neo4j_bolt_transport {

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_auto_commit_run(const std::string& cypher,
                                                                                            const std::map<std::string, boltprotocol::Value>& parameters,
                                                                                            const std::optional<std::map<std::string, boltprotocol::Value>>& tx_metadata,
                                                                                            const std::optional<std::chrono::milliseconds>& tx_timeout,
                                                                                            boltprotocol::SuccessMessageParams& out_run_summary_raw,
                                                                                            boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_auto_commit_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;
        run_p.bookmarks = current_bookmarks_;
        if (session_params_.database_name.has_value()) run_p.db = session_params_.database_name;
        if (session_params_.impersonated_user.has_value()) run_p.imp_user = session_params_.impersonated_user;

        // Compare with a constructed Version object for Bolt 5.0
        if (conn->get_bolt_version() < boltprotocol::versions::Version(5, 0)) {
            if (session_params_.default_access_mode == config::AccessMode::READ) {
                run_p.mode = "r";
            }
        }

        if (tx_metadata.has_value()) {
            run_p.tx_metadata = tx_metadata.value();
        }
        if (tx_timeout.has_value()) {
            run_p.tx_timeout = static_cast<int64_t>(tx_timeout.value().count());
        }

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_writer(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_writer, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger)
            logger->trace(
                "[SessionStream {}] Sending auto-commit RUN. Cypher: {:.30}, Timeout: {}ms, Meta: {}", conn->get_id(), cypher, run_p.tx_timeout.has_value() ? std::to_string(run_p.tx_timeout.value()) : "N/A", run_p.tx_metadata.has_value() && !run_p.tx_metadata.value().empty() ? "Yes" : "No");

        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Auto-commit RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }
        if (conn->get_last_error_code() != boltprotocol::BoltError::SUCCESS) {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Auto-commit RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }

        if (logger) logger->trace("[SessionStream {}] Auto-commit RUN successful, got its summary.", conn->get_id());
        return {boltprotocol::BoltError::SUCCESS, ""};
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_prepare_explicit_tx_run(const std::string& cypher, const std::map<std::string, boltprotocol::Value>& parameters, boltprotocol::SuccessMessageParams& out_run_summary_raw, boltprotocol::FailureMessageParams& out_failure_details_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_prepare_explicit_tx_run");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        if (!in_explicit_transaction_) {
            if (logger) logger->warn("[SessionStream {}] _prepare_explicit_tx_run called when not in transaction.", conn->get_id());
            return {boltprotocol::BoltError::INVALID_ARGUMENT, "Cannot run query in explicit TX mode; not in transaction."};
        }

        boltprotocol::RunMessageParams run_p;
        run_p.cypher_query = cypher;
        run_p.parameters = parameters;

        std::vector<uint8_t> run_payload_bytes;
        boltprotocol::PackStreamWriter run_w(run_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_run_message(run_p, run_w, conn->get_bolt_version());
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending explicit TX RUN. Cypher: {:.30}", conn->get_id(), cypher);
        err = conn->send_request_receive_summary(run_payload_bytes, out_run_summary_raw, out_failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("Explicit TX RUN send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            current_transaction_query_id_.reset();
            // Compare with a constructed Version object for Bolt 4.0
            if (!(conn->get_bolt_version() < boltprotocol::versions::Version(4, 0))) {  // If Bolt version is >= 4.0
                auto it_qid = out_run_summary_raw.metadata.find("qid");
                if (it_qid != out_run_summary_raw.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
                    current_transaction_query_id_ = std::get<int64_t>(it_qid->second);
                    if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful, qid: {}.", conn->get_id(), *current_transaction_query_id_);
                } else {
                    if (logger) logger->warn("[SessionStream {}] Missing qid in RUN SUCCESS for explicit transaction (Bolt version {}.{}). Subsequent PULL/DISCARD may need to be implicit.", conn->get_id(), (int)conn->get_bolt_version().major, (int)conn->get_bolt_version().minor);
                }
            } else {
                if (logger) logger->trace("[SessionStream {}] Explicit TX RUN successful (Bolt < 4.0, no qid expected from RUN).", conn->get_id());
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(out_failure_details_raw);
            std::string msg = error::format_error_message("Explicit TX RUN server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_pull_records(std::optional<int64_t> qid, int64_t n, std::vector<boltprotocol::RecordMessageParams>& out_records, boltprotocol::SuccessMessageParams& out_pull_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_pull_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::PullMessageParams pull_p;
        pull_p.n = n;
        pull_p.qid = qid;

        std::vector<uint8_t> pull_payload_bytes;
        boltprotocol::PackStreamWriter writer(pull_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_pull_message(pull_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending PULL (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;

        auto record_processor = [&](boltprotocol::MessageTag /*tag*/, const std::vector<uint8_t>& rec_payload, internal::BoltPhysicalConnection& /*connection_ref*/) {
            boltprotocol::RecordMessageParams rec;
            boltprotocol::PackStreamReader r(rec_payload);
            if (boltprotocol::deserialize_record_message(r, rec) == boltprotocol::BoltError::SUCCESS) {
                out_records.push_back(std::move(rec));
                return boltprotocol::BoltError::SUCCESS;
            }
            if (logger) logger->error("[SessionStream {}] Failed to deserialize RECORD message during PULL.", conn->get_id());
            return boltprotocol::BoltError::DESERIALIZATION_ERROR;
        };

        err = conn->send_request_receive_stream(pull_payload_bytes, record_processor, out_pull_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("PULL stream processing", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_pull_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_pull_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after PULL: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after PULL, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) {
                bool has_more = false;
                auto it_has_more = out_pull_summary_raw.metadata.find("has_more");
                if (it_has_more != out_pull_summary_raw.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more = std::get<bool>(it_has_more->second);
                }
                logger->trace("[SessionStream {}] PULL successful. Records received: {}. HasMore: {}", conn->get_id(), out_records.size(), has_more);
            }
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("PULL server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

    std::pair<boltprotocol::BoltError, std::string> SessionHandle::_stream_discard_records(std::optional<int64_t> qid, int64_t n, boltprotocol::SuccessMessageParams& out_discard_summary_raw) {
        std::pair<boltprotocol::BoltError, std::string> conn_err_pair;
        internal::BoltPhysicalConnection* conn = _get_valid_connection_for_operation(conn_err_pair, "_stream_discard_records");
        if (!conn) {
            return conn_err_pair;
        }
        auto logger = conn->get_logger();

        boltprotocol::DiscardMessageParams discard_p;
        discard_p.n = n;
        discard_p.qid = qid;

        std::vector<uint8_t> discard_payload_bytes;
        boltprotocol::PackStreamWriter writer(discard_payload_bytes);
        boltprotocol::BoltError err = boltprotocol::serialize_discard_message(discard_p, writer);
        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD serialization", err);
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (logger) logger->trace("[SessionStream {}] Sending DISCARD (n={}, qid={}).", conn->get_id(), n, qid.has_value() ? std::to_string(qid.value()) : "implicit");

        boltprotocol::FailureMessageParams failure_details_raw;
        err = conn->send_request_receive_summary(discard_payload_bytes, out_discard_summary_raw, failure_details_raw);

        if (err != boltprotocol::BoltError::SUCCESS) {
            std::string msg = error::format_error_message("DISCARD send/receive summary", err, conn->get_last_error_message());
            _invalidate_session_due_to_connection_error(err, msg);
            return {err, msg};
        }

        if (conn->get_last_error_code() == boltprotocol::BoltError::SUCCESS) {
            if (!is_in_transaction()) {
                auto it_bookmark = out_discard_summary_raw.metadata.find("bookmark");
                if (it_bookmark != out_discard_summary_raw.metadata.end() && std::holds_alternative<std::string>(it_bookmark->second)) {
                    update_bookmarks({std::get<std::string>(it_bookmark->second)});
                    if (logger) logger->trace("[SessionStream {}] Bookmarks updated after DISCARD: {}", conn->get_id(), std::get<std::string>(it_bookmark->second));
                } else {
                    update_bookmarks({});
                    if (logger) logger->trace("[SessionStream {}] No bookmark returned after DISCARD, bookmarks cleared.", conn->get_id());
                }
            }
            if (logger) logger->trace("[SessionStream {}] DISCARD successful.", conn->get_id());
            return {boltprotocol::BoltError::SUCCESS, ""};
        } else {
            std::string server_fail_detail = error::format_server_failure(failure_details_raw);
            std::string msg = error::format_error_message("DISCARD server failure", conn->get_last_error_code(), server_fail_detail);
            _invalidate_session_due_to_connection_error(conn->get_last_error_code(), msg);
            return {conn->get_last_error_code(), msg};
        }
    }

}  // namespace neo4j_bolt_transport#include "neo4j_bolt_transport/uri/uri_parser.h"

#include <algorithm>  // For std::transform, std::remove_if
#include <cctype>     // For std::tolower, std::isspace
#include <stdexcept>  // For std::stoi, std::stoul exceptions

namespace neo4j_bolt_transport {
    namespace uri {

        // Basic URL decoding (handles %XY and +)
        static std::string url_decode_component(const std::string& encoded) {
            std::string decoded;
            decoded.reserve(encoded.length());
            for (size_t i = 0; i < encoded.length(); ++i) {
                if (encoded[i] == '%' && i + 2 < encoded.length()) {
                    try {
                        std::string hex = encoded.substr(i + 1, 2);
                        char c = static_cast<char>(std::stoi(hex, nullptr, 16));
                        decoded += c;
                        i += 2;
                    } catch (const std::invalid_argument&) {  // Not a hex number
                        decoded += '%';                       // Treat as literal '%'
                    } catch (const std::out_of_range&) {      // Hex value too large for char
                        decoded += '%';                       // Treat as literal '%'
                    }
                } else if (encoded[i] == '+') {
                    decoded += ' ';
                } else {
                    decoded += encoded[i];
                }
            }
            return decoded;
        }

        // Helper to trim leading/trailing whitespace
        static std::string trim_whitespace(const std::string& s) {
            auto first = std::find_if_not(s.begin(), s.end(), [](unsigned char c) {
                return std::isspace(c);
            });
            if (first == s.end()) return "";  // String is all whitespace
            auto last = std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {
                            return std::isspace(c);
                        }).base();
            return std::string(first, last);
        }

        boltprotocol::BoltError UriParser::parse(const std::string& uri_string, ParsedUri& out_parsed_uri) {
            out_parsed_uri = {};  // Reset
            out_parsed_uri.input_uri = uri_string;

            if (uri_string.empty()) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 1. Scheme
            size_t scheme_end_pos = uri_string.find("://");
            if (scheme_end_pos == std::string::npos || scheme_end_pos == 0) {
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }
            out_parsed_uri.scheme = uri_string.substr(0, scheme_end_pos);
            std::transform(out_parsed_uri.scheme.begin(), out_parsed_uri.scheme.end(), out_parsed_uri.scheme.begin(), [](unsigned char c) {
                return std::tolower(c);
            });

            std::string remaining_uri = uri_string.substr(scheme_end_pos + 3);
            if (remaining_uri.empty() || remaining_uri[0] == '/' || remaining_uri[0] == '?') {  // Authority must exist
                return boltprotocol::BoltError::INVALID_ARGUMENT;
            }

            // 2. Authority (and userinfo within it)
            size_t authority_terminator_pos = remaining_uri.find_first_of("/?");
            std::string authority_part_full = remaining_uri.substr(0, authority_terminator_pos);

            std::string path_and_query_part;
            if (authority_terminator_pos != std::string::npos) {
                path_and_query_part = remaining_uri.substr(authority_terminator_pos);
            }

            // Userinfo (username:password@)
            size_t userinfo_terminator_pos = authority_part_full.find('@');
            std::string host_port_list_str = authority_part_full;

            if (userinfo_terminator_pos != std::string::npos) {
                std::string userinfo_str = authority_part_full.substr(0, userinfo_terminator_pos);
                host_port_list_str = authority_part_full.substr(userinfo_terminator_pos + 1);
                if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host missing after @

                size_t password_delim_pos = userinfo_str.find(':');
                if (password_delim_pos != std::string::npos) {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str.substr(0, password_delim_pos));
                    out_parsed_uri.password_from_uri = url_decode_component(userinfo_str.substr(password_delim_pos + 1));
                } else {
                    out_parsed_uri.username_from_uri = url_decode_component(userinfo_str);
                }
            }
            if (host_port_list_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host(s) part is mandatory

            // Parse host(s) and port(s)
            // Host part can be a comma-separated list for routing schemes
            size_t current_token_pos = 0;
            while (current_token_pos < host_port_list_str.length()) {
                size_t next_host_separator = host_port_list_str.find(',', current_token_pos);
                std::string current_host_port_token = trim_whitespace(host_port_list_str.substr(current_token_pos, next_host_separator - current_token_pos));
                if (current_host_port_token.empty()) {  // Handles cases like ",," or leading/trailing commas
                    if (next_host_separator == std::string::npos) break;
                    current_token_pos = next_host_separator + 1;
                    continue;
                }

                std::string current_host_str;
                uint16_t current_port_val = 0;  // Default based on scheme later if not specified here

                size_t port_separator_pos = current_host_port_token.rfind(':');
                size_t ipv6_bracket_end_pos = current_host_port_token.rfind(']');

                if (port_separator_pos != std::string::npos && (ipv6_bracket_end_pos == std::string::npos || port_separator_pos > ipv6_bracket_end_pos)) {
                    // Port is specified
                    current_host_str = trim_whitespace(current_host_port_token.substr(0, port_separator_pos));
                    std::string port_str = trim_whitespace(current_host_port_token.substr(port_separator_pos + 1));
                    if (port_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port num missing after ':'
                    try {
                        unsigned long p_val = std::stoul(port_str);
                        if (p_val == 0 || p_val > 65535) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Invalid port range
                        current_port_val = static_cast<uint16_t>(p_val);
                    } catch (const std::exception&) {                      // std::invalid_argument or std::out_of_range
                        return boltprotocol::BoltError::INVALID_ARGUMENT;  // Port not a number or out of range
                    }
                } else {
                    // No port specified for this token
                    current_host_str = current_host_port_token;
                }

                // Remove IPv6 brackets if present
                if (current_host_str.length() >= 2 && current_host_str.front() == '[' && current_host_str.back() == ']') {
                    current_host_str = current_host_str.substr(1, current_host_str.length() - 2);
                }
                if (current_host_str.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Host cannot be empty

                out_parsed_uri.hosts_with_ports.emplace_back(current_host_str, current_port_val);

                if (next_host_separator == std::string::npos) break;
                current_token_pos = next_host_separator + 1;
            }
            if (out_parsed_uri.hosts_with_ports.empty()) return boltprotocol::BoltError::INVALID_ARGUMENT;  // No valid host found

            // 3. Query Parameters (Path component is usually ignored or used for specific DB in some drivers, simplified here)
            if (!path_and_query_part.empty()) {
                size_t query_start_pos = path_and_query_part.find('?');
                if (query_start_pos != std::string::npos) {
                    std::string query_string = path_and_query_part.substr(query_start_pos + 1);
                    size_t current_param_pos = 0;
                    while (current_param_pos < query_string.length()) {
                        size_t next_amp_pos = query_string.find('&', current_param_pos);
                        std::string param_pair_str = query_string.substr(current_param_pos, next_amp_pos - current_param_pos);
                        size_t eq_pos = param_pair_str.find('=');
                        if (eq_pos != std::string::npos) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str.substr(0, eq_pos)));
                            std::string value = trim_whitespace(url_decode_component(param_pair_str.substr(eq_pos + 1)));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = value;
                        } else if (!param_pair_str.empty()) {
                            std::string key = trim_whitespace(url_decode_component(param_pair_str));
                            if (!key.empty()) out_parsed_uri.query_parameters[key] = "";
                        }
                        if (next_amp_pos == std::string::npos) break;
                        current_param_pos = next_amp_pos + 1;
                    }
                }
            }

            // Apply scheme-specific logic and default ports
            uint16_t default_port_for_scheme = 0;

            if (out_parsed_uri.scheme == "bolt") {
                out_parsed_uri.tls_enabled_by_scheme = false;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "bolt+s") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "bolt+ssc") {
                out_parsed_uri.tls_enabled_by_scheme = true;
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = false;  // Routing table will dictate TLS for resolved servers
                default_port_for_scheme = ParsedUri::DEFAULT_BOLT_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+s") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::SYSTEM_CAS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else if (out_parsed_uri.scheme == "neo4j+ssc") {
                out_parsed_uri.is_routing_scheme = true;
                out_parsed_uri.tls_enabled_by_scheme = true;  // Initial connection to router uses TLS
                out_parsed_uri.trust_strategy_hint = ParsedUri::SchemeTrustStrategy::TRUST_ALL_CERTS;
                default_port_for_scheme = ParsedUri::DEFAULT_BOLTS_PORT;
            } else {
                return boltprotocol::BoltError::INVALID_ARGUMENT;  // Unknown scheme
            }

            // Apply default port if any host_with_port has port 0
            for (auto& host_port_pair : out_parsed_uri.hosts_with_ports) {
                if (host_port_pair.second == 0) {
                    if (default_port_for_scheme == 0) return boltprotocol::BoltError::INVALID_ARGUMENT;  // Scheme needs explicit port
                    host_port_pair.second = default_port_for_scheme;
                }
            }

            out_parsed_uri.is_valid = true;
            return boltprotocol::BoltError::SUCCESS;
        }

    }  // namespace uri
}  // namespace neo4j_bolt_transport