# CMakeLists.txt for BoltProtocol module

# Since this module is purely for protocol logic and data structures,
# it might not have complex dependencies beyond standard C++.
# If PackStream or other parts need external libs (e.g., for specific data types),
# they would be added here.

file(GLOB_RECURSE BOLT_PROTOCOL_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(BoltProtocol ${BOLT_PROTOCOL_SOURCES})

target_include_directories(BoltProtocol
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

# build example, no condition
add_subdirectory(Example)

# BoltProtocol itself likely doesn't link to socket libraries.
# It provides structures and serialization/deserialization logic.
# The Neo4jBoltDriver will link the socket library and use BoltProtocol.

# Example of how other modules would link against BoltProtocol:
# target_link_libraries(Neo4jBoltDriver PRIVATE BoltProtocol)#include <array>      // For handshake
#include <exception>  // For std::bad_alloc, std::exception
#include <iomanip>    // For std::setw, std::setfill
#include <iostream>
#include <map>
#include <memory>   // For std::shared_ptr
#include <sstream>  // For std::stringstream to simulate socket streams
#include <string>
#include <vector>

#include "boltprotocol/chunking.h"
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

// Helper to print BoltError and associated reader/writer errors
void print_bolt_error_details_client(
    const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr, boltprotocol::ChunkedReader* chunk_reader = nullptr, boltprotocol::ChunkedWriter* chunk_writer = nullptr) {
    std::cerr << "Error (Client) " << context << ": " << static_cast<int>(err_code);
    if (reader && reader->has_error() && reader->get_error() != err_code) {
        std::cerr << " (PackStreamReader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err_code) {
        std::cerr << " (PackStreamWriter specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    if (chunk_reader && chunk_reader->has_error() && chunk_reader->get_error() != err_code) {
        std::cerr << " (ChunkedReader specific error: " << static_cast<int>(chunk_reader->get_error()) << ")";
    }
    if (chunk_writer && chunk_writer->has_error() && chunk_writer->get_error() != err_code) {
        std::cerr << " (ChunkedWriter specific error: " << static_cast<int>(chunk_writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

// Helper function to print a byte vector
void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}

// Simulate sending a raw message (PackStream bytes) via ChunkedWriter
// and receiving a raw response (PackStream bytes) via ChunkedReader.
boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response = true) {
    using namespace boltprotocol;
    BoltError err;

    // --- Client Sends Message ---
    std::cout << "Client: Preparing to send " << message_description_for_log << "..." << std::endl;
    print_bytes_client("Client: Raw " + message_description_for_log + " to send: ", raw_message_to_send);

    // Clear client_to_server_pipe for this message (caller responsibility to manage overall pipe lifetime)
    // For this helper, we assume it's okay to clear before writing.
    if (!raw_message_to_send.empty()) {  // Only clear if we are actually sending something
        client_to_server_pipe.clear();
        client_to_server_pipe.str("");
    }

    if (!raw_message_to_send.empty()) {  // Only write if there's a message
        ChunkedWriter chunk_writer(client_to_server_pipe);
        err = chunk_writer.write_message(raw_message_to_send);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("ChunkedWriter writing " + message_description_for_log, err, nullptr, nullptr, nullptr, &chunk_writer);
            return err;
        }
        std::cout << "Client: " << message_description_for_log << " written to client_to_server_pipe (chunked)." << std::endl;
    } else if (expect_response) {  // If sending nothing but expecting response (e.g. implicit PULL after RUN)
        std::cout << "Client: Sending no explicit message, but expecting response for " << message_description_for_log << "." << std::endl;
    } else {  // Sending nothing, expecting nothing
        std::cout << "Client: No message to send and no response expected for " << message_description_for_log << "." << std::endl;
    }

    // --- Client Receiving Response (if expected) ---
    if (!expect_response) {
        std::cout << "Client: No response expected for " << message_description_for_log << "." << std::endl;
        // Even if no response expected, server_pipe might have old data; clear it.
        server_to_client_pipe.clear();
        server_to_client_pipe.str("");
        return BoltError::SUCCESS;
    }

    std::cout << "Client: Waiting for server response to " << message_description_for_log << "..." << std::endl;
    // Check if the server pipe is empty *before* trying to read.
    // Need to peek to see if there's content, as str() doesn't reflect read position.
    server_to_client_pipe.peek();  // This updates EOF state if at end
    if (server_to_client_pipe.str().empty() && server_to_client_pipe.eof()) {
        std::cout << "Client: Server_to_client_pipe is empty and at EOF. No response to read for " << message_description_for_log << "." << std::endl;
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log + " (pipe was empty)", BoltError::NETWORK_ERROR);
        return BoltError::NETWORK_ERROR;
    }

    out_raw_response_received.clear();
    ChunkedReader chunk_reader(server_to_client_pipe);
    err = chunk_reader.read_message(out_raw_response_received);

    if (err != BoltError::SUCCESS) {
        // If read_message fails, it might be due to an empty pipe that wasn't caught above, or actual error.
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log, err, nullptr, nullptr, &chunk_reader);
        return err;
    }
    print_bytes_client("Client: Raw response received for " + message_description_for_log + ": ", out_raw_response_received);

    // Clear the server_to_client_pipe after successful read, ready for next simulated server response.
    server_to_client_pipe.clear();
    server_to_client_pipe.str("");

    return BoltError::SUCCESS;
}

// Helper to simulate server sending a simple SUCCESS {} response
boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid = -1) {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_server_response_bytes;
    BoltError err;
    {
        PackStreamWriter ps_writer(raw_server_response_bytes);
        SuccessMessageParams success_p;
        bool prep_ok = true;
        try {
            if (qid != -1) {
                success_p.metadata.emplace("qid", Value(qid));
            }
            // Add other common success fields if needed for simulation
            // success_p.metadata.emplace("type", Value(std::string("r"))); // For query summary
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        PackStreamStructure success_pss;
        success_pss.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
        std::shared_ptr<BoltMap> meta_map_sptr;
        try {
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_p.metadata);  // Move if success_p not used after
            success_pss.fields.emplace_back(Value(meta_map_sptr));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS PSS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(success_pss));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS sptr: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr null", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        err = ps_writer.write(Value(std::move(pss_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing " + context_log + " SUCCESS", err, nullptr, &ps_writer);
            return err;
        }
    }
    // "Server" puts its response into the server_pipe
    server_pipe.clear();
    server_pipe.str("");  // Clear for this specific response
    {
        ChunkedWriter server_chunk_writer(server_pipe);
        err = server_chunk_writer.write_message(raw_server_response_bytes);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunk writing " + context_log + " SUCCESS", err, nullptr, nullptr, nullptr, &server_chunk_writer);
            return err;
        }
    }
    std::cout << "Server (Simulated): Sent " << context_log << " SUCCESS response." << std::endl;
    return BoltError::SUCCESS;
}

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Client Example (No-Exception, Integrated Handshake/Chunking/Tx)" << std::endl;
    std::cout << "-----------------------------------------------------------------------------" << std::endl;

    BoltError err = BoltError::SUCCESS;
    std::stringstream client_to_server_stream;
    std::stringstream server_to_client_stream;
    versions::Version negotiated_version;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    // --- 0. Perform Handshake ---
    std::cout << "\n--- Performing Handshake ---" << std::endl;
    client_to_server_stream.clear();
    client_to_server_stream.str("");  // Clear client write pipe
    server_to_client_stream.clear();
    server_to_client_stream.str("");  // Clear server write pipe (client read pipe)
    {
        std::vector<versions::Version> proposed_versions = versions::get_default_proposed_versions();
        if (proposed_versions.empty()) {
            print_bolt_error_details_client("main: proposed_versions empty", BoltError::INVALID_ARGUMENT);
            return 1;
        }

        versions::Version server_chosen_version_sim = proposed_versions[0];
        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_b = server_chosen_version_sim.to_handshake_bytes();
        server_to_client_stream.write(reinterpret_cast<const char*>(server_response_b.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);

        err = perform_handshake(client_to_server_stream, server_to_client_stream, proposed_versions, negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("performing handshake", err);
            return 1;
        }
        std::cout << "Client: Handshake successful! Negotiated version: " << static_cast<int>(negotiated_version.major) << "." << static_cast<int>(negotiated_version.minor) << std::endl;
    }
    // After handshake, client_to_server_stream contains handshake request, server_to_client_stream is now empty.

    // --- 1. Client Sends HELLO Message ---
    std::cout << "\n--- Client Sending HELLO ---" << std::endl;
    raw_message_bytes_storage.clear();
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        HelloMessageParams hello_params;
        bool prep_ok = true;
        try {
            std::string user_agent = DEFAULT_USER_AGENT_FORMAT_STRING + " (Bolt " + std::to_string(negotiated_version.major) + "." + std::to_string(negotiated_version.minor) + ")";
            hello_params.extra_auth_tokens.emplace("user_agent", Value(user_agent));
            hello_params.extra_auth_tokens.emplace("scheme", Value(std::string("basic")));
            hello_params.extra_auth_tokens.emplace("principal", Value(std::string("neo4j")));
            hello_params.extra_auth_tokens.emplace("credentials", Value(std::string("password")));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc HELLO params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc HELLO params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep HELLO params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return 1;

        err = serialize_hello_message(hello_params, ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing HELLO", err, nullptr, &ps_writer);
            return 1;
        }
    }
    // Simulate Server Response to HELLO (SUCCESS)
    err = simulate_server_simple_success_response(server_to_client_stream, "HELLO");  // server_to_client_stream now primed
    if (err != BoltError::SUCCESS) return 1;
    // Client sends HELLO and gets response
    client_to_server_stream.clear();
    client_to_server_stream.str("");  // Clear client write pipe for HELLO
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "HELLO");
    if (err != BoltError::SUCCESS) return 1;
    // Client deserializes the SUCCESS response for HELLO
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("HELLO resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    SuccessMessageParams hello_success_params;
    {
        PackStreamReader hello_response_reader(raw_response_bytes_storage);
        err = deserialize_success_message(hello_response_reader, hello_success_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser HELLO SUCCESS", err, &hello_response_reader);
            return 1;
        }
    }
    std::cout << "Client: HELLO SUCCESS deserialized." << std::endl;

    // --- 2. Start a Transaction (BEGIN) ---
    std::cout << "\n--- Client Sending BEGIN ---" << std::endl;
    raw_message_bytes_storage.clear();
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        BeginMessageParams begin_params;  // Empty 'extra' map by default
        err = serialize_begin_message(begin_params, ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing BEGIN", err, nullptr, &ps_writer);
            return 1;
        }
    }
    err = simulate_server_simple_success_response(server_to_client_stream, "BEGIN");
    if (err != BoltError::SUCCESS) return 1;
    client_to_server_stream.clear();
    client_to_server_stream.str("");
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "BEGIN");
    if (err != BoltError::SUCCESS) return 1;
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("BEGIN resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    SuccessMessageParams begin_success_params;
    {
        PackStreamReader r(raw_response_bytes_storage);
        err = deserialize_success_message(r, begin_success_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser BEGIN SUCCESS", err, &r);
            return 1;
        }
    }
    std::cout << "Client: BEGIN SUCCESS deserialized." << std::endl;

    // --- 3. Run a query within the transaction (RUN + PULL) ---
    std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl;
    raw_message_bytes_storage.clear();
    int64_t run_in_tx_qid = 2;
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        RunMessageParams run_params;
        bool prep_ok = true;
        try {
            run_params.cypher_query = "CREATE (a:Person {name: 'Alice'}) RETURN id(a)";
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc RUN_IN_TX params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc RUN_IN_TX params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep RUN_IN_TX params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return 1;
        err = serialize_run_message(run_params, ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing RUN_IN_TX", err, nullptr, &ps_writer);
            return 1;
        }
    }
    // Simulate Server Response to RUN (SUCCESS {fields, qid})
    std::vector<uint8_t> raw_server_run_fields_response;
    {
        PackStreamWriter srv_ps_writer(raw_server_run_fields_response);
        SuccessMessageParams fields_s_p;
        bool prep_ok = true;
        try {
            auto fields_list = std::make_shared<BoltList>();
            fields_list->elements.emplace_back(Value(std::string("id(a)")));
            fields_s_p.metadata.emplace("fields", Value(fields_list));
            fields_s_p.metadata.emplace("qid", Value(run_in_tx_qid));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv: RUN_IN_TX SUCCESS fields alloc", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc Sim Srv: RUN_IN_TX SUCCESS fields: " << e.what() << std::endl;
            print_bolt_error_details_client("Sim Srv: RUN_IN_TX SUCCESS fields stdexc", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return 1;

        PackStreamStructure pss;
        pss.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
        std::shared_ptr<BoltMap> meta;
        bool pss_prep_ok = true;
        try {
            meta = std::make_shared<BoltMap>();
            meta->pairs = std::move(fields_s_p.metadata);
            pss.fields.emplace_back(Value(meta));
        } catch (...) {
            pss_prep_ok = false;
        }
        if (!pss_prep_ok) return 1;

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss));
        } catch (...) {
            return 1;
        }
        if (!pss_sptr) return 1;

        err = srv_ps_writer.write(Value(pss_sptr));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing RUN_IN_TX SUCCESS fields", err);
            return 1;
        }
    }
    server_to_client_stream.clear();
    server_to_client_stream.str("");
    {
        ChunkedWriter srv_c_writer(server_to_client_stream);
        err = srv_c_writer.write_message(raw_server_run_fields_response);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunking RUN_IN_TX SUCCESS fields", err);
            return 1;
        }
    }

    client_to_server_stream.clear();
    client_to_server_stream.str("");
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "RUN_IN_TX");
    if (err != BoltError::SUCCESS) return 1;
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("RUN_IN_TX resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    SuccessMessageParams run_in_tx_success_params;
    {
        PackStreamReader r(raw_response_bytes_storage);
        err = deserialize_success_message(r, run_in_tx_success_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser RUN_IN_TX SUCCESS", err, &r);
            return 1;
        }
    }
    std::cout << "Client: RUN_IN_TX SUCCESS (fields) deserialized." << std::endl;

    // Client sends PULL to get results
    std::cout << "\n--- Client Sending PULL (in transaction) ---" << std::endl;
    raw_message_bytes_storage.clear();
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        PullMessageParams pull_params;
        bool prep_ok = true;
        try {
            pull_params.n = static_cast<int64_t>(-1);
            pull_params.qid = run_in_tx_qid;
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc PULL params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc PULL params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep PULL params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return 1;
        err = serialize_pull_message(pull_params, ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing PULL", err, nullptr, &ps_writer);
            return 1;
        }
    }
    // Simulate Server Response to PULL: one RECORD
    std::vector<uint8_t> raw_server_record_response;
    {
        PackStreamWriter srv_ps_writer(raw_server_record_response);
        RecordMessageParams rec_p;
        bool prep_ok = true;
        try {
            rec_p.fields.emplace_back(Value(static_cast<int64_t>(12345)));
        } catch (...) {
            prep_ok = false;
        }
        if (!prep_ok) return 1;
        PackStreamStructure pss;
        pss.tag = static_cast<uint8_t>(MessageTag::RECORD);
        std::shared_ptr<BoltList> list_sptr;
        bool pss_prep_ok = true;
        try {
            list_sptr = std::make_shared<BoltList>();
            list_sptr->elements = std::move(rec_p.fields);
            pss.fields.emplace_back(Value(list_sptr));
        } catch (...) {
            pss_prep_ok = false;
        }
        if (!pss_prep_ok) return 1;
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss));
        } catch (...) {
            return 1;
        }
        if (!pss_sptr) return 1;
        err = srv_ps_writer.write(Value(pss_sptr));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing RECORD", err);
            return 1;
        }
    }
    server_to_client_stream.clear();
    server_to_client_stream.str("");
    {
        ChunkedWriter srv_c_writer(server_to_client_stream);
        err = srv_c_writer.write_message(raw_server_record_response);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunking RECORD", err);
            return 1;
        }
    }

    client_to_server_stream.clear();
    client_to_server_stream.str("");
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "PULL (for RECORD)");
    if (err != BoltError::SUCCESS) return 1;
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("PULL RECORD resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    RecordMessageParams rec_msg_params;
    {
        PackStreamReader r(raw_response_bytes_storage);
        err = deserialize_record_message(r, rec_msg_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser RECORD", err, &r);
            return 1;
        }
    }
    std::cout << "Client: RECORD deserialized." << std::endl;

    // Server sends SUCCESS (summary for PULL)
    err = simulate_server_simple_success_response(server_to_client_stream, "PULL summary", run_in_tx_qid);
    if (err != BoltError::SUCCESS) return 1;
    raw_message_bytes_storage.clear();
    client_to_server_stream.clear();
    client_to_server_stream.str("");  // No client message, just receiving
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "PULL (for summary SUCCESS)", true);
    if (err != BoltError::SUCCESS) return 1;
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("PULL summary resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    SuccessMessageParams pull_summary_params;
    {
        PackStreamReader r(raw_response_bytes_storage);
        err = deserialize_success_message(r, pull_summary_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser PULL SUCCESS", err, &r);
            return 1;
        }
    }
    std::cout << "Client: PULL summary SUCCESS deserialized." << std::endl;

    // --- 4. Commit the Transaction ---
    std::cout << "\n--- Client Sending COMMIT ---" << std::endl;
    raw_message_bytes_storage.clear();
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        err = serialize_commit_message(ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing COMMIT", err, nullptr, &ps_writer);
            return 1;
        }
    }
    err = simulate_server_simple_success_response(server_to_client_stream, "COMMIT");
    if (err != BoltError::SUCCESS) return 1;
    client_to_server_stream.clear();
    client_to_server_stream.str("");
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "COMMIT");
    if (err != BoltError::SUCCESS) return 1;
    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("COMMIT resp empty", BoltError::DESERIALIZATION_ERROR);
        return 1;
    }
    SuccessMessageParams commit_success_params;
    {
        PackStreamReader r(raw_response_bytes_storage);
        err = deserialize_success_message(r, commit_success_params);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser COMMIT SUCCESS", err, &r);
            return 1;
        }
    }
    std::cout << "Client: COMMIT SUCCESS deserialized." << std::endl;

    // --- 5. Client Sends GOODBYE ---
    std::cout << "\n--- Client Sending GOODBYE ---" << std::endl;
    raw_message_bytes_storage.clear();
    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        err = serialize_goodbye_message(ps_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing GOODBYE", err, nullptr, &ps_writer);
            return 1;
        }
    }
    // GOODBYE is one-way. Server might close or send nothing.
    server_to_client_stream.clear();
    server_to_client_stream.str("");
    client_to_server_stream.clear();
    client_to_server_stream.str("");
    err = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "GOODBYE", false);
    if (err != BoltError::SUCCESS) {
        return 1;
    }
    std::cout << "Client: GOODBYE sent." << std::endl;

    std::cout << "\nClient example finished successfully." << std::endl;
    return 0;
}add_executable(client_example client_example.cpp)
target_link_libraries(client_example PUBLIC BoltProtocol)

add_executable(server_example server_example.cpp)
target_link_libraries(server_example PUBLIC BoltProtocol)#include <exception>  // For std::bad_alloc, std::exception
#include <iomanip>    // For std::setw, std::setfill
#include <iostream>
#include <map>
#include <memory>  // For std::make_shared, std::shared_ptr
#include <string>
#include <variant>  // For std::get_if, std::holds_alternative
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
// #include "boltprotocol/chunking.h"
// #include "boltprotocol/handshake.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr) {
    std::cerr << "Error (Server) " << context << ": " << static_cast<int>(err);
    if (reader && reader->has_error() && reader->get_error() != err) {
        std::cerr << " (Reader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err) {
        std::cerr << " (Writer specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

namespace boltprotocol_example_server {

    using namespace ::boltprotocol;

    void print_bytes_server_internal(const std::string& prefix, const std::vector<uint8_t>& bytes) {
        std::cout << prefix;
        for (uint8_t byte : bytes) {
            std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
        }
        std::cout << std::dec << std::endl;
    }

    BoltError process_run_query(const RunMessageParams& run_params, PackStreamWriter& response_writer) {
        std::cout << "  Server processing RUN query: '" << run_params.cypher_query << "'" << std::endl;
        auto limit_it = run_params.parameters.find("limit");
        if (limit_it != run_params.parameters.end()) {
            if (const auto* limit_val_ptr = std::get_if<int64_t>(&(limit_it->second))) {
                std::cout << "    With limit: " << *limit_val_ptr << std::endl;
            } else {
                std::cout << "    With limit: (value present but not int64_t)" << std::endl;
            }
        } else {
            std::cout << "    No 'limit' parameter found." << std::endl;
        }

        BoltError err = BoltError::SUCCESS;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<BoltList> list_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;

        // 1. Send SUCCESS for RUN (contains field names)
        try {
            SuccessMessageParams run_success_params;
            list_sptr = std::make_shared<BoltList>();
            list_sptr->elements.emplace_back(Value(std::string("name")));
            run_success_params.metadata.emplace("fields", Value(list_sptr));

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();

            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(run_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing RUN SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing RUN SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing RUN SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing RUN SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS for RUN", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS for RUN (with fields)." << std::endl;

        // 2. Send RECORD messages (dummy data)
        for (int i = 0; i < 2; ++i) {
            try {
                RecordMessageParams record_params;
                record_params.fields.emplace_back(Value(std::string("Node " + std::to_string(i))));

                pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::RECORD);
                pss_obj_on_stack.fields.clear();
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(record_params.fields);
                pss_obj_on_stack.fields.emplace_back(Value(list_sptr));

                pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

            } catch (const std::bad_alloc&) {
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e_std) {
                std::cerr << "Std exception server preparing RECORD " << std::to_string(i) << ": " << e_std.what() << std::endl;
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
                response_writer.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }

            if (!pss_to_write_sptr) {
                print_bolt_error_details_server("preparing RECORD (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            }
            err = response_writer.write(Value(std::move(pss_to_write_sptr)));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_server("serializing RECORD " + std::to_string(i), err, nullptr, &response_writer);
                return err;
            }
            std::cout << "  Server sent RECORD " << i << "." << std::endl;
        }

        // 3. Send final SUCCESS (summary)
        try {
            SuccessMessageParams summary_success_params;
            summary_success_params.metadata.emplace("type", Value(std::string("r")));

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(summary_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing summary SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing summary SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing summary SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing summary SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS summary", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS summary." << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol_example_server

int main() {
    using namespace boltprotocol_example_server;
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Server Example (No-Exception Mode)" << std::endl;
    std::cout << "------------------------------------------------" << std::endl;

    std::vector<uint8_t> server_receive_buffer_storage;
    std::vector<uint8_t> server_send_buffer_storage;
    BoltError err = BoltError::SUCCESS;

    // === Stage 1: Client sends HELLO, Server responds SUCCESS ===
    std::cout << "\nServer expecting HELLO message..." << std::endl;
    server_receive_buffer_storage.clear();
    {
        PackStreamWriter client_hello_writer(server_receive_buffer_storage);
        HelloMessageParams client_hello_params;
        bool client_prep_ok = true;
        try {
            client_hello_params.extra_auth_tokens.emplace("user_agent", Value(std::string("MyExampleCppClient/1.0")));
            client_hello_params.extra_auth_tokens.emplace("scheme", Value(std::string("basic")));
            client_hello_params.extra_auth_tokens.emplace("principal", Value(std::string("neo4j")));
            client_hello_params.extra_auth_tokens.emplace("credentials", Value(std::string("password")));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("client sim HELLO (bad_alloc)", BoltError::OUT_OF_MEMORY);
            client_prep_ok = false;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception client sim HELLO: " << e_std.what() << std::endl;
            print_bolt_error_details_server("client sim HELLO (std::exception)", BoltError::UNKNOWN_ERROR);
            client_prep_ok = false;
        }
        if (!client_prep_ok) return 1;

        err = serialize_hello_message(client_hello_params, client_hello_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("client sim serializing HELLO", err, nullptr, &client_hello_writer);
            return 1;
        }
    }
    print_bytes_server_internal("Server received bytes for HELLO (raw): ", server_receive_buffer_storage);

    Value received_value_hello;
    std::shared_ptr<PackStreamStructure> hello_struct_sptr;
    {
        PackStreamReader hello_reader(server_receive_buffer_storage);
        err = hello_reader.read(received_value_hello);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server reading HELLO PSS from received bytes", err, &hello_reader);
            return 1;
        }

        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(received_value_hello)) {
            print_bolt_error_details_server("Received HELLO message is not a PSS", BoltError::INVALID_MESSAGE_FORMAT, &hello_reader);
            return 1;
        }
        try {
            hello_struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(received_value_hello));
        } catch (const std::bad_variant_access&) {
            print_bolt_error_details_server("std::get on HELLO PSS (bad_variant_access)", BoltError::UNKNOWN_ERROR);
            return 1;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception std::get on HELLO PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("std::get on HELLO PSS (std::exception)", BoltError::UNKNOWN_ERROR);
            return 1;
        }

        if (!hello_struct_sptr || static_cast<MessageTag>(hello_struct_sptr->tag) != MessageTag::HELLO) {
            print_bolt_error_details_server("Received PSS is not HELLO or sptr is null", BoltError::INVALID_MESSAGE_FORMAT, &hello_reader);
            return 1;
        }
    }
    std::cout << "Server: HELLO message structure received." << std::endl;

    server_send_buffer_storage.clear();
    {
        PackStreamWriter success_hello_writer(server_send_buffer_storage);
        SuccessMessageParams success_for_hello_params;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;
        bool server_resp_ok = true;

        try {
            success_for_hello_params.metadata.emplace("connection_id", Value(std::string("server-conn-xyz")));
            success_for_hello_params.metadata.emplace("server", Value(std::string("MyExampleBoltServer/0.1")));

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_for_hello_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));
            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("server HELLO SUCCESS resp (bad_alloc)", BoltError::OUT_OF_MEMORY);
            server_resp_ok = false;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server HELLO SUCCESS resp: " << e_std.what() << std::endl;
            print_bolt_error_details_server("server HELLO SUCCESS resp (std::exception)", BoltError::UNKNOWN_ERROR);
            server_resp_ok = false;
        }
        if (!server_resp_ok || !pss_to_write_sptr) {
            if (server_resp_ok) print_bolt_error_details_server("server HELLO SUCCESS resp (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY);
            return 1;
        }

        err = success_hello_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server serializing SUCCESS for HELLO", err, nullptr, &success_hello_writer);
            return 1;
        }
    }
    print_bytes_server_internal("Server sending SUCCESS (for HELLO) (raw): ", server_send_buffer_storage);

    // === Stage 2: Client sends RUN, Server processes and responds ===
    std::cout << "\nServer expecting RUN message..." << std::endl;
    server_receive_buffer_storage.clear();
    {
        PackStreamWriter client_run_writer(server_receive_buffer_storage);
        RunMessageParams client_run_params;
        bool client_run_prep_ok = true;
        try {
            client_run_params.cypher_query = "MATCH (n) RETURN n.name AS name LIMIT $limit";
            client_run_params.parameters.emplace("limit", Value(static_cast<int64_t>(5)));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("client sim RUN (bad_alloc)", BoltError::OUT_OF_MEMORY);
            client_run_prep_ok = false;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception client sim RUN: " << e_std.what() << std::endl;
            print_bolt_error_details_server("client sim RUN (std::exception)", BoltError::UNKNOWN_ERROR);
            client_run_prep_ok = false;
        }
        if (!client_run_prep_ok) return 1;

        err = serialize_run_message(client_run_params, client_run_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("client sim serializing RUN", err, nullptr, &client_run_writer);
            return 1;
        }
    }
    print_bytes_server_internal("Server received bytes for RUN (raw): ", server_receive_buffer_storage);

    RunMessageParams actual_run_params;
    {
        PackStreamReader run_reader(server_receive_buffer_storage);
        Value received_value_run;
        err = run_reader.read(received_value_run);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server reading RUN PSS from received bytes", err, &run_reader);
            return 1;
        }

        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(received_value_run)) {
            print_bolt_error_details_server("Received RUN message is not a PSS", BoltError::INVALID_MESSAGE_FORMAT, &run_reader);
            return 1;
        }
        std::shared_ptr<PackStreamStructure> run_struct_sptr;
        try {
            run_struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(received_value_run));
        } catch (const std::bad_variant_access&) {
            print_bolt_error_details_server("std::get on RUN PSS (bad_variant_access)", BoltError::UNKNOWN_ERROR);
            return 1;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception std::get on RUN PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("std::get on RUN PSS (std::exception)", BoltError::UNKNOWN_ERROR);
            return 1;
        }

        if (!run_struct_sptr || static_cast<MessageTag>(run_struct_sptr->tag) != MessageTag::RUN) {
            print_bolt_error_details_server("Received PSS is not RUN or sptr is null", BoltError::INVALID_MESSAGE_FORMAT, &run_reader);
            return 1;
        }
        std::cout << "Server: RUN message structure received." << std::endl;

        bool run_fields_deser_ok = true;
        try {
            if (run_struct_sptr->fields.size() >= 1 && std::holds_alternative<std::string>(run_struct_sptr->fields[0])) {
                actual_run_params.cypher_query = std::get<std::string>(std::move(run_struct_sptr->fields[0]));
            } else {
                run_fields_deser_ok = false;
            }

            if (run_fields_deser_ok && run_struct_sptr->fields.size() >= 2 && std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_sptr->fields[1])) {
                auto params_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_sptr->fields[1]));
                if (params_map_sptr) {
                    actual_run_params.parameters = std::move(params_map_sptr->pairs);
                } else {
                    run_fields_deser_ok = false;
                }
            } else if (run_struct_sptr->fields.size() >= 2 && run_fields_deser_ok) {
                // If field 2 exists but is not a map, it's an error.
                // If field 2 doesn't exist, parameters map remains empty, which is valid.
                // This logic means if field[1] is present, it MUST be a map.
                if (run_struct_sptr->fields.size() >= 2) run_fields_deser_ok = false;
            }

            if (run_fields_deser_ok && run_struct_sptr->fields.size() >= 3 && std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_sptr->fields[2])) {
                auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_sptr->fields[2]));
                if (extra_map_sptr) {
                    actual_run_params.extra_metadata = std::move(extra_map_sptr->pairs);
                }
                // If field 3 exists but is not a map, or if sptr is null, it's fine, extra_metadata just remains empty.
            }
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("deserializing RUN fields (bad_alloc)", BoltError::OUT_OF_MEMORY, &run_reader);
            return 1;
        } catch (const std::bad_variant_access&) {
            print_bolt_error_details_server("deserializing RUN fields (bad_variant_access)", BoltError::INVALID_MESSAGE_FORMAT, &run_reader);
            return 1;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception deserializing RUN fields: " << e_std.what() << std::endl;
            print_bolt_error_details_server("deserializing RUN fields (std::exception)", BoltError::UNKNOWN_ERROR, &run_reader);
            return 1;
        }

        if (!run_fields_deser_ok) {
            print_bolt_error_details_server("deserializing RUN fields (logical error)", BoltError::INVALID_MESSAGE_FORMAT, &run_reader);
            return 1;
        }
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter run_response_writer(server_send_buffer_storage);
        err = process_run_query(actual_run_params, run_response_writer);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("processing RUN query", err, nullptr, &run_response_writer);
            return 1;
        }
    }
    print_bytes_server_internal("Server sending full response stream for RUN (raw): ", server_send_buffer_storage);

    std::cout << "\nServer example finished." << std::endl;
    return 0;
}#ifndef BOLTPROTOCOL_CHUNKING_H
#define BOLTPROTOCOL_CHUNKING_H

#include <cstdint>
#include <functional>  // For std::function
#include <iosfwd>      // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE

namespace boltprotocol {

    /**
     * @brief ChunkedWriter  Bolt 
     */
    class ChunkedWriter {
      public:
        explicit ChunkedWriter(std::ostream& stream);

        // 
        ChunkedWriter(const ChunkedWriter&) = delete;
        ChunkedWriter& operator=(const ChunkedWriter&) = delete;
        ChunkedWriter(ChunkedWriter&&) = delete;
        ChunkedWriter& operator=(ChunkedWriter&&) = delete;

        /**
         * @brief 
         *        
         * @param message_data  Bolt 
         * @return BoltError::SUCCESS 
         *         BoltError::NETWORK_ERROR 
         *         BoltError::SERIALIZATION_ERROR 
         */
        BoltError write_message(const std::vector<uint8_t>& message_data);

        /**
         * @brief 
         */
        BoltError get_error() const {
            return last_error_;
        }

        /**
         * @brief 
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError write_chunk(const uint8_t* data, uint16_t size);
        BoltError write_chunk_header(uint16_t chunk_payload_size);
        BoltError write_end_of_message_marker();  // Writes a zero-size chunk

        void set_error(BoltError err);

        std::ostream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
    };

    /**
     * @brief ChunkedReader  Bolt 
     */
    class ChunkedReader {
      public:
        explicit ChunkedReader(std::istream& stream);

        // 
        ChunkedReader(const ChunkedReader&) = delete;
        ChunkedReader& operator=(const ChunkedReader&) = delete;
        ChunkedReader(ChunkedReader&&) = delete;
        ChunkedReader& operator=(ChunkedReader&&) = delete;

        /**
         * @brief  Bolt 
         *        
         * @param out_message_data 
         *                         
         * @return BoltError::SUCCESS 
         *         BoltError::NETWORK_ERROR 
         *         BoltError::DESERIALIZATION_ERROR 
         *         BoltError::CHUNK_TOO_LARGE  MAX_CHUNK_PAYLOAD_SIZE.
         */
        BoltError read_message(std::vector<uint8_t>& out_message_data);

        /**
         * @brief 
         */
        BoltError get_error() const {
            return last_error_;
        }
        /**
         * @brief 
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError read_chunk_header(uint16_t& out_chunk_payload_size);
        BoltError read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to);

        void set_error(BoltError err);

        std::istream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
        // 
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CHUNKING_H#ifndef BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H
#define BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H

#include <algorithm>  // For std::reverse
#include <bit>        // For std::endian (C++20 and later)
#include <cstdint>
#include <type_traits>  // For std::is_integral_v, std::is_enum_v

namespace boltprotocol {
    namespace detail {

        // Helper to swap bytes of an integer type T
        template <typename T>
        inline T swap_bytes_helper(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "swap_bytes_helper requires an integral or enum type.");
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
            auto* bytes = reinterpret_cast<unsigned char*>(&value);
            std::reverse(bytes, bytes + sizeof(T));
            return value;
        }

        // --- Host to Big Endian (Network Order) ---
        inline uint16_t host_to_be(uint16_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {  // std::endian::big (or other, assuming network order is what we want if not little)
                return val;
            }
        }

        inline uint32_t host_to_be(uint32_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        inline uint64_t host_to_be(uint64_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        // --- Big Endian (Network Order) to Host ---
        inline uint16_t be_to_host(uint16_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint32_t be_to_host(uint32_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint64_t be_to_host(uint64_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H#ifndef BOLTPROTOCOL_HANDSHAKE_H
#define BOLTPROTOCOL_HANDSHAKE_H

#include <array>
#include <cstdint>
#include <iosfwd>  // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, versions::Version

namespace boltprotocol {

    // Magic Preamble  message_defs.h 
    // constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;

    constexpr size_t HANDSHAKE_NUM_PROPOSED_VERSIONS = 4;
    constexpr size_t HANDSHAKE_VERSION_SIZE_BYTES = 4;
    constexpr size_t HANDSHAKE_REQUEST_SIZE_BYTES = sizeof(BOLT_MAGIC_PREAMBLE) + (HANDSHAKE_NUM_PROPOSED_VERSIONS * HANDSHAKE_VERSION_SIZE_BYTES);
    constexpr size_t HANDSHAKE_RESPONSE_SIZE_BYTES = HANDSHAKE_VERSION_SIZE_BYTES;

    /**
     * @brief  Bolt 
     *
     * @param proposed_versions 440
     *                          44
     * @param out_handshake_bytes 20
     * @return BoltError::SUCCESS 
     *         BoltError::INVALID_ARGUMENT  proposed_versions 
     */
    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes);

    /**
     * @brief  Bolt 
     *
     * @param server_response 4
     * @param out_negotiated_version 
     * @return BoltError::SUCCESS 
     *         BoltError::HANDSHAKE_NO_COMMON_VERSION 
     *         BoltError::DESERIALIZATION_ERROR 4
     */
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response, versions::Version& out_negotiated_version);

    /**
     * @brief  Bolt  (/)
     *        : 
     *
     * @param ostream 
     * @param istream 
     * @param proposed_versions 
     * @param out_negotiated_version 
     * @return BoltError::SUCCESS 
     *         BoltError::NETWORK_ERROR 
     *         BoltError::INVALID_ARGUMENT  proposed_versions 
     *         BoltError::HANDSHAKE_NO_COMMON_VERSION 
     *         
     */
    BoltError perform_handshake(std::ostream& ostream, std::istream& istream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version);

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_HANDSHAKE_H#ifndef BOLTPROTOCOL_MESSAGE_DEFS_H
#define BOLTPROTOCOL_MESSAGE_DEFS_H

#include <array>
#include <cstdint>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <variant>
#include <vector>

namespace boltprotocol {

    // Forward declarations
    struct BoltList;
    struct BoltMap;
    struct PackStreamStructure;

    using Value = std::variant<std::nullptr_t, bool, int64_t, double, std::string, std::shared_ptr<BoltList>, std::shared_ptr<BoltMap>, std::shared_ptr<PackStreamStructure>>;

    struct BoltList {
        std::vector<Value> elements;
        bool operator==(const BoltList& other) const {
            return elements == other.elements;
        }
    };

    struct BoltMap {
        std::map<std::string, Value> pairs;
        bool operator==(const BoltMap& other) const {
            return pairs == other.pairs;
        }
    };

    struct PackStreamStructure {
        uint8_t tag = 0;
        std::vector<Value> fields;
        bool operator==(const PackStreamStructure& other) const {
            return tag == other.tag && fields == other.fields;
        }
    };

    bool operator==(const Value& lhs, const Value& rhs);

    constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;
    extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING;
    constexpr uint16_t MAX_CHUNK_PAYLOAD_SIZE = 65535;
    constexpr uint16_t CHUNK_HEADER_SIZE = 2;

    enum class BoltError {
        SUCCESS = 0,
        UNKNOWN_ERROR,
        INVALID_ARGUMENT,
        SERIALIZATION_ERROR,
        DESERIALIZATION_ERROR,
        INVALID_MESSAGE_FORMAT,
        UNSUPPORTED_PROTOCOL_VERSION,
        NETWORK_ERROR,
        HANDSHAKE_FAILED,
        HANDSHAKE_NO_COMMON_VERSION,
        HANDSHAKE_MAGIC_MISMATCH,
        CHUNK_TOO_LARGE,
        CHUNK_ENCODING_ERROR,
        CHUNK_DECODING_ERROR,
        OUT_OF_MEMORY,
        RECURSION_DEPTH_EXCEEDED,
        MESSAGE_TOO_LARGE
    };

    namespace versions {
        struct Version {
            uint8_t major = 0;
            uint8_t minor = 0;
            Version() = default;
            constexpr Version(uint8_t maj, uint8_t min) : major(maj), minor(min) {
            }
            bool operator<(const Version& other) const;
            bool operator==(const Version& other) const;
            bool operator!=(const Version& other) const;
            std::array<uint8_t, 4> to_handshake_bytes() const;
            static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
        };
        extern const Version V5_4, V5_3, V5_2, V5_1, V5_0, V4_4;
        extern const std::vector<Version>& get_default_proposed_versions();
    }  // namespace versions

    enum class MessageTag : uint8_t {
        HELLO = 0x01,
        RUN = 0x10,
        DISCARD = 0x2F,
        PULL = 0x3F,
        BEGIN = 0x11,
        COMMIT = 0x12,
        ROLLBACK = 0x13,
        RESET = 0x0F,
        GOODBYE = 0x02,
        ROUTE = 0x66,
        TELEMETRY = 0x54,
        SUCCESS = 0x70,
        RECORD = 0x71,
        IGNORED = 0x7E,
        FAILURE = 0x7F,
    };

    // --- Message Parameter Structures ---
    struct HelloMessageParams {
        std::map<std::string, Value> extra_auth_tokens;
    };
    struct RunMessageParams {
        std::string cypher_query;
        std::map<std::string, Value> parameters;
        std::map<std::string, Value> extra_metadata;
    };
    struct DiscardMessageParams {
        std::optional<int64_t> n;
        std::optional<int64_t> qid;
    };
    struct PullMessageParams {
        std::optional<int64_t> n;
        std::optional<int64_t> qid;
    };

    struct BeginMessageParams {
        std::map<std::string, Value> extra;
    };
    struct CommitMessageParams { /* No parameters */
    };
    struct RollbackMessageParams { /* No parameters */
    };

    struct RouteMessageParams {
        std::map<std::string, Value> routing_context;
        std::vector<std::string> bookmarks;
        std::optional<std::string> db_name;
        std::optional<std::string> impersonated_user;
    };

    struct SuccessMessageParams {
        std::map<std::string, Value> metadata;
    };
    struct RecordMessageParams {
        std::vector<Value> fields;
    };
    struct FailureMessageParams {
        std::map<std::string, Value> metadata;
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_DEFS_H#ifndef BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H
#define BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // For message parameter structs, Value, BoltError, MessageTag
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

// Forward declare the Version struct if only passed by const ref and not constructed here.
// However, serialize_route_message takes it, so message_defs.h (which defines it) is fine.
// namespace boltprotocol { namespace versions { struct Version; } }

namespace boltprotocol {

    // --- Client Message Serialization (Client -> Server) ---

    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_goodbye_message(PackStreamWriter& writer);
    BoltError serialize_reset_message(PackStreamWriter& writer);

    // Transaction messages
    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer);  // ADDED DECLARATION
    BoltError serialize_commit_message(PackStreamWriter& writer);                                   // ADDED DECLARATION
    BoltError serialize_rollback_message(PackStreamWriter& writer);                                 // ADDED DECLARATION

    // Routing and Telemetry messages
    // Note: serialize_route_message takes the negotiated Bolt version to adapt its structure.
    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version);  // ADDED DECLARATION
    // TODO: BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer);

    // --- Server Message Deserialization (Server -> Client) ---

    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params);
    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params);
    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params);
    BoltError deserialize_ignored_message(PackStreamReader& reader);

    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count);

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H

#include <cstdint>

namespace boltprotocol {

    // PackStream Marker Bytes
    constexpr uint8_t MARKER_NULL = 0xC0;
    constexpr uint8_t MARKER_FALSE = 0xC2;
    constexpr uint8_t MARKER_TRUE = 0xC3;
    constexpr uint8_t MARKER_FLOAT64 = 0xC1;

    // Integer markers
    // Tiny Int: -16 to 127 directly encoded in the marker byte
    // INT_8:  0xC8 <int8>
    // INT_16: 0xC9 <int16>
    // INT_32: 0xCA <int32>
    // INT_64: 0xCB <int64>
    constexpr uint8_t MARKER_INT_8 = 0xC8;
    constexpr uint8_t MARKER_INT_16 = 0xC9;
    constexpr uint8_t MARKER_INT_32 = 0xCA;
    constexpr uint8_t MARKER_INT_64 = 0xCB;

    // String markers
    // TINY_STRING: 0x80..0x8F (length 0-15)
    // STRING_8:    0xD0 <len_uint8> <utf8_bytes>
    // STRING_16:   0xD1 <len_uint16> <utf8_bytes>
    // STRING_32:   0xD2 <len_uint32> <utf8_bytes>
    constexpr uint8_t MARKER_TINY_STRING_BASE = 0x80;  // Base for 0x80 | len
    constexpr uint8_t MARKER_STRING_8 = 0xD0;
    constexpr uint8_t MARKER_STRING_16 = 0xD1;
    constexpr uint8_t MARKER_STRING_32 = 0xD2;

    // List markers
    // TINY_LIST:   0x90..0x9F (size 0-15)
    // LIST_8:      0xD4 <size_uint8>
    // LIST_16:     0xD5 <size_uint16>
    // LIST_32:     0xD6 <size_uint32>
    constexpr uint8_t MARKER_TINY_LIST_BASE = 0x90;  // Base for 0x90 | size
    constexpr uint8_t MARKER_LIST_8 = 0xD4;
    constexpr uint8_t MARKER_LIST_16 = 0xD5;
    constexpr uint8_t MARKER_LIST_32 = 0xD6;

    // Map markers
    // TINY_MAP:    0xA0..0xAF (size 0-15)
    // MAP_8:       0xD8 <size_uint8>
    // MAP_16:      0xD9 <size_uint16>
    // MAP_32:      0xDA <size_uint32>
    constexpr uint8_t MARKER_TINY_MAP_BASE = 0xA0;  // Base for 0xA0 | size
    constexpr uint8_t MARKER_MAP_8 = 0xD8;
    constexpr uint8_t MARKER_MAP_16 = 0xD9;
    constexpr uint8_t MARKER_MAP_32 = 0xDA;

    // Structure markers
    // TINY_STRUCT: 0xB0..0xBF (size 0-15) <tag_uint8>
    // STRUCT_8:    0xDC <size_uint8> <tag_uint8>
    // STRUCT_16:   0xDD <size_uint16> <tag_uint8>
    constexpr uint8_t MARKER_TINY_STRUCT_BASE = 0xB0;  // Base for 0xB0 | size
    constexpr uint8_t MARKER_STRUCT_8 = 0xDC;
    constexpr uint8_t MARKER_STRUCT_16 = 0xDD;

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamReader {
      public:
        explicit PackStreamReader(const std::vector<uint8_t>& buffer);
        explicit PackStreamReader(std::istream& stream);

        // /
        PackStreamReader(const PackStreamReader&) = delete;
        PackStreamReader& operator=(const PackStreamReader&) = delete;
        PackStreamReader(PackStreamReader&&) = delete;
        PackStreamReader& operator=(PackStreamReader&&) = delete;

        /**
         * @brief Reads a single PackStream Value from the input.
         * @param out_value Output parameter where the read Value will be stored if successful.
         *                  Its content is undefined if an error occurs.
         * @return BoltError::SUCCESS on successful read.
         *         BoltError::DESERIALIZATION_ERROR for format errors, unexpected EOF, etc.
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if reader not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails.
         */
        BoltError read(Value& out_value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

        /**
         * @brief Checks if the end of the underlying buffer or stream has been reached.
         *        Also returns true if an error has occurred, as further reading is not possible.
         * @return True if EOF or error, false otherwise.
         */
        bool eof() const;

      private:
        // IO,  error_state_
        BoltError peek_byte(uint8_t& out_byte);
        BoltError consume_byte(uint8_t& out_byte);
        BoltError consume_bytes(void* dest, size_t size);

        template <typename T>
        BoltError consume_network_int(T& out_val) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "consume_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;  // 

            //  out_val 
            out_val = T{};
            BoltError err;

            if constexpr (sizeof(T) == 1) {
                uint8_t byte_val;
                err = consume_byte(byte_val);
                if (err != BoltError::SUCCESS) return err;
                out_val = static_cast<T>(byte_val);
                return BoltError::SUCCESS;
            } else {
                typename std::conditional<sizeof(T) == 2, uint16_t, typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type>::type raw_be_val = 0;

                err = consume_bytes(&raw_be_val, sizeof(raw_be_val));
                if (err != BoltError::SUCCESS) return err;

                if constexpr (sizeof(T) == 2) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint16_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 4) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint32_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 8) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint64_t>(raw_be_val)));
                } else {
                    static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for consume_network_int.");
                    set_error(BoltError::INVALID_ARGUMENT);  //  static_assert 
                    return BoltError::INVALID_ARGUMENT;
                }
                return BoltError::SUCCESS;
            }
        }

      public:
        void set_error(BoltError error);

      private:
        //  ( BoltError  out_value )
        BoltError read_null_value(Value& out_value);
        BoltError read_boolean_value(bool bool_val_from_marker, Value& out_value);
        BoltError read_float64_value(Value& out_value);
        BoltError read_integer_value(uint8_t marker, Value& out_value);
        BoltError read_string_value(uint8_t marker, Value& out_value);
        BoltError read_string_data_into(std::string& out_string, uint32_t size);
        BoltError read_list_value(uint8_t marker, Value& out_value);
        BoltError read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size);
        BoltError read_map_value(uint8_t marker, Value& out_value);
        BoltError read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size);
        BoltError read_struct_value(uint8_t marker, Value& out_value);
        BoltError read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size);

        const std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::istream* stream_ptr_ = nullptr;
        size_t buffer_pos_ = 0;
        BoltError error_state_ = BoltError::SUCCESS;

        // 
        // ( read_list/map/struct_elements_into )
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamWriter {
      public:
        explicit PackStreamWriter(std::vector<uint8_t>& buffer);
        explicit PackStreamWriter(std::ostream& stream);

        // 
        PackStreamWriter(const PackStreamWriter&) = delete;
        PackStreamWriter& operator=(const PackStreamWriter&) = delete;
        PackStreamWriter(PackStreamWriter&&) = delete;
        PackStreamWriter& operator=(PackStreamWriter&&) = delete;

        /**
         * @brief Writes a single PackStream Value to the output.
         * @param value The Value to serialize and write.
         * @return BoltError::SUCCESS on successful write.
         *         BoltError::SERIALIZATION_ERROR for logical errors (e.g., string too long).
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if writer not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails (e.g. vector resize).
         */
        BoltError write(const Value& value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

      private:
        // IO,  error_state_
        BoltError append_byte(uint8_t byte);
        BoltError append_bytes(const void* data, size_t size);

        template <typename T>
        BoltError append_network_int(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "append_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;

            BoltError err;
            if constexpr (sizeof(T) == 1) {
                err = append_byte(static_cast<uint8_t>(value));
            } else if constexpr (sizeof(T) == 2) {
                uint16_t be_val = detail::host_to_be(static_cast<uint16_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 4) {
                uint32_t be_val = detail::host_to_be(static_cast<uint32_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 8) {
                uint64_t be_val = detail::host_to_be(static_cast<uint64_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else {
                static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for append_network_int.");
                set_error(BoltError::INVALID_ARGUMENT);  //  static_assert 
                return BoltError::INVALID_ARGUMENT;
            }
            return err;  //  append_byte  append_bytes 
        }

      public:
        void set_error(BoltError error);

      private:
        //  ( BoltError)
        BoltError write_null_internal();
        BoltError write_boolean_internal(bool bool_value);
        BoltError write_integer_internal(int64_t int_value);
        BoltError write_float_internal(double float_value);
        BoltError write_string_header_internal(uint32_t size);
        BoltError write_string_data_internal(const std::string& value_str);  //  const ref
        BoltError serialize_string_internal(const std::string& str_value);
        BoltError write_list_header_internal(uint32_t size);
        BoltError serialize_list_internal(const BoltList& list_data);  //  const ref
        BoltError write_map_header_internal(uint32_t size);
        BoltError serialize_map_internal(const BoltMap& map_data);  //  const ref
        BoltError write_struct_header_internal(uint8_t tag, uint32_t size);
        BoltError serialize_structure_internal(const PackStreamStructure& struct_data);  //  const ref

        std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::ostream* stream_ptr_ = nullptr;
        BoltError error_state_ = BoltError::SUCCESS;

        // 
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  //  Reader 
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H#include "boltprotocol/chunking.h"

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy (though not strictly needed if only writing from vector)
#include <exception>  // For std::bad_alloc
#include <iostream>   // For stream operations (std::ostream, std::istream)
#include <vector>     // For std::vector manipulations

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host

namespace boltprotocol {

    // --- ChunkedWriter Implementation ---

    ChunkedWriter::ChunkedWriter(std::ostream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {                        // Initial check of stream state
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if stream is already bad
        }
    }

    void ChunkedWriter::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to write the 2-byte chunk header
    BoltError ChunkedWriter::write_chunk_header(uint16_t chunk_payload_size) {
        if (has_error()) return last_error_;  // Don't proceed if already in error state

        uint16_t size_be = detail::host_to_be(chunk_payload_size);
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.write(reinterpret_cast<const char*>(&size_be), sizeof(size_be));
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return BoltError::NETWORK_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write a data chunk (header + payload)
    BoltError ChunkedWriter::write_chunk(const uint8_t* data, uint16_t size) {
        // This function is internal. `write_message` ensures size <= MAX_CHUNK_PAYLOAD_SIZE.
        // `has_error()` check is done by caller or at the start of `write_message`.

        BoltError err = write_chunk_header(size);
        if (err != BoltError::SUCCESS) {
            // error already set by write_chunk_header
            return err;
        }

        if (size > 0) {             // Only write payload if size is non-zero
            if (data == nullptr) {  // Should not happen if size > 0
                set_error(BoltError::INVALID_ARGUMENT);
                return last_error_;
            }
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return last_error_;
            }
            stream_.write(reinterpret_cast<const char*>(data), size);
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return BoltError::NETWORK_ERROR;
            }
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write the end-of-message marker (a chunk with size 0)
    BoltError ChunkedWriter::write_end_of_message_marker() {
        return write_chunk_header(0);  // This writes a 2-byte header with 0x0000
    }

    // Public method to write a full message, chunked.
    BoltError ChunkedWriter::write_message(const std::vector<uint8_t>& message_data) {
        if (has_error()) return last_error_;  // Check if writer is already in an error state
        last_error_ = BoltError::SUCCESS;     // Reset error for this new operation

        const uint8_t* data_ptr = message_data.data();
        size_t total_message_size = message_data.size();
        size_t remaining_size = total_message_size;

        if (stream_.fail()) {  // Check stream before starting writes for this message
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        // Handle empty message payload: send a single EOM marker if message_data is empty.
        // Bolt messages are typically not empty (even GOODBYE has a PSS structure).
        // If message_data is empty, it means the PSS serialization resulted in zero bytes.
        // This case is unusual. A common interpretation would be to send *no* data chunks,
        // followed by the EOM marker.
        if (total_message_size == 0) {
            BoltError eom_err = write_end_of_message_marker();
            if (eom_err == BoltError::SUCCESS) {
                stream_.flush();  // Attempt to flush
                if (stream_.fail()) {
                    set_error(BoltError::NETWORK_ERROR);
                    return last_error_;
                }
            }
            return eom_err;  // Return error from writing EOM or SUCCESS
        }

        // Write data chunks
        while (remaining_size > 0) {
            uint16_t current_chunk_payload_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(MAX_CHUNK_PAYLOAD_SIZE)));

            BoltError chunk_write_err = write_chunk(data_ptr, current_chunk_payload_size);
            if (chunk_write_err != BoltError::SUCCESS) {
                // Error (and last_error_) already set by write_chunk or write_chunk_header
                return last_error_;
            }

            data_ptr += current_chunk_payload_size;
            remaining_size -= current_chunk_payload_size;
        }

        // After all data chunks are written, write the end-of-message marker
        BoltError eom_err = write_end_of_message_marker();
        if (eom_err != BoltError::SUCCESS) {
            return last_error_;  // Error already set
        }

        // Attempt to flush the stream to ensure all data is sent
        stream_.flush();
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        return BoltError::SUCCESS;
    }

    // --- ChunkedReader Implementation ---

    ChunkedReader::ChunkedReader(std::istream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void ChunkedReader::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to read the 2-byte chunk header
    BoltError ChunkedReader::read_chunk_header(uint16_t& out_chunk_payload_size) {
        out_chunk_payload_size = 0;  // Initialize output
        if (has_error()) return last_error_;

        uint16_t size_be;  // To store big-endian size from stream

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(&size_be), sizeof(size_be));

        if (stream_.fail()) {                     // Check failbit (which is set on EOF by read if not enough bytes)
            set_error(BoltError::NETWORK_ERROR);  // Could be EOF if connection closed cleanly mid-message
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != sizeof(size_be)) {
            // This case should ideally be caught by stream.fail() if not enough bytes were read.
            // But as a safeguard:
            set_error(BoltError::NETWORK_ERROR);  // Incomplete read for header
            return last_error_;
        }

        out_chunk_payload_size = detail::be_to_host(size_be);

        // As per spec, MAX_CHUNK_PAYLOAD_SIZE is 65535 (0xFFFF).
        // The chunk_payload_size read from header can be this max value.
        // There's no separate check for > MAX_CHUNK_PAYLOAD_SIZE here, as uint16_t naturally holds up to this.
        // A CHUNK_TOO_LARGE error would be if a spec defined a lower practical limit, but Bolt uses full uint16_t range.

        return BoltError::SUCCESS;
    }

    // Private helper to read the payload of a chunk
    BoltError ChunkedReader::read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to) {
        if (has_error()) return last_error_;
        if (payload_size == 0) return BoltError::SUCCESS;  // Nothing to read

        size_t current_buffer_capacity = buffer_to_append_to.capacity();
        size_t current_buffer_size = buffer_to_append_to.size();
        size_t required_capacity = current_buffer_size + payload_size;

        // Grow buffer if needed. This is where std::bad_alloc can occur.
        if (required_capacity > current_buffer_capacity) {
            try {
                // Reserve to avoid multiple small reallocations if reading many small chunks.
                // A growth factor could be used (e.g., 1.5x or 2x) for efficiency.
                // For simplicity here, just reserve what's immediately needed for this chunk.
                buffer_to_append_to.reserve(required_capacity);
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return last_error_;
            } catch (const std::length_error&) {          // If required_capacity is too large for vector
                set_error(BoltError::MESSAGE_TOO_LARGE);  // Or OUT_OF_MEMORY if more appropriate
                return last_error_;
            } catch (const std::exception&) {
                set_error(BoltError::UNKNOWN_ERROR);
                return last_error_;
            }
        }

        // Resize to exact size needed for appending, then read directly into new space.
        // This is less efficient than reading into a temporary buffer and then appending,
        // but simpler for now. A more optimized version might use a fixed-size read buffer.
        // We need to append, so we must first store current_buffer_size, then resize, then read.
        try {
            buffer_to_append_to.resize(required_capacity);  // Resize to make space
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return last_error_;
        } catch (const std::length_error&) {
            set_error(BoltError::MESSAGE_TOO_LARGE);
            return last_error_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return last_error_;
        }

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(buffer_to_append_to.data() + current_buffer_size), payload_size);

        if (stream_.fail()) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize on partial read/failure
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != payload_size) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize
            set_error(BoltError::NETWORK_ERROR);              // Incomplete read for payload
            return last_error_;
        }
        return BoltError::SUCCESS;
    }

    // Public method to read a full message, de-chunked.
    BoltError ChunkedReader::read_message(std::vector<uint8_t>& out_message_data) {
        if (has_error()) return last_error_;
        last_error_ = BoltError::SUCCESS;  // Reset error for this new operation

        out_message_data.clear();  // Ensure output vector starts empty for this message
        // Optionally, reserve a typical message size if known, e.g., out_message_data.reserve(4096);
        // This needs a try-catch for bad_alloc if done.

        uint16_t current_chunk_payload_size;
        BoltError err;

        while (true) {  // Loop to read chunks until EOM
            err = read_chunk_header(current_chunk_payload_size);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_header
                return last_error_;
            }

            if (current_chunk_payload_size == 0) {  // End-of-message marker (0x0000 chunk size)
                break;                              // Successfully read all chunks for this message
            }

            // Optional: Check against a max total message size to prevent OOM from malicious server
            // Example: constexpr size_t MAX_ALLOWED_TOTAL_MESSAGE_SIZE = 16 * 1024 * 1024; // 16MB
            // if (out_message_data.size() + current_chunk_payload_size > MAX_ALLOWED_TOTAL_MESSAGE_SIZE) {
            //    set_error(BoltError::MESSAGE_TOO_LARGE);
            //    out_message_data.clear();
            //    return last_error_;
            // }

            err = read_chunk_payload(current_chunk_payload_size, out_message_data);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_payload
                return last_error_;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/handshake.h"

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
#include <iostream>   // For stream operations (std::ostream, std::istream)

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be for BOLT_MAGIC_PREAMBLE

namespace boltprotocol {

    // build_handshake_request: Constructs the 20-byte handshake request.
    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes) {
        if (proposed_versions.empty()) {
            return BoltError::INVALID_ARGUMENT;
        }

        // 1. Magic Preamble (4 bytes, Big Endian)
        uint32_t preamble_be = detail::host_to_be(BOLT_MAGIC_PREAMBLE);
        std::memcpy(out_handshake_bytes.data(), &preamble_be, sizeof(preamble_be));
        size_t current_offset = sizeof(preamble_be);

        // 2. Proposed Versions (4 versions, each 4 bytes, Big Endian)
        size_t num_versions_to_write = std::min(proposed_versions.size(), HANDSHAKE_NUM_PROPOSED_VERSIONS);

        for (size_t i = 0; i < num_versions_to_write; ++i) {
            // Construct the 32-bit integer representing the version for handshake.
            // Bolt version X.Y is represented as 00 00 0X 0Y in Big Endian.
            uint32_t version_for_handshake = 0;  // Initialize
            version_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));

            uint32_t version_be = detail::host_to_be(version_for_handshake);  // Convert to Big Endian
            std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
        }

        // Fill remaining version slots with "No Version" (all zeros)
        if (num_versions_to_write < HANDSHAKE_NUM_PROPOSED_VERSIONS) {
            uint32_t no_version_int_be = detail::host_to_be(static_cast<uint32_t>(0));
            for (size_t i = num_versions_to_write; i < HANDSHAKE_NUM_PROPOSED_VERSIONS; ++i) {
                std::memcpy(out_handshake_bytes.data() + current_offset, &no_version_int_be, HANDSHAKE_VERSION_SIZE_BYTES);
                current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
            }
        }
        return BoltError::SUCCESS;
    }

    // parse_handshake_response: Parses the 4-byte server response.
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response_bytes, versions::Version& out_negotiated_version) {
        BoltError err = versions::Version::from_handshake_bytes(server_response_bytes, out_negotiated_version);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (out_negotiated_version.major == 0 && out_negotiated_version.minor == 0) {
            // This typically means the server sent 0x00000000, indicating no common version.
            // The from_handshake_bytes might return SUCCESS for 0.0, so we explicitly check here.
            return BoltError::HANDSHAKE_NO_COMMON_VERSION;
        }
        return BoltError::SUCCESS;
    }

    // perform_handshake: Executes the full handshake over provided streams.
    BoltError perform_handshake(std::ostream& ostream, std::istream& istream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version) {
        std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes;
        BoltError build_err = build_handshake_request(proposed_versions, handshake_request_bytes);
        if (build_err != BoltError::SUCCESS) {
            return build_err;
        }

        if (ostream.fail()) return BoltError::NETWORK_ERROR;
        ostream.write(reinterpret_cast<const char*>(handshake_request_bytes.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
        if (ostream.fail()) {
            return BoltError::NETWORK_ERROR;
        }
        ostream.flush();
        if (ostream.fail()) {
            return BoltError::NETWORK_ERROR;
        }

        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes;
        if (istream.fail()) return BoltError::NETWORK_ERROR;
        istream.read(reinterpret_cast<char*>(server_response_bytes.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);

        if (istream.fail()) {
            return BoltError::NETWORK_ERROR;
        }
        if (static_cast<size_t>(istream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
            return BoltError::NETWORK_ERROR;
        }

        return parse_handshake_response(server_response_bytes, out_negotiated_version);
    }

}  // namespace boltprotocol#include "boltprotocol/message_defs.h"

#include <algorithm>    // For std::visit in Value::operator==
#include <cstring>      // For std::memcpy
#include <functional>   // For std::visit (though variant includes it)
#include <type_traits>  // For std::decay_t

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host

// Note: <arpa/inet.h> or <winsock2.h> for htonl/ntohl are now encapsulated in byte_order_utils.h
// and used by detail::host_to_be and detail::be_to_host.

namespace boltprotocol {

    // --- Value Equality Implementation ---
    bool operator==(const Value& lhs, const Value& rhs) {
        if (lhs.index() != rhs.index()) {
            return false;
        }
        // std::visit is a good way to compare variants.
        // It calls the lambda with the alternatives held by lhs.
        return std::visit(
            [&rhs](const auto& lhs_alternative_value) -> bool {
                // Get the same type from rhs. This is safe because index() matched.
                using AlternativeType = std::decay_t<decltype(lhs_alternative_value)>;
                const AlternativeType& rhs_alternative_value = std::get<AlternativeType>(rhs);

                // Handle shared_ptr cases specifically: compare pointed-to values if both non-null.
                if constexpr (std::is_same_v<AlternativeType, std::shared_ptr<BoltList>> || std::is_same_v<AlternativeType, std::shared_ptr<BoltMap>> || std::is_same_v<AlternativeType, std::shared_ptr<PackStreamStructure>>) {
                    // Both null: equal. One null, other not: not equal.
                    if (static_cast<bool>(lhs_alternative_value) != static_cast<bool>(rhs_alternative_value)) {
                        return false;
                    }
                    if (!lhs_alternative_value) {  // Both are null
                        return true;
                    }
                    // Both are non-null, compare the pointed-to objects.
                    return *lhs_alternative_value == *rhs_alternative_value;
                } else {
                    // For non-shared_ptr types (nullptr_t, bool, int64_t, double, string)
                    return lhs_alternative_value == rhs_alternative_value;
                }
            },
            lhs);
    }

    // --- Global Definitions ---
    const std::string DEFAULT_USER_AGENT_FORMAT_STRING = "BoltCppDriver/0.2.0 (C++26; NoExcept)";  // Example version

    // --- versions::Version Implementation ---
    namespace versions {

        bool Version::operator<(const Version& other) const {
            if (major != other.major) {
                return major < other.major;
            }
            return minor < other.minor;
        }

        bool Version::operator==(const Version& other) const {
            return major == other.major && minor == other.minor;
        }

        bool Version::operator!=(const Version& other) const {
            return !(*this == other);
        }

        // Returns the 4-byte big-endian representation for handshake
        // E.g., Bolt 5.4 is represented as 00 00 05 04 in Big Endian
        std::array<uint8_t, 4> Version::to_handshake_bytes() const {
            std::array<uint8_t, 4> bytes{};  // Value-initialize to all zeros
            // Bolt versions X.Y are represented as 00 00 0X 0Y (Big Endian)
            // This means byte[0]=0, byte[1]=0, byte[2]=X, byte[3]=Y.
            // This is already in "network byte order" if we construct it this way.
            if (major == 0 && minor == 0) {
                // All zeros is fine, represents "No Version" or an uninitialized version.
            } else {
                bytes[2] = major;
                bytes[3] = minor;
            }
            return bytes;
        }

        // Creates a version from the 4-byte big-endian handshake representation.
        BoltError Version::from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version) {
            // Bytes are expected in Big Endian: byte[0], byte[1], byte[2] (Major), byte[3] (Minor)
            // Example: 0x00, 0x00, 0x05, 0x04 for Bolt 5.4

            // A server might respond with a single number for very old versions,
            // e.g., 0x00000001 for Bolt 1.0.
            // The Bolt specification typically shows X.Y as 00 00 0X 0Y.

            if (bytes[0] == 0 && bytes[1] == 0) {
                if (bytes[2] == 0 && bytes[3] == 0) {  // All zeros: 0.0 ("No Version" agreed upon)
                    out_version.major = 0;
                    out_version.minor = 0;
                    return BoltError::SUCCESS;  // Or HANDSHAKE_NO_COMMON_VERSION if this is server response
                }
                // Handle 00 00 0X 0Y format
                out_version.major = bytes[2];
                out_version.minor = bytes[3];
                // Basic validation: major version should not be 0 if minor is non-zero,
                // unless it's a special single-number version.
                if (out_version.major == 0 && out_version.minor != 0) {
                    // Check for older single-number versions if needed, e.g. 0x00000001 -> 1.0
                    if (out_version.minor == 1) {  // 0x00000001
                        out_version.major = 1;
                        out_version.minor = 0;
                        return BoltError::SUCCESS;
                    }
                    // Add other historic versions if necessary
                    // For now, consider other 0.Y as invalid for handshake response.
                    return BoltError::UNSUPPORTED_PROTOCOL_VERSION;  // Or INVALID_MESSAGE_FORMAT
                }
                return BoltError::SUCCESS;
            } else {
                // If bytes[0] or bytes[1] are non-zero, it's not the standard X.Y format
                // or the all-zero "No Version". This is unexpected for modern Bolt.
                return BoltError::UNSUPPORTED_PROTOCOL_VERSION;  // Or INVALID_MESSAGE_FORMAT
            }
        }

        // --- Predefined Version Constants ---
        const Version V5_4(5, 4);
        const Version V5_3(5, 3);
        const Version V5_2(5, 2);
        const Version V5_1(5, 1);
        const Version V5_0(5, 0);
        const Version V4_4(4, 4);
        // Add V4_3, V4_2 etc. if they need to be common constants
        // const Version V4_3(4,3);
        // const Version V4_2(4,2);

        // Provides a default-ordered list of versions a client might propose.
        // Static to ensure it's initialized once.
        static const std::vector<Version> DEFAULT_PROPOSED_VERSIONS_LIST = {
            V5_4, V5_3, V5_2, V5_1, V5_0, V4_4  // Order from newest to oldest preferred
        };

        const std::vector<Version>& get_default_proposed_versions() {
            return DEFAULT_PROPOSED_VERSIONS_LIST;
        }

    }  // namespace versions

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure pss_hello_obj;
        pss_hello_obj.tag = static_cast<uint8_t>(MessageTag::HELLO);
        std::shared_ptr<BoltMap> map_for_field_sptr;
        try {
            map_for_field_sptr = std::make_shared<BoltMap>();
            // Directly assign if extra_auth_tokens is already map<string, Value>
            // Otherwise, iterate and emplace if types differ or deep copy needed.
            map_for_field_sptr->pairs = params.extra_auth_tokens;
            Value map_value_as_field(map_for_field_sptr);
            pss_hello_obj.fields.emplace_back(std::move(map_value_as_field));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Catch other potential exceptions from map copy/emplace
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_hello_message (map prep): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_hello_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_hello_message (pss make_shared): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {  // Should be redundant if make_shared throws or bad_alloc caught
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure run_struct_obj;  // On stack
        run_struct_obj.tag = static_cast<uint8_t>(MessageTag::RUN);

        std::shared_ptr<BoltMap> parameters_map_sptr;
        std::shared_ptr<BoltMap> extra_metadata_map_sptr;

        try {
            // Field 1: Cypher query (string)
            run_struct_obj.fields.emplace_back(Value(params.cypher_query));  // string to Value can throw (bad_alloc)

            // Field 2: Parameters map
            parameters_map_sptr = std::make_shared<BoltMap>();
            parameters_map_sptr->pairs = params.parameters;                  // map copy
            run_struct_obj.fields.emplace_back(Value(parameters_map_sptr));  // Value copies shared_ptr

            // Field 3: Extra metadata map
            extra_metadata_map_sptr = std::make_shared<BoltMap>();
            extra_metadata_map_sptr->pairs = params.extra_metadata;              // map copy
            run_struct_obj.fields.emplace_back(Value(extra_metadata_map_sptr));  // Value copies shared_ptr

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_run_message (fields prep): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(run_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_run_message (pss make_shared): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure pull_struct_obj;
        pull_struct_obj.tag = static_cast<uint8_t>(MessageTag::PULL);
        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                // Value constructor for int64_t is trivial, emplace can throw bad_alloc for map node
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            // PULL message structure is: PULL {"n": N, "qid": QID}
            // The map itself is the single field.
            pull_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_pull_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pull_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_pull_message (pss make_shared): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure discard_struct_obj;
        discard_struct_obj.tag = static_cast<uint8_t>(MessageTag::DISCARD);
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            discard_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_discard_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(discard_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_discard_message (pss make_shared): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_goodbye_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::GOODBYE);
            // No fields for GOODBYE
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_goodbye_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_reset_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::RESET);
            // No fields for RESET
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_reset_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure begin_struct_obj;  // On stack
        begin_struct_obj.tag = static_cast<uint8_t>(MessageTag::BEGIN);
        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            extra_map_sptr->pairs = params.extra;  // map copy
            begin_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_begin_message (map prep): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(begin_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception (make_shared PSS) in serialize_begin_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_commit_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::COMMIT);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_commit_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_rollback_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::ROLLBACK);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_rollback_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure route_struct_obj;  // On stack
        route_struct_obj.tag = static_cast<uint8_t>(MessageTag::ROUTE);

        std::shared_ptr<BoltMap> context_map_sptr;
        std::shared_ptr<BoltList> bookmarks_list_sptr;

        try {
            // Field 1: Routing Context (Map)
            context_map_sptr = std::make_shared<BoltMap>();
            context_map_sptr->pairs = params.routing_context;  // map copy
            route_struct_obj.fields.emplace_back(Value(context_map_sptr));

            // Field 2: Bookmarks (List of Strings)
            bookmarks_list_sptr = std::make_shared<BoltList>();
            for (const auto& bookmark_str : params.bookmarks) {
                // Value constructor for string can throw bad_alloc, vector emplace_back can throw bad_alloc
                bookmarks_list_sptr->elements.emplace_back(Value(bookmark_str));
            }
            route_struct_obj.fields.emplace_back(Value(bookmarks_list_sptr));

            // Determine which optional fields to include based on Bolt version
            bool db_field_required_by_version = (negotiated_bolt_version.major > 4 || (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor >= 3));
            bool imp_user_field_required_by_version = (negotiated_bolt_version.major >= 5);

            if (db_field_required_by_version) {
                if (params.db_name.has_value()) {
                    route_struct_obj.fields.emplace_back(Value(params.db_name.value()));
                } else {
                    route_struct_obj.fields.emplace_back(nullptr);  // Explicit PackStream NULL
                }
            } else if (params.db_name.has_value()) {
                // Client trying to send db_name when version doesn't support it in ROUTE.
                writer.set_error(BoltError::SERIALIZATION_ERROR);
                // std::cerr << "Error: db_name provided for ROUTE with Bolt version " << ... << " which does not support it." << std::endl; // Optional log
                return BoltError::SERIALIZATION_ERROR;
            }

            if (imp_user_field_required_by_version) {
                // If db field was not required by version but imp_user is, the spec implies db field slot is still there (as null).
                // Our current logic correctly handles this: if db_field_required_by_version is false, nothing is added for db.
                // If then imp_user_field_required_by_version is true, it's added as the next field.
                // This means the number of fields for ROUTE varies (2, 3, or 4).
                // V4.0-4.2: (map, list) - 2 fields
                // V4.3-4.4: (map, list, db_or_null) - 3 fields
                // V5.0+:    (map, list, db_or_null, imp_user_or_null) - 4 fields
                // The logic needs to ensure that if imp_user is present for V5.0+, the db field (even if null) is also serialized
                // if the version is >= 4.3.
                // The current structure of adding fields sequentially based on flags is correct.

                if (params.impersonated_user.has_value()) {
                    route_struct_obj.fields.emplace_back(Value(params.impersonated_user.value()));
                } else {
                    route_struct_obj.fields.emplace_back(nullptr);  // Explicit PackStream NULL
                }
            } else if (params.impersonated_user.has_value()) {
                writer.set_error(BoltError::SERIALIZATION_ERROR);
                // std::cerr << "Error: impersonated_user provided for ROUTE with Bolt version " << ... << " which does not support it." << std::endl; // Optional log
                return BoltError::SERIALIZATION_ERROR;
            }

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception in serialize_route_message (fields prep): " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(route_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // std::cerr << "Std exception (make_shared PSS) in serialize_route_message: " << e_std.what() << std::endl;
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc (though less likely here, more in reader)
#include <map>
#include <memory>   // For std::shared_ptr
#include <variant>  // For std::holds_alternative, std::get
#include <vector>   // For PackStreamStructure::fields

#include "boltprotocol/message_defs.h"           // For message structs, Value, MessageTag, BoltError
#include "boltprotocol/message_serialization.h"  // Defines interfaces
#include "boltprotocol/packstream_reader.h"      // For PackStreamReader

namespace boltprotocol {

    // Helper to deserialize a structure from a reader and validate its basic properties
    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents) {
        if (reader.has_error()) return reader.get_error();

        Value raw_value;
        BoltError err = reader.read(raw_value);  // This now returns BoltError
        if (err != BoltError::SUCCESS) {
            // reader.read() should have set its internal error state.
            // We could propagate reader.get_error() or err. They should be the same.
            return err;
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(raw_value)) {
            // Value's get<>() for shared_ptr doesn't throw bad_variant_access if holds_alternative is true.
            // Move from variant. This itself shouldn't throw bad_alloc unless Value's move ctor does something very unusual.
            try {
                struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(raw_value));
            } catch (const std::bad_variant_access&) {                // Should not happen due to holds_alternative
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Defensive
                return BoltError::INVALID_MESSAGE_FORMAT;
            } catch (const std::exception&) {  // Other potential issues with std::get or Value move
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (!struct_sptr) {  // Null shared_ptr in Value
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Move the contents from the object pointed to by shared_ptr into out_structure_contents.
        // PackStreamStructure move assignment. This should generally not throw if members are well-behaved (vector/map move).
        try {
            out_structure_contents = std::move(*struct_sptr);
        } catch (const std::bad_alloc&) {  // If vector/map move assignment allocates and fails
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (static_cast<MessageTag>(out_structure_contents.tag) != expected_tag) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Tag mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (out_structure_contents.fields.size() < expected_fields_min || out_structure_contents.fields.size() > expected_fields_max) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Field count mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        return BoltError::SUCCESS;
    }

    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();  // Clear before use

        PackStreamStructure success_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::SUCCESS, 1, 1, success_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;  // Propagate error (reader.error_state_ is already set)
        }

        if (success_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(success_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(success_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {  // Null shared_ptr
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);  // map move assignment
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure failure_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::FAILURE, 1, 1, failure_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (failure_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(failure_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(failure_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.fields.clear();

        PackStreamStructure record_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RECORD, 1, 1, record_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (record_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltList>>(record_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltList> fields_list_sptr;
        try {
            fields_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(record_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!fields_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.fields = std::move(fields_list_sptr->elements);  // vector move assignment
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (!ignored_struct_contents.fields.empty()) {
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            // Metadata for IGNORED is optional and usually not used by client, so we don't try to get or move it.
            // If std::get was used, it would also need a try-catch.
        }
        return BoltError::SUCCESS;
    }

    BoltError peek_message_structure_header(PackStreamReader& /*reader*/, uint8_t& /*out_tag*/, uint32_t& /*out_fields_count*/) {
        // This function is problematic with the current reader design.
        // To peek a tag without fully consuming the message structure, the reader would need
        // more complex buffering or lookahead capabilities, or the ability to "unread" bytes.
        // Given the current sequential PackStreamReader, a true non-consuming peek is hard.
        // One could read the Value, get the tag, and then somehow "store" the Value for later full deserialization,
        // but that adds complexity.
        // For now, it's better that the dispatcher reads the full Value and then checks its tag.
        return BoltError::UNKNOWN_ERROR;  // Placeholder, likely not to be implemented this way.
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_reader.h"

#include <cstring>    // For memcpy
#include <exception>  // For std::bad_alloc, std::exception
#include <iostream>   // For std::istream operations
#include <new>        // For std::nothrow (if we were to use it with raw new)

namespace boltprotocol {

    // --- PackStreamReader Constructor and Basic IO ---

    PackStreamReader::PackStreamReader(const std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
    }

    PackStreamReader::PackStreamReader(std::istream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {  // 
            set_error(BoltError::INVALID_ARGUMENT);
        }
    }

    void PackStreamReader::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    bool PackStreamReader::eof() const {
        if (has_error()) return true;  // 
        if (buffer_ptr_) {
            return buffer_pos_ >= buffer_ptr_->size();
        }
        if (stream_ptr_) {
            // stream.eof() true
            // stream.peek() == EOF 
            return stream_ptr_->peek() == EOF;
        }
        return true;  // 
    }

    BoltError PackStreamReader::peek_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize out_byte

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check stream state before peeking
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte = stream_ptr_->peek();
            if (byte == EOF) {
                if (stream_ptr_->bad()) {  // badbit means serious I/O error
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // eofbit or (eofbit and failbit if formatting error also occurred)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_++];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte = stream_ptr_->get();
            if (byte == EOF) {
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_bytes(void* dest, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;
        if (dest == nullptr && size > 0) {  // Should not happen with internal calls
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            if (buffer_pos_ + size <= buffer_ptr_->size()) {
                std::memcpy(dest, buffer_ptr_->data() + buffer_pos_, size);
                buffer_pos_ += size;
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // Buffer read out of bounds
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->read(static_cast<char*>(dest), static_cast<std::streamsize>(size));
            if (stream_ptr_->gcount() != static_cast<std::streamsize>(size)) {
                // failbit will be set if gcount() < size and not EOF, or badbit is set.
                // eofbit will be set if EOF was reached.
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // Could be failbit (less data than requested but not EOF) or eofbit
                    set_error(BoltError::DESERIALIZATION_ERROR);  // Not enough data or other stream error
                }
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    // --- PackStreamReader Main Read Logic ---

    BoltError PackStreamReader::read(Value& out_value) {
        // Reset output value to a known state (nullptr for variant is good)
        out_value = nullptr;
        if (has_error()) return error_state_;
        if (eof()) {                                      // Check before attempting to consume
            set_error(BoltError::DESERIALIZATION_ERROR);  // Attempt to read past EOF
            return error_state_;
        }

        uint8_t marker;
        BoltError err = consume_byte(marker);
        if (err != BoltError::SUCCESS) return err;  // error_state_ already set

        // Handle recursion depth for composite types
        // Note: Simple types don't increment depth here; composite type readers do.

        if (marker >= 0xF0) {  // Tiny Negative Int (-16 to -1)
            out_value = static_cast<int64_t>(static_cast<int8_t>(marker));
            return BoltError::SUCCESS;
        }
        if (marker <= 0x7F) {  // Tiny Positive Int (0 to 127)
            out_value = static_cast<int64_t>(marker);
            return BoltError::SUCCESS;
        }

        switch (marker) {
            case MARKER_NULL:
                return read_null_value(out_value);
            case MARKER_FALSE:
                return read_boolean_value(false, out_value);
            case MARKER_TRUE:
                return read_boolean_value(true, out_value);
            case MARKER_FLOAT64:
                return read_float64_value(out_value);

            case MARKER_INT_8:
            case MARKER_INT_16:
            case MARKER_INT_32:
            case MARKER_INT_64:
                return read_integer_value(marker, out_value);

            case MARKER_TINY_STRING_BASE ...(MARKER_TINY_STRING_BASE + 0x0F):
            case MARKER_STRING_8:
            case MARKER_STRING_16:
            case MARKER_STRING_32:
                return read_string_value(marker, out_value);

            case MARKER_TINY_LIST_BASE ...(MARKER_TINY_LIST_BASE + 0x0F):
            case MARKER_LIST_8:
            case MARKER_LIST_16:
            case MARKER_LIST_32:
                return read_list_value(marker, out_value);

            case MARKER_TINY_MAP_BASE ...(MARKER_TINY_MAP_BASE + 0x0F):
            case MARKER_MAP_8:
            case MARKER_MAP_16:
            case MARKER_MAP_32:
                return read_map_value(marker, out_value);

            case MARKER_TINY_STRUCT_BASE ...(MARKER_TINY_STRUCT_BASE + 0x0F):
            case MARKER_STRUCT_8:
            case MARKER_STRUCT_16:
                return read_struct_value(marker, out_value);

            default:
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Unknown marker
                return error_state_;
        }
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy
#include <exception>  // For std::bad_alloc
#include <map>        // For std::map in BoltMap
#include <memory>     // For std::make_shared
#include <new>        // For std::nothrow (alternative for make_shared if needed)
#include <string>     // For std::string
#include <vector>     // For std::vector

#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // --- PackStreamReader Type-Specific Reader Implementations (returning BoltError) ---

    BoltError PackStreamReader::read_null_value(Value& out_value) {
        if (has_error()) return error_state_;
        out_value = nullptr;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_boolean_value(bool bool_val_from_marker, Value& out_value) {
        if (has_error()) return error_state_;
        out_value = bool_val_from_marker;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_float64_value(Value& out_value) {
        if (has_error()) return error_state_;
        uint64_t temp_int;
        BoltError err = consume_network_int(temp_int);
        if (err != BoltError::SUCCESS) return err;

        double val;
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&val, &temp_int, sizeof(double));
        out_value = val;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_integer_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        BoltError err;
        switch (marker) {
            case MARKER_INT_8:
                {
                    int8_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    out_value = static_cast<int64_t>(val);
                    return BoltError::SUCCESS;
                }
            case MARKER_INT_16:
                {
                    int16_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    out_value = static_cast<int64_t>(val);
                    return BoltError::SUCCESS;
                }
            case MARKER_INT_32:
                {
                    int32_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    out_value = static_cast<int64_t>(val);
                    return BoltError::SUCCESS;
                }
            case MARKER_INT_64:
                {
                    int64_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    out_value = val;
                    return BoltError::SUCCESS;
                }
            default:
                set_error(BoltError::INVALID_ARGUMENT);  // Should not be reached
                return error_state_;
        }
    }

    BoltError PackStreamReader::read_string_data_into(std::string& out_string, uint32_t size) {
        if (has_error()) return error_state_;
        out_string.clear();  // Clear before use

        if (size == 0) {
            return BoltError::SUCCESS;
        }
        try {
            out_string.resize(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {  // String too long
            set_error(BoltError::DESERIALIZATION_ERROR);
            return error_state_;
        } catch (const std::exception&) {  // Catch any other std exceptions from resize
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        // Note: A truly no-exception build might make catch(...) more relevant if `new` returns nullptr.

        return consume_bytes(out_string.data(), size);  // consume_bytes sets error_state_ on failure
    }

    BoltError PackStreamReader::read_string_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRING_BASE) {
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_STRING_8:
                    {
                        uint8_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_STRING_16:
                    {
                        uint16_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_STRING_32:
                    {
                        uint32_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::string s_val;
        err = read_string_data_into(s_val, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(s_val);  // std::string move ctor can technically throw (rarely, if allocator does)
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!list_sptr) {  // Should be pre-allocated by caller
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = BoltError::SUCCESS;
        try {
            list_sptr->elements.reserve(size);  // Potential std::bad_alloc
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large for vector
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value element;
            err = this->read(element);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call to read()
                return error_state_;
            }
            try {
                list_sptr->elements.push_back(std::move(element));  // Value move ctor/vector push_back
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_list_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_LIST_BASE) {
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_LIST_8:
                    {
                        uint8_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_LIST_16:
                    {
                        uint16_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_LIST_32:
                    {
                        uint32_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltList> list_sptr;
        try {
            list_sptr = std::make_shared<BoltList>();  // Potential std::bad_alloc
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);  // Other errors from make_shared construction
            return error_state_;
        }
        if (!list_sptr) {  // Should not happen with make_shared unless exceptions truly disabled and new returns nullptr
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        err = read_list_elements_into(list_sptr, size);
        if (err != BoltError::SUCCESS) return err;  // Error already set

        out_value = std::move(list_sptr);
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!map_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        for (uint32_t i = 0; i < size; ++i) {
            Value key_val;
            err = this->read(key_val);  // Read map key
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            std::string key_str;
            if (std::holds_alternative<std::string>(key_val)) {
                try {
                    // Move if possible, copy if necessary (Value holds string directly)
                    key_str = std::get<std::string>(std::move(key_val));
                } catch (const std::bad_alloc&) {
                    current_recursion_depth_--;
                    set_error(BoltError::OUT_OF_MEMORY);
                    return error_state_;
                } catch (const std::exception&) {
                    current_recursion_depth_--;
                    set_error(BoltError::UNKNOWN_ERROR);
                    return error_state_;
                }
            } else {
                current_recursion_depth_--;
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map key not a string
                return error_state_;
            }

            Value map_value;
            err = this->read(map_value);  // Read map value
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            try {
                // map::emplace can throw (e.g. bad_alloc for node, or if Value copy/move throws)
                map_sptr->pairs.emplace(std::move(key_str), std::move(map_value));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other exceptions from emplace or Value's move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_map_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_MAP_BASE) {
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_MAP_8:
                    {
                        uint8_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_MAP_16:
                    {
                        uint16_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                case MARKER_MAP_32:
                    {
                        uint32_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltMap> map_sptr;
        try {
            map_sptr = std::make_shared<BoltMap>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        if (!map_sptr) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        err = read_map_pairs_into(map_sptr, size);
        if (err != BoltError::SUCCESS) return err;

        out_value = std::move(map_sptr);
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        if (!struct_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        struct_sptr->tag = tag;

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        try {
            struct_sptr->fields.reserve(size);
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value field_val;
            err = this->read(field_val);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }
            try {
                struct_sptr->fields.push_back(std::move(field_val));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_struct_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        uint8_t tag = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRUCT_BASE) {
            size = marker & 0x0F;
            err = consume_byte(tag);
            if (err != BoltError::SUCCESS) return err;
        } else {
            switch (marker) {
                case MARKER_STRUCT_8:
                    {
                        uint8_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                    }
                    err = consume_byte(tag);
                    if (err != BoltError::SUCCESS) return err;
                    break;
                case MARKER_STRUCT_16:
                    {
                        uint16_t s;
                        err = consume_network_int(s);
                        if (err != BoltError::SUCCESS) return err;
                        size = s;
                    }
                    err = consume_byte(tag);
                    if (err != BoltError::SUCCESS) return err;
                    break;
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        try {
            struct_sptr = std::make_shared<PackStreamStructure>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        if (!struct_sptr) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        err = read_struct_fields_into(struct_sptr, tag, size);
        if (err != BoltError::SUCCESS) return err;

        out_value = std::move(struct_sptr);
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_writer.h"

#include <cstring>    // For memcpy
#include <exception>  // For std::bad_alloc, std::exception
#include <iostream>   // For std::ostream
#include <variant>    // For std::visit

namespace boltprotocol {

    // --- PackStreamWriter Constructor and Low-Level IO ---

    PackStreamWriter::PackStreamWriter(std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
    }

    PackStreamWriter::PackStreamWriter(std::ostream& stream) : stream_ptr_(&stream), buffer_ptr_(nullptr), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {
            set_error(BoltError::INVALID_ARGUMENT);
        }
    }

    void PackStreamWriter::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    BoltError PackStreamWriter::append_byte(uint8_t byte) {
        if (has_error()) return error_state_;

        if (buffer_ptr_) {
            try {
                buffer_ptr_->push_back(byte);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other possible exceptions from vector
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->put(static_cast<char>(byte));
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::append_bytes(const void* data, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;
        if (data == nullptr && size > 0) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            const auto* byte_data = static_cast<const uint8_t*>(data);
            try {
                buffer_ptr_->insert(buffer_ptr_->end(), byte_data, byte_data + size);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->write(static_cast<const char*>(data), static_cast<std::streamsize>(size));
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // --- PackStreamWriter Main Dispatch Logic ---

    BoltError PackStreamWriter::write(const Value& value) {
        if (has_error()) return error_state_;  // Already in error

        // Visitor lambda
        auto visitor = [&](const auto& arg) -> BoltError {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, std::nullptr_t>) {
                return write_null_internal();
            } else if constexpr (std::is_same_v<T, bool>) {
                return write_boolean_internal(arg);
            } else if constexpr (std::is_same_v<T, int64_t>) {
                return write_integer_internal(arg);
            } else if constexpr (std::is_same_v<T, double>) {
                return write_float_internal(arg);
            } else if constexpr (std::is_same_v<T, std::string>) {
                return serialize_string_internal(arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltList>>) {
                if (!arg) {  // Handle null shared_ptr as PackStream NULL
                    return write_null_internal();
                }
                return serialize_list_internal(*arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltMap>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_map_internal(*arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<PackStreamStructure>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_structure_internal(*arg);
            } else {
                // Should not be reached if Value variant is exhaustive for PackStream types
                set_error(BoltError::SERIALIZATION_ERROR);
                return error_state_;
            }
        };

        return std::visit(visitor, value);
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float)
#include <exception>  // For std::bad_alloc, std::exception (though not directly caught here, called functions might)
#include <limits>     // For std::numeric_limits

#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    // --- PackStreamWriter Type-Specific Internal Implementations ---

    BoltError PackStreamWriter::write_null_internal() {
        if (has_error()) return error_state_;
        return append_byte(MARKER_NULL);
    }

    BoltError PackStreamWriter::write_boolean_internal(bool bool_value) {
        if (has_error()) return error_state_;
        return append_byte(bool_value ? MARKER_TRUE : MARKER_FALSE);
    }

    BoltError PackStreamWriter::write_integer_internal(int64_t int_value) {
        if (has_error()) return error_state_;
        BoltError err;
        if (int_value >= -16 && int_value <= 127) {  // Tiny Int
            err = append_byte(static_cast<uint8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int8_t>::min() && int_value <= std::numeric_limits<int8_t>::max()) {
            err = append_byte(MARKER_INT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int16_t>::min() && int_value <= std::numeric_limits<int16_t>::max()) {
            err = append_byte(MARKER_INT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int16_t>(int_value));
        } else if (int_value >= std::numeric_limits<int32_t>::min() && int_value <= std::numeric_limits<int32_t>::max()) {
            err = append_byte(MARKER_INT_32);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int32_t>(int_value));
        } else {
            err = append_byte(MARKER_INT_64);
            if (err == BoltError::SUCCESS) err = append_network_int(int_value);
        }
        return err;
    }

    BoltError PackStreamWriter::write_float_internal(double float_value) {
        if (has_error()) return error_state_;
        BoltError err = append_byte(MARKER_FLOAT64);
        if (err != BoltError::SUCCESS) return err;

        uint64_t temp_int;
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&temp_int, &float_value, sizeof(double));
        return append_network_int(temp_int);
    }

    BoltError PackStreamWriter::write_string_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err;
        if (size <= 0x0F) {  // Tiny String
            err = append_byte(MARKER_TINY_STRING_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_STRING_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_STRING_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // STRING_32
            err = append_byte(MARKER_STRING_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::write_string_data_internal(const std::string& value_str) {
        if (has_error()) return error_state_;
        if (value_str.empty()) return BoltError::SUCCESS;  // No data to append for empty string
        return append_bytes(value_str.data(), value_str.length());
    }

    BoltError PackStreamWriter::serialize_string_internal(const std::string& str_value) {
        if (has_error()) return error_state_;
        // PackStream strings are limited to 2^32 - 1 bytes.
        // std::string::length() returns size_t, which could be larger on 64-bit.
        if (str_value.length() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // String too long for PackStream
            return error_state_;
        }
        uint32_t len = static_cast<uint32_t>(str_value.length());
        BoltError err = write_string_header_internal(len);
        if (err != BoltError::SUCCESS) return err;
        return write_string_data_internal(str_value);
    }

    BoltError PackStreamWriter::write_list_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err;
        if (size <= 0x0F) {  // Tiny List
            err = append_byte(MARKER_TINY_LIST_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_LIST_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_LIST_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // LIST_32
            err = append_byte(MARKER_LIST_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_list_internal(const BoltList& list_data) {
        if (has_error()) return error_state_;
        const auto& list_elements = list_data.elements;
        if (list_elements.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // List too large
            return error_state_;
        }
        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_list_header_internal(static_cast<uint32_t>(list_elements.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return err;
        }

        for (const auto& item : list_elements) {
            err = this->write(item);  // Recursive call to main write
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call to write()
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::write_map_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err;
        if (size <= 0x0F) {  // Tiny Map
            err = append_byte(MARKER_TINY_MAP_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_MAP_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_MAP_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // MAP_32
            err = append_byte(MARKER_MAP_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_map_internal(const BoltMap& map_data) {
        if (has_error()) return error_state_;
        const auto& map_pairs = map_data.pairs;
        if (map_pairs.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // Map too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_map_header_internal(static_cast<uint32_t>(map_pairs.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return err;
        }

        for (const auto& pair : map_pairs) {
            err = serialize_string_internal(pair.first);  // Write key (string)
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
            err = this->write(pair.second);  // Write value (recursive)
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::write_struct_header_internal(uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err;
        if (size <= 0x0F) {  // Tiny Struct
            err = append_byte(MARKER_TINY_STRUCT_BASE | static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint8_t>::max()) {  // Struct 8
            err = append_byte(MARKER_STRUCT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint16_t>::max()) {  // Struct 16
            err = append_byte(MARKER_STRUCT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else {
            // PackStream v1 (Bolt) does not define STRUCT_32. Max fields for a struct is 65535.
            set_error(BoltError::SERIALIZATION_ERROR);  // Structure too large
            return error_state_;
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_structure_internal(const PackStreamStructure& struct_data) {
        if (has_error()) return error_state_;
        // Max fields for a PackStream structure that Bolt messages use is typically limited by STRUCT_16
        if (struct_data.fields.size() > 0xFFFF) {       // 65535
            set_error(BoltError::SERIALIZATION_ERROR);  // Structure too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_struct_header_internal(struct_data.tag, static_cast<uint32_t>(struct_data.fields.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return err;
        }

        for (const auto& field : struct_data.fields) {
            err = this->write(field);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol