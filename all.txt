file(GLOB_RECURSE SQL_DRIVER_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(SqlDriver ${SQL_DRIVER_SOURCE})

target_include_directories(SqlDriver
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(SqlDriver PUBLIC Qt6::Core)

# # build example, no condition
# add_subdirectory(Example)
// cpporm_sqldriver/i_sql_driver.h
#pragma once

#include <any>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_connection_parameters.h"  // Provides ConnectionParameters
#include "sql_enums.h"                  // Provides Feature, IdentifierType, StatementType, TransactionIsolationLevel, ISqlDriverNs::TableType
#include "sql_error.h"
#include "sql_index.h"
#include "sql_record.h"
#include "sql_value.h"  // For SqlValue, SqlValueType

namespace cpporm_sqldriver {

    class SqlResult;
    class SqlField;

    class ISqlDriver {
      public:
        virtual ~ISqlDriver() = default;

        virtual bool open(const ConnectionParameters& params) = 0;
        virtual void close() = 0;
        virtual bool isOpen() const = 0;
        virtual bool isOpenError() const = 0;
        virtual bool ping(int timeout_seconds = 2) = 0;

        virtual bool beginTransaction() = 0;
        virtual bool commitTransaction() = 0;
        virtual bool rollbackTransaction() = 0;
        virtual bool setTransactionIsolationLevel(TransactionIsolationLevel level) = 0;
        virtual TransactionIsolationLevel transactionIsolationLevel() const = 0;
        virtual bool setSavepoint(const std::string& name) = 0;
        virtual bool rollbackToSavepoint(const std::string& name) = 0;
        virtual bool releaseSavepoint(const std::string& name) = 0;

        virtual std::unique_ptr<SqlResult> createResult() const = 0;

        virtual std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const = 0;
        virtual std::vector<std::string> schemas(const std::string& schemaFilter = "") const = 0;
        virtual SqlRecord record(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const = 0;

        virtual bool hasFeature(Feature feature) const = 0;
        virtual SqlError lastError() const = 0;
        virtual std::string databaseProductVersion() const = 0;
        virtual std::string driverVersion() const = 0;

        virtual std::string formatValue(const SqlValue& value, SqlValueType type_hint = SqlValueType::Null, const SqlField* field_meta_hint = nullptr) const = 0;
        virtual std::string escapeIdentifier(const std::string& identifier, IdentifierType type) const = 0;
        virtual std::string sqlStatement(StatementType type, const std::string& tableName, const SqlRecord& rec, bool prepared, const std::string& schema = "") const = 0;

        virtual bool setClientCharset(const std::string& charsetName) = 0;
        virtual std::string clientCharset() const = 0;

        virtual SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "") = 0;

        virtual SqlValue nativeHandle() const = 0;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_connection_parameters.h
#pragma once

#include <map>
#include <optional>
#include <string>
#include <vector>  // Not directly used here, but often associated with parameter sets

#include "sql_value.h"  // For SqlValue used as map value

namespace cpporm_sqldriver {

    struct ConnectionParameters : public std::map<std::string, SqlValue> {
        // 定义键常量 (声明)
        static const std::string KEY_DRIVER_TYPE;
        static const std::string KEY_DB_NAME;
        static const std::string KEY_USER_NAME;
        static const std::string KEY_PASSWORD;
        static const std::string KEY_HOST_NAME;
        static const std::string KEY_PORT;
        static const std::string KEY_CONNECT_OPTIONS;
        static const std::string KEY_CLIENT_CHARSET;
        static const std::string KEY_APPLICATION_NAME;
        static const std::string KEY_CONNECTION_TIMEOUT_SECONDS;
        static const std::string KEY_READ_TIMEOUT_SECONDS;
        static const std::string KEY_WRITE_TIMEOUT_SECONDS;
        static const std::string KEY_SSL_MODE;
        static const std::string KEY_SSL_CERT_PATH;
        static const std::string KEY_SSL_KEY_PATH;
        static const std::string KEY_SSL_CA_PATH;
        static const std::string KEY_SSL_CIPHER;
        static const std::string KEY_POOL_MAX_SIZE;
        static const std::string KEY_POOL_MIN_SIZE;
        static const std::string KEY_POOL_ACQUIRE_TIMEOUT_MS;
        static const std::string KEY_POOL_CONNECTION_LIFETIME_MS;
        static const std::string KEY_POOL_IDLE_TIMEOUT_MS;

        // Setters (声明)
        void setDriverType(const std::string& v);
        void setDbName(const std::string& v);
        void setUserName(const std::string& v);
        void setPassword(const std::string& v);
        void setHostName(const std::string& v);
        void setPort(int v);
        void setConnectOptions(const std::string& v);
        void setClientCharset(const std::string& v);
        void setApplicationName(const std::string& v);
        void setConnectionTimeoutSeconds(int v);
        void setReadTimeoutSeconds(int v);
        void setWriteTimeoutSeconds(int v);
        void setSslMode(const std::string& v);
        void setSslCertPath(const std::string& v);
        void setSslKeyPath(const std::string& v);
        void setSslCaPath(const std::string& v);
        void setSslCipher(const std::string& v);
        void setPoolMaxSize(int v);
        void setPoolMinSize(int v);
        void setPoolAcquireTimeoutMs(long long v);
        void setPoolConnectionLifetimeMs(long long v);
        void setPoolIdleTimeoutMs(long long v);

        // Getters (声明)
        template <typename T>
        std::optional<T> get(const std::string& key) const;

        std::optional<std::string> driverType() const;
        std::optional<std::string> dbName() const;
        std::optional<std::string> userName() const;
        std::optional<std::string> password() const;
        std::optional<std::string> hostName() const;
        std::optional<int> port() const;
        std::optional<std::string> connectOptions() const;
        std::optional<std::string> clientCharset() const;
        std::optional<std::string> applicationName() const;
        std::optional<int> connectionTimeoutSeconds() const;
        std::optional<int> readTimeoutSeconds() const;
        std::optional<int> writeTimeoutSeconds() const;
        std::optional<std::string> sslMode() const;
        std::optional<std::string> sslCertPath() const;
        std::optional<std::string> sslKeyPath() const;
        std::optional<std::string> sslCaPath() const;
        std::optional<std::string> sslCipher() const;
        std::optional<int> poolMaxSize() const;
        std::optional<int> poolMinSize() const;
        std::optional<long long> poolAcquireTimeoutMs() const;
        std::optional<long long> poolConnectionLifetimeMs() const;
        std::optional<long long> poolIdleTimeoutMs() const;
    };

    template <typename T>
    std::optional<T> ConnectionParameters::get(const std::string& key) const {
        auto it = find(key);
        if (it != end() && !it->second.isNull()) {
            bool ok = false;
            T result{};
            if constexpr (std::is_same_v<T, std::string>) {
                result = it->second.toString(&ok);
            } else if constexpr (std::is_same_v<T, int>) {
                result = it->second.toInt32(&ok);
            } else if constexpr (std::is_same_v<T, unsigned int>) {
                result = it->second.toUInt32(&ok);
            } else if constexpr (std::is_same_v<T, long long>) {
                result = it->second.toInt64(&ok);
            } else if constexpr (std::is_same_v<T, unsigned long long>) {
                result = it->second.toUInt64(&ok);
            } else if constexpr (std::is_same_v<T, bool>) {
                result = it->second.toBool(&ok);
            } else if constexpr (std::is_same_v<T, float>) {
                result = it->second.toFloat(&ok);
            } else if constexpr (std::is_same_v<T, double>) {
                result = it->second.toDouble(&ok);
            } else if constexpr (std::is_same_v<T, long double>) {
                result = it->second.toLongDouble(&ok);
            } else if constexpr (std::is_same_v<T, QByteArray>) {
                result = it->second.toByteArray(&ok);
            } else if constexpr (std::is_same_v<T, QDate>) {
                result = it->second.toDate(&ok);
            } else if constexpr (std::is_same_v<T, QTime>) {
                result = it->second.toTime(&ok);
            } else if constexpr (std::is_same_v<T, QDateTime>) {
                result = it->second.toDateTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDate>) {
                result = it->second.toChronoDate(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoTime>) {
                result = it->second.toChronoTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDateTime>) {
                result = it->second.toChronoDateTime(&ok);
            } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                result = it->second.toStdVectorUChar(&ok);
            }
            // else if constexpr (std::is_same_v<T, SqlDecimal>) { result = it->second.toDecimal(&ok); } // Example for custom types
            // else if constexpr (std::is_same_v<T, SqlJsonDocument>) { result = it->second.toJsonDocument(&ok); }
            else {
                // For std::any or other unlisted types, this path would be taken.
                // Consider if a static_assert(false, "Unsupported type T for ConnectionParameters::get") is appropriate,
                // or if it should attempt a toStdAny() and std::any_cast, which is more risky.
                // For now, ok will remain false if no specific conversion is matched.
            }
            if (ok) return result;
        }
        return std::nullopt;
    }

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_database.h
#pragma once
#include <any>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "i_sql_driver.h"               // Provides ISqlDriver interface
#include "sql_connection_parameters.h"  // Provides ConnectionParameters
#include "sql_enums.h"                  // Provides Feature, TransactionIsolationLevel, ISqlDriverNs::TableType etc.
#include "sql_error.h"
#include "sql_index.h"   // Provides SqlIndex
#include "sql_record.h"  // Provides SqlRecord

namespace cpporm_sqldriver {

    class SqlQuery;

    class SqlDatabase {
      public:
        ~SqlDatabase();

        bool open(const ConnectionParameters& params);
        bool open();
        bool open(const std::string& user, const std::string& password);
        void close();
        bool isOpen() const;
        bool isValid() const;
        bool ping(int timeout_seconds = 2);

        bool transaction();
        bool commit();
        bool rollback();
        bool isTransactionActive() const;
        bool setTransactionIsolationLevel(TransactionIsolationLevel level);
        TransactionIsolationLevel transactionIsolationLevel() const;
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        std::string driverName() const;
        std::string databaseName() const;
        void setDatabaseName(const std::string& name);

        std::string userName() const;
        void setUserName(const std::string& name);

        void setPassword(const std::string& password);

        std::string hostName() const;
        void setHostName(const std::string& host);

        int port() const;
        void setPort(int port);

        std::string connectOptionsString() const;
        void setConnectOptionsString(const std::string& options);

        const ConnectionParameters& connectionParameters() const;
        void setConnectionParameter(const std::string& key, const SqlValue& value);
        SqlValue connectionParameter(const std::string& key) const;

        SqlError lastError() const;

        ISqlDriver* driver() const;
        std::string connectionName() const;

        std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const;
        std::vector<std::string> schemas(const std::string& schemaFilter = "") const;
        SqlRecord record(const std::string& tablename, const std::string& schema = "") const;
        SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const;
        std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const;

        bool hasFeature(Feature feature) const;
        SqlValue nativeHandle() const;
        std::string databaseProductVersion() const;
        std::string driverVersion() const;

        bool setClientCharset(const std::string& charsetName);
        std::string clientCharset() const;

        SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "");

      private:
        friend class SqlDriverManager;
        friend class SqlQuery;

        SqlDatabase(const std::string& driverTypeFromManager, const std::string& assignedConnectionName, std::unique_ptr<ISqlDriver> driverImplementation);

        class Private;
        std::unique_ptr<Private> d;

        SqlDatabase(const SqlDatabase&) = delete;
        SqlDatabase& operator=(const SqlDatabase&) = delete;
        SqlDatabase(SqlDatabase&&) noexcept;
        SqlDatabase& operator=(SqlDatabase&&) noexcept;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_driver_manager.h
#pragma once
#include <functional>  // For std::function
#include <memory>
#include <string>
#include <vector>

#include "sql_database.h"

namespace cpporm_sqldriver {

    class ISqlDriver;  // 前向声明

    class SqlDriverManager {
      public:
        using DriverFactory = std::function<std::unique_ptr<ISqlDriver>()>;

        // 连接管理
        static SqlDatabase addDatabase(const std::string& driverType, const std::string& connectionName = defaultConnectionName());
        static SqlDatabase database(const std::string& connectionName = defaultConnectionName(), bool open = true);
        static void removeDatabase(const std::string& connectionName);
        static bool contains(const std::string& connectionName = defaultConnectionName());

        // 驱动信息
        static std::vector<std::string> drivers();                     // 列出已注册的驱动类型
        static bool isDriverAvailable(const std::string& driverType);  // 检查驱动是否可用

        static std::string defaultConnectionName();

        // 驱动注册 (由具体驱动实现模块在初始化时调用)
        static bool registerDriver(const std::string& driverName, DriverFactory factory);
        // static void unregisterDriver(const std::string& driverName); // 可选

      private:
        SqlDriverManager() = delete;  // 静态类

        class Private;  // PImpl for static data
        static Private* d();
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_enums.h
#pragma once

namespace cpporm_sqldriver {

    // --- Enums used across driver interfaces ---

    enum class Feature {
        Transactions,
        QuerySize,
        BLOB,
        Unicode,
        PreparedQueries,
        NamedPlaceholders,
        PositionalPlaceholders,
        LastInsertId,
        BatchOperations,
        SimpleScrollOnError,
        EventNotifications,
        FinishQuery,
        MultipleResultSets,
        LowPrecisionNumbers,
        CancelQuery,
        InsertAndReturnId,
        NamedSavepoints,
        ThreadSafe,
        SchemaOperations,
        SequenceOperations,
        UpdatableCursors,
        TransactionIsolationLevel,
        GetTypeInfo,
        PingConnection,
        SetQueryTimeout,
        StreamBlob,
        CallableStatements,
        BatchWithErrorDetails
    };

    enum class IdentifierType { Table, Field, Index, Schema, Sequence, Trigger, View, Constraint, User, Role, Procedure, Function };

    enum class StatementType { Select, Insert, Update, Delete, DDL, DCL, TCL, Call, Begin, Commit, Rollback, Savepoint, Unknown };

    enum class TransactionIsolationLevel { ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, Snapshot, Default };

    enum class ParamType { In, Out, InOut, Binary, ReturnValue };

    enum class CursorMovement { Absolute, RelativeFirst, RelativeNext, RelativePrevious, RelativeLast };

    namespace ISqlDriverNs {
        enum class TableType { All, Tables, Views, SystemTables, Aliases, Synonyms, TemporaryTables, GlobalTemporaryTables };
    }  // namespace ISqlDriverNs

    namespace SqlResultNs {
        enum class ScrollMode { ForwardOnly, Scrollable };
        enum class ConcurrencyMode { ReadOnly, Updatable };
        enum class NamedBindingSyntax { Colon, AtSign, QuestionMark };
    }  // namespace SqlResultNs

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_error.h
#pragma once
#include <optional>
#include <string>

namespace cpporm_sqldriver {

    // ErrorCategory 和 ErrorType 枚举定义在文件顶部或类的外部
    enum class ErrorCategory { NoError, Connectivity, Syntax, Constraint, Permissions, DataRelated, Resource, Transaction, DriverInternal, DatabaseInternal, OperationCancelled, FeatureNotSupported, Unknown };

    // 旧的 ErrorType，如果仍需保留用于映射或兼容
    enum class ErrorType {
        NoError = 0,  // 保持与Qt QSqlError::NoError 一致
        ConnectionError,
        StatementError,
        TransactionError,
        UnknownError,
        FeatureNotSupportedError,
        DataError,
        ConstraintViolationError
    };

    class SqlError {
      public:
        SqlError();
        SqlError(ErrorCategory category,
                 const std::string& databaseText,
                 const std::string& driverText = "",
                 const std::string& nativeErrorCode = "",
                 int nativeDbCodeNumeric = 0,
                 const std::string& failedQuery = "",
                 const std::string& constraintName = "",
                 const std::optional<int>& errorOffset = std::nullopt);

        ErrorCategory category() const;
        ErrorType type() const;  // 可以基于 category() 返回一个映射的 ErrorType
        std::string databaseText() const;
        std::string driverText() const;
        std::string text() const;
        std::string nativeErrorCode() const;
        int nativeErrorCodeNumeric() const;
        std::string failedQuery() const;
        std::string constraintName() const;
        std::optional<int> errorOffsetInQuery() const;
        bool isValid() const;  // category() != ErrorCategory::NoError

        void setCategory(ErrorCategory category);
        void setType(ErrorType type);
        void setDatabaseText(const std::string& text);
        void setDriverText(const std::string& text);
        void setNativeErrorCode(const std::string& code);
        void setNativeErrorCodeNumeric(int code);
        void setFailedQuery(const std::string& query);
        void setConstraintName(const std::string& name);
        void setErrorOffsetInQuery(const std::optional<int>& offset);
        void clear();

      private:
        ErrorCategory category_ = ErrorCategory::NoError;
        ErrorType legacy_type_ = ErrorType::NoError;
        std::string database_text_;
        std::string driver_text_;
        std::string native_error_code_str_;
        int native_error_code_num_ = 0;
        std::string failed_query_;
        std::string constraint_name_;
        std::optional<int> error_offset_;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_field.h
#pragma once
#include <any>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "sql_value.h"

namespace cpporm_sqldriver {

    enum class RequiredStatus { Unknown = -1, Optional = 0, Required = 1 };

    class SqlField {
      public:
        SqlField(const std::string& name = "", SqlValueType type = SqlValueType::Null, const std::string& db_type_name = "");
        SqlField(const SqlField& other);
        SqlField& operator=(const SqlField& other);
        SqlField(SqlField&& other) noexcept;
        SqlField& operator=(SqlField&& other) noexcept;
        ~SqlField();

        std::string name() const;
        void setName(const std::string& name);

        SqlValueType type() const;
        void setType(SqlValueType type);

        std::string databaseTypeName() const;
        void setDatabaseTypeName(const std::string& name);
        int driverType() const;
        void setDriverType(int typeId);

        int length() const;
        void setLength(int len);

        int precision() const;
        void setPrecision(int prec);

        int scale() const;
        void setScale(int s);

        bool isNullInValue() const;
        bool isAutoValue() const;
        void setAutoValue(bool autoVal);

        bool isReadOnly() const;
        void setReadOnly(bool ro);

        RequiredStatus requiredStatus() const;
        void setRequiredStatus(RequiredStatus status);

        SqlValue defaultValue() const;
        void setDefaultValue(const SqlValue& value);

        SqlValue value() const;
        void setValue(const SqlValue& value);
        void clearValue();

        bool isValid() const;
        bool isGenerated() const;
        void setGenerated(bool generated);

        bool isPrimaryKeyPart() const;
        void setPrimaryKeyPart(bool is_pk);

        bool isForeignKeyPart() const;
        void setForeignKeyPart(bool is_fk);
        std::optional<std::string> referencedTableName() const;
        void setReferencedTableName(const std::optional<std::string>& name);
        std::optional<std::string> referencedColumnName() const;
        void setReferencedColumnName(const std::optional<std::string>& name);

        std::optional<std::string> collationName() const;
        void setCollationName(const std::optional<std::string>& name);

        bool isExpression() const;
        void setIsExpression(bool is_expr);
        std::optional<std::string> aliasName() const;
        void setAliasName(const std::optional<std::string>& alias);
        std::optional<std::string> baseTableName() const;
        void setBaseTableName(const std::optional<std::string>& name);
        std::optional<std::string> baseColumnName() const;
        void setBaseColumnName(const std::optional<std::string>& name);
        std::optional<std::string> baseSchemaName() const;
        void setBaseSchemaName(const std::optional<std::string>& name);

        std::any metaData() const;
        void setMetaData(const std::any& data);

      private:
        class Private;
        std::unique_ptr<Private> d;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_index.h
#pragma once
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "sql_field.h"
#include "sql_value.h"

namespace cpporm_sqldriver {

    enum class IndexSortOrder { Ascending, Descending, Default };
    enum class IndexNullsPosition { Default, First, Last };  // For NULLS FIRST/LAST

    struct IndexColumnDefinition {
        std::string fieldName;
        IndexSortOrder sortOrder = IndexSortOrder::Default;
        IndexNullsPosition nullsPosition = IndexNullsPosition::Default;
        std::optional<std::string> opClass;  // For PostgreSQL operator class
        // std::optional<std::string> collation; // Per-column collation if supported
    };

    class SqlIndex {
      public:
        SqlIndex(const std::string& cursorName = "", const std::string& name = "");
        SqlIndex(const SqlIndex& other);
        SqlIndex& operator=(const SqlIndex& other);
        SqlIndex(SqlIndex&& other) noexcept;
        SqlIndex& operator=(SqlIndex&& other) noexcept;
        ~SqlIndex();

        std::string name() const;
        void setName(const std::string& name);

        std::string cursorName() const;  // Table name
        void setCursorName(const std::string& name);

        std::string schemaName() const;
        void setSchemaName(const std::string& schema);

        bool isUnique() const;
        void setUnique(bool unique);

        bool isPrimaryKey() const;
        void setPrimaryKey(bool pk);

        bool isFunctional() const;  // 是否为函数/表达式索引
        void setFunctional(bool functional);

        void append(const IndexColumnDefinition& colDef);
        void append(const std::string& fieldName, IndexSortOrder order = IndexSortOrder::Default, IndexNullsPosition nulls = IndexNullsPosition::Default, const std::optional<std::string>& opClass = std::nullopt);

        int count() const;
        IndexColumnDefinition columnDefinition(int i) const;

        std::string typeMethod() const;  // e.g., BTREE, HASH, GIN, GIST, SPGIST, BRIN
        void setTypeMethod(const std::string& method);

        std::string condition() const;  // Partial index condition (WHERE clause)
        void setCondition(const std::string& cond);

        std::vector<std::string> includedColumnNames() const;  // SQL Server INCLUDE, PG INCLUDE
        void addIncludedColumn(const std::string& columnName);

        std::map<std::string, SqlValue> options() const;  // e.g., FILLFACTOR, WITH (...)
        void setOption(const std::string& optionName, const SqlValue& value);
        SqlValue option(const std::string& optionName) const;

        void clear();

      private:
        class Private;
        std::unique_ptr<Private> d;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_query.h
#pragma once
#include <functional>
#include <future>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "i_sql_driver.h"  // Provides ISqlDriver
#include "sql_enums.h"     // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_field.h"  // Provides SqlField
#include "sql_record.h"
#include "sql_result.h"  // Provides SqlResult
#include "sql_value.h"   // Provides NumericalPrecisionPolicy

namespace cpporm_sqldriver {

    class SqlDatabase;

    enum class BatchExecutionMode {
        ValuesAsRows,
    };

    class SqlQuery {
      public:
        explicit SqlQuery(SqlDatabase& db);
        explicit SqlQuery(const std::string& query, SqlDatabase& db);
        ~SqlQuery();

        bool prepare(const std::string& query, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly);
        bool exec();
        bool exec(const std::string& query);
        bool setQueryTimeout(int seconds);

        void bindValue(int pos, const SqlValue& val, ParamType type = ParamType::In, int size_hint_for_out_param = 0);
        void bindValue(const std::string& placeholderName, const SqlValue& val, ParamType type = ParamType::In, int size_hint_for_out_param = 0);
        void addBindValue(const SqlValue& val, ParamType type = ParamType::In);
        void bindValues(const std::vector<SqlValue>& values, ParamType type = ParamType::In);
        void bindValues(const std::map<std::string, SqlValue>& values, ParamType type = ParamType::In);

        SqlValue boundValue(int pos) const;
        SqlValue boundValue(const std::string& placeholderName) const;
        const std::map<std::string, SqlValue>& namedBoundValues() const;
        const std::vector<SqlValue>& positionalBoundValues() const;
        void clearBoundValues();
        int numberOfBoundValues() const;

        bool next();
        bool previous();
        bool first();
        bool last();
        bool seek(int index, CursorMovement movement = CursorMovement::Absolute);

        SqlRecord recordMetadata() const;
        SqlRecord currentFetchedRow() const;
        SqlValue value(int index) const;
        SqlValue value(const std::string& name) const;
        bool isNull(int index) const;
        bool isNull(const std::string& name) const;
        SqlField field(int index) const;
        SqlField field(const std::string& name) const;

        int at() const;
        int size() const;

        bool isActive() const;
        bool isValid() const;
        bool isSelect() const;
        bool setForwardOnly(bool forward);
        bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy);
        SqlError lastError() const;
        std::string lastQuery() const;
        std::string executedQuery() const;

        long long numRowsAffected() const;
        SqlValue lastInsertId() const;

        void finish();
        void clear();

        SqlDatabase& database() const;
        ISqlDriver* driver() const;
        SqlResult* result() const;

        bool execBatch(BatchExecutionMode mode = BatchExecutionMode::ValuesAsRows);

        bool nextResult();

      private:
        class Private;
        std::unique_ptr<Private> d;

        SqlQuery(const SqlQuery&) = delete;
        SqlQuery& operator=(const SqlQuery&) = delete;
        SqlQuery(SqlQuery&&) noexcept;
        SqlQuery& operator=(SqlQuery&&) noexcept;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_record.h
#pragma once
#include <optional>  // For std::optional
#include <string>
#include <vector>

#include "sql_field.h"  // SqlField 包含元数据和可选的当前值
#include "sql_value.h"

namespace cpporm_sqldriver {

    class SqlRecord {
      public:
        SqlRecord();
        ~SqlRecord();

        // 检查和计数
        bool isEmpty() const;  // 是否包含任何字段
        int count() const;

        // 字段访问
        SqlField field(int index) const;                // 按索引获取字段对象 (包含元数据和值)
        SqlField field(const std::string& name) const;  // 按名称获取字段对象

        std::string fieldName(int index) const;  // 仅获取字段名

        // 值访问 (便捷方法)
        SqlValue value(int index) const;
        SqlValue value(const std::string& name) const;
        bool isNull(int index) const;
        bool isNull(const std::string& name) const;

        // 查找和包含
        int indexOf(const std::string& name) const;  // -1 if not found
        bool contains(const std::string& name) const;

        // 修改 (通常由驱动内部使用来填充记录)
        void append(const SqlField& field);  // 添加一个字段 (元数据+值)
        void insert(int pos, const SqlField& field);
        void remove(int pos);
        void replace(int pos, const SqlField& field);
        void setValue(int index, const SqlValue& val);
        void setValue(const std::string& name, const SqlValue& val);
        void setNull(int index);
        void setNull(const std::string& name);
        void clear();  // 移除所有字段

      private:
        class Private;  // PImpl
        std::unique_ptr<Private> d;

        // SqlRecord 可以被拷贝和赋值
        SqlRecord(const SqlRecord& other);
        SqlRecord& operator=(const SqlRecord& other);
        SqlRecord(SqlRecord&& other) noexcept;
        SqlRecord& operator=(SqlRecord&& other) noexcept;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_result.h
#pragma once

#include <iosfwd>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_enums.h"  // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_record.h"
#include "sql_value.h"  // Provides SqlValue, NumericalPrecisionPolicy, SqlValueType
// #include "sql_field.h" // Forward declare or include if needed

namespace cpporm_sqldriver {

    class SqlField;  // Forward declare for SqlResult::field()
    // struct SqlFieldExtendedInfo; // Forward declare if used

    class SqlResult {
      public:
        virtual ~SqlResult() = default;

        virtual bool prepare(const std::string& query, const std::map<std::string, SqlValueType>* named_bindings_type_hints = nullptr, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly) = 0;
        virtual bool exec() = 0;
        virtual bool setQueryTimeout(int seconds) = 0;
        virtual bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) = 0;
        virtual bool setPrefetchSize(int rows) = 0;
        virtual int prefetchSize() const = 0;

        virtual void addPositionalBindValue(const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void setNamedBindValue(const std::string& placeholder, const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(int pos, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(const std::string& placeholder, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void clearBindValues() = 0;
        virtual void reset() = 0;
        virtual bool setForwardOnly(bool forward) = 0;

        virtual bool fetchNext(SqlRecord& record_buffer) = 0;
        virtual bool fetchPrevious(SqlRecord& record_buffer) = 0;
        virtual bool fetchFirst(SqlRecord& record_buffer) = 0;
        virtual bool fetchLast(SqlRecord& record_buffer) = 0;
        virtual bool fetch(int index, SqlRecord& record_buffer, CursorMovement movement = CursorMovement::Absolute) = 0;

        virtual SqlValue data(int column_index) = 0;
        virtual std::shared_ptr<std::istream> openReadableBlobStream(int column_index) = 0;
        virtual std::shared_ptr<std::ostream> openWritableBlobStream(int column_index, long long initial_size_hint = 0) = 0;

        virtual bool isNull(int column_index) = 0;
        virtual SqlRecord recordMetadata() const = 0;
        virtual SqlRecord currentFetchedRow() const = 0;
        virtual SqlField field(int column_index) const = 0;
        // virtual SqlFieldExtendedInfo fieldExtendedInfo(int column_index) const = 0;

        virtual long long numRowsAffected() = 0;
        virtual SqlValue lastInsertId() = 0;
        virtual int columnCount() const = 0;
        virtual int size() = 0;
        virtual int at() const = 0;

        virtual bool isActive() const = 0;
        virtual bool isValid() const = 0;
        virtual SqlError error() const = 0;
        virtual const std::string& lastQuery() const = 0;
        virtual const std::string& preparedQueryText() const = 0;

        virtual void finish() = 0;
        virtual void clear() = 0;

        virtual bool nextResult() = 0;

        virtual SqlValue getOutParameter(int pos) const = 0;
        virtual SqlValue getOutParameter(const std::string& name) const = 0;
        virtual std::map<std::string, SqlValue> getAllOutParameters() const = 0;

        virtual bool setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) = 0;
    };

}  // namespace cpporm_sqldriver// cpporm_sqldriver/sql_value.h
#pragma once
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>
#include <QVariant>
#include <any>
#include <chrono>
#include <iosfwd>
#include <memory>
#include <optional>
#include <string>
#include <typeinfo>
#include <variant>
#include <vector>

namespace cpporm_sqldriver {

    enum class SqlValueType {
        Null,
        Bool,
        Int8,
        UInt8,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        LongDouble,
        String,
        FixedString,
        ByteArray,
        BinaryLargeObject,
        CharacterLargeObject,
        Date,
        Time,
        DateTime,
        Timestamp,
        Interval,
        Decimal,
        Numeric,
        Json,
        Xml,
        Array,
        RowId,
        Custom,
        Unknown
    };

    enum class NumericalPrecisionPolicy { LowPrecision, HighPrecision, ExactRepresentation };

    class SqlValue {
      public:
        using ChronoDate = std::chrono::year_month_day;
        using ChronoTime = std::chrono::nanoseconds;
        using ChronoDateTime = std::chrono::system_clock::time_point;
        using BlobInputStream = std::shared_ptr<std::istream>;
        using BlobOutputStream = std::shared_ptr<std::ostream>;
        using ClobInputStream = std::shared_ptr<std::basic_istream<char>>;
        using ClobOutputStream = std::shared_ptr<std::basic_ostream<char>>;

        SqlValue();
        SqlValue(std::nullptr_t);
        SqlValue(bool val);
        SqlValue(int8_t val);
        SqlValue(uint8_t val);
        SqlValue(int16_t val);
        SqlValue(uint16_t val);
        SqlValue(int32_t val);
        SqlValue(uint32_t val);
        SqlValue(int64_t val);
        SqlValue(uint64_t val);
        SqlValue(float val);
        SqlValue(double val);
        SqlValue(long double val);
        SqlValue(const char* val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::string& val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::vector<unsigned char>& val);

        // SqlValue(const SqlDecimal& val);
        // SqlValue(const SqlJsonDocument& val);
        // SqlValue(const SqlXmlDocument& val);
        // template<typename T> SqlValue(const SqlArray<T>& val);

        SqlValue(BlobInputStream stream_handle, long long size = -1);
        SqlValue(ClobInputStream stream_handle, long long size = -1, const std::string& charset = "UTF-8");

        SqlValue(const QByteArray& val);
        SqlValue(const QDate& val);
        SqlValue(const QTime& val);
        SqlValue(const QDateTime& val);

        SqlValue(const ChronoDate& val);
        SqlValue(const ChronoTime& val);
        SqlValue(const ChronoDateTime& val);

        SqlValue(const SqlValue& other);
        SqlValue& operator=(const SqlValue& other);
        SqlValue(SqlValue&& other) noexcept;
        SqlValue& operator=(SqlValue&& other) noexcept;
        ~SqlValue();

        bool isNull() const;
        bool isValid() const;
        SqlValueType type() const;
        const char* typeName() const;
        std::string driverTypeName() const;
        void setDriverTypeName(const std::string& name);

        bool toBool(bool* ok = nullptr) const;
        int8_t toInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint8_t toUInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int16_t toInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint16_t toUInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int32_t toInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;    // Corresponds to 'int'
        uint32_t toUInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;  // Corresponds to 'unsigned int'
        int64_t toInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;    // Corresponds to 'long long'
        uint64_t toUInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;  // Corresponds to 'unsigned long long'
        float toFloat(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        double toDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        long double toLongDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::string toString(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::vector<unsigned char> toStdVectorUChar(bool* ok = nullptr) const;

        // SqlDecimal toDecimal(bool* ok = nullptr) const;
        // SqlJsonDocument toJsonDocument(bool* ok = nullptr) const;
        // SqlXmlDocument toXmlDocument(bool* ok = nullptr) const;
        // template<typename T> std::optional<SqlArray<T>> toArray(bool* ok = nullptr) const;

        BlobInputStream toBlobInputStream(bool* ok = nullptr) const;
        ClobInputStream toClobInputStream(bool* ok = nullptr) const;

        QByteArray toByteArray(bool* ok = nullptr) const;
        QDate toDate(bool* ok = nullptr) const;
        QTime toTime(bool* ok = nullptr) const;
        QDateTime toDateTime(bool* ok = nullptr) const;

        ChronoDate toChronoDate(bool* ok = nullptr) const;
        ChronoTime toChronoTime(bool* ok = nullptr) const;
        ChronoDateTime toChronoDateTime(bool* ok = nullptr) const;

        bool operator==(const SqlValue& other) const;
        bool operator!=(const SqlValue& other) const;

        void clear();

        QVariant toQVariant() const;
        static SqlValue fromQVariant(const QVariant& qv);

        std::any toStdAny() const;
        static SqlValue fromStdAny(const std::any& val, SqlValueType type_hint = SqlValueType::Custom);

      private:
        using StorageType = std::variant<std::monostate,
                                         bool,
                                         int8_t,
                                         uint8_t,
                                         int16_t,
                                         uint16_t,
                                         int32_t,
                                         uint32_t,
                                         int64_t,
                                         uint64_t,
                                         float,
                                         double,
                                         long double,
                                         std::string,
                                         std::vector<unsigned char>,
                                         BlobInputStream,
                                         ClobInputStream,
                                         QByteArray,
                                         QDate,
                                         QTime,
                                         QDateTime,
                                         ChronoDate,
                                         ChronoTime,
                                         ChronoDateTime,
                                         std::any>;
        StorageType value_;
        SqlValueType current_type_enum_ = SqlValueType::Null;
        std::string driver_type_name_;
        void updateCurrentTypeEnum();
    };

}  // namespace cpporm_sqldriver// DataBaseDriver/SqlDriver/Source/dummy.cpp

#include "cpporm_sqldriver/i_sql_driver.h"
#include "cpporm_sqldriver/sql_connection_parameters.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_driver_manager.h"
// #include "cpporm_sqldriver/sql_driver_types.h" // <-- 移除这一行
#include "cpporm_sqldriver/sql_enums.h"
#include "cpporm_sqldriver/sql_error.h"
#include "cpporm_sqldriver/sql_field.h"
#include "cpporm_sqldriver/sql_index.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_record.h"
#include "cpporm_sqldriver/sql_result.h"
#include "cpporm_sqldriver/sql_value.h"

// No other content needed in this dummy file.// Source/sql_connection_parameters.cpp
#include "cpporm_sqldriver/sql_connection_parameters.h"

#include "cpporm_sqldriver/sql_value.h"

namespace cpporm_sqldriver {

    // 定义静态常量成员
    const std::string ConnectionParameters::KEY_DRIVER_TYPE = "driver_type";
    const std::string ConnectionParameters::KEY_DB_NAME = "db_name";
    const std::string ConnectionParameters::KEY_USER_NAME = "user_name";
    const std::string ConnectionParameters::KEY_PASSWORD = "password";
    const std::string ConnectionParameters::KEY_HOST_NAME = "host_name";
    const std::string ConnectionParameters::KEY_PORT = "port";
    const std::string ConnectionParameters::KEY_CONNECT_OPTIONS = "connect_options";
    const std::string ConnectionParameters::KEY_CLIENT_CHARSET = "client_charset";
    const std::string ConnectionParameters::KEY_APPLICATION_NAME = "application_name";
    const std::string ConnectionParameters::KEY_CONNECTION_TIMEOUT_SECONDS = "connection_timeout_seconds";
    const std::string ConnectionParameters::KEY_READ_TIMEOUT_SECONDS = "read_timeout_seconds";
    const std::string ConnectionParameters::KEY_WRITE_TIMEOUT_SECONDS = "write_timeout_seconds";
    const std::string ConnectionParameters::KEY_SSL_MODE = "ssl_mode";
    const std::string ConnectionParameters::KEY_SSL_CERT_PATH = "ssl_cert_path";
    const std::string ConnectionParameters::KEY_SSL_KEY_PATH = "ssl_key_path";
    const std::string ConnectionParameters::KEY_SSL_CA_PATH = "ssl_ca_path";
    const std::string ConnectionParameters::KEY_SSL_CIPHER = "ssl_cipher";
    const std::string ConnectionParameters::KEY_POOL_MAX_SIZE = "pool_max_size";
    const std::string ConnectionParameters::KEY_POOL_MIN_SIZE = "pool_min_size";
    const std::string ConnectionParameters::KEY_POOL_ACQUIRE_TIMEOUT_MS = "pool_acquire_timeout_ms";
    const std::string ConnectionParameters::KEY_POOL_CONNECTION_LIFETIME_MS = "pool_connection_lifetime_ms";
    const std::string ConnectionParameters::KEY_POOL_IDLE_TIMEOUT_MS = "pool_idle_timeout_ms";

    // Setters (实现)
    void ConnectionParameters::setDriverType(const std::string& v) {
        (*this)[KEY_DRIVER_TYPE] = SqlValue(v);
    }
    void ConnectionParameters::setDbName(const std::string& v) {
        (*this)[KEY_DB_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setUserName(const std::string& v) {
        (*this)[KEY_USER_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setPassword(const std::string& v) {
        (*this)[KEY_PASSWORD] = SqlValue(v);
    }
    void ConnectionParameters::setHostName(const std::string& v) {
        (*this)[KEY_HOST_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setPort(int v) {
        (*this)[KEY_PORT] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setConnectOptions(const std::string& v) {
        (*this)[KEY_CONNECT_OPTIONS] = SqlValue(v);
    }
    void ConnectionParameters::setClientCharset(const std::string& v) {
        (*this)[KEY_CLIENT_CHARSET] = SqlValue(v);
    }
    void ConnectionParameters::setApplicationName(const std::string& v) {
        (*this)[KEY_APPLICATION_NAME] = SqlValue(v);
    }
    void ConnectionParameters::setConnectionTimeoutSeconds(int v) {
        (*this)[KEY_CONNECTION_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setReadTimeoutSeconds(int v) {
        (*this)[KEY_READ_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setWriteTimeoutSeconds(int v) {
        (*this)[KEY_WRITE_TIMEOUT_SECONDS] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setSslMode(const std::string& v) {
        (*this)[KEY_SSL_MODE] = SqlValue(v);
    }
    void ConnectionParameters::setSslCertPath(const std::string& v) {
        (*this)[KEY_SSL_CERT_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslKeyPath(const std::string& v) {
        (*this)[KEY_SSL_KEY_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslCaPath(const std::string& v) {
        (*this)[KEY_SSL_CA_PATH] = SqlValue(v);
    }
    void ConnectionParameters::setSslCipher(const std::string& v) {
        (*this)[KEY_SSL_CIPHER] = SqlValue(v);
    }
    void ConnectionParameters::setPoolMaxSize(int v) {
        (*this)[KEY_POOL_MAX_SIZE] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setPoolMinSize(int v) {
        (*this)[KEY_POOL_MIN_SIZE] = SqlValue(static_cast<int32_t>(v));
    }
    void ConnectionParameters::setPoolAcquireTimeoutMs(long long v) {
        (*this)[KEY_POOL_ACQUIRE_TIMEOUT_MS] = SqlValue(static_cast<int64_t>(v));
    }
    void ConnectionParameters::setPoolConnectionLifetimeMs(long long v) {
        (*this)[KEY_POOL_CONNECTION_LIFETIME_MS] = SqlValue(static_cast<int64_t>(v));
    }
    void ConnectionParameters::setPoolIdleTimeoutMs(long long v) {
        (*this)[KEY_POOL_IDLE_TIMEOUT_MS] = SqlValue(static_cast<int64_t>(v));
    }

    // Getters (实现 - 使用模板的 get<T>)
    std::optional<std::string> ConnectionParameters::driverType() const {
        return get<std::string>(KEY_DRIVER_TYPE);
    }
    std::optional<std::string> ConnectionParameters::dbName() const {
        return get<std::string>(KEY_DB_NAME);
    }
    std::optional<std::string> ConnectionParameters::userName() const {
        return get<std::string>(KEY_USER_NAME);
    }
    std::optional<std::string> ConnectionParameters::password() const {
        return get<std::string>(KEY_PASSWORD);
    }
    std::optional<std::string> ConnectionParameters::hostName() const {
        return get<std::string>(KEY_HOST_NAME);
    }
    std::optional<int> ConnectionParameters::port() const {
        return get<int>(KEY_PORT);
    }
    std::optional<std::string> ConnectionParameters::connectOptions() const {
        return get<std::string>(KEY_CONNECT_OPTIONS);
    }
    std::optional<std::string> ConnectionParameters::clientCharset() const {
        return get<std::string>(KEY_CLIENT_CHARSET);
    }
    std::optional<std::string> ConnectionParameters::applicationName() const {
        return get<std::string>(KEY_APPLICATION_NAME);
    }
    std::optional<int> ConnectionParameters::connectionTimeoutSeconds() const {
        return get<int>(KEY_CONNECTION_TIMEOUT_SECONDS);
    }
    std::optional<int> ConnectionParameters::readTimeoutSeconds() const {
        return get<int>(KEY_READ_TIMEOUT_SECONDS);
    }
    std::optional<int> ConnectionParameters::writeTimeoutSeconds() const {
        return get<int>(KEY_WRITE_TIMEOUT_SECONDS);
    }
    std::optional<std::string> ConnectionParameters::sslMode() const {
        return get<std::string>(KEY_SSL_MODE);
    }
    std::optional<std::string> ConnectionParameters::sslCertPath() const {
        return get<std::string>(KEY_SSL_CERT_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslKeyPath() const {
        return get<std::string>(KEY_SSL_KEY_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslCaPath() const {
        return get<std::string>(KEY_SSL_CA_PATH);
    }
    std::optional<std::string> ConnectionParameters::sslCipher() const {
        return get<std::string>(KEY_SSL_CIPHER);
    }
    std::optional<int> ConnectionParameters::poolMaxSize() const {
        return get<int>(KEY_POOL_MAX_SIZE);
    }
    std::optional<int> ConnectionParameters::poolMinSize() const {
        return get<int>(KEY_POOL_MIN_SIZE);
    }
    std::optional<long long> ConnectionParameters::poolAcquireTimeoutMs() const {
        return get<long long>(KEY_POOL_ACQUIRE_TIMEOUT_MS);
    }
    std::optional<long long> ConnectionParameters::poolConnectionLifetimeMs() const {
        return get<long long>(KEY_POOL_CONNECTION_LIFETIME_MS);
    }
    std::optional<long long> ConnectionParameters::poolIdleTimeoutMs() const {
        return get<long long>(KEY_POOL_IDLE_TIMEOUT_MS);
    }

}  // namespace cpporm_sqldriver// cpporm/session.h
#ifndef cpporm_SESSION_H
#define cpporm_SESSION_H

// 核心 Session 类定义（非模板成员，模板成员声明）
#include "cpporm/session_core.h"

// 简单模板化 CRUD 便捷函数的实现
#include "cpporm/session_crud_ops.h"

// CreateBatch 模板函数的实现
#include "cpporm/session_batch_ops.h"

// 如果将来有其他可分离的模板操作组，可以继续添加：
// #include "cpporm/session_preload_ops.h"
// #include "cpporm/session_advanced_query_ops.h"

#endif // cpporm_SESSION_H#ifndef cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H
#define cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H

#include "cpporm/builder_parts/query_builder_conditions_mixin.h" // << 需要 wrap_for_query_value
#include "cpporm/builder_parts/query_builder_state.h"
#include <algorithm>
#include <initializer_list>
#include <set>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

namespace cpporm {

template <typename Derived> class QueryBuilderClausesMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

private:
  // 内部辅助函数：重置（清空）选择字段列表
  void reset_select_fields() { _state().select_fields_.clear(); }

  // 当添加具体的选择项时，如果当前仅有默认的 "*" 选择，则清除它
  void clear_default_select_if_adding_specifics() {
    if (_state().select_fields_.size() == 1 &&
        std::holds_alternative<std::string>(_state().select_fields_[0]) &&
        std::get<std::string>(_state().select_fields_[0]) == "*") {
      _state().select_fields_.clear();
    }
  }

  // 如果选择字段列表为空，则恢复为默认的 "*"
  void restore_default_select_if_empty() {
    if (_state().select_fields_.empty()) {
      _state().select_fields_.push_back(std::string("*"));
    }
  }

  // 内部辅助函数：添加一个选择字段变体到列表（不清除现有）
  // 主要用于公共 Select 方法内部，或者 AddSelect 方法
  void add_select_field_variant(SelectField field_variant) {
    bool found = false;
    if (std::holds_alternative<std::string>(field_variant)) {
      const std::string &field_str_to_add =
          std::get<std::string>(field_variant);
      if (field_str_to_add.empty())
        return;
      // DISTINCT 关键字不应通过 Select 添加，而是通过 Distinct() 方法
      // std::string temp_check_str = field_str_to_add;
      // std::transform(temp_check_str.begin(), temp_check_str.end(),
      //                temp_check_str.begin(), ::tolower);
      // if (temp_check_str == "distinct" && _state().apply_distinct_) {
      //   return; // Distinct() 方法已处理
      // }

      for (const auto &existing_field : _state().select_fields_) {
        if (std::holds_alternative<std::string>(existing_field) &&
            std::get<std::string>(existing_field) == field_str_to_add) {
          found = true; // 简单字符串去重
          break;
        }
      }
    } else if (std::holds_alternative<NamedSubqueryField>(field_variant)) {
      // 子查询通常不基于字符串内容去重，它们的别名可能不同
    }

    if (!found) {
      _state().select_fields_.push_back(std::move(field_variant));
    }
  }

  std::string trim_field_string(const std::string &field_str_with_spaces) {
    size_t first = field_str_with_spaces.find_first_not_of(" \t\n\r\f\v");
    if (std::string::npos == first)
      return "";
    size_t last = field_str_with_spaces.find_last_not_of(" \t\n\r\f\v");
    return field_str_with_spaces.substr(first, (last - first + 1));
  }

public:
  // Select 方法：这些方法应该 *替换* 当前的选择列表
  Derived &Select(const std::string &fields_string) {
    reset_select_fields(); // 清除所有之前的选择项
    std::string temp_field_str;
    std::stringstream ss(fields_string);
    while (std::getline(ss, temp_field_str, ',')) {
      std::string trimmed_field = trim_field_string(temp_field_str);
      if (!trimmed_field.empty()) {
        add_select_field_variant(trimmed_field); // 添加新的选择项
      }
    }
    restore_default_select_if_empty(); // 如果最终列表为空，恢复为 "*"
    return static_cast<Derived &>(*this);
  }

  Derived &Select(const std::vector<std::string> &fields_list) {
    reset_select_fields(); // 清除所有之前的选择项
    if (!fields_list.empty()) {
      for (const auto &field_str : fields_list) {
        std::string trimmed_field = trim_field_string(field_str);
        if (!trimmed_field.empty()) {
          add_select_field_variant(trimmed_field);
        }
      }
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  Derived &Select(std::initializer_list<std::string_view> fields_il) {
    reset_select_fields(); // 清除所有之前的选择项
    if (fields_il.size() > 0) {
      for (std::string_view sv : fields_il) {
        std::string trimmed_field = trim_field_string(std::string(sv));
        if (!trimmed_field.empty()) {
          add_select_field_variant(trimmed_field);
        }
      }
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  template <
      typename... Args,
      std::enable_if_t<
          std::conjunction_v<std::is_convertible<Args, std::string_view>...>,
          int> = 0>
  Derived &Select(std::string_view first_field, Args &&...rest_fields) {
    reset_select_fields(); // 清除所有之前的选择项
    std::string trimmed_first = trim_field_string(std::string(first_field));
    if (!trimmed_first.empty()) {
      add_select_field_variant(trimmed_first);
    }
    if constexpr (sizeof...(Args) > 0) {
      (
          (void)[&] {
            std::string trimmed_rest =
                trim_field_string(std::string(std::forward<Args>(rest_fields)));
            if (!trimmed_rest.empty()) {
              add_select_field_variant(trimmed_rest);
            }
          }(),
          ...);
    }
    restore_default_select_if_empty();
    return static_cast<Derived &>(*this);
  }

  // AddSelect 方法：这些方法 *追加* 到当前的选择列表
  Derived &AddSelect(const std::string &field_or_expr_string) {
    clear_default_select_if_adding_specifics(); // 如果当前仅为 "*", 则清除
    std::string trimmed_field = trim_field_string(field_or_expr_string);
    if (!trimmed_field.empty()) {
      add_select_field_variant(trimmed_field);
    }
    // restore_default_select_if_empty(); // AddSelect 不应该在添加后恢复为 "*",
    // 除非列表在清除 "*" 后仍为空
    if (_state().select_fields_.empty() &&
        field_or_expr_string
            .empty()) { // 仅当添加了一个空字符串且原先是*时才恢复
      restore_default_select_if_empty();
    } else if (_state().select_fields_.empty() &&
               !field_or_expr_string.empty()) {
      // 如果添加了有效字段后列表仍为空（理论上不应该，除非
      // add_select_field_variant 有bug），
      // 或者就是想添加一个有效的，那么不应该恢复为 *
    } else if (_state()
                   .select_fields_
                   .empty()) { // 最终如果还是空的（比如只添加了空字符串）
      restore_default_select_if_empty();
    }

    return static_cast<Derived &>(*this);
  }

  Derived &AddSelect(const NamedSubqueryField &subquery_field) {
    clear_default_select_if_adding_specifics();
    add_select_field_variant(subquery_field);
    // restore_default_select_if_empty(); // 同上，AddSelect 不应轻易恢复为 "*"
    if (_state().select_fields_.empty()) {
      restore_default_select_if_empty();
    }
    return static_cast<Derived &>(*this);
  }
  Derived &AddSelect(
      NamedSubqueryField &&subquery_field) { // Rvalue overload for efficiency
    clear_default_select_if_adding_specifics();
    add_select_field_variant(std::move(subquery_field));
    if (_state().select_fields_.empty()) {
      restore_default_select_if_empty();
    }
    return static_cast<Derived &>(*this);
  }

  Derived &Distinct(bool apply = true) {
    _state().apply_distinct_ = apply;
    return static_cast<Derived &>(*this);
  }

  Derived &Order(const std::string &order_string) {
    _state().order_clause_ = order_string;
    return static_cast<Derived &>(*this);
  }

  Derived &Limit(int limit_val_param) {
    _state().limit_val_ = limit_val_param;
    return static_cast<Derived &>(*this);
  }

  Derived &Offset(int offset_val_param) {
    _state().offset_val_ = offset_val_param;
    return static_cast<Derived &>(*this);
  }

  Derived &Group(const std::string &group_string) {
    _state().group_clause_ = group_string;
    return static_cast<Derived &>(*this);
  }

  // --- Having 方法 ---
  Derived &Having(const std::string &query_str,
                  const std::vector<QueryValue> &args) {
    _state().having_condition_ = std::make_unique<Condition>(query_str, args);
    return static_cast<Derived &>(*this);
  }

  Derived &Having(const std::string &query_str) {
    _state().having_condition_ =
        std::make_unique<Condition>(query_str, std::vector<QueryValue>{});
    return static_cast<Derived &>(*this);
  }

  Derived &Having(const std::string &query_str,
                  std::initializer_list<QueryValue> il) {
    _state().having_condition_ = std::make_unique<Condition>(query_str, il);
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value,
                int> = 0>
  Derived &Having(const std::string &query_str, T &&val1,
                  TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(wrap_for_query_value(std::forward<T>(val1)));
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back(
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().having_condition_ =
        std::make_unique<Condition>(query_str, std::move(collected_args));
    return static_cast<Derived &>(*this);
  }
  // --- 结束 Having 方法 ---

  const std::string &getOrderClause_mixin() const {
    return _state().order_clause_;
  }
  int getLimitVal_mixin() const { return _state().limit_val_; }
  int getOffsetVal_mixin() const { return _state().offset_val_; }
  const std::string &getGroupClause_mixin() const {
    return _state().group_clause_;
  }
  const Condition *getHavingCondition_mixin() const {
    return _state().having_condition_ ? &(*_state().having_condition_)
                                      : nullptr;
  }
  bool isDistinctApplied_mixin() const { return _state().apply_distinct_; }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_CLAUSES_MIXIN_H#ifndef cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H
#define cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/error.h"
#include <expected>

#include <initializer_list>
#include <iterator>
#include <map>
#include <string>
#include <type_traits>
#include <vector>

#ifdef QT_CORE_LIB
#include <QDebug>
#endif

// Forward declare QueryBuilder for wrap_for_query_value and quoteSqlIdentifier
namespace cpporm {
class QueryBuilder;
}

namespace cpporm {

namespace detail {
template <typename T> struct is_std_initializer_list : std::false_type {};
template <typename E>
struct is_std_initializer_list<std::initializer_list<E>> : std::true_type {};
} // namespace detail

// Modified wrap_for_query_value
template <typename Arg>
QueryValue wrap_for_query_value(Arg &&arg) { // Explicitly return QueryValue
  using DecayedArg = std::decay_t<Arg>;
  if constexpr (std::is_same_v<DecayedArg, const char *> ||
                (std::is_array_v<DecayedArg> &&
                 std::is_same_v<std::remove_extent_t<DecayedArg>,
                                const char>)) {
    return std::string(std::forward<Arg>(arg));
  } else if constexpr (std::is_same_v<DecayedArg, SubqueryExpression>) {
    return std::forward<Arg>(arg);
  } else if constexpr (std::is_base_of_v<QueryBuilder, DecayedArg> ||
                       std::is_same_v<DecayedArg, QueryBuilder>) {
    // If 'arg' is a QueryBuilder (or derived from it), convert it to
    // SubqueryExpression. This requires QueryBuilder::AsSubquery() to be
    // accessible. We need to include "cpporm/query_builder_core.h" for
    // QueryBuilder::AsSubquery, or ensure QueryBuilder is fully defined. This
    // creates a dependency cycle risk if QueryBuilderCore includes this file.
    // A common pattern is to have QueryBuilder::AsSubquery() defined where
    // QueryBuilder is complete. For now, assume 'arg.AsSubquery()' is callable.
    auto sub_expr_expected = arg.AsSubquery();
    if (sub_expr_expected.has_value()) {
      return sub_expr_expected.value();
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "wrap_for_query_value: Failed to convert QueryBuilder to "
                    "SubqueryExpression: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Returning nullptr for QueryValue.";
#endif
      return nullptr;
    }
  } else if constexpr (std::is_constructible_v<QueryValue, DecayedArg>) {
    return QueryValue(
        std::forward<Arg>(arg)); // Explicit construction for QueryValue
  } else {
    // Default forwarding for types directly convertible to one of QueryValue's
    // alternatives If this also fails, it will be a variant construction error.
    return std::forward<Arg>(arg);
  }
}

template <typename Derived> class QueryBuilderConditionsMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  // --- WHERE methods ---
  Derived &Where(const std::string &query_string) {
    _state().where_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 const std::vector<QueryValue> &args) {
    _state().where_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 std::vector<QueryValue> &&args) {
    _state().where_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::string &query_string,
                 std::initializer_list<QueryValue> il) {
    _state().where_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Where(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().where_conditions_.insert(_state().where_conditions_.end(),
                                      std::make_move_iterator(mc.begin()),
                                      std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }

  Derived &
  Where(const std::string &query_string,
        const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().where_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Where(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Where(const std::string &query_string, T &&val1,
                 TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed to push_back
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed to push_back
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().where_conditions_.emplace_back(query_string,
                                            std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- OR methods --- (Similar structure to Where)
  Derived &Or(const std::string &query_string) {
    _state().or_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string,
              const std::vector<QueryValue> &args) {
    _state().or_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string, std::vector<QueryValue> &&args) {
    _state().or_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::string &query_string,
              std::initializer_list<QueryValue> il) {
    _state().or_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Or(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().or_conditions_.insert(_state().or_conditions_.end(),
                                   std::make_move_iterator(mc.begin()),
                                   std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }
  Derived &
  Or(const std::string &query_string,
     const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().or_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Or(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Or(const std::string &query_string, T &&val1, TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().or_conditions_.emplace_back(query_string,
                                         std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- NOT methods --- (Similar structure to Where)
  Derived &Not(const std::string &query_string) {
    _state().not_conditions_.emplace_back(query_string);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               const std::vector<QueryValue> &args) {
    _state().not_conditions_.emplace_back(query_string, args);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               std::vector<QueryValue> &&args) {
    _state().not_conditions_.emplace_back(query_string, std::move(args));
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::string &query_string,
               std::initializer_list<QueryValue> il) {
    _state().not_conditions_.emplace_back(query_string, il);
    return static_cast<Derived &>(*this);
  }
  Derived &Not(const std::map<std::string, QueryValue> &conditions) {
    auto mc = mapToConditions(conditions);
    _state().not_conditions_.insert(_state().not_conditions_.end(),
                                    std::make_move_iterator(mc.begin()),
                                    std::make_move_iterator(mc.end()));
    return static_cast<Derived &>(*this);
  }
  Derived &
  Not(const std::string &query_string,
      const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
    if (sub_expr_expected.has_value()) {
      _state().not_conditions_.emplace_back(
          query_string, std::vector<QueryValue>{sub_expr_expected.value()});
    } else {
#ifdef QT_CORE_LIB
      qWarning() << "QueryBuilderConditionsMixin::Not(string, "
                    "expected<Subquery>): Subquery generation failed: "
                 << QString::fromStdString(sub_expr_expected.error().message)
                 << ". Condition based on this subquery will not be added.";
#endif
    }
    return static_cast<Derived &>(*this);
  }

  template <typename T, typename... TArgs,
            std::enable_if_t<
                !std::is_same_v<std::decay_t<T>, std::vector<QueryValue>> &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::map<std::string, QueryValue>> &&
                    !detail::is_std_initializer_list<std::decay_t<T>>::value &&
                    !std::is_same_v<std::decay_t<T>,
                                    std::expected<SubqueryExpression, Error>>,
                int> = 0>
  Derived &Not(const std::string &query_string, T &&val1,
               TArgs &&...vals_rest) {
    std::vector<QueryValue> collected_args;
    collected_args.reserve(1 + sizeof...(TArgs));
    collected_args.push_back(
        wrap_for_query_value(std::forward<T>(val1))); // Changed
    if constexpr (sizeof...(TArgs) > 0) {
      (collected_args.push_back( // Changed
           wrap_for_query_value(std::forward<TArgs>(vals_rest))),
       ...);
    }
    _state().not_conditions_.emplace_back(query_string,
                                          std::move(collected_args));
    return static_cast<Derived &>(*this);
  }

  // --- IN methods ---
  // Takes a vector of QueryValue directly
  Derived &In(const std::string &column_name,
              const std::vector<QueryValue> &values) {
    if (values.empty()) {
      // For an empty IN list, "1 = 0" ensures no rows are matched.
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }

    std::string placeholders;
    placeholders.reserve(values.size() * 3); // Approximate size for "?, ?, ?"
    for (size_t i = 0; i < values.size(); ++i) {
      placeholders += (i == 0 ? "?" : ", ?");
    }

    // QueryBuilder::quoteSqlIdentifier is a public static method
    // This creates a circular dependency if QueryBuilder needs this header.
    // For now, assuming QueryBuilder is defined before this, or
    // quoteSqlIdentifier is moved/forwarded. Let's assume
    // `static_cast<Derived*>(this)->quoteSqlIdentifier()` exists or a global
    // one. For simplicity, we will call a static method assumed to be
    // available.
    // **This means QueryBuilder must be fully defined before this header, or a
    // static helper for quoting must be in a common place.** The easiest is
    // that QueryBuilder.h includes this.
    std::string quoted_column =
        static_cast<Derived *>(this)->quoteSqlIdentifier(
            column_name); // Calling through Derived
    _state().where_conditions_.emplace_back(
        quoted_column + " IN (" + placeholders + ")", values);
    return static_cast<Derived &>(*this);
  }

  Derived &In(const std::string &column_name,
              std::vector<QueryValue> &&values) {
    if (values.empty()) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::string placeholders;
    placeholders.reserve(values.size() * 3);
    for (size_t i = 0; i < values.size(); ++i) {
      placeholders += (i == 0 ? "?" : ", ?");
    }
    std::string quoted_column =
        static_cast<Derived *>(this)->quoteSqlIdentifier(column_name);
    _state().where_conditions_.emplace_back(
        quoted_column + " IN (" + placeholders + ")", std::move(values));
    return static_cast<Derived &>(*this);
  }

  // Templated version for convenience, taking a vector of arbitrary types
  template <typename T>
  Derived &In(const std::string &column_name, const std::vector<T> &values) {
    if (values.empty()) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::vector<QueryValue> qv_values;
    qv_values.reserve(values.size());
    for (const auto &val : values) {
      qv_values.push_back(
          wrap_for_query_value(val)); // Use existing wrap_for_query_value
    }
    return In(column_name,
              std::move(qv_values)); // Delegate to QueryValue vector overload
  }

  // Overload for initializer_list<QueryValue>
  Derived &In(const std::string &column_name,
              std::initializer_list<QueryValue> il) {
    // Create a vector from the initializer_list to reuse the vector overload
    return In(column_name, std::vector<QueryValue>(il.begin(), il.end()));
  }

  // Templated version for initializer_list<T> where T is not QueryValue
  template <
      typename T,
      std::enable_if_t<!std::is_same_v<std::decay_t<T>, QueryValue> &&
                           !std::is_same_v<std::decay_t<T>, SubqueryExpression>,
                       int> = 0>
  Derived &In(const std::string &column_name, std::initializer_list<T> il) {
    if (il.size() == 0) {
      _state().where_conditions_.emplace_back("1 = 0");
      return static_cast<Derived &>(*this);
    }
    std::vector<QueryValue> qv_values;
    qv_values.reserve(il.size());
    for (const T &val : il) {
      qv_values.push_back(wrap_for_query_value(val));
    }
    return In(column_name, std::move(qv_values)); // Delegate
  }

  const std::vector<Condition> &getWhereConditions_mixin() const {
    return _state().where_conditions_;
  }
  const std::vector<Condition> &getOrConditions_mixin() const {
    return _state().or_conditions_;
  }
  const std::vector<Condition> &getNotConditions_mixin() const {
    return _state().not_conditions_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_CONDITIONS_MIXIN_H#ifndef cpporm_QUERY_BUILDER_JOINS_MIXIN_H
#define cpporm_QUERY_BUILDER_JOINS_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState, JoinClause
#include <QDebug>    // For qWarning (optional, for join parsing warning)
#include <algorithm> // For std::transform
#include <string>
#include <vector>

namespace cpporm {

template <typename Derived> class QueryBuilderJoinsMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  Derived &Joins(const std::string &join_str) {
    std::string upper_join = join_str;
    // Ensure cpporm namespace for toupper or use ::toupper
    std::transform(upper_join.begin(), upper_join.end(), upper_join.begin(),
                   [](unsigned char c) { return std::toupper(c); });

    if (upper_join.rfind("LEFT JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("LEFT", "", join_str);
    } else if (upper_join.rfind("RIGHT JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("RIGHT", "", join_str);
    } else if (upper_join.rfind("INNER JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("INNER", "", join_str);
    } else if (upper_join.rfind("FULL JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back("FULL", "", join_str);
    } else if (upper_join.rfind("JOIN ", 0) == 0) {
      _state().join_clauses_.emplace_back(
          "INNER", "", join_str); // Default JOIN is usually INNER
    } else {
// qWarning() is a Qt function, ensure QDebug is included if used.
// For a library, consider a more generic logging/warning mechanism or none
// here.
#if defined(QT_CORE_LIB) // Only use qWarning if Qt is available
      qWarning() << "cpporm QueryBuilder::JoinsMixin: Could not determine "
                    "explicit join type from '"
                 << join_str.c_str() << "'. Storing as raw fragment.";
#endif
      _state().join_clauses_.emplace_back(
          "", "", join_str); // Empty type, just the raw string
    }
    return static_cast<Derived &>(*this);
  }

  Derived &InnerJoin(const std::string &table,
                     const std::string &on_condition) {
    _state().join_clauses_.emplace_back("INNER", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  Derived &LeftJoin(const std::string &table, const std::string &on_condition) {
    _state().join_clauses_.emplace_back("LEFT", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  Derived &RightJoin(const std::string &table,
                     const std::string &on_condition) {
    _state().join_clauses_.emplace_back("RIGHT", table, on_condition);
    return static_cast<Derived &>(*this);
  }

  // Accessor
  const std::vector<JoinClause> &getJoinClauses_mixin() const {
    return _state().join_clauses_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_JOINS_MIXIN_H#ifndef cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H
#define cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState, PreloadRequest
#include <string>
#include <vector> // For state_.preload_requests_

namespace cpporm {

template <typename Derived> class QueryBuilderPreloadMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  // Simple Preload by association C++ field name.
  // GORM also supports Preload("Orders.OrderItems") for nested preloading,
  // and Preload("Orders", func(db *gorm.DB) *gorm.DB { ... }) for conditional
  // preloading. We'll start with the basic form.
  Derived &Preload(const std::string &association_cpp_field_name) {
    // TODO: Add support for dot-separated nested preload paths if needed.
    // For now, assume association_cpp_field_name is a direct association of the
    // current model.
    _state().preload_requests_.emplace_back(association_cpp_field_name);
    return static_cast<Derived &>(*this);
  }

  // Accessor for preload requests (mainly for Session to use)
  const std::vector<PreloadRequest> &getPreloadRequests_mixin() const {
    return _state().preload_requests_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_PRELOAD_MIXIN_H#ifndef cpporm_QUERY_BUILDER_SCOPES_MIXIN_H
#define cpporm_QUERY_BUILDER_SCOPES_MIXIN_H

#include "cpporm/builder_parts/query_builder_state.h" // For QueryBuilderState

namespace cpporm {

template <typename Derived> class QueryBuilderScopesMixin {
protected:
  QueryBuilderState &_state() {
    return static_cast<Derived *>(this)->getState_();
  }
  const QueryBuilderState &_state() const {
    return static_cast<const Derived *>(this)->getState_();
  }

public:
  Derived &Unscoped() {
    _state().apply_soft_delete_scope_ = false;
    // Potentially disable other default scopes here if they are added
    return static_cast<Derived &>(*this);
  }

  bool isSoftDeleteScopeActive_mixin() const {
    return _state().apply_soft_delete_scope_;
  }
};

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_SCOPES_MIXIN_H#ifndef cpporm_QUERY_BUILDER_STATE_H
#define cpporm_QUERY_BUILDER_STATE_H

#include "cpporm/model_base.h"
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QString>
#include <QTime>
#include <QVariant>

#include <map>
#include <memory>
#include <set>
#include <string>
#include <variant>
#include <vector>

namespace cpporm {

// 用于子查询绑定的 QueryValue 变体 (不包含 SubqueryExpression 自身以避免递归)
using QueryValueVariantForSubquery =
    std::variant<std::nullptr_t, int, long long, double, std::string, bool,
                 QDateTime, QDate, QTime, QByteArray>;

// 表示子查询表达式的结构体
struct SubqueryExpression {
  std::string sql_string;                             // 子查询的 SQL 语句
  std::vector<QueryValueVariantForSubquery> bindings; // 子查询的绑定参数

  // 构造函数
  SubqueryExpression(std::string s,
                     std::vector<QueryValueVariantForSubquery> b = {})
      : sql_string(std::move(s)), bindings(std::move(b)) {}

  // 默认的拷贝和移动语义
  SubqueryExpression(const SubqueryExpression &) = default;
  SubqueryExpression &operator=(const SubqueryExpression &) = default;
  SubqueryExpression(SubqueryExpression &&) = default;
  SubqueryExpression &operator=(SubqueryExpression &&) = default;
};

// 表示查询中参数值的类型 (std::variant 允许多种类型)
// 新增: 将 SubqueryExpression 作为 QueryValue 的一个可能类型
using QueryValue =
    std::variant<std::nullptr_t, int, long long, double, std::string, bool,
                 QDateTime, QDate, QTime, QByteArray, SubqueryExpression>;

// 表示查询条件的结构体 (例如 WHERE, HAVING 中的条件)
struct Condition {
  std::string query_string;     // 条件的 SQL 片段 (例如 "age > ?")
  std::vector<QueryValue> args; // 条件的绑定参数

  // 构造函数
  Condition(std::string qs, std::vector<QueryValue> a = {})
      : query_string(std::move(qs)), args(std::move(a)) {}
};

// 表示 JOIN 子句的结构体
struct JoinClause {
  std::string join_type;     // JOIN 类型 (例如 "INNER", "LEFT")
  std::string table_to_join; // 要连接的表名
  std::string on_condition;  // JOIN 的 ON 条件

  // 构造函数
  JoinClause(std::string type, std::string table, std::string on)
      : join_type(std::move(type)), table_to_join(std::move(table)),
        on_condition(std::move(on)) {}
};

// 表示预加载请求的结构体
struct PreloadRequest {
  std::string association_cpp_field_name; // 要预加载的关联字段的 C++ 名称

  // 构造函数
  explicit PreloadRequest(std::string name)
      : association_cpp_field_name(std::move(name)) {}
};

// 定义 ON CONFLICT (或 ON DUPLICATE KEY UPDATE) 子句的状态
struct OnConflictClause {
  enum class Action {
    DoNothing, // 例如 PostgreSQL 的 DO NOTHING 或 MySQL 的 INSERT IGNORE
    UpdateAllExcluded, // 更新所有非主键列为新插入的值 (MySQL: VALUES(col))
    UpdateSpecific     // 更新指定的列
  };

  Action action = Action::DoNothing; // 默认操作
  std::vector<std::string>
      conflict_target_columns_db_names; // 冲突目标列 (主要用于 PostgreSQL)
  std::map<std::string, QueryValue>
      update_assignments; // 指定更新时的列名和值映射

  // 构造函数
  OnConflictClause(Action act = Action::DoNothing) : action(act) {}
  // 默认的拷贝和移动语义
  OnConflictClause(const OnConflictClause &other) = default;
  OnConflictClause(OnConflictClause &&other) noexcept = default;
  OnConflictClause &operator=(const OnConflictClause &other) = default;
  OnConflictClause &operator=(OnConflictClause &&other) noexcept = default;
};

// 表示一个 Common Table Expression (CTE) 的状态
struct CTEState {
  std::string name;         // CTE 的名称
  SubqueryExpression query; // CTE 的定义查询 (使用 SubqueryExpression 结构)
  bool recursive = false;   // CTE 是否是递归的

  CTEState(std::string n, SubqueryExpression q, bool rec = false)
      : name(std::move(n)), query(std::move(q)), recursive(rec) {}

  // 默认的拷贝和移动语义
  CTEState(const CTEState &other) = default;
  CTEState(CTEState &&other) noexcept = default;
  CTEState &operator=(const CTEState &other) = default;
  CTEState &operator=(CTEState &&other) noexcept = default;
};

// --- New structures for enhanced subquery support ---
struct SubquerySource {
  SubqueryExpression subquery;
  std::string alias;

  SubquerySource(SubqueryExpression sq, std::string a)
      : subquery(std::move(sq)), alias(std::move(a)) {}
  // Default copy/move
  SubquerySource(const SubquerySource &) = default;
  SubquerySource &operator=(const SubquerySource &) = default;
  SubquerySource(SubquerySource &&) = default;
  SubquerySource &operator=(SubquerySource &&) = default;
};

// Represents the source for a FROM clause (either a table name or a subquery
// with an alias)
using FromClauseSource =
    std::variant<std::string /* table_name */, SubquerySource>;

struct NamedSubqueryField {
  SubqueryExpression subquery;
  std::string alias;

  NamedSubqueryField(SubqueryExpression sq, std::string a)
      : subquery(std::move(sq)), alias(std::move(a)) {}
  // Default copy/move
  NamedSubqueryField(const NamedSubqueryField &) = default;
  NamedSubqueryField &operator=(const NamedSubqueryField &) = default;
  NamedSubqueryField(NamedSubqueryField &&) = default;
  NamedSubqueryField &operator=(NamedSubqueryField &&) = default;
};

// Represents a field in the SELECT list (either a string or a named subquery)
using SelectField = std::variant<std::string /* field_name_or_expression */,
                                 NamedSubqueryField>;
// --- End of new structures ---

// QueryBuilder 的内部状态结构体, 存储所有查询构建部分
struct QueryBuilderState {
  const ModelMeta *model_meta_ = nullptr; // 指向当前操作模型的元数据
  FromClauseSource from_clause_source_{
      std::string("")}; // Default to empty table name string

  // 条件子句
  std::vector<Condition> where_conditions_; // WHERE 条件列表
  std::vector<Condition> or_conditions_;    // OR 条件列表
  std::vector<Condition> not_conditions_; // NOT 条件列表 (通常包装一组AND条件)

  // SELECT 子句相关
  std::vector<SelectField> select_fields_{
      std::string("*")};        // 要选择的字段列表 (默认 "*")
  bool apply_distinct_ = false; // 新增: 是否在 SELECT 后应用 DISTINCT

  std::string order_clause_;                    // ORDER BY 子句
  int limit_val_ = -1;                          // LIMIT 值 (-1 表示无限制)
  int offset_val_ = -1;                         // OFFSET 值 (-1 表示无偏移)
  std::string group_clause_;                    // GROUP BY 子句
  std::unique_ptr<Condition> having_condition_; // HAVING 条件

  // JOIN 子句
  std::vector<JoinClause> join_clauses_; // JOIN 子句列表

  // 预加载
  std::vector<PreloadRequest> preload_requests_; // 预加载请求列表

  // 作用域控制
  bool apply_soft_delete_scope_ = true; // 是否应用软删除作用域 (默认是)

  // OnConflict 子句
  std::unique_ptr<OnConflictClause> on_conflict_clause_; // ON CONFLICT 子句状态

  // Common Table Expressions (CTEs)
  std::vector<CTEState> ctes_; // WITH 子句列表

  // 默认构造函数
  QueryBuilderState() = default;

  // 拷贝构造函数 (深拷贝)
  QueryBuilderState(const QueryBuilderState &other)
      : model_meta_(other.model_meta_),
        from_clause_source_(other.from_clause_source_),
        where_conditions_(other.where_conditions_),
        or_conditions_(other.or_conditions_),
        not_conditions_(other.not_conditions_),
        select_fields_(other.select_fields_),
        apply_distinct_(other.apply_distinct_), // 拷贝 apply_distinct_
        order_clause_(other.order_clause_), limit_val_(other.limit_val_),
        offset_val_(other.offset_val_), group_clause_(other.group_clause_),
        join_clauses_(other.join_clauses_),
        preload_requests_(other.preload_requests_),
        apply_soft_delete_scope_(other.apply_soft_delete_scope_),
        ctes_(other.ctes_) {
    if (other.having_condition_) {
      having_condition_ = std::make_unique<Condition>(*other.having_condition_);
    }
    if (other.on_conflict_clause_) {
      on_conflict_clause_ =
          std::make_unique<OnConflictClause>(*other.on_conflict_clause_);
    }
  }

  // 移动构造函数
  QueryBuilderState(QueryBuilderState &&other) noexcept
      : model_meta_(other.model_meta_),
        from_clause_source_(std::move(other.from_clause_source_)),
        where_conditions_(std::move(other.where_conditions_)),
        or_conditions_(std::move(other.or_conditions_)),
        not_conditions_(std::move(other.not_conditions_)),
        select_fields_(std::move(other.select_fields_)),
        apply_distinct_(other.apply_distinct_), // 移动 apply_distinct_
        order_clause_(std::move(other.order_clause_)),
        limit_val_(other.limit_val_), offset_val_(other.offset_val_),
        group_clause_(std::move(other.group_clause_)),
        having_condition_(std::move(other.having_condition_)),
        join_clauses_(std::move(other.join_clauses_)),
        preload_requests_(std::move(other.preload_requests_)),
        apply_soft_delete_scope_(other.apply_soft_delete_scope_),
        on_conflict_clause_(std::move(other.on_conflict_clause_)),
        ctes_(std::move(other.ctes_)) {
    other.model_meta_ = nullptr;
    other.limit_val_ = -1;
    other.offset_val_ = -1;
    other.apply_distinct_ = false; // 重置源对象的 apply_distinct_
  }

  // 拷贝赋值运算符
  QueryBuilderState &operator=(const QueryBuilderState &other) {
    if (this == &other)
      return *this;

    model_meta_ = other.model_meta_;
    from_clause_source_ = other.from_clause_source_;
    where_conditions_ = other.where_conditions_;
    or_conditions_ = other.or_conditions_;
    not_conditions_ = other.not_conditions_;
    select_fields_ = other.select_fields_;
    apply_distinct_ = other.apply_distinct_; // 赋值 apply_distinct_
    order_clause_ = other.order_clause_;
    limit_val_ = other.limit_val_;
    offset_val_ = other.offset_val_;
    group_clause_ = other.group_clause_;
    if (other.having_condition_) {
      having_condition_ = std::make_unique<Condition>(*other.having_condition_);
    } else {
      having_condition_.reset();
    }
    join_clauses_ = other.join_clauses_;
    preload_requests_ = other.preload_requests_;
    apply_soft_delete_scope_ = other.apply_soft_delete_scope_;
    if (other.on_conflict_clause_) {
      on_conflict_clause_ =
          std::make_unique<OnConflictClause>(*other.on_conflict_clause_);
    } else {
      on_conflict_clause_.reset();
    }
    ctes_ = other.ctes_;
    return *this;
  }

  // 移动赋值运算符
  QueryBuilderState &operator=(QueryBuilderState &&other) noexcept {
    if (this == &other)
      return *this;

    model_meta_ = other.model_meta_;
    from_clause_source_ = std::move(other.from_clause_source_);
    where_conditions_ = std::move(other.where_conditions_);
    or_conditions_ = std::move(other.or_conditions_);
    not_conditions_ = std::move(other.not_conditions_);
    select_fields_ = std::move(other.select_fields_);
    apply_distinct_ = other.apply_distinct_; // 移动 apply_distinct_
    order_clause_ = std::move(other.order_clause_);
    limit_val_ = other.limit_val_;
    offset_val_ = other.offset_val_;
    group_clause_ = std::move(other.group_clause_);
    having_condition_ = std::move(other.having_condition_);
    join_clauses_ = std::move(other.join_clauses_);
    preload_requests_ = std::move(other.preload_requests_);
    apply_soft_delete_scope_ = other.apply_soft_delete_scope_;
    on_conflict_clause_ = std::move(other.on_conflict_clause_);
    ctes_ = std::move(other.ctes_);

    other.model_meta_ = nullptr;
    other.from_clause_source_ = std::string("");
    other.limit_val_ = -1;
    other.offset_val_ = -1;
    other.apply_distinct_ = false; // 重置源对象的 apply_distinct_
    return *this;
  }
};

std::vector<Condition>
mapToConditions(const std::map<std::string, QueryValue> &condition_map);

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_STATE_H#ifndef cpporm_DB_MANAGER_H
#define cpporm_DB_MANAGER_H

#include <expected>
#include <memory>
#include <string>  // 使用 std::string

#include "cpporm/error.h"
#include "cpporm_sqldriver/sql_connection_parameters.h"  // 新的连接参数
#include "cpporm_sqldriver/sql_database.h"               // 新的数据库对象
#include "cpporm_sqldriver/sql_driver_manager.h"         // 新的驱动管理器

namespace cpporm {

    struct DbConfig {
        std::string driver_type;  // 例如 "MYSQL", "PSQL", "SQLITE"
        std::string host_name = "127.0.0.1";
        int port = -1;
        std::string database_name;
        std::string user_name;
        std::string password;
        std::string connect_options;
        std::string client_charset;   // 例如 "utf8mb4"
        std::string connection_name;  // 连接名，如果为空则自动生成

        static std::string generateUniqueConnectionName() {
            static long long counter = 0;
            return "cpporm_sqldrv_conn_" + std::to_string(++counter);
        }

        cpporm_sqldriver::ConnectionParameters toDriverParameters() const {
            cpporm_sqldriver::ConnectionParameters params;
            params.setDriverType(driver_type);  // 驱动类型现在由 SqlDriverManager 处理
            params.setHostName(host_name);
            if (port > 0) {
                params.setPort(port);
            }
            params.setDbName(database_name);
            params.setUserName(user_name);
            params.setPassword(password);
            if (!connect_options.empty()) {
                params.setConnectOptions(connect_options);
            }
            // client_charset 在 SqlDatabase 打开后单独设置
            return params;
        }
    };

    class DbManager {
      public:
        DbManager() = delete;

        // openDatabase 返回 std::expected<std::string, Error>
        // connection_name 现在是 std::string
        static std::expected<std::string, Error> openDatabase(const DbConfig &config);

        // getDatabase 返回 cpporm_sqldriver::SqlDatabase
        // connection_name_str 现在是 std::string
        static cpporm_sqldriver::SqlDatabase getDatabase(const std::string &connection_name_str = cpporm_sqldriver::SqlDriverManager::defaultConnectionName());

        // closeDatabase connection_name_str 现在是 std::string
        static void closeDatabase(const std::string &connection_name_str);

        // isConnectionValid connection_name_str 现在是 std::string
        static bool isConnectionValid(const std::string &connection_name_str);
    };

}  // namespace cpporm

#endif  // cpporm_DB_MANAGER_H#ifndef cpporm_ERROR_H
#define cpporm_ERROR_H

#include <string>
#include <system_error> // For std::error_code, std::errc (potential future use)

namespace cpporm {

// 错误码枚举
enum class ErrorCode {
  Ok = 0,
  // 连接相关错误
  ConnectionFailed,
  ConnectionAlreadyOpen,
  ConnectionNotOpen,
  ConnectionInvalid,
  DriverNotFound,
  // 配置错误
  InvalidConfiguration,
  // SQL 执行错误
  QueryExecutionError,
  StatementPreparationError,
  TransactionError,
  // ORM 层面错误
  RecordNotFound,
  MappingError,
  UnsupportedFeature,
  // 其他
  InternalError,
  UnknownError,
};

// Error 结构体，用于封装错误信息
struct Error {
  ErrorCode code = ErrorCode::Ok;
  std::string message;
  int native_db_error_code = 0; // 可选的数据库原生错误码
  std::string sql_state;        // 可选的 SQLSTATE

  // 构造函数
  Error() = default;
  Error(ErrorCode c, std::string msg = "", int native_code = 0,
        std::string state = "")
      : code(c), message(std::move(msg)), native_db_error_code(native_code),
        sql_state(std::move(state)) {}

  // 检查是否为成功状态
  bool isOk() const { return code == ErrorCode::Ok; }

  // 允许在布尔上下文中使用 (if (error))
  explicit operator bool() const {
    return !isOk(); // true if there is an error
  }

  // 获取错误描述
  std::string toString() const {
    std::string err_str =
        "Error Code: " + std::to_string(static_cast<int>(code));
    if (!message.empty()) {
      err_str += ", Message: " + message;
    }
    if (native_db_error_code != 0) {
      err_str += ", DB Error: " + std::to_string(native_db_error_code);
    }
    if (!sql_state.empty()) {
      err_str += ", SQLState: " + sql_state;
    }
    return err_str;
  }
};

// 一个辅助函数，用于快速创建 Ok 状态的 Error
inline Error make_ok() { return Error(ErrorCode::Ok); }

} // namespace cpporm

#endif // cpporm_ERROR_H#ifndef cpporm_I_QUERY_EXECUTOR_H
#define cpporm_I_QUERY_EXECUTOR_H

#include "cpporm/error.h"
// 直接包含 query_builder_state.h 来获取 QueryValue 和 OnConflictClause 的定义
#include <QString>  // QVariantList 依赖 QString, QVariant 仍用于 QueryBuilder 的接口层
#include <QVariant>
#include <QVariantList>
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <vector>

#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/model_base.h"           // ModelBase, ModelMeta (ModelBase 也会包含 query_builder_state.h)
#include "cpporm_sqldriver/sql_value.h"  // 使用 SqlValue 替代 QVariant 作为原生DB交互类型

namespace cpporm {

    class QueryBuilder;  // 前向声明 QueryBuilder

    // QueryValue 和 OnConflictClause 现在通过包含 query_builder_state.h
    // 来确保其定义可见

    class IQueryExecutor {
      public:
        virtual ~IQueryExecutor() = default;

        virtual Error FirstImpl(const QueryBuilder &qb, ModelBase &result_model) = 0;

        virtual Error FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) = 0;

        // CreateImpl 返回的是 SqlValue，它比 QVariant 更接近底层驱动的值类型
        virtual std::expected<cpporm_sqldriver::SqlValue, Error> CreateImpl(const QueryBuilder &qb, ModelBase &model, const OnConflictClause *conflict_options_override) = 0;

        virtual std::expected<long long, Error> UpdatesImpl(const QueryBuilder &qb, const std::map<std::string, QueryValue> &updates) = 0;

        virtual std::expected<long long, Error> DeleteImpl(const QueryBuilder &qb) = 0;

        virtual std::expected<long long, Error> SaveImpl(const QueryBuilder &qb, ModelBase &model) = 0;

        virtual std::expected<int64_t, Error> CountImpl(const QueryBuilder &qb) = 0;
    };

}  // namespace cpporm
#endif  // cpporm_I_QUERY_EXECUTOR_H#ifndef cpporm_MODEL_H
#define cpporm_MODEL_H

#include <string>
#include <vector>
#include <any> // For generic field values, or consider std::variant
#include <map>

// Forward declaration if DB operations are directly tied to model methods
// namespace cpporm { class Database; }

namespace cpporm {

// Forward declaration for Session/DB context if models don't own a DB pointer directly
class Session; // Or class DB; (representing an active DB session/transaction context)


// A very basic concept for a model field attribute (e.g., primary key, nullable, etc.)
// This will be expanded significantly.
enum class FieldAttribute {
    None,
    PrimaryKey,
    AutoIncrement,
    NotNull,
    Unique
    // etc.
};

struct FieldDefinition {
    std::string name;
    std::string type_name; // e.g., "INT", "VARCHAR(255)" - for schema generation or reflection
    // std::type_index cpp_type; // For type checking
    std::vector<FieldAttribute> attributes;
    // Potentially default value, etc.
};


// Base class for all ORM models
class Model {
public:
    virtual ~Model() = default;

    // Method to get the table name for the model
    // GORM uses struct tags or conventions; C++ needs a different approach.
    // Pure virtual makes subclasses implement it.
    [[nodiscard]] virtual std::string getTableName() const = 0;

    // Method to get primary key field name(s)
    // For simplicity, starting with a single string, could be a vector for composite keys.
    [[nodiscard]] virtual std::string getPrimaryKeyName() const { return "id"; } // Default

    // Placeholder for getting/setting field values by name
    // This is a complex area: type safety, reflection-like capabilities.
    // virtual std::any getField(const std::string& fieldName) const = 0;
    // virtual void setField(const std::string& fieldName, const std::any& value) = 0;

    // Placeholder for schema definition, could be static or virtual
    // static virtual std::vector<FieldDefinition> defineSchema() = 0; // Static virtual not allowed
    // This needs a pattern like CRTP or a registration mechanism.
    // For now, each model might just "know" its fields.

protected:
    // Models might not directly hold a DB connection pointer.
    // Operations would typically go through a `Session` or `DB` object
    // to which the model instance is passed.
    // e.g., session.Save(myUserInstance);
    //
    // If GORM-style chainable methods directly on model instances are desired (user.DB.Where(...)),
    // then a (possibly non-owning) pointer/reference to the DB context is needed.
    // This is a design choice with trade-offs.

    // Example: if models were to manage their own state persistence directly
    // cpporm::Database* db_ = nullptr; // Non-owning, set by a session or context

    // For now, let's keep models as Plain Old Data Objects (PODs) as much as possible,
    // with persistence logic handled by other classes (Repository, Session, QueryBuilder).

    // Primary key value (example, assuming 'id' and type int64_t)
    // This will be made generic later.
    // int64_t id_ = 0;
};

} // namespace cpporm

#endif // cpporm_MODEL_H// cpporm/model_base.h
#ifndef cpporm_MODEL_BASE_H
#define cpporm_MODEL_BASE_H

#include "cpporm/error.h"
#include <QDebug>
#include <algorithm>
#include <any>
#include <cstdint>
#include <functional>
#include <map>
#include <memory> // For std::shared_ptr
#include <mutex>
#include <string>
#include <typeindex>
#include <vector>

#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>

namespace cpporm {

// Forward declarations
class Session;
class QueryBuilder;
class ModelBase;
struct ModelMeta;
struct FieldMeta;
struct AssociationMeta;
struct IndexDefinition;

// --- Index Definition ---
struct IndexDefinition {
  std::string index_name;
  std::vector<std::string> db_column_names;
  bool is_unique = false;
  std::string type_str;
  std::string condition_str;
};

// --- Association Related Enums and Structs ---
enum class AssociationType { None, HasOne, BelongsTo, HasMany, ManyToMany };

// Type-erased provider for target model's type_index
using TargetTypeIndexProvider = std::function<std::type_index()>;

struct AssociationMeta {
  std::string cpp_field_name;
  AssociationType type = AssociationType::None;

  // Store the provider function instead of the type_index directly at
  // registration
  TargetTypeIndexProvider target_type_index_provider;
  std::type_index target_model_type; // To be filled during finalization

  std::string foreign_key_db_name;
  std::string primary_key_db_name_on_current_model;
  std::string target_model_pk_db_name;

  std::function<void(
      void * /* model_instance */,
      std::vector<std::shared_ptr<ModelBase>> & /* associated_models */)>
      data_setter_vector;

  std::function<void(void * /* model_instance */,
                     std::shared_ptr<ModelBase> /* associated_model */)>
      data_setter_single;

  AssociationMeta(
      std::string fieldName, AssociationType assocType,
      TargetTypeIndexProvider targetTypeProvider, // Changed parameter
      std::string fkDbName, std::string currentModelRefKeyDbName = "",
      std::string targetModelReferencedKeyDbName = "",
      std::function<void(void *, std::vector<std::shared_ptr<ModelBase>> &)>
          vec_setter = nullptr,
      std::function<void(void *, std::shared_ptr<ModelBase>)> single_setter =
          nullptr)
      : cpp_field_name(std::move(fieldName)), type(assocType),
        target_type_index_provider(std::move(targetTypeProvider)),
        target_model_type(typeid(void)), // Initialize to a dummy value
        foreign_key_db_name(std::move(fkDbName)),
        primary_key_db_name_on_current_model(
            std::move(currentModelRefKeyDbName)),
        target_model_pk_db_name(std::move(targetModelReferencedKeyDbName)),
        data_setter_vector(std::move(vec_setter)),
        data_setter_single(std::move(single_setter)) {}
};

// --- Field Flags ---
enum class FieldFlag : uint32_t {
  None = 0,
  PrimaryKey = 1 << 0,
  AutoIncrement = 1 << 1,
  NotNull = 1 << 2,
  Unique = 1 << 3,
  HasDefault = 1 << 4,
  Indexed = 1 << 5,
  CreatedAt = 1 << 6,
  UpdatedAt = 1 << 7,
  DeletedAt = 1 << 8,
  Association = 1 << 9
};

inline FieldFlag operator|(FieldFlag a, FieldFlag b) {
  return static_cast<FieldFlag>(static_cast<uint32_t>(a) |
                                static_cast<uint32_t>(b));
}
inline FieldFlag operator&(FieldFlag a, FieldFlag b) {
  return static_cast<FieldFlag>(static_cast<uint32_t>(a) &
                                static_cast<uint32_t>(b));
}
inline FieldFlag &operator|=(FieldFlag &a, FieldFlag b) {
  a = a | b;
  return a;
}
inline bool has_flag(FieldFlag flags, FieldFlag flag_to_check) {
  return (static_cast<uint32_t>(flags) &
          static_cast<uint32_t>(flag_to_check)) != 0;
}

// --- Field Metadata ---
struct FieldMeta {
  std::string db_name;
  std::string cpp_name;
  std::type_index cpp_type;
  std::string db_type_hint;
  FieldFlag flags = FieldFlag::None;
  std::any default_value;

  std::function<std::any(const void *)> getter;
  std::function<void(void *, const std::any &)> setter;

  FieldMeta(std::string dbName, std::string cppName, std::type_index cppType,
            std::string dbTypeHint = "", FieldFlag fieldFlags = FieldFlag::None,
            std::function<std::any(const void *)> g = nullptr,
            std::function<void(void *, const std::any &)> s = nullptr)
      : db_name(std::move(dbName)), cpp_name(std::move(cppName)),
        cpp_type(cppType), db_type_hint(std::move(dbTypeHint)),
        flags(fieldFlags), getter(std::move(g)), setter(std::move(s)) {}
};

// --- ModelBase Definition ---
class ModelBase {
public:
  virtual ~ModelBase() = default;

  [[nodiscard]] virtual const ModelMeta &_getOwnModelMeta() const = 0;
  [[nodiscard]] virtual std::string _getTableName() const = 0;
  [[nodiscard]] virtual std::map<std::string, std::any> _getPrimaryKeys() const;

  bool _is_persisted = false;

  std::any getFieldValue(const std::string &cpp_field_name) const;
  Error setFieldValue(const std::string &cpp_field_name, const std::any &value);

  virtual Error beforeCreate(Session & /*session*/) { return make_ok(); }
  virtual Error afterCreate(Session & /*session*/) { return make_ok(); }
  virtual Error beforeUpdate(Session & /*session*/) { return make_ok(); }
  virtual Error afterUpdate(Session & /*session*/) { return make_ok(); }
  virtual Error beforeSave(Session & /*session*/) { return make_ok(); }
  virtual Error afterSave(Session & /*session*/) { return make_ok(); }
  virtual Error beforeDelete(Session & /*session*/) { return make_ok(); }
  virtual Error afterDelete(Session & /*session*/) { return make_ok(); }
  virtual Error afterFind(Session & /*session*/) { return make_ok(); }
};

// --- ModelMeta Definition ---
struct ModelMeta {
  std::string table_name;
  std::vector<FieldMeta> fields;
  std::vector<AssociationMeta> associations;
  std::vector<std::string> primary_keys_db_names;
  std::vector<IndexDefinition> indexes;
  bool _is_finalized = false;

  const FieldMeta *findFieldByDbName(const std::string &name) const {
    for (const auto &f : fields)
      if (f.db_name == name && !f.db_name.empty())
        return &f;
    return nullptr;
  }
  const FieldMeta *findFieldByCppName(const std::string &name) const {
    for (const auto &f : fields)
      if (f.cpp_name == name)
        return &f;
    return nullptr;
  }
  const AssociationMeta *
  findAssociationByCppName(const std::string &cpp_assoc_field_name) const {
    for (const auto &assoc : associations)
      if (assoc.cpp_field_name == cpp_assoc_field_name)
        return &assoc;
    return nullptr;
  }
  const FieldMeta *getPrimaryField(size_t idx = 0) const {
    if (primary_keys_db_names.empty() || idx >= primary_keys_db_names.size())
      return nullptr;
    return findFieldByDbName(primary_keys_db_names[idx]);
  }
  std::vector<const FieldMeta *> getPrimaryKeyFields() const {
    std::vector<const FieldMeta *> pks;
    pks.reserve(primary_keys_db_names.size());
    for (const auto &pk_name : primary_keys_db_names) {
      if (auto *f = findFieldByDbName(pk_name))
        pks.push_back(f);
    }
    return pks;
  }
  const FieldMeta *findFieldWithFlag(FieldFlag flag_to_find) const {
    auto it = std::find_if(fields.begin(), fields.end(),
                           [flag_to_find](const FieldMeta &fm) {
                             return has_flag(fm.flags, flag_to_find);
                           });
    return (it == fields.end()) ? nullptr : &(*it);
  }
};

inline std::any
ModelBase::getFieldValue(const std::string &cpp_field_name) const {
  const ModelMeta &meta = this->_getOwnModelMeta();
  const FieldMeta *field = meta.findFieldByCppName(cpp_field_name);
  if (!field) {
    const AssociationMeta *assoc =
        meta.findAssociationByCppName(cpp_field_name);
    if (assoc) {
      qWarning()
          << "cpporm ModelBase::getFieldValue: Attempted to get association "
             "collection or object '"
          << cpp_field_name.c_str()
          << "' via generic getter. Access the member directly after Preload.";
      return std::any{};
    }
    qWarning() << "cpporm ModelBase::getFieldValue: Field or Association "
                  "placeholder '"
               << cpp_field_name.c_str() << "' not found in meta for table "
               << QString::fromStdString(meta.table_name);
    return std::any{};
  }
  if (!field->getter) {
    qWarning() << "cpporm ModelBase::getFieldValue: Getter not found or "
                  "not finalized for field '"
               << cpp_field_name.c_str() << "' in table "
               << QString::fromStdString(meta.table_name);
    return std::any{};
  }
  return field->getter(this);
}

inline Error ModelBase::setFieldValue(const std::string &cpp_field_name,
                                      const std::any &value) {
  const ModelMeta &meta = this->_getOwnModelMeta();
  const FieldMeta *field = meta.findFieldByCppName(cpp_field_name);
  if (!field) {
    const AssociationMeta *assoc =
        meta.findAssociationByCppName(cpp_field_name);
    if (assoc) {
      qWarning() << "cpporm ModelBase::setFieldValue: Attempted to set "
                    "association collection or object '"
                 << cpp_field_name.c_str()
                 << "' via generic setter. This is usually handled by Preload "
                    "setters or direct member assignment if applicable.";
      return Error(ErrorCode::MappingError,
                   "Cannot set association via generic setFieldValue.");
    }
    qWarning() << "cpporm ModelBase::setFieldValue: Field or Association "
                  "placeholder '"
               << cpp_field_name.c_str() << "' not found in meta for table "
               << QString::fromStdString(meta.table_name);
    return Error(ErrorCode::MappingError, "Field or Association placeholder " +
                                              cpp_field_name + " not found.");
  }
  if (!field->setter) {
    qWarning() << "cpporm ModelBase::setFieldValue: Setter not found or "
                  "not finalized for field '"
               << cpp_field_name.c_str() << "' in table "
               << QString::fromStdString(meta.table_name);
    return Error(ErrorCode::MappingError,
                 "Setter for " + cpp_field_name + " not found/finalized.");
  }
  try {
    field->setter(this, value);
  } catch (const std::bad_any_cast &e) {
    qWarning() << "cpporm ModelBase::setFieldValue: Bad_any_cast for field '"
               << cpp_field_name.c_str()
               << "' (table: " << QString::fromStdString(meta.table_name)
               << ", expected C++ type: " << field->cpp_type.name()
               << ", value provided type: "
               << (value.has_value() ? value.type().name() : "empty_any")
               << "): " << e.what();
    return Error(ErrorCode::MappingError,
                 "Type mismatch for field " + cpp_field_name + ": " + e.what());
  } catch (const std::exception &e) {
    qWarning()
        << "cpporm ModelBase::setFieldValue: Exception while setting field '"
        << cpp_field_name.c_str()
        << "' (table: " << QString::fromStdString(meta.table_name)
        << "): " << e.what();
    return Error(ErrorCode::MappingError,
                 "Setter failed for field " + cpp_field_name + ": " + e.what());
  }
  return make_ok();
}

inline std::map<std::string, std::any> ModelBase::_getPrimaryKeys() const {
  std::map<std::string, std::any> pks;
  const auto &meta = this->_getOwnModelMeta();
  for (const auto &pk_db_name : meta.primary_keys_db_names) {
    const FieldMeta *fm = meta.findFieldByDbName(pk_db_name);
    if (fm && fm->getter) {
      try {
        pks[pk_db_name] = fm->getter(this);
      } catch (const std::exception &e) {
        qWarning()
            << "cpporm ModelBase::_getPrimaryKeys: Getter failed for PK field "
            << pk_db_name.c_str() << " on table "
            << QString::fromStdString(meta.table_name) << ": " << e.what();
      }
    } else {
      qWarning()
          << "cpporm ModelBase::_getPrimaryKeys: Primary key field meta or "
             "getter not found for DB name: "
          << pk_db_name.c_str() << " on table "
          << QString::fromStdString(meta.table_name);
    }
  }
  return pks;
}

namespace internal {
using ModelFactory = std::function<std::unique_ptr<ModelBase>()>;
std::map<std::type_index, ModelFactory> &getGlobalModelFactoryRegistry();
std::mutex &getGlobalModelFactoryRegistryMutex();

template <typename T> void registerModelFactory() {
  std::lock_guard<std::mutex> lock(getGlobalModelFactoryRegistryMutex());
  getGlobalModelFactoryRegistry()[typeid(T)] = []() {
    return std::make_unique<T>();
  };
}

using VoidFunc = std::function<void()>;
std::vector<VoidFunc> &getGlobalModelFinalizerFunctions();
std::mutex &getGlobalModelFinalizersRegistryMutex();

template <typename ModelClass> void registerModelClassForFinalization() {
  std::lock_guard<std::mutex> lock(getGlobalModelFinalizersRegistryMutex());
  getGlobalModelFinalizerFunctions().push_back(
      []() { ModelClass::_finalizeModelMeta(); });
}

} // namespace internal

void finalize_all_model_meta();

using FieldMetaProvider = std::function<FieldMeta()>;
// Renamed from AssociationMetaConfigurator to be more specific
// This provider now returns a partially filled AssociationMeta (without
// target_model_type) and the TargetTypeIndexProvider separately.
using PendingAssociationProvider = std::function<AssociationMeta()>;

using IndexDefinitionProvider = std::function<IndexDefinition()>;

template <typename Derived> class Model : public ModelBase {
public:
  inline static ModelMeta _shared_meta_instance;
  inline static std::vector<FieldMetaProvider> *_pending_field_meta_providers =
      nullptr;
  // Changed type for pending associations
  inline static std::vector<PendingAssociationProvider>
      *_pending_association_providers = nullptr;
  inline static std::vector<IndexDefinitionProvider>
      *_pending_index_definition_providers = nullptr;
  inline static std::mutex _meta_init_mutex;

  // New static function to get type_index of Derived
  static std::type_index _get_static_type_index() { return typeid(Derived); }

  static void _initSharedMetaTableName(const char *tableNameFromMacro) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (Model<Derived>::_shared_meta_instance.table_name.empty() &&
        tableNameFromMacro && *tableNameFromMacro) {
      Model<Derived>::_shared_meta_instance.table_name = tableNameFromMacro;
      cpporm::internal::registerModelFactory<Derived>();
    }
  }

  static void _addPendingFieldMetaProvider(FieldMetaProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_field_meta_providers)
      Model<Derived>::_pending_field_meta_providers =
          new std::vector<FieldMetaProvider>();
    Model<Derived>::_pending_field_meta_providers->push_back(
        std::move(provider));
  }

  static void
  _addPendingAssociationProvider(PendingAssociationProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_association_providers) {
      Model<Derived>::_pending_association_providers =
          new std::vector<PendingAssociationProvider>();
    }
    Model<Derived>::_pending_association_providers->push_back(
        std::move(provider));
  }

  static void
  _addPendingIndexDefinitionProvider(IndexDefinitionProvider provider) {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    if (!Model<Derived>::_pending_index_definition_providers)
      Model<Derived>::_pending_index_definition_providers =
          new std::vector<IndexDefinitionProvider>();
    Model<Derived>::_pending_index_definition_providers->push_back(
        std::move(provider));
  }

  static void _finalizeModelMeta() {
    std::lock_guard<std::mutex> lock(Model<Derived>::_meta_init_mutex);
    ModelMeta &s_meta = Model<Derived>::_shared_meta_instance;
    if (s_meta._is_finalized)
      return;

    if (Model<Derived>::_pending_field_meta_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_field_meta_providers)
        if (provider_func) {
          auto field_meta_obj = provider_func();
          bool already_exists = false;
          for (const auto &existing_field_meta : s_meta.fields)
            if (existing_field_meta.cpp_name == field_meta_obj.cpp_name)
              already_exists = true;
          if (!already_exists) {
            s_meta.fields.push_back(std::move(field_meta_obj));
            const auto &added_field_meta = s_meta.fields.back();
            if (has_flag(added_field_meta.flags, FieldFlag::PrimaryKey)) {
              bool pk_already_listed = false;
              for (const auto &pk_name_str : s_meta.primary_keys_db_names)
                if (pk_name_str == added_field_meta.db_name)
                  pk_already_listed = true;
              if (!pk_already_listed && !added_field_meta.db_name.empty())
                s_meta.primary_keys_db_names.push_back(
                    added_field_meta.db_name);
            }
          }
        }
      delete Model<Derived>::_pending_field_meta_providers;
      Model<Derived>::_pending_field_meta_providers = nullptr;
    }

    // Process pending associations
    if (Model<Derived>::_pending_association_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_association_providers) {
        if (provider_func) {
          AssociationMeta assoc_meta_obj = provider_func();
          // Now, resolve the target_model_type using the provider function
          if (assoc_meta_obj.target_type_index_provider) {
            assoc_meta_obj.target_model_type =
                assoc_meta_obj.target_type_index_provider();
          } else {
            qWarning() << "cpporm Model::finalizeModelMeta: Association"
                       << QString::fromStdString(assoc_meta_obj.cpp_field_name)
                       << "in model"
                       << QString::fromStdString(s_meta.table_name)
                       << "is missing a target type index provider.";
          }

          bool already_exists = false;
          for (const auto &existing_assoc_meta : s_meta.associations) {
            if (existing_assoc_meta.cpp_field_name ==
                assoc_meta_obj.cpp_field_name) {
              already_exists = true;
              break;
            }
          }
          if (!already_exists) {
            s_meta.associations.push_back(std::move(assoc_meta_obj));
          }
        }
      }
      delete Model<Derived>::_pending_association_providers;
      Model<Derived>::_pending_association_providers = nullptr;
    }

    if (Model<Derived>::_pending_index_definition_providers) {
      for (const auto &provider_func :
           *Model<Derived>::_pending_index_definition_providers)
        if (provider_func)
          s_meta.indexes.push_back(provider_func());
      delete Model<Derived>::_pending_index_definition_providers;
      Model<Derived>::_pending_index_definition_providers = nullptr;
    }
    s_meta._is_finalized = true;
  }

  static const ModelMeta &getModelMeta() {
    if (!Model<Derived>::_shared_meta_instance._is_finalized) {
      Model<Derived>::_finalizeModelMeta();
    }
    return Model<Derived>::_shared_meta_instance;
  }

  [[nodiscard]] const ModelMeta &_getOwnModelMeta() const final {
    return Model<Derived>::getModelMeta();
  }
  [[nodiscard]] std::string _getTableName() const final {
    return Model<Derived>::getModelMeta().table_name;
  }

  static std::unique_ptr<ModelBase> createInstance() {
    return std::make_unique<Derived>();
  }

  template <typename FieldType, FieldType Derived::*MemberPtr>
  static std::any _cpporm_generated_getter(const void *obj_ptr) {
    return static_cast<const Derived *>(obj_ptr)->*MemberPtr;
  }

  template <typename FieldType, FieldType Derived::*MemberPtr>
  static void _cpporm_generated_setter(void *obj_ptr, const std::any &value) {
    try {
      if (value.has_value()) {
        (static_cast<Derived *>(obj_ptr)->*MemberPtr) =
            std::any_cast<FieldType>(value);
      } else {
        (static_cast<Derived *>(obj_ptr)->*MemberPtr) = FieldType{};
      }
    } catch (const std::bad_any_cast &e) {
      qWarning() << "cpporm Model::generated_setter: Bad_any_cast for type "
                 << typeid(FieldType).name() << " from value of type "
                 << (value.has_value() ? value.type().name() : "empty_any")
                 << ". Details: " << e.what();
      throw;
    } catch (const std::exception &e) {
      qWarning() << "cpporm Model::generated_setter: Exception for type "
                 << typeid(FieldType).name() << ": " << e.what();
      throw;
    }
  }

  template <typename AssociatedModel,
            std::vector<std::shared_ptr<AssociatedModel>> Derived::*MemberPtr>
  static void _cpporm_generated_association_vector_setter(
      void *obj_ptr, std::vector<std::shared_ptr<ModelBase>>
                         &associated_models_base_sptr_vec) {
    Derived *model_instance = static_cast<Derived *>(obj_ptr);
    std::vector<std::shared_ptr<AssociatedModel>> &target_vector =
        model_instance->*MemberPtr;

    target_vector.clear();
    target_vector.reserve(associated_models_base_sptr_vec.size());

    for (auto &base_model_sptr : associated_models_base_sptr_vec) {
      if (!base_model_sptr)
        continue;

      std::shared_ptr<AssociatedModel> derived_sptr =
          std::dynamic_pointer_cast<AssociatedModel>(base_model_sptr);

      if (derived_sptr) {
        target_vector.push_back(derived_sptr);
      } else {
        qWarning() << "cpporm: Type mismatch in "
                      "_cpporm_generated_association_vector_setter. Expected "
                   << typeid(AssociatedModel).name()
                   << " but got different type "
                   << typeid(*base_model_sptr.get()).name()
                   << ". Object not added to target vector.";
      }
    }
  }

  template <typename AssociatedModel,
            std::shared_ptr<AssociatedModel> Derived::*MemberPtr>
  static void _cpporm_generated_association_single_setter(
      void *obj_ptr, std::shared_ptr<ModelBase> associated_model_base_sptr) {
    Derived *model_instance = static_cast<Derived *>(obj_ptr);

    if (!associated_model_base_sptr) {
      (model_instance->*MemberPtr) = nullptr;
      return;
    }

    std::shared_ptr<AssociatedModel> derived_sptr =
        std::dynamic_pointer_cast<AssociatedModel>(associated_model_base_sptr);

    if (derived_sptr) {
      (model_instance->*MemberPtr) = derived_sptr;
    } else {
      qWarning() << "cpporm: Type mismatch in "
                    "_cpporm_generated_association_single_setter. Expected "
                 << typeid(AssociatedModel).name() << " but got different type "
                 << typeid(*associated_model_base_sptr.get()).name()
                 << ". Object not set.";
      (model_instance->*MemberPtr) = nullptr;
    }
  }
};

#if __cplusplus < 201703L
template <typename Derived> ModelMeta Model<Derived>::_shared_meta_instance;
template <typename Derived>
std::vector<FieldMetaProvider> *Model<Derived>::_pending_field_meta_providers;
template <typename Derived>
std::vector<PendingAssociationProvider>
    *Model<Derived>::_pending_association_providers;
template <typename Derived>
std::vector<IndexDefinitionProvider>
    *Model<Derived>::_pending_index_definition_providers;
template <typename Derived> std::mutex Model<Derived>::_meta_init_mutex;
#endif

} // namespace cpporm
#endif // cpporm_MODEL_BASE_H// cpporm/model_definition_macros.h
#ifndef cpporm_MODEL_DEFINITION_MACROS_H
#define cpporm_MODEL_DEFINITION_MACROS_H

#include "cpporm/model_base.h"
#include <any>
#include <initializer_list>
#include <map>
#include <memory> // For std::shared_ptr
#include <sstream>
#include <string>
#include <typeindex>
#include <vector>

// --- Helper Macros ---
#define cpporm_STRINGIFY_DETAIL(x) #x
#define cpporm_STRINGIFY(x) cpporm_STRINGIFY_DETAIL(x)
#define cpporm_CONCAT_DETAIL(x, y) x##y
#define cpporm_CONCAT(x, y) cpporm_CONCAT_DETAIL(x, y)

namespace cpporm {
template <typename BaseFlagType, typename... Flags>
constexpr BaseFlagType combine_flags_recursive(BaseFlagType base,
                                               Flags... flags) {
  if constexpr (sizeof...(flags) == 0) {
    return base;
  } else {
    return (base | ... | flags);
  }
}
namespace internal {
template <size_t N_one_based, typename... Args>
std::string get_optional_arg_str(const char *default_val_if_absent_or_empty,
                                 Args... args) {
  if constexpr (N_one_based > 0 && N_one_based <= sizeof...(Args)) {
    const char *arg_array[] = {args...};
    const char *selected_arg = arg_array[N_one_based - 1];
    if (selected_arg && selected_arg[0] != '\0') {
      return selected_arg;
    }
  }
  return default_val_if_absent_or_empty ? default_val_if_absent_or_empty : "";
}
} // namespace internal
inline std::vector<std::string>
_cpporm_make_string_vector(std::initializer_list<const char *> list) {
  std::vector<std::string> vec;
  vec.reserve(list.size());
  for (const char *s : list) {
    if (s && *s) {
      vec.emplace_back(s);
    }
  }
  return vec;
}
} // namespace cpporm

#define cpporm_DEFINE_MODEL_CLASS_NAME(ClassName)                             \
  using _cppormThisModelClass = ClassName;                                    \
  friend class cpporm::Model<ClassName>;

#define cpporm_MODEL_BEGIN(CurrentClassName, TableNameStr)                    \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_cpporm_tbl_init_, __COUNTER__) =   \
      (cpporm::Model<CurrentClassName>::_initSharedMetaTableName(             \
           TableNameStr),                                                      \
       true);                                                                  \
  inline static const bool cpporm_CONCAT(_cpporm_mfinal_reg_, __COUNTER__) = \
      (cpporm::internal::registerModelClassForFinalization<                   \
           CurrentClassName>(),                                                \
       true);                                                                  \
                                                                               \
public:

#undef cpporm_FIELD
#define cpporm_FIELD(CppType, CppName, DbNameStr, ...)                        \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_f_prov_reg_, CppName) =             \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType), "",   \
                 cpporm::combine_flags_recursive(cpporm::FieldFlag::None,    \
                                                  ##__VA_ARGS__),              \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_FIELD_TYPE(CppType, CppName, DbNameStr, DbTypeHintStr, ...)    \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_ft_prov_reg_, CppName) =            \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType),       \
                 DbTypeHintStr,                                                \
                 cpporm::combine_flags_recursive(cpporm::FieldFlag::None,    \
                                                  ##__VA_ARGS__),              \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#undef cpporm_ASSOCIATION_FIELD
#define cpporm_ASSOCIATION_FIELD(ContainerCppType, CppName)                   \
public:                                                                        \
  ContainerCppType CppName{};                                                  \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_f_prov_reg_, CppName) =       \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             return cpporm::FieldMeta(                                        \
                 "", cpporm_STRINGIFY(CppName), typeid(ContainerCppType), "", \
                 cpporm::FieldFlag::Association, nullptr, nullptr);           \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

// Association macros now pass a TargetTypeIndexProvider
#define cpporm_HAS_MANY(CppFieldName, AssocModelParamName, FKOnAssoc, ...)    \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_hm_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_vec =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_vector_setter<    \
                         AssocModelParamName,                                  \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string current_model_ref_key =                               \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             /* Create the provider function for target_model_type */          \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<AssocModelParamName>::_get_static_type_index; \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::HasMany, target_type_provider,      \
                 FKOnAssoc, current_model_ref_key, "", d_setter_vec, nullptr); \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_HAS_ONE(CppFieldName, AssocModelParamName, FKOnAssoc, ...)     \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_ho_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_sgl =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_single_setter<    \
                         AssocModelParamName,                                  \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string current_model_ref_key =                               \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<AssocModelParamName>::_get_static_type_index; \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::HasOne, target_type_provider,       \
                 FKOnAssoc, current_model_ref_key, "", nullptr, d_setter_sgl); \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_BELONGS_TO(CppFieldName, TargetModelParamName, FKOnCurrent,    \
                           ...)                                                \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_assoc_m_prov_reg_bt_,               \
                                          CppFieldName) =                      \
      (cpporm::Model<_cppormThisModelClass>::_addPendingAssociationProvider( \
           []() -> cpporm::AssociationMeta {                                  \
             auto d_setter_sgl =                                               \
                 &cpporm::Model<_cppormThisModelClass>::                     \
                     template _cpporm_generated_association_single_setter<    \
                         TargetModelParamName,                                 \
                         &_cppormThisModelClass::CppFieldName>;               \
             std::string target_model_ref_key =                                \
                 cpporm::internal::get_optional_arg_str<1>("",                \
                                                            ##__VA_ARGS__);    \
             cpporm::TargetTypeIndexProvider target_type_provider =           \
                 &cpporm::Model<                                              \
                     TargetModelParamName>::_get_static_type_index;            \
             return cpporm::AssociationMeta(                                  \
                 cpporm_STRINGIFY(CppFieldName),                              \
                 cpporm::AssociationType::BelongsTo, target_type_provider,    \
                 FKOnCurrent, FKOnCurrent, target_model_ref_key, nullptr,      \
                 d_setter_sgl);                                                \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_INDEX_INTERNAL(IsUniqueParam, IndexNameOrFirstColParam, ...)   \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_idx_def_prov_reg_, __COUNTER__) =   \
      (cpporm::Model<_cppormThisModelClass>::                                \
           _addPendingIndexDefinitionProvider(                                 \
               []() -> cpporm::IndexDefinition {                              \
                 cpporm::IndexDefinition def;                                 \
                 def.is_unique = IsUniqueParam;                                \
                 const char *first_arg = IndexNameOrFirstColParam;             \
                 std::initializer_list<const char *> other_cols_il = {         \
                     __VA_ARGS__};                                             \
                 std::vector<std::string> other_cols_vec =                     \
                     cpporm::_cpporm_make_string_vector(other_cols_il);      \
                 if (!other_cols_vec.empty()) {                                \
                   if (first_arg && *first_arg)                                \
                     def.index_name = first_arg;                               \
                   def.db_column_names = other_cols_vec;                       \
                 } else if (first_arg && *first_arg) {                         \
                   std::string temp_s(first_arg);                              \
                   std::stringstream ss_cols(temp_s);                          \
                   std::string segment;                                        \
                   bool looks_like_single_col_name_not_index_name =            \
                       (temp_s.find(',') == std::string::npos &&               \
                        temp_s.find(' ') == std::string::npos &&               \
                        temp_s.rfind("idx_", 0) != 0 &&                        \
                        temp_s.rfind("uix_", 0) != 0);                         \
                   std::vector<std::string> parsed_cols;                       \
                   while (std::getline(ss_cols, segment, ',')) {               \
                     size_t f = segment.find_first_not_of(" \t");              \
                     if (f != std::string::npos) {                             \
                       size_t l = segment.find_last_not_of(" \t");             \
                       parsed_cols.push_back(segment.substr(f, (l - f + 1)));  \
                     }                                                         \
                   }                                                           \
                   if (parsed_cols.size() > 1 ||                               \
                       looks_like_single_col_name_not_index_name) {            \
                     def.db_column_names = parsed_cols;                        \
                   } else {                                                    \
                     def.index_name = temp_s;                                  \
                     if (def.db_column_names.empty()) {                        \
                     }                                                         \
                   }                                                           \
                 }                                                             \
                 if (def.db_column_names.empty() && !def.index_name.empty()) { \
                 } else if (def.db_column_names.empty() &&                     \
                            def.index_name.empty()) {                          \
                 }                                                             \
                 return def;                                                   \
               }),                                                             \
       true);                                                                  \
                                                                               \
public:

#define cpporm_INDEX(IndexNameOrFirstCol, ...)                                \
  cpporm_INDEX_INTERNAL(false, IndexNameOrFirstCol, ##__VA_ARGS__)
#define cpporm_UNIQUE_INDEX(IndexNameOrFirstCol, ...)                         \
  cpporm_INDEX_INTERNAL(true, IndexNameOrFirstCol, ##__VA_ARGS__)

#undef cpporm_PRIMARY_KEY
#define cpporm_PRIMARY_KEY(CppType, CppName, DbNameStr, ...)                  \
public:                                                                        \
  CppType CppName{};                                                           \
                                                                               \
private:                                                                       \
  inline static const bool cpporm_CONCAT(_pk_prov_reg_, CppName) =            \
      (cpporm::Model<_cppormThisModelClass>::_addPendingFieldMetaProvider(   \
           []() -> cpporm::FieldMeta {                                        \
             auto g = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_getter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             auto s = &cpporm::Model<_cppormThisModelClass>::                \
                          template _cpporm_generated_setter<                  \
                              CppType, &_cppormThisModelClass::CppName>;      \
             return cpporm::FieldMeta(                                        \
                 DbNameStr, cpporm_STRINGIFY(CppName), typeid(CppType), "",   \
                 cpporm::combine_flags_recursive(                             \
                     cpporm::FieldFlag::PrimaryKey, ##__VA_ARGS__),           \
                 g, s);                                                        \
           }),                                                                 \
       true);                                                                  \
                                                                               \
public:

#define cpporm_AUTO_INCREMENT_PRIMARY_KEY(CppType, CppName, DbNameStr)        \
  cpporm_PRIMARY_KEY(CppType, CppName, DbNameStr,                             \
                      cpporm::FieldFlag::AutoIncrement)

#define cpporm_TIMESTAMPS(TimestampCppType)                                   \
  cpporm_FIELD_TYPE(TimestampCppType, created_at, "created_at", "DATETIME",   \
                     cpporm::FieldFlag::CreatedAt)                            \
  cpporm_FIELD_TYPE(TimestampCppType, updated_at, "updated_at", "DATETIME",   \
                     cpporm::FieldFlag::UpdatedAt)

#define cpporm_SOFT_DELETE(TimestampCppType)                                  \
  cpporm_FIELD_TYPE(TimestampCppType, deleted_at, "deleted_at", "DATETIME",   \
                     cpporm::FieldFlag::DeletedAt,                            \
                     cpporm::FieldFlag::HasDefault)

#define cpporm_MODEL_END()

#endif // cpporm_MODEL_DEFINITION_MACROS_H// cpporm/query_builder.h
#ifndef cpporm_QUERY_BUILDER_H
#define cpporm_QUERY_BUILDER_H

// Core QueryBuilder class definition (non-template members, mixins, state)
#include "cpporm/query_builder_core.h"

// Template member implementations for QueryBuilder (e.g., First<T>, Find<T>)
#include "cpporm/query_builder_execution.h"

// query_builder_setters.h is currently minimal as setters are part of
// QueryBuilder class #include "cpporm/query_builder_setters.h"

// query_builder_fwd.h is for forward declarations, not typically included by
// the main header itself, but by files that need to forward declare
// QueryBuilder.

#endif // cpporm_QUERY_BUILDER_H#ifndef cpporm_QUERY_BUILDER_CORE_H
#define cpporm_QUERY_BUILDER_CORE_H

#include <QDateTime>  // QVariantList 依赖
#include <QMetaType>  // QVariantList 依赖
#include <QString>    // QVariantList 依赖
#include <QVariant>
#include <QVariantList>
#include <algorithm>  // For std::transform, std::tolower (needed for string_contains_ci)
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

#include "cpporm/builder_parts/query_builder_clauses_mixin.h"
#include "cpporm/builder_parts/query_builder_conditions_mixin.h"
#include "cpporm/builder_parts/query_builder_joins_mixin.h"
#include "cpporm/builder_parts/query_builder_preload_mixin.h"
#include "cpporm/builder_parts/query_builder_scopes_mixin.h"
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder_fwd.h"
#include "cpporm_sqldriver/sql_value.h"  // For CreateImpl return type

namespace cpporm {

    // --- Helper for case-insensitive string find (inline definition) ---
    // Placed within the namespace but outside the class, available to QueryBuilder implementation files.
    inline bool string_contains_ci(const std::string &text, const std::string &pattern) {
        if (pattern.empty()) return true;  // Empty pattern is always "found"
        if (text.empty()) return false;    // Pattern is not empty, but text is

        // Create lowercase copies for comparison
        std::string text_lower = text;
        std::string pattern_lower = pattern;
        // Ensure correct overload of std::tolower is used by casting char to unsigned char first
        std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });
        std::transform(pattern_lower.begin(), pattern_lower.end(), pattern_lower.begin(), [](unsigned char c) {
            return static_cast<char>(std::tolower(c));
        });

        return text_lower.find(pattern_lower) != std::string::npos;
    }

    class OnConflictUpdateSetter {
      public:
        explicit OnConflictUpdateSetter(OnConflictClause &clause_ref);
        OnConflictUpdateSetter &Set(const std::string &db_column_name, const QueryValue &value);
        OnConflictUpdateSetter &Set(const std::map<std::string, QueryValue> &assignments);

      private:
        OnConflictClause &clause_;
    };

    class QueryBuilder : public QueryBuilderConditionsMixin<QueryBuilder>, public QueryBuilderClausesMixin<QueryBuilder>, public QueryBuilderJoinsMixin<QueryBuilder>, public QueryBuilderScopesMixin<QueryBuilder>, public QueryBuilderPreloadMixin<QueryBuilder> {
      public:
        using QueryBuilderConditionsMixin<QueryBuilder>::Where;
        using QueryBuilderConditionsMixin<QueryBuilder>::Or;
        using QueryBuilderConditionsMixin<QueryBuilder>::Not;
        using QueryBuilderConditionsMixin<QueryBuilder>::In;

        // 构造函数和析构函数
        // connection_name 现在是 std::string
        explicit QueryBuilder(IQueryExecutor *executor, std::string connection_name, const ModelMeta *model_meta = nullptr);
        QueryBuilder(const QueryBuilder &other);
        QueryBuilder &operator=(const QueryBuilder &other);
        QueryBuilder(QueryBuilder &&other) noexcept;
        QueryBuilder &operator=(QueryBuilder &&other) noexcept;
        ~QueryBuilder();

        // 核心 Model/Table/From 设置器
        QueryBuilder &Model(const ModelBase *model_instance_hint);
        QueryBuilder &Model(const ModelMeta &meta);
        template <typename T>
        QueryBuilder &Model() {
            static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
            return this->Model(T::getModelMeta());
        }
        QueryBuilder &Table(std::string table_name);

        QueryBuilder &From(const QueryBuilder &subquery_builder, const std::string &alias);
        QueryBuilder &From(const SubqueryExpression &subquery_expr, const std::string &alias);
        QueryBuilder &From(std::string source_name_or_cte_alias);

        // Specific Setters
        QueryBuilder &OnConflictUpdateAllExcluded();
        QueryBuilder &OnConflictDoNothing();
        QueryBuilder &OnConflictUpdateSpecific(std::function<void(OnConflictUpdateSetter &)> updater_fn);

        QueryBuilder &With(const std::string &cte_name, const QueryBuilder &cte_query_builder, bool recursive = false);
        QueryBuilder &WithRaw(const std::string &cte_name, const std::string &raw_sql, const std::vector<QueryValue> &bindings = {}, bool recursive = false);

        QueryBuilder &SelectSubquery(const QueryBuilder &subquery_builder, const std::string &alias);
        QueryBuilder &SelectSubquery(const SubqueryExpression &subquery_expr, const std::string &alias);

        // QueryBuilder specific Where/Or/Not overloads
        QueryBuilder &Where(const QueryBuilder &sub_qb_condition);
        QueryBuilder &Or(const QueryBuilder &sub_qb_condition);
        QueryBuilder &Not(const QueryBuilder &sub_qb_condition);

        QueryBuilder &Where(const std::expected<SubqueryExpression, Error> &sub_expr_expected);
        QueryBuilder &Or(const std::expected<SubqueryExpression, Error> &sub_expr_expected);
        QueryBuilder &Not(const std::expected<SubqueryExpression, Error> &sub_expr_expected);

        // SQL 构建和转换方法
        std::pair<QString, QVariantList> buildSelectSQL(bool for_subquery_generation = false) const;
        std::pair<QString, QVariantList> buildInsertSQLSuffix(const std::vector<std::string> &inserted_columns_db_names_for_values_clause) const;
        std::pair<QString, QVariantList> buildUpdateSQL(const std::map<std::string, QueryValue> &updates) const;
        std::pair<QString, QVariantList> buildDeleteSQL() const;
        std::expected<SubqueryExpression, Error> AsSubquery() const;
        std::pair<std::string, std::vector<QueryValue>> buildConditionClauseGroup() const;

        // 状态访问器
        const ModelMeta *getModelMeta() const {
            return state_.model_meta_;
        }
        QString getFromSourceName() const;
        const FromClauseSource &getFromClauseSource() const {
            return state_.from_clause_source_;
        }
        const std::string &getConnectionName() const {
            return connection_name_;
        }
        IQueryExecutor *getExecutor() const {
            return executor_;
        }

        const std::vector<Condition> &getWhereConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getWhereConditions_mixin();
        }
        const std::vector<Condition> &getOrConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getOrConditions_mixin();
        }
        const std::vector<Condition> &getNotConditions() const {
            return QueryBuilderConditionsMixin<QueryBuilder>::getNotConditions_mixin();
        }
        const std::vector<CTEState> &getCTEs() const {
            return state_.ctes_;
        }
        const std::vector<SelectField> &getSelectFields() const {
            return state_.select_fields_;
        }
        const std::string &getOrderClause() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getOrderClause_mixin();
        }
        int getLimitVal() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getLimitVal_mixin();
        }
        int getOffsetVal() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getOffsetVal_mixin();
        }
        const std::string &getGroupClause() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getGroupClause_mixin();
        }
        const Condition *getHavingCondition() const {
            return QueryBuilderClausesMixin<QueryBuilder>::getHavingCondition_mixin();
        }
        const std::vector<JoinClause> &getJoinClauses() const {
            return QueryBuilderJoinsMixin<QueryBuilder>::getJoinClauses_mixin();
        }
        bool isSoftDeleteScopeActive() const {
            return QueryBuilderScopesMixin<QueryBuilder>::isSoftDeleteScopeActive_mixin();
        }
        const std::vector<PreloadRequest> &getPreloadRequests() const {
            return QueryBuilderPreloadMixin<QueryBuilder>::getPreloadRequests_mixin();
        }
        const OnConflictClause *getOnConflictClause() const {
            return state_.on_conflict_clause_.get();
        }

        // 公共静态方法
        static QVariant toQVariant(const QueryValue &qv, QVariantList &subquery_bindings_accumulator);
        static QueryValue qvariantToQueryValue(const QVariant &qv);
        static std::string quoteSqlIdentifier(const std::string &identifier);

        // 内部状态访问
        QueryBuilderState &getState_() {
            return state_;
        }
        const QueryBuilderState &getState_() const {
            return state_;
        }

        // 调试方法
        QString toSqlDebug() const;

        // 模板化执行方法 (声明)
        template <typename T>
        Error First(T *result_model);
        template <typename T>
        Error First(T *result_model, const QueryValue &primary_key_value);
        template <typename T>
        Error First(T *result_model, const std::vector<QueryValue> &primary_key_values);
        template <typename T>
        Error First(T *result_model, const std::map<std::string, QueryValue> &conditions);

        template <typename T>
        Error Find(std::vector<T> *results_vector);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        // Create 返回类型与 IQueryExecutor::CreateImpl 保持一致
        template <typename TModel>
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(TModel &model);

        template <typename TModel>
        std::expected<long long, Error> Save(TModel &model);

        // 非模板化执行方法 (声明)
        Error First(ModelBase &result_model);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory);
        // Create 返回类型与 IQueryExecutor::CreateImpl 保持一致
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(ModelBase &model, const OnConflictClause *conflict_options_override = nullptr);
        std::expected<long long, Error> Updates(const std::map<std::string, QueryValue> &updates);
        std::expected<long long, Error> Delete();
        std::expected<long long, Error> Save(ModelBase &model);
        std::expected<int64_t, Error> Count();

      private:
        friend class QueryBuilderConditionsMixin<QueryBuilder>;
        friend class QueryBuilderClausesMixin<QueryBuilder>;
        friend class QueryBuilderJoinsMixin<QueryBuilder>;
        friend class QueryBuilderScopesMixin<QueryBuilder>;
        friend class QueryBuilderPreloadMixin<QueryBuilder>;

        IQueryExecutor *executor_;
        std::string connection_name_;
        QueryBuilderState state_;

        void build_condition_logic_internal(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator, bool &first_overall_condition_written, const std::string &prepended_scope_sql = "") const;
        void build_ctes_sql_prefix(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator) const;

        static bool build_one_condition_block_internal_static_helper(std::ostringstream &to_stream, QVariantList &bindings_acc, const std::vector<Condition> &conditions_group, const std::string &op_within_group, bool is_not_group);
    };

    inline OnConflictUpdateSetter::OnConflictUpdateSetter(OnConflictClause &clause_ref) : clause_(clause_ref) {
        clause_.action = OnConflictClause::Action::UpdateSpecific;
    }

    inline OnConflictUpdateSetter &OnConflictUpdateSetter::Set(const std::string &db_column_name, const QueryValue &value) {
        clause_.update_assignments[db_column_name] = value;
        return *this;
    }

    inline OnConflictUpdateSetter &OnConflictUpdateSetter::Set(const std::map<std::string, QueryValue> &assignments) {
        for (const auto &pair : assignments) {
            clause_.update_assignments[pair.first] = pair.second;
        }
        return *this;
    }

}  // namespace cpporm

#endif  // cpporm_QUERY_BUILDER_CORE_H// cpporm/query_builder_execution.h
#ifndef cpporm_QUERY_BUILDER_EXECUTION_H
#define cpporm_QUERY_BUILDER_EXECUTION_H

#include "cpporm/query_builder_core.h"
#include "cpporm_sqldriver/sql_value.h"  // For SqlValue type

// Other necessary includes are transitively included via query_builder_core.h

namespace cpporm {

    // --- Templated Execution Method Implementations ---

    template <typename T>
    inline Error QueryBuilder::First(T *result_model) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for First operation.");
        if (!result_model) return Error(ErrorCode::InternalError, "Result model pointer is null for QueryBuilder::First.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }
        return executor_->FirstImpl(*this, *static_cast<ModelBase *>(result_model));
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const QueryValue &primary_key_value) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        const ModelMeta *meta = this->state_.model_meta_;
        if (!meta || meta->primary_keys_db_names.empty()) return Error(ErrorCode::MappingError, "Model has no primary key defined for First by PK.");
        if (meta->primary_keys_db_names.size() > 1)
            return Error(ErrorCode::InvalidConfiguration,
                         "Model has composite PKs. Use vector<QueryValue> or map "
                         "overload for First by PK.");
        this->Where(quoteSqlIdentifier(meta->primary_keys_db_names[0]) + " = ?", {primary_key_value});
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const std::vector<QueryValue> &primary_key_values) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        const ModelMeta *meta = this->state_.model_meta_;
        if (!meta || meta->primary_keys_db_names.empty()) return Error(ErrorCode::MappingError, "Model has no primary keys defined for First by PKs.");
        if (meta->primary_keys_db_names.size() != primary_key_values.size()) return Error(ErrorCode::InvalidConfiguration, "Number of PK values does not match PK columns for First by PKs.");
        std::map<std::string, QueryValue> conditions;
        for (size_t i = 0; i < meta->primary_keys_db_names.size(); ++i) {
            conditions[meta->primary_keys_db_names[i]] = primary_key_values[i];
        }
        this->Where(conditions);
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::First(T *result_model, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        this->Model<T>();
        this->Where(conditions);
        return this->First(result_model);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for Find operation.");
        if (!results_vector) return Error(ErrorCode::InternalError, "Results vector pointer is null for QueryBuilder::Find.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }

        std::vector<std::unique_ptr<ModelBase>> base_results;
        auto factory = []() -> std::unique_ptr<ModelBase> {
            return std::make_unique<T>();
        };
        Error err = executor_->FindImpl(*this, base_results, factory);
        if (err) {
            return err;
        }

        results_vector->clear();
        results_vector->reserve(base_results.size());
        for (auto &base_ptr : base_results) {
            if (base_ptr) {
                T *typed_ptr = static_cast<T *>(base_ptr.release());
                results_vector->push_back(std::move(*typed_ptr));
                delete typed_ptr;
            }
        }
        return make_ok();
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        this->Model<T>();
        this->Where(conditions);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        this->Model<T>();
        this->Where(query_string, args);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor for Find operation.");
        if (!results_vector) return Error(ErrorCode::InternalError, "Results vector pointer is null for QueryBuilder::Find.");

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &(T::getModelMeta())) {
            this->Model<T>();
        }

        std::vector<std::unique_ptr<ModelBase>> base_results;
        auto factory = []() -> std::unique_ptr<ModelBase> {
            return std::make_unique<T>();
        };
        Error err = executor_->FindImpl(*this, base_results, factory);
        if (err) {
            return err;
        }

        results_vector->clear();
        results_vector->reserve(base_results.size());
        for (auto &base_ptr : base_results) {
            results_vector->emplace_back(static_cast<T *>(base_ptr.release()));
        }
        return make_ok();
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        this->Model<T>();
        this->Where(conditions);
        return this->Find(results_vector);
    }

    template <typename T>
    inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        this->Model<T>();
        this->Where(query_string, args);
        return this->Find(results_vector);
    }

    template <typename TModel>
    inline std::expected<cpporm_sqldriver::SqlValue, Error> QueryBuilder::Create(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        // 调用非模板 Create，它现在返回 std::expected<SqlValue, Error>
        return this->Create(static_cast<ModelBase &>(model), nullptr);
    }

    template <typename TModel>
    inline std::expected<long long, Error> QueryBuilder::Save(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        return this->Save(static_cast<ModelBase &>(model));
    }

}  // namespace cpporm

#endif  // cpporm_QUERY_BUILDER_EXECUTION_H// cpporm/query_builder_fwd.h
#ifndef cpporm_QUERY_BUILDER_FWD_H
#define cpporm_QUERY_BUILDER_FWD_H

namespace cpporm {
class QueryBuilder;
class OnConflictUpdateSetter; // 也前向声明
struct OnConflictClause;      // 如果 setter 会用到
struct SubqueryExpression;    // 如果 setter 会用到
// struct QueryValue;            // 如果 setter 会用到
} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_FWD_H// cpporm/query_builder_setters.h
#ifndef cpporm_QUERY_BUILDER_SETTERS_H
#define cpporm_QUERY_BUILDER_SETTERS_H

// This file is intended for QueryBuilder setter method declarations if they
// were separated from the main QueryBuilder class definition, or for related
// free functions. Currently, setter methods like OnConflict..., With...,
// SelectSubquery... are declared directly within the QueryBuilder class in
// query_builder_core.h, and their non-template implementations are in
// query_builder_core.cpp.

// #include "cpporm/query_builder_fwd.h" // For forward declarations if needed
// #include "cpporm/builder_parts/query_builder_state.h" // For types like
// OnConflictClause

namespace cpporm {

// Declarations for OnConflictUpdateSetter are in query_builder_core.h as it's
// tightly coupled.

// If there were free functions related to QueryBuilder state manipulation or
// specific setters, they could be declared here. For now, this file remains
// mostly a placeholder.

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_SETTERS_H// cpporm/query_builder_execution.h
#ifndef cpporm_QUERY_BUILDER_EXECUTION_H
#define cpporm_QUERY_BUILDER_EXECUTION_H

#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"   // 执行方法依赖 IQueryExecutor
#include "cpporm/model_base.h"         // For ModelBase constraint
#include "cpporm/query_builder_core.h" // 需要 QueryBuilder 类的完整定义

#include <QVariant> // For Create result
#include <expected>
#include <functional> // For factory function
#include <map>        // For map conditions
#include <memory>     // For std::unique_ptr
#include <string>
#include <type_traits> // For std::is_base_of
#include <vector>

namespace cpporm {

// --- QueryBuilder Execution Method Implementations ---
// 这些是模板方法，它们的实现通常放在头文件中。
// 注意：这些实现已从旧的 query_builder.h 移至此处。

template <typename T> inline Error QueryBuilder::First(T *result_model) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for First operation.");
  if (!result_model)
    return Error(ErrorCode::InternalError,
                 "Result model pointer is null for QueryBuilder::First.");

  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  return executor_->FirstImpl(*this, *static_cast<ModelBase *>(result_model));
}

template <typename T>
inline Error QueryBuilder::First(T *result_model,
                                 const QueryValue &primary_key_value) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  const ModelMeta *meta = this->state_.model_meta_;
  if (!meta || meta->primary_keys_db_names.empty())
    return Error(ErrorCode::MappingError, "Model has no primary key defined.");
  if (meta->primary_keys_db_names.size() > 1)
    return Error(ErrorCode::InvalidConfiguration,
                 "Model has composite PKs. Use vector<QueryValue> overload.");
  this->Where(meta->primary_keys_db_names[0] + " = ?", {primary_key_value});

  return this->First(result_model);
}

template <typename T>
inline Error
QueryBuilder::First(T *result_model,
                    const std::vector<QueryValue> &primary_key_values) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  const ModelMeta *meta = this->state_.model_meta_;
  if (!meta || meta->primary_keys_db_names.empty())
    return Error(ErrorCode::MappingError, "Model has no primary keys defined.");
  if (meta->primary_keys_db_names.size() != primary_key_values.size())
    return Error(ErrorCode::InvalidConfiguration,
                 "Number of PK values does not match PK columns.");
  std::map<std::string, QueryValue> conditions;
  for (size_t i = 0; i < meta->primary_keys_db_names.size(); ++i) {
    conditions[meta->primary_keys_db_names[i]] = primary_key_values[i];
  }
  this->Where(conditions);
  return this->First(result_model);
}

template <typename T>
inline Error
QueryBuilder::First(T *result_model,
                    const std::map<std::string, QueryValue> &conditions) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");
  if (!result_model)
    return Error(ErrorCode::InternalError, "Result model pointer is null.");

  this->Model<T>();
  this->Where(conditions);
  return this->First(result_model);
}

// Non-template First(ModelBase&) is in query_builder_core.cpp

template <typename T>
inline Error QueryBuilder::Find(std::vector<T> *results_vector) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for Find operation.");
  if (!results_vector)
    return Error(ErrorCode::InternalError,
                 "Results vector pointer is null for QueryBuilder::Find.");
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  std::vector<std::unique_ptr<ModelBase>> base_results;
  auto factory = []() -> std::unique_ptr<ModelBase> {
    return std::make_unique<T>();
  };
  Error err = executor_->FindImpl(*this, base_results, factory);
  if (err) {
    return err;
  }

  results_vector->clear();
  results_vector->reserve(base_results.size());
  for (auto &base_ptr : base_results) {
    if (base_ptr) {
      T *typed_ptr = static_cast<T *>(base_ptr.release());
      results_vector->push_back(std::move(*typed_ptr));
      delete typed_ptr;
    }
  }
  return make_ok();
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<T> *results_vector,
                   const std::map<std::string, QueryValue> &conditions) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(conditions);
  return this->Find(results_vector);
}

template <typename T>
inline Error QueryBuilder::Find(std::vector<T> *results_vector,
                                const std::string &query_string,
                                const std::vector<QueryValue> &args) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(query_string, args);
  return this->Find(results_vector);
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector) {
  static_assert(std::is_base_of<ModelBase, T>::value,
                "T must be a descendant of cpporm::ModelBase");
  if (!executor_)
    return Error(ErrorCode::InternalError,
                 "QueryBuilder has no executor for Find operation.");
  if (!results_vector)
    return Error(ErrorCode::InternalError,
                 "Results vector pointer is null for QueryBuilder::Find.");
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }

  std::vector<std::unique_ptr<ModelBase>> base_results;
  auto factory = []() -> std::unique_ptr<ModelBase> {
    return std::make_unique<T>();
  };
  Error err = executor_->FindImpl(*this, base_results, factory);
  if (err) {
    return err;
  }

  results_vector->clear();
  results_vector->reserve(base_results.size());
  for (auto &base_ptr : base_results) {
    results_vector->emplace_back(static_cast<T *>(base_ptr.release()));
  }
  return make_ok();
}

template <typename T>
inline Error
QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector,
                   const std::map<std::string, QueryValue> &conditions) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(conditions);
  return this->Find(results_vector);
}

template <typename T>
inline Error QueryBuilder::Find(std::vector<std::unique_ptr<T>> *results_vector,
                                const std::string &query_string,
                                const std::vector<QueryValue> &args) {
  if (!this->state_.model_meta_ ||
      this->state_.model_meta_ != &(T::getModelMeta())) {
    this->Model<T>();
  }
  this->Where(query_string, args);
  return this->Find(results_vector);
}

// Non-template Find(std::vector<std::unique_ptr<ModelBase>>&, factory) is in
// query_builder_core.cpp

template <typename TModel>
inline std::expected<QVariant, Error> QueryBuilder::Create(TModel &model) {
  static_assert(std::is_base_of<ModelBase, TModel>::value,
                "TModel must be a descendant of cpporm::ModelBase");
  return this->Create(static_cast<ModelBase &>(model), nullptr);
}

// Non-template Create(ModelBase&, const OnConflictClause*) is in
// query_builder_core.cpp

// Non-template Updates(map) is in query_builder_core.cpp
// Non-template Delete() is in query_builder_core.cpp

template <typename TModel>
inline std::expected<long long, Error> QueryBuilder::Save(TModel &model) {
  static_assert(std::is_base_of<ModelBase, TModel>::value,
                "TModel must be a descendant of cpporm::ModelBase");
  return this->Save(static_cast<ModelBase &>(model));
}

// Non-template Save(ModelBase&) is in query_builder_core.cpp
// Non-template Count() is in query_builder_core.cpp

} // namespace cpporm

#endif // cpporm_QUERY_BUILDER_EXECUTION_H// cpporm/session_batch_ops.h
#ifndef cpporm_SESSION_BATCH_OPS_H
#define cpporm_SESSION_BATCH_OPS_H

#include <algorithm>  // For std::min
#include <expected>
#include <functional>
#include <memory>
#include <optional>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/model_base.h"    // For ModelType constraints
#include "cpporm/session_core.h"  // Needs Session definition

// QueryBuilder is included via session_core.h -> query_builder.h

namespace cpporm {

    // --- Implementations for Templated CreateBatch methods ---
    // 这些实现看起来应该能与 CreateBatchProviderInternal 配合，
    // 因为后者处理底层的 ModelBase*。主要的关注点是返回类型和错误处理。
    // 返回类型 `std::expected<std::vector<std::shared_ptr<ModelType>>, Error>` 保持不变。
    // 错误处理依赖于 CreateBatchProviderInternal 返回的 Error 对象。

    // Vector of raw pointers version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(const std::vector<ModelType *> &models_raw_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_raw_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        base_models_for_internal_provider.reserve(models_raw_input.size());
        std::vector<ModelType *> original_input_ptrs_filtered;
        original_input_ptrs_filtered.reserve(models_raw_input.size());

        for (ModelType *typed_ptr : models_raw_input) {
            if (typed_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(typed_ptr));
                original_input_ptrs_filtered.push_back(typed_ptr);
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;  // 表示没有更多数据或当前块为空
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (ModelBase *base_ptr : successfully_processed_and_backfilled_models_collector) {
            ModelType *typed_ptr = static_cast<ModelType *>(base_ptr);
            bool found_in_original = false;
            for (ModelType *original_typed_ptr : original_input_ptrs_filtered) {
                if (typed_ptr == original_typed_ptr) {
                    found_in_original = true;
                    break;
                }
            }
            if (found_in_original) {
                final_result_sptrs.emplace_back(typed_ptr, [](ModelType *) { /* no-op deleter */ });
            }
        }
        return final_result_sptrs;
    }

    // Vector of unique_ptr version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(std::vector<std::unique_ptr<ModelType>> &models_unique_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_unique_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        std::vector<ModelType *> unique_ptr_original_raw_ptrs;
        base_models_for_internal_provider.reserve(models_unique_input.size());
        unique_ptr_original_raw_ptrs.reserve(models_unique_input.size());

        for (const auto &u_ptr : models_unique_input) {
            if (u_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(u_ptr.get()));
                unique_ptr_original_raw_ptrs.push_back(u_ptr.get());
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (auto &u_ptr : models_unique_input) {
            if (u_ptr) {
                bool found_and_persisted = false;
                for (ModelBase *processed_base_ptr : successfully_processed_and_backfilled_models_collector) {
                    if (static_cast<ModelBase *>(u_ptr.get()) == processed_base_ptr) {
                        found_and_persisted = true;
                        break;
                    }
                }
                if (found_and_persisted) {
                    final_result_sptrs.push_back(std::move(u_ptr));
                }
            }
        }
        models_unique_input.erase(std::remove(models_unique_input.begin(), models_unique_input.end(), nullptr), models_unique_input.end());
        return final_result_sptrs;
    }

    // Vector of shared_ptr version
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(const std::vector<std::shared_ptr<ModelType>> &models_shared_input, size_t internal_db_batch_size_hint, const OnConflictClause *conflict_options_override) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");
        if (models_shared_input.empty()) return std::vector<std::shared_ptr<ModelType>>{};

        std::vector<ModelBase *> base_models_for_internal_provider;
        base_models_for_internal_provider.reserve(models_shared_input.size());
        for (const auto &s_ptr : models_shared_input) {
            if (s_ptr) {
                base_models_for_internal_provider.push_back(static_cast<ModelBase *>(s_ptr.get()));
            }
        }
        if (base_models_for_internal_provider.empty()) {
            return std::vector<std::shared_ptr<ModelType>>{};
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> final_result_sptrs;
        Error overall_error_from_all_batches = make_ok();

        size_t current_idx_provider = 0;
        auto internal_data_provider = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_idx_provider >= base_models_for_internal_provider.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk_to_process;
            size_t end_idx = std::min(base_models_for_internal_provider.size(), current_idx_provider + internal_db_batch_size_hint);
            for (size_t i = current_idx_provider; i < end_idx; ++i) {
                chunk_to_process.push_back(base_models_for_internal_provider[i]);
            }
            current_idx_provider = end_idx;
            if (chunk_to_process.empty()) return std::nullopt;
            return chunk_to_process;
        };

        std::vector<ModelBase *> successfully_processed_and_backfilled_models_collector;

        auto internal_completion_callback = [&overall_error_from_all_batches, &successfully_processed_and_backfilled_models_collector](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_with_ids) {
                    if (bm && bm->_is_persisted) {
                        successfully_processed_and_backfilled_models_collector.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, internal_data_provider, internal_completion_callback, conflict_options_override);

        if (provider_loop_error) return std::unexpected(provider_loop_error);
        if (overall_error_from_all_batches) return std::unexpected(overall_error_from_all_batches);

        final_result_sptrs.reserve(successfully_processed_and_backfilled_models_collector.size());
        for (const auto &original_s_ptr : models_shared_input) {
            if (original_s_ptr) {
                bool found_and_persisted = false;
                for (ModelBase *processed_base_ptr : successfully_processed_and_backfilled_models_collector) {
                    if (static_cast<ModelBase *>(original_s_ptr.get()) == processed_base_ptr) {
                        found_and_persisted = true;
                        break;
                    }
                }
                if (found_and_persisted) {
                    final_result_sptrs.push_back(original_s_ptr);
                }
            }
        }
        return final_result_sptrs;
    }

    // Provider-based CreateBatch implementation
    template <typename ModelType>
    inline std::expected<std::vector<std::shared_ptr<ModelType>>, Error> Session::CreateBatch(std::function<std::optional<std::vector<ModelType *>>()> data_batch_provider_typed, const OnConflictClause *conflict_options_override, size_t) {
        static_assert(std::is_base_of<ModelBase, ModelType>::value, "ModelType must derive from ModelBase.");

        if (!data_batch_provider_typed) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateBatch (provider): data_batch_provider_typed is null."));
        }

        QueryBuilder qb_proto = this->Model<ModelType>();
        std::vector<std::shared_ptr<ModelType>> all_successfully_created_models_sptr;
        Error overall_error_from_all_batches = make_ok();

        auto data_batch_provider_base_adapted = [provider_typed = std::move(data_batch_provider_typed)]() mutable -> std::optional<std::vector<ModelBase *>> {
            auto typed_batch_opt = provider_typed();
            if (!typed_batch_opt.has_value()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> base_batch;
            base_batch.reserve(typed_batch_opt.value().size());
            for (ModelType *typed_ptr : typed_batch_opt.value()) {
                if (typed_ptr) {
                    base_batch.push_back(static_cast<ModelBase *>(typed_ptr));
                }
            }
            return base_batch;
        };

        std::vector<ModelBase *> collected_processed_base_models_with_ids;

        auto internal_completion_callback_for_provider = [&overall_error_from_all_batches, &collected_processed_base_models_with_ids](const std::vector<ModelBase *> &processed_batch_models_from_internal_call, Error batch_db_error) {
            if (batch_db_error && overall_error_from_all_batches.isOk()) {
                overall_error_from_all_batches = batch_db_error;
            }
            if (!batch_db_error) {
                for (ModelBase *bm : processed_batch_models_from_internal_call) {
                    if (bm && bm->_is_persisted) {
                        collected_processed_base_models_with_ids.push_back(bm);
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, data_batch_provider_base_adapted, internal_completion_callback_for_provider, conflict_options_override);

        if (provider_loop_error) {
            return std::unexpected(provider_loop_error);
        }
        if (overall_error_from_all_batches) {
            return std::unexpected(overall_error_from_all_batches);
        }

        all_successfully_created_models_sptr.reserve(collected_processed_base_models_with_ids.size());
        for (ModelBase *base_ptr : collected_processed_base_models_with_ids) {
            ModelType *typed_ptr = static_cast<ModelType *>(base_ptr);
            all_successfully_created_models_sptr.emplace_back(typed_ptr);
        }

        return all_successfully_created_models_sptr;
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_BATCH_OPS_H// Base/CppOrm/Include/cpporm/session_core.h
#ifndef cpporm_SESSION_CORE_H
#define cpporm_SESSION_CORE_H

#include <QString>
#include <QVariant>
#include <QVariantList>
#include <any>
#include <expected>
#include <functional>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session_fwd.h"
#include "cpporm/session_types.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_driver_manager.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {
        class FriendAccess;
    }
}  // namespace cpporm

namespace cpporm {

    class Session : public IQueryExecutor {
      public:
        explicit Session(const std::string &connection_name);
        explicit Session(cpporm_sqldriver::SqlDatabase &&db_handle_rval);

        Session(const Session &) = delete;
        Session &operator=(const Session &) = delete;
        Session(Session &&other) noexcept;
        Session &operator=(Session &&other) noexcept;
        ~Session();

        QueryBuilder Model(const ModelBase *model_instance_hint);
        QueryBuilder Model(const ModelMeta &meta);
        template <typename T>
        QueryBuilder Model() {
            static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
            return QueryBuilder(this, connection_name_, &(T::getModelMeta()));
        }
        QueryBuilder Table(const std::string &table_name);
        QueryBuilder MakeQueryBuilder();

        Session &OnConflictUpdateAllExcluded();
        Session &OnConflictDoNothing();
        Session &OnConflictUpdateSpecific(std::function<void(SessionOnConflictUpdateSetter &)> updater_fn);

        Error FirstImpl(const QueryBuilder &qb, ModelBase &result_model) override;
        Error FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) override;
        std::expected<cpporm_sqldriver::SqlValue, Error> CreateImpl(const QueryBuilder &qb, ModelBase &model, const OnConflictClause *conflict_options_override) override;
        std::expected<long long, Error> UpdatesImpl(const QueryBuilder &qb, const std::map<std::string, QueryValue> &updates) override;
        std::expected<long long, Error> DeleteImpl(const QueryBuilder &qb) override;
        std::expected<long long, Error> SaveImpl(const QueryBuilder &qb, ModelBase &model) override;
        std::expected<int64_t, Error> CountImpl(const QueryBuilder &qb) override;

        std::expected<cpporm_sqldriver::SqlValue, Error> Create(ModelBase &model, const OnConflictClause *conflict_options_override = nullptr);

        template <typename TModel>
        std::expected<cpporm_sqldriver::SqlValue, Error> Create(TModel &model);

        Error First(ModelBase &result_model);
        Error First(ModelBase &result_model, const QueryValue &primary_key_value);
        Error First(ModelBase &result_model, const std::vector<QueryValue> &primary_key_values);
        Error First(ModelBase &result_model, const std::map<std::string, QueryValue> &conditions);

        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory, const std::map<std::string, QueryValue> &conditions);
        Error Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error First(T *result_model, QueryBuilder qb);
        template <typename T>
        Error First(T *result_model);
        template <typename T>
        Error First(T *result_model, const QueryValue &primary_key_value);
        template <typename T>
        Error First(T *result_model, const std::vector<QueryValue> &primary_key_values);
        template <typename T>
        Error First(T *result_model, const std::map<std::string, QueryValue> &conditions);

        template <typename T>
        Error Find(std::vector<T> *results_vector, QueryBuilder qb);
        template <typename T>
        Error Find(std::vector<T> *results_vector);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, QueryBuilder qb);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions);
        template <typename T>
        Error Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args = {});

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(const std::vector<ModelType *> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(std::vector<std::unique_ptr<ModelType>> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(const std::vector<std::shared_ptr<ModelType>> &models, size_t internal_db_batch_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        template <typename ModelType>
        std::expected<std::vector<std::shared_ptr<ModelType>>, Error> CreateBatch(std::function<std::optional<std::vector<ModelType *>>()> data_batch_provider_typed, const OnConflictClause *conflict_options_override = nullptr, size_t internal_db_batch_processing_size_hint = 100);

        std::expected<size_t, Error> CreateBatchWithMeta(const ModelMeta &meta, const std::vector<ModelBase *> &models, size_t internal_batch_processing_size = 100, const OnConflictClause *conflict_options_override = nullptr);

        Error CreateBatchProviderInternal(QueryBuilder qb_prototype,
                                          std::function<std::optional<std::vector<ModelBase *>>()> data_batch_provider_base,
                                          std::function<void(const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error)> per_db_batch_completion_callback,
                                          const OnConflictClause *conflict_options_override);

        std::expected<long long, Error> Save(ModelBase &model);
        template <typename TModel>
        std::expected<long long, Error> Save(TModel &model);

        std::expected<long long, Error> Updates(QueryBuilder qb, const std::map<std::string, QueryValue> &updates);
        std::expected<long long, Error> Delete(QueryBuilder qb);

        std::expected<long long, Error> Updates(const ModelMeta &meta, const std::map<std::string, QueryValue> &updates, const std::map<std::string, QueryValue> &conditions);
        std::expected<long long, Error> Updates(const ModelBase &model_condition, const std::map<std::string, QueryValue> &updates);

        std::expected<long long, Error> Delete(const ModelBase &model_condition);
        std::expected<long long, Error> Delete(const ModelMeta &meta, const std::map<std::string, QueryValue> &conditions);

        std::expected<long long, Error> DeleteBatch(const ModelMeta &meta, const std::vector<std::map<std::string, QueryValue>> &primary_keys_list, size_t batch_delete_size = 100);

        std::expected<long long, Error> ExecRaw(const QString &sql, const QVariantList &args = {});

        Error AutoMigrate(const ModelMeta &meta);
        Error AutoMigrate(const std::vector<const ModelMeta *> &metas);

        std::expected<std::unique_ptr<Session>, Error> Begin();
        Error Commit();
        Error Rollback();
        bool IsTransaction() const;

        const std::string &getConnectionName() const;
        cpporm_sqldriver::SqlDatabase &getDbHandle();
        const cpporm::OnConflictClause *getTempOnConflictClause() const;
        void clearTempOnConflictClause();

        static std::string getSqlTypeForCppType(const FieldMeta &field_meta, const QString &driverName_std);
        static void qvariantToAny(const QVariant &qv, const std::type_index &target_cpp_type, std::any &out_any, bool &out_conversion_ok);
        static QueryValue anyToQueryValueForSessionConvenience(const std::any &val);

        static cpporm_sqldriver::SqlValue queryValueToSqlValue(const QueryValue &qv);
        static QueryValue sqlValueToQueryValue(const cpporm_sqldriver::SqlValue &sv);

      private:
        static std::pair<cpporm_sqldriver::SqlQuery, Error> execute_query_internal(cpporm_sqldriver::SqlDatabase &db_conn_ref, const std::string &sql, const std::vector<cpporm_sqldriver::SqlValue> &bound_params);
        Error mapRowToModel(cpporm_sqldriver::SqlQuery &query, ModelBase &model, const ModelMeta &meta);
        internal::SessionModelDataForWrite extractModelData(const ModelBase &model_instance, const ModelMeta &meta, bool for_update = false, bool include_timestamps_even_if_null = false);

        friend class internal_batch_helpers::FriendAccess;

        void autoSetTimestamps(ModelBase &model_instance, const ModelMeta &meta, bool is_create_op);

        Error processPreloadsInternal(const QueryBuilder &qb, std::vector<ModelBase *> &models_raw_ptr);
        Error processPreloads(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &loaded_models);
        // Declaration for executePreloadForAssociation with 4 parameters
        Error executePreloadForAssociation(const AssociationMeta &assoc_meta, const ModelMeta &parent_model_meta, std::vector<ModelBase *> &parent_models_raw_ptr, const std::string &remaining_nested_preload_path = "");

        std::string connection_name_;
        cpporm_sqldriver::SqlDatabase db_handle_;
        bool is_explicit_transaction_handle_;
        std::unique_ptr<OnConflictClause> temp_on_conflict_clause_;
    };

}  // namespace cpporm

#endif// cpporm/session_crud_ops.h
#ifndef cpporm_SESSION_CRUD_OPS_H
#define cpporm_SESSION_CRUD_OPS_H

#include "cpporm/session_core.h"         // 包含 Session 核心定义和 QueryBuilder
#include "cpporm_sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    // --- 实现简单的模板化便捷 CRUD 方法 ---

    template <typename TModel>  // 返回 SqlValue
    inline std::expected<cpporm_sqldriver::SqlValue, Error> Session::Create(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        // 调用 Session 的非模板 Create 方法，该方法已更新为返回 SqlValue
        return this->Create(static_cast<ModelBase &>(model), nullptr);
    }

    template <typename T>
    inline Error Session::First(T *result_model, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        // QueryBuilder::First 已经过修改以与 IQueryExecutor 的新接口配合
        return qb.First(result_model);
    }

    template <typename T>
    inline Error Session::First(T *result_model) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const QueryValue &primary_key_value) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model, primary_key_value);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const std::vector<QueryValue> &primary_key_values) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().First(result_model, primary_key_values);
    }

    template <typename T>
    inline Error Session::First(T *result_model, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).First(result_model);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return qb.Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<T> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(query_string, args).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, QueryBuilder qb) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return qb.Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::map<std::string, QueryValue> &conditions) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(conditions).Find(results_vector);
    }

    template <typename T>
    inline Error Session::Find(std::vector<std::unique_ptr<T>> *results_vector, const std::string &query_string, const std::vector<QueryValue> &args) {
        static_assert(std::is_base_of<ModelBase, T>::value, "T must be a descendant of cpporm::ModelBase");
        return this->Model<T>().Where(query_string, args).Find(results_vector);
    }

    template <typename TModel>
    inline std::expected<long long, Error> Session::Save(TModel &model) {
        static_assert(std::is_base_of<ModelBase, TModel>::value, "TModel must be a descendant of cpporm::ModelBase");
        return this->Save(static_cast<ModelBase &>(model));
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_CRUD_OPS_H// cpporm/session_fwd.h
#ifndef cpporm_SESSION_FWD_H
#define cpporm_SESSION_FWD_H

#include <memory> // For std::unique_ptr if used in forward declared params/returns

namespace cpporm {

class Session; // Forward declaration
class QueryBuilder;
struct OnConflictClause; // Forward declaration if needed by SessionCore setters
                         // but defined elsewhere (e.g., query_builder_state.h)

// If SessionOnConflictUpdateSetter is tightly coupled and only used by Session,
// its forward declaration or full definition might go here or in session_core.h
// For now, let's assume it's defined before session_core.h needs its full type.

} // namespace cpporm

#endif // cpporm_SESSION_FWD_H// Base/CppOrm/Include/cpporm/session_migrate_priv.h
#ifndef cpporm_SESSION_MIGRATE_PRIV_H
#define cpporm_SESSION_MIGRATE_PRIV_H

#include "cpporm/error.h"
#include "cpporm/model_base.h"
// #include <QSqlDatabase> // Removed: No longer needed here, functions use Session&
#include <QString>  // Still used for driverNameUpper and some internal logic if not fully migrated
#include <map>
#include <string>
#include <vector>

// Forward declare SqlDatabase if needed, but Session reference should provide it
namespace cpporm_sqldriver {
    class SqlDatabase;
    class SqlQuery;
}  // namespace cpporm_sqldriver

namespace cpporm {

    class Session;

    namespace internal {

        // --- Table Operations ---
        Error migrateCreateTable(Session &session, const ModelMeta &meta, const QString &driverNameUpper);

        // --- Column Operations ---
        struct DbColumnInfo {
            std::string name;
            std::string type;
            std::string normalized_type;
            bool is_nullable = true;
            std::string default_value;
            std::string character_set_name;
            std::string collation_name;
            std::string column_key;
            std::string extra;
        };
        std::map<std::string, DbColumnInfo> getTableColumnsInfo(Session &session, const QString &tableName, const QString &driverNameUpper);
        Error migrateModifyColumns(Session &session, const ModelMeta &meta, const QString &driverNameUpper);

        // --- Index Operations ---
        struct DbIndexInfo {
            std::string index_name;
            std::vector<std::string> column_names;
            bool is_unique = false;
            bool is_primary_key = false;
            std::string type_method;
        };
        std::map<std::string, DbIndexInfo> getTableIndexesInfo(Session &session, const QString &tableName, const QString &driverNameUpper);
        Error migrateManageIndexes(Session &session, const ModelMeta &meta, const QString &driverNameUpper);

        // Helper for executing DDL - signature changed
        std::pair<cpporm_sqldriver::SqlQuery, Error> execute_ddl_query(cpporm_sqldriver::SqlDatabase &db,  // Pass by reference
                                                                       const std::string &ddl_sql_std);    // SQL as std::string

    }  // namespace internal
}  // namespace cpporm

#endif  // cpporm_SESSION_MIGRATE_PRIV_H// Base/CppOrm/Include/cpporm/session_priv_batch_helpers.h
#ifndef cpporm_SESSION_PRIV_BATCH_HELPERS_H
#define cpporm_SESSION_PRIV_BATCH_HELPERS_H

#include <QString>
#include <QStringList>
#include <QVariantList>
#include <string>
#include <typeindex>
#include <vector>

#include "cpporm/error.h"
#include "cpporm/session_fwd.h"
#include "cpporm/session_types.h"

// Forward declare types from cpporm_sqldriver that are used in signatures
namespace cpporm_sqldriver {
    class SqlQuery;
    class SqlValue;
    class SqlDatabase;  // Added forward declaration for SqlDatabase
}  // namespace cpporm_sqldriver

namespace cpporm {

    class ModelBase;
    struct ModelMeta;
    struct FieldMeta;
    struct OnConflictClause;
    class QueryBuilder;

    namespace internal_batch_helpers {

        class FriendAccess {
          public:
            static internal::SessionModelDataForWrite callExtractModelData(Session &s, const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null);

            static std::pair<cpporm_sqldriver::SqlQuery, Error> callExecuteQueryInternal(cpporm_sqldriver::SqlDatabase &db_ref,  // Changed from QSqlDatabase
                                                                                         const std::string &sql,
                                                                                         const std::vector<cpporm_sqldriver::SqlValue> &params);

            static void callAutoSetTimestamps(Session &s, ModelBase &model_instance, const ModelMeta &meta, bool is_create_op);
        };

        struct BatchSqlParts {
            QString sql_insert_base;
            QStringList row_placeholders;
            std::vector<cpporm_sqldriver::SqlValue> all_values_flattened;
            QString sql_on_conflict_suffix;
            QVariantList conflict_suffix_bindings;
            std::string final_sql_statement;
            std::vector<cpporm_sqldriver::SqlValue> final_bindings;
            bool can_proceed = false;
        };

        struct ExecutionResult {
            cpporm_sqldriver::SqlQuery query_object;
            long long rows_affected = -1;
            Error db_error = make_ok();
            std::vector<ModelBase *> models_potentially_persisted;

            // Default constructor to initialize query_object if SqlQuery needs it
            ExecutionResult() : query_object(nullptr) {
            }  // Assuming SqlQuery can be constructed with nullptr or similar for default
               // Or ensure SqlQuery has a proper default constructor if not taking a db handle.
               // If SqlQuery MUST take a SqlDatabase, then this default ctor is problematic
               // and might need to be removed if an invalid SqlQuery state is acceptable.
               // Let's assume SqlQuery can be default constructed or from nullptr.
               // If SqlQuery has a constructor like SqlQuery(SqlDatabase* db = nullptr) or similar,
               // or a default constructor, then this is fine.
               // Given the later assignment `result.query_object = std::move(exec_pair.first);`
               // a default-constructible query_object is necessary.
        };

        std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(Session &session, const std::vector<ModelBase *> &models_in_provider_chunk, const ModelMeta &meta, const std::vector<std::string> &batch_ordered_db_field_names_cache, BatchSqlParts &out_sql_parts);

        Error buildFullBatchSqlStatement(const Session &session, const QueryBuilder &qb_prototype, const ModelMeta &meta, const std::vector<std::string> &batch_ordered_db_field_names_cache, const OnConflictClause *active_conflict_clause, BatchSqlParts &in_out_sql_parts);

        ExecutionResult executeBatchSql(Session &session, const std::string &sql_to_execute_std, const std::vector<cpporm_sqldriver::SqlValue> &bindings_sqlvalue, const std::vector<ModelBase *> &models_in_db_op, const OnConflictClause *active_conflict_clause);

        std::vector<ModelBase *> backfillIdsFromReturning(cpporm_sqldriver::SqlQuery &executed_query, const ModelMeta &meta, const std::vector<ModelBase *> &models_to_backfill_from, const std::string &pk_cpp_name_str, const std::type_index &pk_cpp_type);

        std::vector<ModelBase *> backfillIdsFromLastInsertId(cpporm_sqldriver::SqlQuery &executed_query,
                                                             const Session &session,
                                                             const ModelMeta &meta,
                                                             const std::vector<ModelBase *> &models_to_backfill_from,
                                                             long long total_rows_affected_by_query,
                                                             const std::string &pk_cpp_name_str,
                                                             const std::type_index &pk_cpp_type,
                                                             const OnConflictClause *active_conflict_clause);

        void callAfterCreateHooks(Session &session, const std::vector<ModelBase *> &successfully_persisted_and_backfilled_models, Error &in_out_first_error_encountered);

    }  // namespace internal_batch_helpers
}  // namespace cpporm

#endif// cpporm/session_priv_batch_helpers_fwd.h
#ifndef cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H
#define cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H

#include <QString>
#include <QVariant>
#include <string>
#include <utility> // For std::pair
#include <vector>
// 前向声明核心类型，避免循环依赖
namespace cpporm {
class Session;
class ModelBase;
struct ModelMeta;
struct Error; // 假设 Error 定义在 error.h 中，并且被广泛包含
struct OnConflictClause;

namespace internal_batch_helpers {
struct BatchSqlParts;   // 在 session_priv_batch_helpers.h 中定义
struct ExecutionResult; // 在 session_priv_batch_helpers.h 中定义

// 声明将成为 Session 友元的函数
std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(
    Session &session, const std::vector<ModelBase *> &models_in_provider_chunk,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache,
    BatchSqlParts &out_sql_parts);

ExecutionResult executeBatchSql(Session &session, const QString &sql_to_execute,
                                const QVariantList &bindings,
                                const std::vector<ModelBase *> &models_in_db_op,
                                const OnConflictClause *active_conflict_clause);

// 其他在 internal_batch_helpers 中定义但在 session_core.h 中不需要友元的函数，
// 则不需要在此处前向声明。
} // namespace internal_batch_helpers
} // namespace cpporm

#endif // cpporm_SESSION_PRIV_BATCH_HELPERS_FWD_H#ifndef cpporm_SESSION_TYPES_H
#define cpporm_SESSION_TYPES_H

#include <QString>   // QVariant 依赖 QString
#include <QVariant>  // QueryValue 仍然可以持有 QVariant 支持的类型
#include <map>
#include <string>
#include <typeindex>

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause, QueryValue
#include "cpporm_sqldriver/sql_value.h"                // 使用 SqlValue

namespace cpporm {

    class SessionOnConflictUpdateSetter {
      public:
        explicit SessionOnConflictUpdateSetter(OnConflictClause &clause_ref);
        SessionOnConflictUpdateSetter &Set(const std::string &db_column_name, const QueryValue &value);
        SessionOnConflictUpdateSetter &Set(const std::map<std::string, QueryValue> &assignments);

      private:
        OnConflictClause &clause_to_build_;
    };

    // Session 内部用于数据提取的结构体
    namespace internal {
        struct SessionModelDataForWrite {
            // fields_to_write 将从 QVariant 改为 SqlValue
            std::map<std::string, cpporm_sqldriver::SqlValue> fields_to_write;
            // primary_key_fields 也改为 SqlValue
            std::map<std::string, cpporm_sqldriver::SqlValue> primary_key_fields;
            bool has_auto_increment_pk = false;
            std::string auto_increment_pk_name_db;      // 已经是 std::string
            std::string pk_cpp_name_for_autoincrement;  // 已经是 std::string
            std::type_index pk_cpp_type_for_autoincrement = typeid(void);
        };
    }  // namespace internal

    inline SessionOnConflictUpdateSetter::SessionOnConflictUpdateSetter(OnConflictClause &clause_ref) : clause_to_build_(clause_ref) {
        clause_to_build_.action = OnConflictClause::Action::UpdateSpecific;
    }

    inline SessionOnConflictUpdateSetter &SessionOnConflictUpdateSetter::Set(const std::string &db_column_name, const QueryValue &value) {
        clause_to_build_.update_assignments[db_column_name] = value;
        return *this;
    }

    inline SessionOnConflictUpdateSetter &SessionOnConflictUpdateSetter::Set(const std::map<std::string, QueryValue> &assignments) {
        for (const auto &pair : assignments) {
            clause_to_build_.update_assignments[pair.first] = pair.second;
        }
        return *this;
    }

}  // namespace cpporm

#endif  // cpporm_SESSION_TYPES_H// cpporm/builder_parts/query_builder_conditions_qb_overloads.cpp
#include <QDebug>   // For qWarning
#include <QString>  // For getFromSourceName return type

#include "cpporm/builder_parts/query_builder_state.h"  // For SubqueryExpression, Error, QueryValue
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and QueryBuilderConditionsMixin

namespace cpporm {

    // --- Implementations for QueryBuilder's own Where/Or/Not overloads ---
    // These handle QueryBuilder instances as conditions.

    QueryBuilder &QueryBuilder::Where(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;

        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            // Check if both are simple table names or both are same model implied tables
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() &&                       // Current QB uses this table name directly
                std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {  // Sub QB uses this table name directly
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ &&                           // Same model
                       std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&                     // Current QB implies model table
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()  // Sub QB implies model table
            ) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            // Merge conditions directly
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Where(sub_cond_sql, sub_cond_args);
            }
            // If the sub-condition disables soft delete, propagate that
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            // Use EXISTS (subquery)
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Where(const QueryBuilder& sub_qb): Failed "
                              "to convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Where("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Or(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;
        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() && std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) &&
                std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ && std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Or(sub_cond_sql, sub_cond_args);
            }
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Or(const QueryBuilder& sub_qb): Failed to "
                              "convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Or("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Not(const QueryBuilder &sub_qb_condition) {
        bool same_table_and_simple_source = false;
        QString this_from_name_qstr = this->getFromSourceName();
        QString sub_from_name_qstr = sub_qb_condition.getFromSourceName();

        if (!this_from_name_qstr.isEmpty() && !sub_from_name_qstr.isEmpty() && this_from_name_qstr == sub_from_name_qstr) {
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_) == this_from_name_qstr.toStdString() && std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) &&
                std::get<std::string>(sub_qb_condition.state_.from_clause_source_) == sub_from_name_qstr.toStdString()) {
                same_table_and_simple_source = true;
            } else if (this->state_.model_meta_ && sub_qb_condition.state_.model_meta_ && this->state_.model_meta_ == sub_qb_condition.state_.model_meta_ && std::holds_alternative<std::string>(this->state_.from_clause_source_) && std::get<std::string>(this->state_.from_clause_source_).empty() &&
                       std::holds_alternative<std::string>(sub_qb_condition.state_.from_clause_source_) && std::get<std::string>(sub_qb_condition.state_.from_clause_source_).empty()) {
                same_table_and_simple_source = true;
            }
        }

        if (same_table_and_simple_source) {
            auto [sub_cond_sql, sub_cond_args] = sub_qb_condition.buildConditionClauseGroup();
            if (!sub_cond_sql.empty()) {
                this->QueryBuilderConditionsMixin<QueryBuilder>::Not(sub_cond_sql, sub_cond_args);
            }
            if (!sub_qb_condition.state_.apply_soft_delete_scope_) {
                this->state_.apply_soft_delete_scope_ = false;
            }
        } else {
            auto sub_expr_expected = sub_qb_condition.AsSubquery();
            if (!sub_expr_expected) {
                qWarning() << "QueryBuilder::Not(const QueryBuilder& sub_qb): Failed to "
                              "convert subquery for EXISTS: "
                           << QString::fromStdString(sub_expr_expected.error().message);
                return *this;
            }
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Not("EXISTS (?)", std::vector<QueryValue>{std::move(sub_expr_expected.value())});
        }
        return *this;
    }

    // Overloads for std::expected<SubqueryExpression, Error>
    QueryBuilder &QueryBuilder::Where(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Where("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Where(expected<Subquery>): Subquery "
                          "generation failed: "
                       << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Or(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Or("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Or(expected<Subquery>): Subquery generation failed: " << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Not(const std::expected<SubqueryExpression, Error> &sub_expr_expected) {
        if (sub_expr_expected.has_value()) {
            return this->QueryBuilderConditionsMixin<QueryBuilder>::Not("EXISTS (?)", std::vector<QueryValue>{sub_expr_expected.value()});
        } else {
#ifdef QT_CORE_LIB
            qWarning() << "QueryBuilder::Not(expected<Subquery>): Subquery generation failed: " << QString::fromStdString(sub_expr_expected.error().message) << ". Condition based on this subquery will not be added.";
#endif
        }
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_core.cpp
#include "cpporm/query_builder_core.h"
#include "cpporm/i_query_executor.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h" // For Session::anyToQueryValueForSessionConvenience

#include <QDebug>
#include <QMetaType>
#include <sstream>
#include <variant>

namespace cpporm {

// Non-template member function definitions for QueryBuilder have been moved to:
// - query_builder_lifecycle.cpp (constructors, destructor, assignments)
// - query_builder_setters_core.cpp (Model, Table, From, With, OnConflict,
// SelectSubquery, QB-specific Where/Or/Not)
// - query_builder_execution_non_template.cpp (First(ModelBase&), Find, Create,
// Updates, Delete, Save, Count)
// - query_builder_utils.cpp (getFromSourceName, AsSubquery, static
// quoteSqlIdentifier, static toQVariant, toSqlDebug)
// - query_builder_helpers.cpp (internal SQL build helpers)

// This file (query_builder_core.cpp) is now primarily for any potential future
// non-template, non-static QueryBuilder methods that don't fit into the above
// categories, or if some specific core logic needed a central, non-header
// definition point. Currently, based on the linker errors, it seems all
// problematic definitions were duplicated from their intended separate files.

} // namespace cpporm// cpporm/builder_parts/query_builder_cte_select_subquery.cpp
#include <QDebug>   // For qWarning
#include <variant>  // For std::visit in WithRaw

#include "cpporm/builder_parts/query_builder_state.h"  // For SubqueryExpression, QueryValue, CTEState, NamedSubqueryField
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and QueryBuilderClausesMixin

namespace cpporm {

    QueryBuilder &QueryBuilder::SelectSubquery(const QueryBuilder &subquery_builder, const std::string &alias) {
        auto sub_expr_expected = subquery_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::SelectSubquery(QueryBuilder): Failed "
                          "to create subquery expression: "
                       << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        // AddSelect is part of QueryBuilderClausesMixin
        this->AddSelect(NamedSubqueryField{std::move(sub_expr_expected.value()), alias});
        return *this;
    }

    QueryBuilder &QueryBuilder::SelectSubquery(const SubqueryExpression &subquery_expr, const std::string &alias) {
        this->AddSelect(NamedSubqueryField{subquery_expr, alias});
        return *this;
    }

    QueryBuilder &QueryBuilder::With(const std::string &cte_name, const QueryBuilder &cte_query_builder, bool recursive) {
        auto sub_expr_expected = cte_query_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::With: Failed to create subquery for CTE '" << QString::fromStdString(cte_name) << "': " << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        state_.ctes_.emplace_back(cte_name, std::move(sub_expr_expected.value()), recursive);
        return *this;
    }

    QueryBuilder &QueryBuilder::WithRaw(const std::string &cte_name, const std::string &raw_sql, const std::vector<QueryValue> &bindings, bool recursive) {
        std::vector<QueryValueVariantForSubquery> native_bindings;
        native_bindings.reserve(bindings.size());
        for (const auto &qv_arg : bindings) {
            std::visit(
                [&native_bindings](auto &&arg_val) {
                    using ArgT = std::decay_t<decltype(arg_val)>;
                    if constexpr (std::is_same_v<ArgT, SubqueryExpression>) {
                        qWarning() << "cpporm QueryBuilder::WithRaw: SubqueryExpression as a "
                                      "binding for raw CTE is complex. Only its bindings are "
                                      "used.";
                        for (const auto &sub_binding : arg_val.bindings) {
                            native_bindings.push_back(sub_binding);
                        }
                    } else if constexpr (std::is_same_v<ArgT, std::nullptr_t> || std::is_same_v<ArgT, int> || std::is_same_v<ArgT, long long> || std::is_same_v<ArgT, double> || std::is_same_v<ArgT, std::string> || std::is_same_v<ArgT, bool> || std::is_same_v<ArgT, QDateTime> ||
                                         std::is_same_v<ArgT, QDate> || std::is_same_v<ArgT, QTime> || std::is_same_v<ArgT, QByteArray>) {
                        native_bindings.push_back(arg_val);
                    } else {
                        qWarning() << "QueryBuilder::WithRaw: Skipping unsupported "
                                      "QueryValue variant type '"
                                   << typeid(ArgT).name() << "' for raw CTE binding.";
                    }
                },
                qv_arg);
        }
        state_.ctes_.emplace_back(cte_name, SubqueryExpression(raw_sql, std::move(native_bindings)), recursive);
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_execution_non_template.cpp
#include "cpporm/i_query_executor.h"     // For IQueryExecutor
#include "cpporm/query_builder_core.h"   // For QueryBuilder definition
#include "cpporm/session.h"              // For Session::anyToQueryValueForSessionConvenience (still valid)
#include "cpporm_sqldriver/sql_value.h"  // For SqlValue in Create return type

// QDebug, QMetaType, sstream, variant are included via query_builder_core.h or session.h

namespace cpporm {

    Error QueryBuilder::First(ModelBase &result_model) {
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

        const ModelMeta &meta = result_model._getOwnModelMeta();
        if (this->state_.model_meta_ != &meta) {
            this->Model(meta);
        }

        std::map<std::string, QueryValue> pk_conditions;
        bool all_pks_set_in_model = true;
        if (meta.primary_keys_db_names.empty()) {
            all_pks_set_in_model = false;
        } else {
            for (const std::string &pk_db_name : meta.primary_keys_db_names) {
                const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
                if (!pk_field) {
                    all_pks_set_in_model = false;
                    break;
                }
                std::any pk_val_any = result_model.getFieldValue(pk_field->cpp_name);
                if (!pk_val_any.has_value()) {
                    all_pks_set_in_model = false;
                    break;
                }
                // Session::anyToQueryValueForSessionConvenience is still valid for converting model field to QueryValue
                QueryValue qv = Session::anyToQueryValueForSessionConvenience(pk_val_any);

                bool use_this_pk_value = false;
                if (std::holds_alternative<int>(qv) && std::get<int>(qv) != 0)
                    use_this_pk_value = true;
                else if (std::holds_alternative<long long>(qv) && std::get<long long>(qv) != 0)
                    use_this_pk_value = true;
                else if (std::holds_alternative<std::string>(qv) && !std::get<std::string>(qv).empty())
                    use_this_pk_value = true;
                // Add other QueryValue types if they can be PKs and have non-default "empty" states

                if (use_this_pk_value) {
                    pk_conditions[pk_db_name] = qv;
                } else {
                    all_pks_set_in_model = false;
                    break;
                }
            }
        }

        if (all_pks_set_in_model && !pk_conditions.empty()) {
            this->Where(pk_conditions);
        } else {
            if (!meta.primary_keys_db_names.empty() && this->state_.order_clause_.empty()) {
                std::string order_by_pk_clause;
                for (size_t i = 0; i < meta.primary_keys_db_names.size(); ++i) {
                    order_by_pk_clause += quoteSqlIdentifier(  // Uses static QB::quoteSqlIdentifier
                        meta.primary_keys_db_names[i]);
                    if (i < meta.primary_keys_db_names.size() - 1) order_by_pk_clause += ", ";
                }
                if (!order_by_pk_clause.empty()) {
                    this->Order(order_by_pk_clause);  // Calls mixin's Order
                }
            }
        }
        return executor_->FirstImpl(*this, result_model);
    }

    Error QueryBuilder::Find(std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
        if (!executor_) return Error(ErrorCode::InternalError, "QueryBuilder has no executor.");

        if (!this->state_.model_meta_ && element_type_factory) {
            auto temp_instance = element_type_factory();
            if (temp_instance) {
                this->Model(temp_instance->_getOwnModelMeta());
            } else {
                return Error(ErrorCode::InternalError, "Model factory returned nullptr for Find.");
            }
        } else if (!this->state_.model_meta_ && !element_type_factory) {
            return Error(ErrorCode::InvalidConfiguration, "Find requires ModelMeta or an element factory.");
        }

        return executor_->FindImpl(*this, results_vector, element_type_factory);
    }

    // Create 返回 std::expected<SqlValue, Error>
    std::expected<cpporm_sqldriver::SqlValue, Error> QueryBuilder::Create(ModelBase &model, const OnConflictClause *conflict_options_override) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &model._getOwnModelMeta()) {
            this->Model(model._getOwnModelMeta());
        }
        const OnConflictClause *final_conflict_options = conflict_options_override;
        if (!final_conflict_options && this->state_.on_conflict_clause_) {
            final_conflict_options = this->state_.on_conflict_clause_.get();
        }
        return executor_->CreateImpl(*this, model, final_conflict_options);
    }

    std::expected<long long, Error> QueryBuilder::Updates(const std::map<std::string, QueryValue> &updates) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 &&  // index 0 is std::string for table name
                                          std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Updates requires a Model or Table to be set."));
        }
        return executor_->UpdatesImpl(*this, updates);
    }

    std::expected<long long, Error> QueryBuilder::Delete() {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 && std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Delete requires a Model or Table to be set."));
        }
        return executor_->DeleteImpl(*this);
    }

    std::expected<long long, Error> QueryBuilder::Save(ModelBase &model) {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));

        if (!this->state_.model_meta_ || this->state_.model_meta_ != &model._getOwnModelMeta()) {
            this->Model(model._getOwnModelMeta());
        }
        return executor_->SaveImpl(*this, model);
    }

    std::expected<int64_t, Error> QueryBuilder::Count() {
        if (!executor_) return std::unexpected(Error(ErrorCode::InternalError, "QueryBuilder has no executor."));
        if (!this->state_.model_meta_ && (this->state_.from_clause_source_.index() == 0 && std::get<std::string>(this->state_.from_clause_source_).empty())) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "Count requires a Model or Table to be set."));
        }
        return executor_->CountImpl(*this);
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_helpers.cpp
#include <QDebug>
#include <QMetaType>  // For QMetaType::UnknownType
#include <QVariant>
#include <sstream>
#include <variant>  // For std::visit

#include "cpporm/model_base.h"     // For ModelMeta related logic
#include "cpporm/query_builder.h"  // For QueryBuilder class and its members like quoteSqlIdentifier, toQVariant

namespace cpporm {

    // --- Private SQL Building Helper Implementations for QueryBuilder ---

    void QueryBuilder::build_ctes_sql_prefix(std::ostringstream &sql_stream, QVariantList &bound_params_accumulator) const {
        if (state_.ctes_.empty()) {
            return;
        }

        sql_stream << "WITH ";
        bool has_recursive_cte = false;
        for (const auto &cte_state : state_.ctes_) {
            if (cte_state.recursive) {
                has_recursive_cte = true;
                break;
            }
        }
        if (has_recursive_cte) {
            sql_stream << "RECURSIVE ";
        }

        for (size_t i = 0; i < state_.ctes_.size(); ++i) {
            const auto &cte = state_.ctes_[i];
            sql_stream << quoteSqlIdentifier(cte.name) << " AS (";  // Static call is fine
            sql_stream << cte.query.sql_string;
            sql_stream << ")";

            // Bindings for CTEs are QueryValueVariantForSubquery, convert to QVariant
            for (const auto &binding_variant : cte.query.bindings) {
                std::visit(
                    [&bound_params_accumulator](auto &&arg_val) {
                        using ArgT = std::decay_t<decltype(arg_val)>;
                        if constexpr (std::is_same_v<ArgT, std::nullptr_t>) {
                            bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                        } else if constexpr (std::is_same_v<ArgT, std::string>) {
                            bound_params_accumulator.append(QString::fromStdString(arg_val));
                        } else if constexpr (std::is_same_v<ArgT, int> || std::is_same_v<ArgT, long long> || std::is_same_v<ArgT, double> || std::is_same_v<ArgT, bool> || std::is_same_v<ArgT, QDateTime> || std::is_same_v<ArgT, QDate> || std::is_same_v<ArgT, QTime> ||
                                             std::is_same_v<ArgT, QByteArray>) {
                            bound_params_accumulator.append(QVariant::fromValue(arg_val));
                        } else {
                            // This static_assert will fail compilation if a type is not handled,
                            // which is better than a runtime warning for unhandled types in a variant.
                            // static_assert(false, "Unhandled type in QueryValueVariantForSubquery to QVariant conversion for CTE");
                            // Or, keep the qWarning for less strictness during development if new types are added to QueryValueVariantForSubquery
                            qWarning() << "QueryBuilder::build_ctes_sql_prefix: Unhandled "
                                          "native type in "
                                          "CTE binding for QVariant conversion:"
                                       << typeid(ArgT).name();
                        }
                    },
                    binding_variant);
            }
            if (i < state_.ctes_.size() - 1) {
                sql_stream << ", ";
            }
        }
        sql_stream << " ";
    }

    // Static helper, so QueryBuilder::toQVariant must be static or called on an instance
    bool QueryBuilder::build_one_condition_block_internal_static_helper(std::ostringstream &to_stream, QVariantList &bindings_acc, const std::vector<Condition> &conditions_group, const std::string &op_within_group, bool is_not_group) {
        if (conditions_group.empty()) {
            return false;
        }

        if (is_not_group) {
            to_stream << "NOT ";
        }
        to_stream << "(";

        for (size_t i = 0; i < conditions_group.size(); ++i) {
            if (i > 0) {
                to_stream << " " << op_within_group << " ";
            }

            const std::string &local_query_string = conditions_group[i].query_string;
            const std::vector<QueryValue> &local_args = conditions_group[i].args;

            std::string::size_type last_pos = 0;
            std::string::size_type find_pos = 0;
            int arg_idx = 0;

            while ((find_pos = local_query_string.find('?', last_pos)) != std::string::npos) {
                to_stream << local_query_string.substr(last_pos, find_pos - last_pos);
                if (arg_idx < static_cast<int>(local_args.size())) {
                    const auto &arg_value = local_args[arg_idx++];
                    // QueryBuilder::toQVariant is static, so this is fine.
                    // It appends to bindings_acc if arg_value is not a SubqueryExpression.
                    QVariant qv_arg = QueryBuilder::toQVariant(arg_value, bindings_acc);
                    if (std::holds_alternative<SubqueryExpression>(arg_value)) {
                        // If it's a subquery, its SQL is directly injected.
                        // Its bindings were already added to bindings_acc by toQVariant.
                        to_stream << qv_arg.toString().toStdString();  // qv_arg here holds "(subquery_sql_string)"
                    } else {
                        to_stream << "?";  // Placeholder for regular values
                                           // bindings_acc.append(qv_arg); // This is now done *inside* toQVariant for non-subqueries
                    }
                } else {
                    qWarning() << "cpporm: Not enough arguments for placeholders in "
                                  "condition string:"
                               << QString::fromStdString(local_query_string);
                    to_stream << "?";  // Still output placeholder to maintain query structure
                }
                last_pos = find_pos + 1;
            }
            to_stream << local_query_string.substr(last_pos);

            // Check for too many arguments (excluding SubqueryExpressions that don't consume '?')
            if (arg_idx < static_cast<int>(local_args.size())) {
                bool only_subqueries_left = true;
                for (size_t k = arg_idx; k < local_args.size(); ++k) {
                    if (!std::holds_alternative<SubqueryExpression>(local_args[k])) {
                        only_subqueries_left = false;
                        break;
                    }
                }
                if (!only_subqueries_left) {
                    qWarning() << "cpporm: Too many non-subquery arguments for "
                                  "placeholders in condition string:"
                               << QString::fromStdString(local_query_string);
                }
            }
        }
        to_stream << ")";
        return true;
    }

    void QueryBuilder::build_condition_logic_internal(std::ostringstream &sql_stream,
                                                      QVariantList &bound_params_accumulator,
                                                      bool &first_overall_condition_written,           // True if "WHERE" or "HAVING" needs to be written by this call for the main user conditions
                                                      const std::string &prepended_scope_sql) const {  // e.g., soft delete SQL

        std::ostringstream user_conditions_builder_ss;
        QVariantList user_conditions_bindings_list;  // Bindings specific to this block of user conditions
        bool any_user_condition_written_in_block = false;

        if (!state_.where_conditions_.empty()) {
            // Call static helper
            QueryBuilder::build_one_condition_block_internal_static_helper(user_conditions_builder_ss,
                                                                           user_conditions_bindings_list,  // Pass local list
                                                                           state_.where_conditions_,
                                                                           "AND",
                                                                           false);
            any_user_condition_written_in_block = true;
        }

        if (!state_.or_conditions_.empty()) {
            if (any_user_condition_written_in_block) user_conditions_builder_ss << " OR ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_conditions_builder_ss, user_conditions_bindings_list, state_.or_conditions_, "OR", false);
            any_user_condition_written_in_block = true;
        }

        if (!state_.not_conditions_.empty()) {
            if (any_user_condition_written_in_block) user_conditions_builder_ss << " AND ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_conditions_builder_ss, user_conditions_bindings_list, state_.not_conditions_, "AND", true);  // is_not_group = true
                                                                                                                                                                             // any_user_condition_written_in_block = true; // Already true if others were present or becomes true here
        }

        std::string user_conditions_final_sql = user_conditions_builder_ss.str();
        bool main_clause_keyword_written_this_call = false;

        if (!prepended_scope_sql.empty()) {
            if (first_overall_condition_written) {
                // This is for row-level conditions, so always WHERE, not HAVING.
                // The `state_.having_condition_` check was a bug here.
                sql_stream << " WHERE ";
                first_overall_condition_written = false;  // WHERE/HAVING has now been written (or started)
                main_clause_keyword_written_this_call = true;
            } else {
                // A WHERE/HAVING clause was already started by something else, or by a previous scope.
                sql_stream << " AND ";
            }
            sql_stream << "(" << prepended_scope_sql << ")";
        }

        if (!user_conditions_final_sql.empty()) {
            if (first_overall_condition_written) {
                sql_stream << " WHERE ";  // Always WHERE for this context
                first_overall_condition_written = false;
                main_clause_keyword_written_this_call = true;
            } else {
                // If a main keyword (WHERE/HAVING) was written by this call for the scope SQL,
                // or if scope SQL itself was written, we need an AND.
                if (main_clause_keyword_written_this_call || !prepended_scope_sql.empty()) {
                    sql_stream << " AND ";
                } else {
                    // If neither scope SQL nor main keyword was written *by this call*,
                    // but first_overall_condition_written is false (meaning something external to this call
                    // or a prior group within this call already started a WHERE/HAVING clause),
                    // we need an "AND" to connect.
                    // The original complex logic based on last_char was fragile.
                    // A simpler check: if the stream is not empty AND first_overall_condition_written is false,
                    // it implies a prior condition exists and needs "AND".
                    std::string current_sql_in_stream = sql_stream.str();
                    if (!current_sql_in_stream.empty()) {  // Ensure stream is not empty before checking last char
                        char last_significant_char = ' ';
                        for (auto it = current_sql_in_stream.rbegin(); it != current_sql_in_stream.rend(); ++it) {
                            if (*it != ' ') {
                                last_significant_char = *it;
                                break;
                            }
                        }
                        // If it doesn't end with an opening paren or already an operator/space, add AND
                        if (last_significant_char != '(' && last_significant_char != ' ' && !(current_sql_in_stream.length() >= 3 && current_sql_in_stream.substr(current_sql_in_stream.length() - 3) == "AND") &&  // poor check
                            !(current_sql_in_stream.length() >= 2 && current_sql_in_stream.substr(current_sql_in_stream.length() - 2) == "OR")                                                                      // poor check
                        ) {
                            // Add AND if it's not immediately after WHERE/HAVING (which would be handled by first_overall_condition_written)
                            // and not after another logical operator that implies connection.
                            // This part is tricky. A robust solution is for buildSelectSQL to manage the first WHERE/HAVING
                            // and subsequent appends always use AND if needed.
                            // The current state of `first_overall_condition_written` should guide this.
                            // If `first_overall_condition_written` is false, it means `WHERE` or `HAVING` (or `AND/OR` to connect to it)
                            // has already been written by *something*. So we need `AND`.
                            sql_stream << " AND ";
                        }
                    }
                    // If the stream was empty, and first_overall_condition_written is false, it's an invalid state.
                    // This 'else' block is reached if first_overall_condition_written is false (so WHERE/HAVING already exists)
                    // AND main_clause_keyword_written_this_call is false (so this call didn't write WHERE/HAVING for scope)
                    // AND prepended_scope_sql is empty (so scope didn't write AND).
                    // This means we are appending user conditions to an existing WHERE/HAVING.
                    // We *always* need an AND in this case, unless sql_stream is empty (which would be an error if first_overall is false).
                    // The original logic here was complex and potentially buggy.
                    // A clearer approach: if first_overall_condition_written is false, it means a WHERE/HAVING (or its connector)
                    // has been output. Thus, any subsequent condition block *must* be joined by AND/OR.
                    // Since build_condition_logic_internal is for one group (WHERE or HAVING),
                    // if first_overall_condition_written is false, it means we append with AND.
                    // The only exception is if sql_stream is truly empty, which means an error in logic.
                    // Given the `else` implies `!main_clause_keyword_written_this_call` and `prepended_scope_sql.empty()`,
                    // and `!first_overall_condition_written`, it means a previous call or part handled WHERE/HAVING.
                    // So, we just need " AND ".
                    // The complex last_char check can be simplified if the overall structure is managed well.
                    // For now, relying on the refined logic.
                }
            }
            sql_stream << "(" << user_conditions_final_sql << ")";
            bound_params_accumulator.append(user_conditions_bindings_list);  // Append the block's bindings
        }
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_lifecycle.cpp
#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // 构造函数接收 std::string connection_name
    QueryBuilder::QueryBuilder(IQueryExecutor *executor, std::string connection_name, const ModelMeta *model_meta) : executor_(executor), connection_name_(std::move(connection_name)) {
        if (model_meta) {
            this->state_.model_meta_ = model_meta;
            if (!model_meta->table_name.empty()) {
                this->state_.from_clause_source_ = model_meta->table_name;
            }
        }
        // Default select_fields_ is already "*" in QueryBuilderState constructor
    }

    QueryBuilder::QueryBuilder(const QueryBuilder &other) : executor_(other.executor_), connection_name_(other.connection_name_), state_(other.state_) {
    }

    QueryBuilder &QueryBuilder::operator=(const QueryBuilder &other) {
        if (this != &other) {
            this->executor_ = other.executor_;
            this->connection_name_ = other.connection_name_;
            this->state_ = other.state_;
        }
        return *this;
    }

    QueryBuilder::QueryBuilder(QueryBuilder &&other) noexcept : executor_(other.executor_), connection_name_(std::move(other.connection_name_)), state_(std::move(other.state_)) {
        other.executor_ = nullptr;
    }

    QueryBuilder &QueryBuilder::operator=(QueryBuilder &&other) noexcept {
        if (this != &other) {
            this->executor_ = other.executor_;
            this->connection_name_ = std::move(other.connection_name_);
            this->state_ = std::move(other.state_);
            other.executor_ = nullptr;
        }
        return *this;
    }

    QueryBuilder::~QueryBuilder() = default;

}  // namespace cpporm// cpporm/builder_parts/query_builder_model_table_from.cpp
#include <QDebug>  // For qWarning, if used by From(QueryBuilder&)

#include "cpporm/model_base.h"
#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // --- 核心 Model/Table/From 设置器 ---
    QueryBuilder &QueryBuilder::Model(const ModelBase *model_instance_hint) {
        if (model_instance_hint) {
            const ModelMeta &meta = model_instance_hint->_getOwnModelMeta();
            this->state_.model_meta_ = &meta;
            if (!meta.table_name.empty()) {
                this->state_.from_clause_source_ = meta.table_name;
            } else {
                this->state_.from_clause_source_ = std::string("");
            }
        } else {
            this->state_.model_meta_ = nullptr;
            this->state_.from_clause_source_ = std::string("");
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Model(const ModelMeta &meta) {
        this->state_.model_meta_ = &meta;
        if (!meta.table_name.empty()) {
            this->state_.from_clause_source_ = meta.table_name;
        } else {
            this->state_.from_clause_source_ = std::string("");
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::Table(std::string table_name) {
        this->state_.from_clause_source_ = std::move(table_name);
        if (this->state_.model_meta_ && this->state_.model_meta_->table_name != std::get<std::string>(this->state_.from_clause_source_)) {
            this->state_.model_meta_ = nullptr;
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::From(std::string source_name_or_cte_alias) {
        // std::string old_from_source_string_if_any; // Not used in current logic
        // if (std::holds_alternative<std::string>(this->state_.from_clause_source_)) {
        //   old_from_source_string_if_any =
        //       std::get<std::string>(this->state_.from_clause_source_);
        // }

        this->state_.from_clause_source_ = std::move(source_name_or_cte_alias);

        if (this->state_.model_meta_) {
            // If the new source is a string (table or CTE alias)
            if (std::holds_alternative<std::string>(this->state_.from_clause_source_)) {
                const std::string &new_from_str = std::get<std::string>(this->state_.from_clause_source_);
                bool is_known_cte = false;
                for (const auto &cte_def : this->state_.ctes_) {
                    if (cte_def.name == new_from_str) {
                        is_known_cte = true;
                        break;
                    }
                }
                // If it's a CTE or the new table name doesn't match the model's table name,
                // then the model context is no longer valid.
                if (is_known_cte || (this->state_.model_meta_->table_name != new_from_str && !new_from_str.empty())) {
                    this->state_.model_meta_ = nullptr;
                }
            } else {  // If the new source is a subquery, model_meta_ is definitely not applicable
                this->state_.model_meta_ = nullptr;
            }
        }
        return *this;
    }

    QueryBuilder &QueryBuilder::From(const QueryBuilder &subquery_builder, const std::string &alias) {
        auto sub_expr_expected = subquery_builder.AsSubquery();
        if (!sub_expr_expected.has_value()) {
            qWarning() << "cpporm QueryBuilder::From(QueryBuilder): Failed to create "
                          "subquery expression: "
                       << QString::fromStdString(sub_expr_expected.error().message);
            return *this;
        }
        this->state_.from_clause_source_ = SubquerySource{std::move(sub_expr_expected.value()), alias};
        this->state_.model_meta_ = nullptr;  // Setting FROM to a subquery invalidates model context
        return *this;
    }

    QueryBuilder &QueryBuilder::From(const SubqueryExpression &subquery_expr, const std::string &alias) {
        this->state_.from_clause_source_ = SubquerySource{subquery_expr, alias};
        this->state_.model_meta_ = nullptr;  // Setting FROM to a subquery invalidates model context
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_onconflict.cpp
#include <memory>  // For std::make_unique

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause
#include "cpporm/query_builder_core.h"                 // For QueryBuilder definition and OnConflictUpdateSetter

namespace cpporm {

    QueryBuilder &QueryBuilder::OnConflictUpdateAllExcluded() {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::UpdateAllExcluded;
        state_.on_conflict_clause_->update_assignments.clear();
        state_.on_conflict_clause_->conflict_target_columns_db_names.clear();  // Reset target for this action
        return *this;
    }

    QueryBuilder &QueryBuilder::OnConflictDoNothing() {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
        state_.on_conflict_clause_->update_assignments.clear();
        // For DO NOTHING, conflict_target_columns_db_names can be relevant for PG.
        // If the user wants a general DO NOTHING (e.g. MySQL INSERT IGNORE semantic),
        // they should not set targets. If they want PG "ON CONFLICT (target) DO NOTHING",
        // they'd typically call a method to set the target before or after this.
        // For now, this method doesn't clear the target.
        return *this;
    }

    QueryBuilder &QueryBuilder::OnConflictUpdateSpecific(std::function<void(OnConflictUpdateSetter &)> updater_fn) {
        if (!state_.on_conflict_clause_) {
            state_.on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        state_.on_conflict_clause_->action = OnConflictClause::Action::UpdateSpecific;
        // Conflict target should be set by user if needed for PG before calling this,
        // or through a dedicated method. This method doesn't clear target.
        OnConflictUpdateSetter setter(*state_.on_conflict_clause_);
        updater_fn(setter);
        return *this;
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_delete.cpp
#include <QDebug>   // For qWarning
#include <sstream>  // For std::ostringstream
#include <variant>  // For std::holds_alternative

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h"

namespace cpporm {

    std::pair<QString, QVariantList> QueryBuilder::buildDeleteSQL() const {
        if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            qWarning(
                "cpporm QueryBuilder::buildDeleteSQL: DELETE operation cannot "
                "target a subquery directly.");
            return {QString(), QVariantList()};
        }

        QString table_name_qstr = getFromSourceName();  // Returns QString
        if (table_name_qstr.isEmpty()) {
            qWarning("cpporm QueryBuilder: Table name not set for buildDeleteSQL.");
            return {QString(), QVariantList()};
        }

        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;
        sql_stream << "DELETE FROM " << quoteSqlIdentifier(table_name_qstr.toStdString());

        std::string soft_delete_target_fragment_for_hard_delete;
        // This soft delete logic is for building the WHERE clause for a *hard* delete
        // if soft delete scope is active (i.e., "DELETE FROM table WHERE deleted_at IS NULL AND ...other_conditions...")
        // The actual soft delete (which is an UPDATE) is handled in Session::DeleteImpl.
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
                const std::string &from_name_str = std::get<std::string>(state_.from_clause_source_);
                if ((!from_name_str.empty() && from_name_str == state_.model_meta_->table_name) || (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
                    apply_sd_on_this_from_source = true;
                }
            }
            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_target_fragment_for_hard_delete = quoteSqlIdentifier(state_.model_meta_->table_name) + "." +  // Assuming table name from model meta
                                                                  quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool where_clause_started_by_builder = true;  // True if "WHERE" needs to be written
        build_condition_logic_internal(sql_stream, bound_params_accumulator, where_clause_started_by_builder, soft_delete_target_fragment_for_hard_delete);

        if (where_clause_started_by_builder &&                                    // "WHERE" was not written by build_condition_logic_internal
            soft_delete_target_fragment_for_hard_delete.empty() &&                // and no soft delete fragment
            state_.where_conditions_.empty() && state_.or_conditions_.empty() &&  // and no user conditions
            state_.not_conditions_.empty()) {
            qWarning() << "cpporm QueryBuilder::buildDeleteSQL: Generating DELETE "
                          "statement without a WHERE clause for table "
                       << table_name_qstr  // This is QString
                       << ". This will affect ALL rows if not intended.";
        }
        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_insert.cpp
#include <QDebug>     // For qWarning
#include <algorithm>  // For std::tolower in string comparison (if needed for driver name)
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::holds_alternative in QueryBuilder::toQVariant

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta for OnConflictUpdateAllExcluded
#include "cpporm/query_builder.h"

namespace cpporm {

    // Helper (already defined in query_builder_sql_select.cpp, ideally should be in a common util or QueryBuilder itself if static)
    // For now, let's assume it's accessible or re-define locally if necessary.
    // bool string_contains_ci(const std::string& text, const std::string& pattern); // Declaration

    // This is the SOLE definition of buildInsertSQLSuffix
    std::pair<QString, QVariantList> QueryBuilder::buildInsertSQLSuffix(const std::vector<std::string> &inserted_columns_db_names_for_values_clause) const {
        std::ostringstream sql_suffix_stream;
        QVariantList suffix_bindings_accumulator;

        if (!state_.on_conflict_clause_) {
            return {QString(), QVariantList()};
        }

        std::string driver_name_upper_std;                       // Store as std::string
        const std::string &conn_name_std = getConnectionName();  // std::string

        // Simplified driver detection based on connection name content
        // This is a basic heuristic and might need refinement for robustness.
        auto to_upper_std_string = [](std::string s) {
            std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {
                return std::toupper(c);
            });
            return s;
        };

        // Check based on common substrings in connection_name (heuristic)
        // Or, ideally, Session would pass a hint or the driver itself would be queried.
        // For now, sticking to the string contains logic for simplicity.
        if (string_contains_ci(conn_name_std, "psql") || string_contains_ci(conn_name_std, "postgres")) {
            driver_name_upper_std = "QPSQL";  // Using Qt-like names as placeholders for logic
        } else if (string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb")) {
            driver_name_upper_std = "QMYSQL";
        } else if (string_contains_ci(conn_name_std, "sqlite")) {
            driver_name_upper_std = "QSQLITE";
        }
        // Add other dialects if needed

        if (driver_name_upper_std.empty()) {
            // Fallback if connection_name_ doesn't give a hint.
            // qWarning() << "QueryBuilder::buildInsertSQLSuffix: Could not reliably determine SQL dialect from connection name '"
            //            << QString::fromStdString(conn_name_std) << "'. Defaulting to MySQL-like syntax for suffix.";
            driver_name_upper_std = "QMYSQL";  // Default to MySQL behavior if unknown
        }

        if (state_.on_conflict_clause_->action == OnConflictClause::Action::DoNothing) {
            if (driver_name_upper_std == "QMYSQL") {  // MySQL, MariaDB
                // MySQL uses "INSERT IGNORE", which is typically handled by modifying the main "INSERT" verb,
                // not by a suffix. So, this suffix part should be empty for "DoNothing" on MySQL.
                // The caller (Session::CreateImpl or Session's batch create) should adjust "INSERT" to "INSERT IGNORE".
                return {QString(), QVariantList()};
            } else if (driver_name_upper_std == "QPSQL") {  // PostgreSQL
                sql_suffix_stream << " ON CONFLICT";
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < state_.on_conflict_clause_->conflict_target_columns_db_names.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(state_.on_conflict_clause_->conflict_target_columns_db_names[i]);
                        if (i < state_.on_conflict_clause_->conflict_target_columns_db_names.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }
                // If no specific target columns, PG might require ON CONSTRAINT name.
                // GORM often requires specifying a target for PG ON CONFLICT DO NOTHING.
                // For simplicity, if no target, assume general DO NOTHING (might fail on some PG setups without target/constraint).
                sql_suffix_stream << " DO NOTHING";
            } else if (driver_name_upper_std == "QSQLITE") {  // SQLite
                // SQLite uses "INSERT OR IGNORE" or "ON CONFLICT DO NOTHING"
                // "INSERT OR IGNORE" is a verb modification.
                // "ON CONFLICT ... DO NOTHING" is a suffix.
                // Let's assume Session will handle "INSERT OR IGNORE". If suffix is desired:
                sql_suffix_stream << " ON CONFLICT";
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < state_.on_conflict_clause_->conflict_target_columns_db_names.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(state_.on_conflict_clause_->conflict_target_columns_db_names[i]);
                        if (i < state_.on_conflict_clause_->conflict_target_columns_db_names.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }
                sql_suffix_stream << " DO NOTHING";
            }
            // Other dialects might have different syntaxes or no direct "DO NOTHING" via suffix.
        } else if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded || state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific) {
            bool first_update_col = true;
            if (driver_name_upper_std == "QMYSQL") {  // MySQL, MariaDB
                sql_suffix_stream << " ON DUPLICATE KEY UPDATE ";
            } else if (driver_name_upper_std == "QPSQL") {  // PostgreSQL
                sql_suffix_stream << " ON CONFLICT ";
                std::vector<std::string> pg_conflict_targets;
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    pg_conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names;
                } else if (state_.model_meta_ && !state_.model_meta_->primary_keys_db_names.empty()) {
                    pg_conflict_targets = state_.model_meta_->primary_keys_db_names;
                }

                if (!pg_conflict_targets.empty()) {
                    sql_suffix_stream << "(";
                    for (size_t i = 0; i < pg_conflict_targets.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(pg_conflict_targets[i]);
                        if (i < pg_conflict_targets.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ") ";
                } else {
                    qWarning(
                        "cpporm QueryBuilder: For PostgreSQL ON CONFLICT DO UPDATE, "
                        "conflict target (columns or PK) must be defined.");
                    return {QString(), QVariantList()};  // Error condition
                }
                sql_suffix_stream << "DO UPDATE SET ";
            } else if (driver_name_upper_std == "QSQLITE") {  // SQLite
                sql_suffix_stream << " ON CONFLICT";
                // SQLite needs conflict target for DO UPDATE similar to PG
                std::vector<std::string> sqlite_conflict_targets;
                if (!state_.on_conflict_clause_->conflict_target_columns_db_names.empty()) {
                    sqlite_conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names;
                } else if (state_.model_meta_ && !state_.model_meta_->primary_keys_db_names.empty()) {
                    sqlite_conflict_targets = state_.model_meta_->primary_keys_db_names;
                }
                if (!sqlite_conflict_targets.empty()) {
                    sql_suffix_stream << " (";
                    for (size_t i = 0; i < sqlite_conflict_targets.size(); ++i) {
                        sql_suffix_stream << quoteSqlIdentifier(sqlite_conflict_targets[i]);
                        if (i < sqlite_conflict_targets.size() - 1) sql_suffix_stream << ", ";
                    }
                    sql_suffix_stream << ")";
                }  // SQLite can also infer from PK/UNIQUE constraints if target omitted
                sql_suffix_stream << " DO UPDATE SET ";
            } else {  // Fallback for other/unknown drivers
                qWarning() << "QueryBuilder::buildInsertSQLSuffix: ON CONFLICT UPDATE behavior for driver '" << QString::fromStdString(driver_name_upper_std) << "' is not specifically handled. Defaulting to MySQL-like 'ON DUPLICATE KEY UPDATE'.";
                sql_suffix_stream << " ON DUPLICATE KEY UPDATE ";
            }

            if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded) {
                if (inserted_columns_db_names_for_values_clause.empty() && driver_name_upper_std != "QPSQL" && driver_name_upper_std != "QSQLITE" /*PG/SQLite can use EXCLUDED/excluded even with empty insert list with DEFAULT VALUES*/) {
                    qWarning(
                        "cpporm QueryBuilder: OnConflictUpdateAllExcluded specified for non-PG/non-SQLite, "
                        "but no columns provided from INSERT part to determine VALUES() updates.");
                }
                for (const std::string &db_col_name : inserted_columns_db_names_for_values_clause) {
                    bool skip_this_column_in_set = false;
                    // Skip updating PKs or conflict target columns themselves in the SET clause
                    if (state_.model_meta_) {
                        const auto &conflict_targets_to_check = (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE")
                                                                    ? (state_.on_conflict_clause_->conflict_target_columns_db_names.empty() ? state_.model_meta_->primary_keys_db_names : state_.on_conflict_clause_->conflict_target_columns_db_names)
                                                                    : state_.model_meta_->primary_keys_db_names;  // For MySQL, skip PKs

                        for (const auto &key_col_name : conflict_targets_to_check) {
                            if (key_col_name == db_col_name) {
                                skip_this_column_in_set = true;
                                break;
                            }
                        }
                        // MySQL also skips PKs if not already caught by conflict_targets_to_check
                        if (driver_name_upper_std == "QMYSQL" && !skip_this_column_in_set) {
                            for (const auto &pk_name : state_.model_meta_->primary_keys_db_names) {
                                if (pk_name == db_col_name) {
                                    skip_this_column_in_set = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (skip_this_column_in_set) continue;

                    if (!first_update_col) sql_suffix_stream << ", ";
                    sql_suffix_stream << quoteSqlIdentifier(db_col_name) << " = ";

                    if (driver_name_upper_std == "QMYSQL") {
                        sql_suffix_stream << "VALUES(" << quoteSqlIdentifier(db_col_name) << ")";
                    } else if (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") {
                        sql_suffix_stream << "excluded." << quoteSqlIdentifier(db_col_name);
                    } else {                       // Fallback for other drivers
                        sql_suffix_stream << "?";  // This would require the value to be bound, which is not typical for UpdateAllExcluded
                        qWarning(
                            "QueryBuilder::buildInsertSQLSuffix: UpdateAllExcluded for driver '%s' "
                            "might need specific value passing or is not fully supported by this generic builder. Using '?' for column '%s'.",
                            driver_name_upper_std.c_str(),
                            db_col_name.c_str());
                    }
                    first_update_col = false;
                }
                if (first_update_col && !inserted_columns_db_names_for_values_clause.empty()) {
                    qWarning("cpporm QueryBuilder: OnConflictUpdateAllExcluded resulted in empty SET clause. SQL might be invalid.");
                }
            } else if (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific) {
                if (state_.on_conflict_clause_->update_assignments.empty()) {
                    qWarning("cpporm QueryBuilder: OnConflictUpdateSpecific specified, but no update assignments provided.");
                }
                for (const auto &assign_pair : state_.on_conflict_clause_->update_assignments) {
                    // For PG/SQLite, ensure the column being SET is not part of the conflict target itself
                    if ((driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") && state_.model_meta_) {
                        const auto &conflict_targets = state_.on_conflict_clause_->conflict_target_columns_db_names.empty() ? state_.model_meta_->primary_keys_db_names : state_.on_conflict_clause_->conflict_target_columns_db_names;
                        bool is_conflict_target_col = false;
                        for (const auto &ct_col : conflict_targets) {
                            if (ct_col == assign_pair.first) {
                                is_conflict_target_col = true;
                                break;
                            }
                        }
                        if (is_conflict_target_col) {
                            qWarning() << "QueryBuilder::buildInsertSQLSuffix (" << QString::fromStdString(driver_name_upper_std) << "): Column '" << QString::fromStdString(assign_pair.first) << "' is part of the conflict target and cannot be in the SET clause of ON CONFLICT DO UPDATE. Skipping.";
                            continue;
                        }
                    }

                    if (!first_update_col) sql_suffix_stream << ", ";
                    sql_suffix_stream << quoteSqlIdentifier(assign_pair.first) << " = ";

                    if (std::holds_alternative<SubqueryExpression>(assign_pair.second)) {
                        // toQVariant is static, appends subquery bindings to suffix_bindings_accumulator
                        sql_suffix_stream << QueryBuilder::toQVariant(assign_pair.second, suffix_bindings_accumulator).toString().toStdString();  // Injects "(subquery_sql)"
                    } else {
                        sql_suffix_stream << "?";
                        // toQVariant here just converts the value, does not add to accumulator.
                        // The accumulator is for subquery bindings within the expression.
                        // Regular values are added here.
                        suffix_bindings_accumulator.append(QueryBuilder::toQVariant(assign_pair.second, suffix_bindings_accumulator));
                    }
                    first_update_col = false;
                }
            }

            if (first_update_col &&  // No assignments were actually made
                (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateAllExcluded ||
                 (state_.on_conflict_clause_->action == OnConflictClause::Action::UpdateSpecific && !state_.on_conflict_clause_->update_assignments.empty() /* only if user provided assignments but all were skipped */))) {
                qWarning(
                    "cpporm QueryBuilder::buildInsertSQLSuffix: Resulted in an ON CONFLICT UPDATE clause "
                    "with no actual assignments. SQL may be invalid or action ineffective.");
                // Depending on DB, an empty SET might be an error or a no-op.
                // For safety, we might return an empty suffix to indicate this problematic state.
                // For now, let it pass, but this is a strong indicator of potential issues.
                // If driver_name_upper_std is PG or SQLite, an empty SET is usually an error.
                if (driver_name_upper_std == "QPSQL" || driver_name_upper_std == "QSQLITE") {
                    return {QString(), QVariantList()};  // Return empty to signal failure for PG/SQLite
                }
            }
        }

        return {QString::fromStdString(sql_suffix_stream.str()), suffix_bindings_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_select.cpp
#include <QDebug>     // For qWarning, qInfo
#include <QMetaType>  // For QMetaType::UnknownType
#include <algorithm>  // For std::tolower in string comparison
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::visit

#include "cpporm/model_base.h"     // For ModelMeta, FieldMeta, FieldFlag
#include "cpporm/query_builder.h"  // Includes QueryBuilderState via query_builder.h -> query_builder_core.h -> ..._state.h

namespace cpporm {

    std::pair<QString, QVariantList> QueryBuilder::buildSelectSQL(bool for_subquery_generation) const {
        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;  // QueryBuilder still accumulates QVariant bindings internally

        build_ctes_sql_prefix(sql_stream, bound_params_accumulator);

        sql_stream << "SELECT ";
        if (state_.apply_distinct_) {
            sql_stream << "DISTINCT ";
        }

        const std::string &conn_name_std = this->getConnectionName();  // Now std::string

        auto get_field_select_expression = [&conn_name_std, this](const FieldMeta &fm) -> std::string {  // Capture conn_name_std
            // Use helper for case-insensitive check
            bool is_mysql = string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb");

            if (is_mysql) {
                if (fm.db_type_hint == "POINT") {
                    return "ST_AsText(" + quoteSqlIdentifier(fm.db_name) + ") AS " + quoteSqlIdentifier(fm.db_name);
                } else if (fm.db_type_hint == "JSON") {
                    // For MySQL JSON, casting to CHAR might be needed for some clients/drivers
                    // if they don't handle JSON type directly from C++ side.
                    // This was likely for QSql which might treat JSON as string.
                    // SqlDriver might handle JSON better, but keeping the cast for now if it was intentional.
                    return "CAST(" + quoteSqlIdentifier(fm.db_name) + " AS CHAR) AS " + quoteSqlIdentifier(fm.db_name);
                }
            }
            // For other drivers or default case
            return quoteSqlIdentifier(fm.db_name);
        };

        if (state_.select_fields_.empty() || (state_.select_fields_.size() == 1 && std::holds_alternative<std::string>(state_.select_fields_[0]) && std::get<std::string>(state_.select_fields_[0]) == "*")) {
            if (state_.model_meta_) {
                bool first_col = true;
                for (const auto &field_meta_obj : state_.model_meta_->fields) {  // Renamed for clarity
                    if (has_flag(field_meta_obj.flags, FieldFlag::Association) || field_meta_obj.db_name.empty()) {
                        continue;
                    }
                    if (!first_col) {
                        sql_stream << ", ";
                    }
                    sql_stream << get_field_select_expression(field_meta_obj);
                    first_col = false;
                }
                if (first_col) {  // No fields were selected from model_meta
                    sql_stream << "*";
                    qWarning(
                        "cpporm QueryBuilder::buildSelectSQL: SELECT * expanded to "
                        "no columns for model %s, falling back to literal '*'.",
                        state_.model_meta_->table_name.c_str());
                }
            } else {
                sql_stream << "*";  // No model_meta, so select literal "*"
            }
        } else {  // Specific fields or subqueries selected
            for (size_t i = 0; i < state_.select_fields_.size(); ++i) {
                std::visit(
                    [&sql_stream, &bound_params_accumulator, this](auto &&arg) {  // `this` needed for quoteSqlIdentifier
                        using T = std::decay_t<decltype(arg)>;
                        if constexpr (std::is_same_v<T, std::string>) {
                            sql_stream << arg;  // Assumes string is already quoted or is an expression
                        } else if constexpr (std::is_same_v<T, NamedSubqueryField>) {
                            sql_stream << "(" << arg.subquery.sql_string << ") AS " << quoteSqlIdentifier(arg.alias);  // quoteSqlIdentifier is static
                            // Bindings for subquery in SELECT list are QueryValueVariantForSubquery
                            for (const auto &sub_binding_variant : arg.subquery.bindings) {
                                std::visit(
                                    [&bound_params_accumulator](auto &&sub_val) {
                                        using SubVT = std::decay_t<decltype(sub_val)>;
                                        if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                            bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                        } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                            bound_params_accumulator.append(QString::fromStdString(sub_val));
                                        } else if constexpr (std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray> || std::is_same_v<SubVT, bool> || std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> ||
                                                             std::is_same_v<SubVT, double>) {
                                            bound_params_accumulator.append(QVariant::fromValue(sub_val));
                                        } else {
                                            qWarning() << "buildSelectSQL (SelectField): Unhandled "
                                                          "native type in NamedSubqueryField "
                                                          "binding during QVariant conversion for subquery in SELECT.";
                                        }
                                    },
                                    sub_binding_variant);
                            }
                        }
                    },
                    state_.select_fields_[i]);
                if (i < state_.select_fields_.size() - 1) {
                    sql_stream << ", ";
                }
            }
        }

        sql_stream << " FROM ";
        std::visit(
            [&sql_stream, &bound_params_accumulator, this](auto &&arg) {  // `this` needed for getFromSourceName and quoteSqlIdentifier
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::string>) {           // Table name
                    QString table_name_qstr = this->getFromSourceName();  // Returns QString
                    if (table_name_qstr.isEmpty()) {
                        qWarning(
                            "cpporm QueryBuilder: Table name is empty for "
                            "buildSelectSQL FROM clause.");
                        sql_stream << "__MISSING_TABLE_NAME_IN_FROM__";  // Placeholder for error
                    } else {
                        sql_stream << quoteSqlIdentifier(table_name_qstr.toStdString());
                    }
                } else if constexpr (std::is_same_v<T, SubquerySource>) {  // Subquery as source
                    sql_stream << "(" << arg.subquery.sql_string << ") AS " << quoteSqlIdentifier(arg.alias);
                    for (const auto &sub_binding_variant : arg.subquery.bindings) {
                        std::visit(
                            [&bound_params_accumulator](auto &&sub_val) {
                                using SubVT = std::decay_t<decltype(sub_val)>;
                                if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                    bound_params_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                    bound_params_accumulator.append(QString::fromStdString(sub_val));
                                } else if constexpr (std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray> || std::is_same_v<SubVT, bool> || std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> ||
                                                     std::is_same_v<SubVT, double>) {
                                    bound_params_accumulator.append(QVariant::fromValue(sub_val));
                                } else {
                                    qWarning() << "buildSelectSQL (FromClauseSource): "
                                                  "Unhandled native type in SubquerySource "
                                                  "binding during QVariant conversion for FROM subquery.";
                                }
                            },
                            sub_binding_variant);
                    }
                }
            },
            state_.from_clause_source_);

        for (const auto &join : state_.join_clauses_) {
            if (!join.join_type.empty() && !join.table_to_join.empty() && !join.on_condition.empty()) {
                sql_stream << " " << join.join_type << " JOIN " << quoteSqlIdentifier(join.table_to_join) << " ON " << join.on_condition;
            } else if (!join.on_condition.empty()) {  // Raw join fragment
                sql_stream << " " << join.on_condition;
            } else {
                qWarning() << "cpporm QueryBuilder: Invalid join clause for source " << getFromSourceName()  // Returns QString
                           << " (type: " << QString::fromStdString(join.join_type) << ", table: " << QString::fromStdString(join.table_to_join) << ").";
            }
        }

        std::string soft_delete_sql_fragment;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            QString current_from_qstr = this->getFromSourceName();  // Returns QString
            if (!current_from_qstr.isEmpty() && state_.model_meta_->table_name == current_from_qstr.toStdString()) {
                apply_sd_on_this_from_source = true;
            }

            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_sql_fragment = quoteSqlIdentifier(state_.model_meta_->table_name) + "." + quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool first_condition_written_flag = true;  // True if "WHERE" needs to be written
        build_condition_logic_internal(sql_stream, bound_params_accumulator, first_condition_written_flag, soft_delete_sql_fragment);

        if (!state_.group_clause_.empty()) {
            sql_stream << " GROUP BY " << state_.group_clause_;
            if (state_.having_condition_) {  // Check if having_condition_ unique_ptr is set
                sql_stream << " HAVING ";
                const std::string &having_query_str = state_.having_condition_->query_string;
                const std::vector<QueryValue> &having_args = state_.having_condition_->args;

                std::string::size_type last_pos_having = 0, find_pos_having = 0;
                int arg_idx_having = 0;
                while ((find_pos_having = having_query_str.find('?', last_pos_having)) != std::string::npos) {
                    sql_stream << having_query_str.substr(last_pos_having, find_pos_having - last_pos_having);
                    if (arg_idx_having < static_cast<int>(having_args.size())) {
                        const auto &arg_val_having = having_args[arg_idx_having++];
                        // toQVariant is static and handles SubqueryExpression by adding its bindings to accumulator
                        QVariant qv_arg_having = QueryBuilder::toQVariant(arg_val_having, bound_params_accumulator);
                        if (std::holds_alternative<SubqueryExpression>(arg_val_having)) {
                            sql_stream << qv_arg_having.toString().toStdString();  // Injects "(subquery_sql)"
                        } else {
                            sql_stream << "?";  // Placeholder for regular value
                        }
                    } else {
                        sql_stream << "?";
                        qWarning() << "cpporm: Not enough arguments for placeholders in "
                                      "HAVING clause: "
                                   << QString::fromStdString(having_query_str);
                    }
                    last_pos_having = find_pos_having + 1;
                }
                sql_stream << having_query_str.substr(last_pos_having);
                if (arg_idx_having < static_cast<int>(having_args.size())) {
                    bool only_subqueries_left_having = true;
                    for (size_t k_having = arg_idx_having; k_having < having_args.size(); ++k_having) {
                        if (!std::holds_alternative<SubqueryExpression>(having_args[k_having])) {
                            only_subqueries_left_having = false;
                            break;
                        }
                    }
                    if (!only_subqueries_left_having) {
                        qWarning() << "cpporm: Too many non-subquery arguments for "
                                      "placeholders in HAVING clause: "
                                   << QString::fromStdString(having_query_str);
                    }
                }
            }
        }

        if (!state_.order_clause_.empty()) {
            sql_stream << " ORDER BY " << state_.order_clause_;
        }

        // LIMIT and OFFSET are not applied if for_subquery_generation is true
        if (!for_subquery_generation) {
            if (state_.limit_val_ > 0) {
                sql_stream << " LIMIT ?";
                bound_params_accumulator.append(QVariant::fromValue(state_.limit_val_));  // Use QVariant::fromValue for clarity
                if (state_.offset_val_ >= 0) {                                            // Only add OFFSET if limit is also present and offset is valid
                    sql_stream << " OFFSET ?";
                    bound_params_accumulator.append(QVariant::fromValue(state_.offset_val_));
                }
            } else if (state_.offset_val_ >= 0) {  // OFFSET without LIMIT (some DBs need a large LIMIT)
                // const std::string& connNameStd = getConnectionName(); // Already fetched
                if (string_contains_ci(conn_name_std, "mysql")) {
                    sql_stream << " LIMIT 18446744073709551615";  // MySQL's max rows
                }
                sql_stream << " OFFSET ?";
                bound_params_accumulator.append(QVariant::fromValue(state_.offset_val_));
                if (!string_contains_ci(conn_name_std, "mysql") && !string_contains_ci(conn_name_std, "sqlite")) {
                    // This warning is fine, just for developer awareness
                    qInfo(
                        "cpporm QueryBuilder: OFFSET without LIMIT is used for driver '%s'. "
                        "Behavior might vary. MySQL and SQLite effectively add a large LIMIT.",
                        conn_name_std.c_str());
                }
            }
        }
        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_sql_update.cpp
#include <QDebug>     // For qWarning
#include <algorithm>  // For std::tolower in string comparison
#include <sstream>    // For std::ostringstream
#include <variant>    // For std::holds_alternative

#include "cpporm/model_base.h"  // For ModelMeta, FieldMeta, FieldFlag (indirectly for ST_GeomFromText logic)
#include "cpporm/query_builder.h"

namespace cpporm {

    // Helper (already defined in query_builder_sql_select.cpp, ideally should be in a common util or QueryBuilder itself if static)
    // bool string_contains_ci(const std::string& text, const std::string& pattern); // Declaration

    std::pair<QString, QVariantList> QueryBuilder::buildUpdateSQL(const std::map<std::string, QueryValue> &updates) const {
        if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            qWarning(
                "cpporm QueryBuilder::buildUpdateSQL: UPDATE operation cannot "
                "target a subquery directly.");
            return {QString(), QVariantList()};
        }

        QString table_name_qstr = getFromSourceName();  // Returns QString
        if (table_name_qstr.isEmpty()) {
            qWarning("cpporm QueryBuilder: Table name not set for buildUpdateSQL.");
            return {QString(), QVariantList()};
        }

        if (updates.empty()) {
            qWarning("cpporm QueryBuilder: No update values provided for table %s.", table_name_qstr.toStdString().c_str());
            return {QString(), QVariantList()};
        }

        std::ostringstream sql_stream;
        QVariantList bound_params_accumulator;

        sql_stream << "UPDATE " << quoteSqlIdentifier(table_name_qstr.toStdString()) << " SET ";

        std::string driver_name_upper_std;
        const std::string &conn_name_std = getConnectionName();  // std::string

        if (string_contains_ci(conn_name_std, "mysql") || string_contains_ci(conn_name_std, "mariadb")) {
            driver_name_upper_std = "QMYSQL";
        } else if (string_contains_ci(conn_name_std, "psql") || string_contains_ci(conn_name_std, "postgres")) {
            driver_name_upper_std = "QPSQL";
        } else if (string_contains_ci(conn_name_std, "sqlite")) {
            driver_name_upper_std = "QSQLITE";
        }
        // driver_name_upper_std might remain empty if no match

        bool first_set_col = true;
        for (const auto &pair : updates) {
            if (!first_set_col) {
                sql_stream << ", ";
            }
            sql_stream << quoteSqlIdentifier(pair.first) << " = ";

            if (std::holds_alternative<SubqueryExpression>(pair.second)) {
                // toQVariant is static, appends subquery bindings to bound_params_accumulator
                sql_stream << QueryBuilder::toQVariant(pair.second, bound_params_accumulator).toString().toStdString();  // Injects "(subquery_sql)"
            } else {
                bool use_st_geom_from_text = false;
                if (state_.model_meta_ && (driver_name_upper_std == "QMYSQL" /*|| driver_name_upper_std == "QMARIADB" - covered by QMYSQL logic*/)) {
                    const FieldMeta *fm = state_.model_meta_->findFieldByDbName(pair.first);
                    if (fm && (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" || fm->db_type_hint == "LINESTRING" || fm->db_type_hint == "POLYGON" || fm->db_type_hint == "MULTIPOINT" || fm->db_type_hint == "MULTILINESTRING" || fm->db_type_hint == "MULTIPOLYGON" ||
                               fm->db_type_hint == "GEOMETRYCOLLECTION")) {
                        use_st_geom_from_text = true;
                    }
                }
                // Similar logic for PostgreSQL with ST_GeomFromEWKT or ::geometry might be needed
                // if PostGIS is used and types are WKT strings.
                // For SQLite with SpatiaLite, it would be GeomFromText() or similar.

                if (use_st_geom_from_text) {
                    sql_stream << "ST_GeomFromText(?)";
                } else {
                    sql_stream << "?";
                }
                // Regular value, convert to QVariant and add to accumulator
                // toQVariant here does not add to accumulator, it just converts.
                bound_params_accumulator.append(QueryBuilder::toQVariant(pair.second, bound_params_accumulator));
            }
            first_set_col = false;
        }

        std::string soft_delete_where_fragment;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
                const std::string &from_name_str = std::get<std::string>(state_.from_clause_source_);
                if ((!from_name_str.empty() && from_name_str == state_.model_meta_->table_name) || (from_name_str.empty() && !state_.model_meta_->table_name.empty())) {
                    apply_sd_on_this_from_source = true;
                }
            }
            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    soft_delete_where_fragment = quoteSqlIdentifier(state_.model_meta_->table_name) + "." + quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool where_clause_started_by_builder = true;  // True if "WHERE" needs to be written by build_condition_logic_internal
        build_condition_logic_internal(sql_stream, bound_params_accumulator, where_clause_started_by_builder, soft_delete_where_fragment);

        if (where_clause_started_by_builder && soft_delete_where_fragment.empty() && state_.where_conditions_.empty() && state_.or_conditions_.empty() && state_.not_conditions_.empty()) {
            qWarning() << "cpporm QueryBuilder::buildUpdateSQL: Generating UPDATE "
                          "statement without a WHERE clause for table "
                       << table_name_qstr  // This is still QString
                       << ". This will affect ALL rows if not intended.";
        }

        return {QString::fromStdString(sql_stream.str()), bound_params_accumulator};
    }

}  // namespace cpporm// cpporm/builder_parts/query_builder_state.cpp
#include "cpporm/builder_parts/query_builder_state.h"
#include "cpporm/query_builder.h" // For QueryBuilder::quoteSqlIdentifier

namespace cpporm {

// Definition for the free function mapToConditions
std::vector<Condition>
mapToConditions(const std::map<std::string, QueryValue> &condition_map) {
  std::vector<Condition> conditions_vec;
  conditions_vec.reserve(condition_map.size());
  for (const auto &pair : condition_map) {
    // For map conditions, the key is the column name, and the value is its
    // target. The query string becomes "column_name = ?" If the value is a
    // SubqueryExpression, it will be handled by build_condition_logic_internal
    // when QueryBuilder::toQVariant is called for the argument.
    // Here, we just construct the "column = ?" part.
    conditions_vec.emplace_back(QueryBuilder::quoteSqlIdentifier(pair.first) +
                                    " = ?",
                                std::vector<QueryValue>{pair.second});
  }
  return conditions_vec;
}

} // namespace cpporm// cpporm/builder_parts/query_builder_utils.cpp
#include <QDebug>
#include <QMetaType>  // For QMetaType in AsSubquery and toQVariant
#include <QVariant>   // For QVariant
#include <sstream>    // For std::ostringstream in buildConditionClauseGroup
#include <variant>    // For std::visit on QueryValue

#include "cpporm/query_builder_core.h"  // For QueryBuilder definition

namespace cpporm {

    // getFromSourceName 返回 QString，这依赖于 connection_name_ (std::string) 的转换。
    // 如果 QueryBuilder 要完全摆脱 QString，这里需要返回 std::string。
    // 目前 QueryBuilder 仍使用 QVariantList，所以 QString 可能仍然方便。
    QString QueryBuilder::getFromSourceName() const {
        if (std::holds_alternative<std::string>(state_.from_clause_source_)) {
            const std::string &table_name_str = std::get<std::string>(state_.from_clause_source_);
            if (!table_name_str.empty()) {
                return QString::fromStdString(table_name_str);
            }
            if (state_.model_meta_ && !state_.model_meta_->table_name.empty()) {
                return QString::fromStdString(state_.model_meta_->table_name);
            }
        } else if (std::holds_alternative<SubquerySource>(state_.from_clause_source_)) {
            return QString::fromStdString(std::get<SubquerySource>(state_.from_clause_source_).alias);
        }
        return QString();
    }

    std::expected<SubqueryExpression, Error> QueryBuilder::AsSubquery() const {
        auto [qsql_string, qvariant_bindings] = buildSelectSQL(true);
        if (qsql_string.isEmpty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for subquery."));
        }
        std::vector<QueryValueVariantForSubquery> subquery_native_bindings;
        subquery_native_bindings.reserve(qvariant_bindings.size());

        for (const QVariant &qv : qvariant_bindings) {
            if (qv.isNull() || !qv.isValid()) {
                subquery_native_bindings.push_back(nullptr);
            } else {
                QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
                type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

                if (type_id_val == QMetaType::UnknownType && qv.userType() != QMetaType::UnknownType) {
                    type_id_val = static_cast<QMetaType::Type>(qv.userType());
                }

                if (type_id_val == QMetaType::Int) {
                    subquery_native_bindings.push_back(qv.toInt());
                } else if (type_id_val == QMetaType::LongLong || type_id_val == QMetaType::ULongLong) {
                    subquery_native_bindings.push_back(qv.toLongLong());
                } else if (type_id_val == QMetaType::Double) {
                    subquery_native_bindings.push_back(qv.toDouble());
                } else if (type_id_val == QMetaType::QString) {
                    subquery_native_bindings.push_back(qv.toString().toStdString());
                } else if (type_id_val == QMetaType::Bool) {
                    subquery_native_bindings.push_back(qv.toBool());
                } else if (type_id_val == QMetaType::QDateTime) {
                    subquery_native_bindings.push_back(qv.toDateTime());
                } else if (type_id_val == QMetaType::QDate) {
                    subquery_native_bindings.push_back(qv.toDate());
                } else if (type_id_val == QMetaType::QTime) {
                    subquery_native_bindings.push_back(qv.toTime());
                } else if (type_id_val == QMetaType::QByteArray) {
                    subquery_native_bindings.push_back(qv.toByteArray());
                } else {
                    qWarning() << "cpporm QueryBuilder::AsSubquery: Unhandled QVariant typeId " << static_cast<int>(type_id_val) << " (" << qv.typeName() << ") for native conversion into SubqueryExpression bindings.";
                    return std::unexpected(Error(ErrorCode::MappingError, "Unhandled QVariant type in AsSubquery bindings conversion: " + std::string(qv.typeName())));
                }
            }
        }
        return SubqueryExpression(qsql_string.toStdString(), subquery_native_bindings);
    }

    std::string QueryBuilder::quoteSqlIdentifier(const std::string &identifier) {
        if (identifier.empty()) return "";
        if (identifier == "*" || identifier.find('(') != std::string::npos || identifier.find(')') != std::string::npos || (identifier.front() == '`' && identifier.back() == '`') || (identifier.front() == '"' && identifier.back() == '"')) {
            return identifier;
        }

        char quote_char = '`';  // Default to MySQL/MariaDB style
        // TODO: Potentially use connection_name_ to determine quote style per driver
        // For example, PostgreSQL uses double quotes:
        // if (this->connection_name_.find("psql") != std::string::npos || this->connection_name_.find("postgres") != std::string::npos) {
        //     quote_char = '"';
        // }
        // For now, sticking to backticks as per original.

        std::string result;
        size_t start_pos = 0;
        std::string temp_identifier = identifier;  // Work with a copy for find/substr

        // Handle dot-separated identifiers (e.g., "schema.table.column")
        size_t dot_pos;
        while ((dot_pos = temp_identifier.find('.', start_pos)) != std::string::npos) {
            std::string part = temp_identifier.substr(start_pos, dot_pos - start_pos);
            if (part != "*") {  // Don't quote '*' in "table.*"
                result += quote_char + part + quote_char;
            } else {
                result += part;
            }
            result += ".";
            start_pos = dot_pos + 1;
        }
        // Quote the last part (or the only part if no dots)
        std::string last_part = temp_identifier.substr(start_pos);
        if (last_part != "*") {
            result += quote_char + last_part + quote_char;
        } else {
            result += last_part;
        }
        return result;
    }

    QVariant QueryBuilder::toQVariant(const QueryValue &qv, QVariantList &subquery_bindings_accumulator) {
        return std::visit(
            [&subquery_bindings_accumulator](auto &&arg) -> QVariant {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, std::nullptr_t>) {
                    return QVariant(QMetaType(QMetaType::UnknownType));
                } else if constexpr (std::is_same_v<T, int>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, long long>) {
                    return QVariant(static_cast<qlonglong>(arg));
                } else if constexpr (std::is_same_v<T, double>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return QVariant(QString::fromStdString(arg));
                } else if constexpr (std::is_same_v<T, bool>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QDateTime>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QDate>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QTime>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, QByteArray>) {
                    return QVariant(arg);
                } else if constexpr (std::is_same_v<T, SubqueryExpression>) {
                    for (const auto &sub_binding_variant : arg.bindings) {
                        std::visit(
                            [&subquery_bindings_accumulator](auto &&sub_val) {
                                using SubVT = std::decay_t<decltype(sub_val)>;
                                if constexpr (std::is_same_v<SubVT, std::nullptr_t>) {
                                    subquery_bindings_accumulator.append(QVariant(QMetaType(QMetaType::UnknownType)));
                                } else if constexpr (std::is_same_v<SubVT, int> || std::is_same_v<SubVT, long long> || std::is_same_v<SubVT, double> || std::is_same_v<SubVT, bool> ||  // bool added
                                                     std::is_same_v<SubVT, QDateTime> || std::is_same_v<SubVT, QDate> || std::is_same_v<SubVT, QTime> || std::is_same_v<SubVT, QByteArray>) {
                                    subquery_bindings_accumulator.append(QVariant::fromValue(sub_val));
                                } else if constexpr (std::is_same_v<SubVT, std::string>) {
                                    subquery_bindings_accumulator.append(QString::fromStdString(sub_val));
                                } else {
                                    qWarning() << "QueryBuilder::toQVariant (Subquery binding): "
                                                  "Unhandled native type in subquery binding: "
                                               << typeid(SubVT).name();
                                }
                            },
                            sub_binding_variant);
                    }
                    return QVariant(QString::fromStdString("(" + arg.sql_string + ")"));
                }
                qWarning() << "QueryBuilder::toQVariant: Unhandled QueryValue variant type: " << typeid(T).name();
                return QVariant();
            },
            qv);
    }

    QueryValue QueryBuilder::qvariantToQueryValue(const QVariant &qv) {
        if (qv.isNull() || !qv.isValid()) return nullptr;

        QMetaType::Type type_id_val;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        type_id_val = static_cast<QMetaType::Type>(qv.typeId());
#else
        type_id_val = static_cast<QMetaType::Type>(qv.type());
#endif

        if (type_id_val == QMetaType::UnknownType && qv.userType() != QMetaType::UnknownType) {
            type_id_val = static_cast<QMetaType::Type>(qv.userType());
        }

        if (type_id_val == QMetaType::Int) return qv.toInt();
        if (type_id_val == QMetaType::LongLong) return qv.toLongLong();
        if (type_id_val == QMetaType::ULongLong)  // QueryValue uses signed long long
            return qv.toLongLong();
        if (type_id_val == QMetaType::UInt)  // QueryValue uses signed int
            return static_cast<int>(qv.toUInt());
        if (type_id_val == QMetaType::Double) return qv.toDouble();
        if (type_id_val == QMetaType::Float)  // Promote to double for QueryValue
            return static_cast<double>(qv.toFloat());
        if (type_id_val == QMetaType::QString) return qv.toString().toStdString();
        if (type_id_val == QMetaType::Bool) return qv.toBool();
        if (type_id_val == QMetaType::QDateTime) return qv.toDateTime();
        if (type_id_val == QMetaType::QDate) return qv.toDate();
        if (type_id_val == QMetaType::QTime) return qv.toTime();
        if (type_id_val == QMetaType::QByteArray) return qv.toByteArray();

        qWarning() << "QueryBuilder::qvariantToQueryValue: Unhandled QVariant type "
                      "for QueryValue conversion: "
                   << qv.typeName() << "(TypeId: " << static_cast<int>(type_id_val) << ")";
        return nullptr;
    }

    std::pair<std::string, std::vector<QueryValue>> QueryBuilder::buildConditionClauseGroup() const {
        std::ostringstream group_sql_stream;
        QVariantList group_qbindings;  // Accumulates QVariants first

        std::ostringstream user_defined_conditions_ss;
        bool any_user_condition_written = false;

        if (!state_.where_conditions_.empty()) {
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.where_conditions_, "AND", false);
            any_user_condition_written = true;
        }
        if (!state_.or_conditions_.empty()) {
            if (any_user_condition_written) user_defined_conditions_ss << " OR ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.or_conditions_, "OR", false);
            any_user_condition_written = true;
        }
        if (!state_.not_conditions_.empty()) {
            if (any_user_condition_written) user_defined_conditions_ss << " AND ";
            QueryBuilder::build_one_condition_block_internal_static_helper(user_defined_conditions_ss, group_qbindings, state_.not_conditions_, "AND", true);
            // any_user_condition_written = true; // This was missing, though might not affect logic if not_conditions_ is last
        }
        std::string user_conditions_part_sql = user_defined_conditions_ss.str();

        std::string soft_delete_fragment_for_this_group;
        if (state_.model_meta_ && state_.apply_soft_delete_scope_) {
            bool apply_sd_on_this_from_source = false;
            QString current_from_qstr = this->getFromSourceName();  // Returns QString
            if (!current_from_qstr.isEmpty() && state_.model_meta_->table_name == current_from_qstr.toStdString()) {
                apply_sd_on_this_from_source = true;
            }

            if (apply_sd_on_this_from_source) {
                if (const FieldMeta *deleted_at_field = state_.model_meta_->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    // Use QueryBuilder::quoteSqlIdentifier (static)
                    soft_delete_fragment_for_this_group = QueryBuilder::quoteSqlIdentifier(this->getFromSourceName().toStdString()) +  // Uses QB's getFromSourceName
                                                          "." + QueryBuilder::quoteSqlIdentifier(deleted_at_field->db_name) + " IS NULL";
                }
            }
        }

        bool has_soft_delete = !soft_delete_fragment_for_this_group.empty();
        bool has_user_conditions = !user_conditions_part_sql.empty();

        if (has_soft_delete) {
            group_sql_stream << "(" << soft_delete_fragment_for_this_group << ")";
        }
        if (has_soft_delete && has_user_conditions) {
            group_sql_stream << " AND ";
        }
        if (has_user_conditions) {
            group_sql_stream << user_conditions_part_sql;
        }

        std::string final_built_sql_group = group_sql_stream.str();
        if (final_built_sql_group.empty()) {
            return {"", {}};
        }

        std::vector<QueryValue> native_args;
        native_args.reserve(group_qbindings.size());
        for (const QVariant &qv : group_qbindings) {
            native_args.push_back(QueryBuilder::qvariantToQueryValue(qv));
        }

        return {"(" + final_built_sql_group + ")", native_args};
    }

    QString QueryBuilder::toSqlDebug() const {
        auto [sql_qstr, params_list] = this->buildSelectSQL();
        QString debug_sql = sql_qstr;
        int current_param_idx = 0;
        int placeholder_pos = 0;

        while (current_param_idx < params_list.size()) {
            placeholder_pos = debug_sql.indexOf('?', placeholder_pos);
            if (placeholder_pos == -1) break;

            QVariant v = params_list.at(current_param_idx);
            QString param_str_val;

            QMetaType::Type v_type_id;
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            v_type_id = static_cast<QMetaType::Type>(v.typeId());
#else
            v_type_id = static_cast<QMetaType::Type>(v.type());
#endif
            if (v_type_id == QMetaType::UnknownType && v.userType() != QMetaType::UnknownType) {
                v_type_id = static_cast<QMetaType::Type>(v.userType());
            }

            if (v.isNull() || !v.isValid() || v_type_id == QMetaType::UnknownType) {
                param_str_val = "NULL";
            } else if (v_type_id == QMetaType::QString) {
                param_str_val = "'" + v.toString().replace("'", "''") + "'";
            } else if (v_type_id == QMetaType::QByteArray) {
                param_str_val = "'<BinaryData:" + QString::number(v.toByteArray().size()) + "bytes>'";
            } else if (v_type_id == QMetaType::QDateTime) {
                param_str_val = "'" + v.toDateTime().toString(Qt::ISODateWithMs) + "'";
            } else if (v_type_id == QMetaType::QDate) {
                param_str_val = "'" + v.toDate().toString(Qt::ISODate) + "'";
            } else if (v_type_id == QMetaType::QTime) {
                param_str_val = "'" + v.toTime().toString(Qt::ISODateWithMs) + "'";
            } else if (v_type_id == QMetaType::Bool) {
                param_str_val = v.toBool() ? "TRUE" : "FALSE";
            } else {  // For numbers (int, long long, double)
                param_str_val = v.toString();
            }

            debug_sql.replace(placeholder_pos, 1, param_str_val);
            placeholder_pos += param_str_val.length();
            current_param_idx++;
        }
        return debug_sql;
    }

}  // namespace cpporm#include "cpporm/db_manager.h"  // 引用新的头文件

#include <QDebug>  // 仍然可以使用 Qt Core 的调试功能

// SqlDriverManager, SqlConnectionParameters, SqlDatabase, Error 已经在 db_manager.h 中包含

namespace cpporm {

    // openDatabase 现在返回 std::expected<std::string, Error>
    // 连接名现在是 std::string
    std::expected<std::string, Error> DbManager::openDatabase(const DbConfig &config) {
        std::string conn_name_std = config.connection_name;
        if (conn_name_std.empty()) {
            conn_name_std = DbConfig::generateUniqueConnectionName();
        }

        // 使用 cpporm_sqldriver::ConnectionParameters
        cpporm_sqldriver::ConnectionParameters driver_params = config.toDriverParameters();

        // SqlDriverManager::addDatabase 返回一个 SqlDatabase 对象
        // 我们需要检查它是否有效以及是否能打开
        // addDatabase 内部会处理驱动注册和创建
        // SqlDriverManager 本身不直接 "打开" 连接，而是 SqlDatabase 对象自己打开
        cpporm_sqldriver::SqlDatabase db = cpporm_sqldriver::SqlDriverManager::addDatabase(config.driver_type, conn_name_std);

        if (!db.isValid()) {
            // 获取更详细的错误信息，如果 SqlDatabase 提供了
            cpporm_sqldriver::SqlError last_err = db.lastError();
            return std::unexpected(Error(ErrorCode::DriverNotFound, "Failed to add database: Driver type '" + config.driver_type + "' might be unavailable or invalid. Connection name: " + conn_name_std + ". Driver Msg: " + last_err.text()));
        }

        // SqlDatabase::open(params) 负责实际的连接打开
        if (!db.open(driver_params)) {
            cpporm_sqldriver::SqlError last_err = db.lastError();
            cpporm_sqldriver::SqlDriverManager::removeDatabase(conn_name_std);  // 打开失败，移除它
            return std::unexpected(Error(ErrorCode::ConnectionFailed, "Failed to open database connection: " + last_err.text() + " (Native Code: " + last_err.nativeErrorCode() + ")", last_err.nativeErrorCodeNumeric()));
        }

        // 如果驱动支持并且配置中指定了字符集，则尝试设置
        // 注意: SqlDatabase::setClientCharset 应该在 open 之后调用
        if (!config.client_charset.empty()) {
            if (!db.setClientCharset(config.client_charset)) {
                cpporm_sqldriver::SqlError charset_err = db.lastError();
                // 根据需求决定这是否是致命错误
                qWarning() << "DbManager::openDatabase: Failed to set client charset '" << QString::fromStdString(config.client_charset) << "' for connection" << QString::fromStdString(conn_name_std) << ". Error:" << QString::fromStdString(charset_err.text())
                           << ". Continuing without this charset setting.";
            }
        }
        return conn_name_std;
    }

    // getDatabase 返回 cpporm_sqldriver::SqlDatabase
    // 连接名现在是 std::string
    cpporm_sqldriver::SqlDatabase DbManager::getDatabase(const std::string &connection_name_str) {
        // SqlDriverManager::database() 返回一个 SqlDatabase 对象。
        // 第二个参数 bool open 默认为 true，表示如果连接不存在或未打开，则尝试打开它。
        // 这可能需要传递完整的 ConnectionParameters，但 SqlDriverManager
        // 应该已经存储了它们（或者需要一个更复杂的 getDatabase 实现）。
        // 假设 SqlDriverManager::database(name, true) 会处理打开逻辑。
        // 如果仅获取句柄而不保证打开，则用 false。
        return cpporm_sqldriver::SqlDriverManager::database(connection_name_str, false /* do not auto-open here, openDatabase should handle it */);
    }

    // closeDatabase 连接名现在是 std::string
    void DbManager::closeDatabase(const std::string &connection_name_str) {
        // SqlDriverManager::removeDatabase 会处理关闭和移除
        cpporm_sqldriver::SqlDriverManager::removeDatabase(connection_name_str);
    }

    // isConnectionValid 连接名现在是 std::string
    bool DbManager::isConnectionValid(const std::string &connection_name_str) {
        if (!cpporm_sqldriver::SqlDriverManager::contains(connection_name_str)) {
            return false;
        }
        // 获取数据库句柄，但不尝试打开它（如果它尚未打开）
        cpporm_sqldriver::SqlDatabase db = cpporm_sqldriver::SqlDriverManager::database(connection_name_str, false);
        return db.isValid() && db.isOpen();
    }

}  // namespace cpporm#include "cpporm/model_base.h" // For declarations in model_base.h

namespace cpporm {
namespace internal {

// Definitions for the global model factory registry
std::map<std::type_index, ModelFactory> &getGlobalModelFactoryRegistry() {
  static std::map<std::type_index, ModelFactory> registry;
  return registry;
}

std::mutex &getGlobalModelFactoryRegistryMutex() {
  static std::mutex registry_mutex;
  return registry_mutex;
}

// Definitions for Global Meta Finalization
std::vector<VoidFunc> &getGlobalModelFinalizerFunctions() {
  static std::vector<VoidFunc> finalizers;
  return finalizers;
}
std::mutex &getGlobalModelFinalizersRegistryMutex() {
  static std::mutex mtx;
  return mtx;
}

} // namespace internal

// Definition for the user-callable global finalization function
void finalize_all_model_meta() {
  // It's crucial that this function is called *after* all static initializers
  // (which call registerModelClassForFinalization) have run, and all model
  // class definitions are complete.

  // Create a copy of the finalizer functions to avoid issues if a finalizer
  // somehow tries to re-register (should not happen with current design).
  std::vector<internal::VoidFunc> finalizers_copy;
  {
    std::lock_guard<std::mutex> lock(
        internal::getGlobalModelFinalizersRegistryMutex());
    finalizers_copy = internal::getGlobalModelFinalizerFunctions();
  }

  // Sort finalizers? Not strictly necessary if _finalizeModelMeta is idempotent
  // and handles its dependencies gracefully (which it tries to, but typeid
  // makes it tricky). For now, call in registration order. A more robust system
  // might involve multiple passes or dependency tracking. qInfo() << "cpporm:
  // Globally finalizing metadata for" << finalizers_copy.size() << "models...";
  for (const auto &finalizer_func : finalizers_copy) {
    if (finalizer_func) {
      finalizer_func();
    }
  }
  // qInfo() << "cpporm: Global metadata finalization complete.";

  // Optional: Clear the global list if finalization is truly a one-time startup
  // event. This prevents re-finalization and saves a little memory. However, if
  // models could be registered dynamically later (not typical for this ORM
  // style), clearing would be problematic.
  // {
  //     std::lock_guard<std::mutex>
  //     lock(internal::getGlobalModelFinalizersRegistryMutex());
  //     internal::getGlobalModelFinalizerFunctions().clear();
  // }
}

} // namespace cpporm#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h" // FriendAccess 定义在此

#include <QDebug>
// #include <QSqlError> // No longer directly needed for error reporting from SqlQuery
// #include <QSqlQuery> // No longer using QSqlQuery
#include <QVariant>  // For QVariantList from BatchSqlParts (suffix bindings)

// SqlDriver specific includes
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_error.h"
#include "cpporm_sqldriver/sql_value.h"


namespace cpporm {
namespace internal_batch_helpers {

ExecutionResult
executeBatchSql(Session &session, // Pass Session to get db_handle
                const std::string &sql_to_execute_std, // SQL is now std::string
                const std::vector<cpporm_sqldriver::SqlValue> &bindings_sqlvalue, // Bindings are SqlValue
                const std::vector<ModelBase *> &models_in_db_op,
                const OnConflictClause *active_conflict_clause) {

    ExecutionResult result; // query_object is now cpporm_sqldriver::SqlQuery

    // FriendAccess::callExecuteQueryInternal now takes std::string and std::vector<SqlValue>
    // and returns std::pair<cpporm_sqldriver::SqlQuery, Error>
    auto exec_pair = FriendAccess::callExecuteQueryInternal(
        session.getDbHandle(), sql_to_execute_std, bindings_sqlvalue);

    result.query_object = std::move(exec_pair.first); // Move SqlQuery
    result.db_error = exec_pair.second;

    if (result.db_error) {
        return result;
    }

    result.rows_affected = result.query_object.numRowsAffected(); // From SqlQuery

    // Determine which models were potentially persisted based on rows_affected and conflict action
    if (result.rows_affected > 0 ||
        (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing && result.rows_affected >= 0 /* Could be 0 if ON CONFLICT DO UPDATE results in no change */) ) {
        for (ModelBase *m : models_in_db_op) {
            if (m) {
                m->_is_persisted = true;
                result.models_potentially_persisted.push_back(m);
            }
        }
    } else if (result.rows_affected == 0 && active_conflict_clause &&
               active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
        // For DO NOTHING and 0 rows affected, models might exist but were not modified.
        // Their _is_persisted state should not change to true if they weren't already.
        // They are "processed" in the sense that the DB acknowledged them in the conflict.
        for (ModelBase *m : models_in_db_op) {
            if (m) {
                // If _is_persisted was already true (e.g. from a previous load), it remains true.
                // If it was false (typical for new objects in CreateBatch), it remains false.
                // These models are added to potentially_persisted because the DB operation "saw" them.
                // ID backfilling logic might still be relevant if the conflict target was a PK and it's an "upsert returning ID" scenario.
                result.models_potentially_persisted.push_back(m);
            }
        }
    }
    // If rows_affected < 0 (error or non-DML), models_potentially_persisted remains empty unless error already handled.
    return result;
}

void callAfterCreateHooks(
    Session &session,
    const std::vector<ModelBase *> &models_for_hooks,
    Error &in_out_first_error_encountered) {

    for (ModelBase *model_ptr : models_for_hooks) {
        if (!model_ptr || !model_ptr->_is_persisted) { // Only call for successfully persisted models
            continue;
        }

        Error hook_err = model_ptr->afterCreate(session);
        if (hook_err) {
            if (in_out_first_error_encountered.isOk()) {
                in_out_first_error_encountered = hook_err;
            }
            qWarning() << "callAfterCreateHooks: afterCreate hook failed for a model (table: "
                       << QString::fromStdString(model_ptr->_getTableName()) << "). Error: "
                       << QString::fromStdString(hook_err.toString());
        }
    }
}

} // namespace internal_batch_helpers
} // namespace cpporm// Base/CppOrm/Source/session_batch_id_backfillers.cpp
#include <QDebug>
#include <QVariant>
#include <algorithm>

#include "cpporm/builder_parts/query_builder_state.h"  // For OnConflictClause
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_enums.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_value.h"

namespace cpporm {
    namespace internal_batch_helpers {

        std::vector<ModelBase *> backfillIdsFromReturning(cpporm_sqldriver::SqlQuery &executed_query, const ModelMeta &meta, const std::vector<ModelBase *> &models_to_backfill_from, const std::string &pk_cpp_name_str, const std::type_index &pk_cpp_type) {
            std::vector<ModelBase *> successfully_backfilled_models;
            if (models_to_backfill_from.empty()) {
                return successfully_backfilled_models;
            }

            for (ModelBase *model_to_backfill : models_to_backfill_from) {
                if (!model_to_backfill || !model_to_backfill->_is_persisted) {
                    continue;
                }

                if (!executed_query.next()) {
                    qWarning() << "backfillIdsFromReturning: RETURNING clause provided fewer "
                                  "ID rows than the number of persisted models in the batch for table "
                               << QString::fromStdString(meta.table_name);
                    break;
                }
                cpporm_sqldriver::SqlValue id_sql_val_ret = executed_query.value(0);
                std::any pk_any_val;
                bool conv_ok = false;

                if (id_sql_val_ret.isNull()) {
                    conv_ok = true;
                } else {
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = id_sql_val_ret.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = id_sql_val_ret.toInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned int))
                        pk_any_val = id_sql_val_ret.toUInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned long long))
                        pk_any_val = id_sql_val_ret.toUInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(std::string))
                        pk_any_val = id_sql_val_ret.toString(&conv_ok);
                    else if (pk_cpp_type == typeid(QByteArray))  // Handle QByteArray for UUID etc.
                        pk_any_val = id_sql_val_ret.toByteArray(&conv_ok);
                    else {
                        qWarning() << "backfillIdsFromReturning: Unsupported C++ PK type for backfill: " << pk_cpp_type.name() << "for table" << QString::fromStdString(meta.table_name) << ". Attempting string conversion.";
                        pk_any_val = id_sql_val_ret.toString(&conv_ok);
                    }
                }

                if (conv_ok) {
                    Error set_err = model_to_backfill->setFieldValue(pk_cpp_name_str, pk_any_val);
                    if (set_err) {
                        qWarning() << "backfillIdsFromReturning: Error setting PK value for table " << QString::fromStdString(meta.table_name) << ", field " << QString::fromStdString(pk_cpp_name_str) << " after RETURNING:" << QString::fromStdString(set_err.toString());
                    } else {
                        successfully_backfilled_models.push_back(model_to_backfill);
                    }
                } else {
                    qWarning() << "backfillIdsFromReturning: PK backfill conversion failed for RETURNING. SqlValue type:" << id_sql_val_ret.typeName() << "to C++ type" << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                }
            }
            return successfully_backfilled_models;
        }

        std::vector<ModelBase *> backfillIdsFromLastInsertId(cpporm_sqldriver::SqlQuery &executed_query,
                                                             const Session &session,
                                                             const ModelMeta &meta,
                                                             const std::vector<ModelBase *> &models_to_backfill_from,
                                                             long long total_rows_affected_by_query,
                                                             const std::string &pk_cpp_name_str,
                                                             const std::type_index &pk_cpp_type,
                                                             const OnConflictClause *active_conflict_clause) {
            std::vector<ModelBase *> successfully_backfilled_models;
            if (models_to_backfill_from.empty() || total_rows_affected_by_query <= 0) {
                return successfully_backfilled_models;
            }

            cpporm_sqldriver::SqlValue first_id_sql_val = executed_query.lastInsertId();
            if (!first_id_sql_val.isValid() || first_id_sql_val.isNull()) {
                bool is_zero_id = false;
                bool conv_check_ok = false;
                if (first_id_sql_val.type() == cpporm_sqldriver::SqlValueType::Int32 && first_id_sql_val.toInt32(&conv_check_ok) == 0 && conv_check_ok)
                    is_zero_id = true;
                else if (first_id_sql_val.type() == cpporm_sqldriver::SqlValueType::Int64 && first_id_sql_val.toInt64(&conv_check_ok) == 0 && conv_check_ok)
                    is_zero_id = true;

                if (!is_zero_id || (is_zero_id && pk_cpp_type != typeid(int) && pk_cpp_type != typeid(long long))) {
                    qWarning() << "backfillIdsFromLastInsertId: lastInsertId is invalid, null, or zero (and PK is not int/longlong) for table " << QString::fromStdString(meta.table_name) << ". Value: " << QString::fromStdString(first_id_sql_val.toString());
                    return successfully_backfilled_models;
                }
            }

            std::string db_driver_name_upper_std;
            // Use a const reference to the db_handle to call const methods
            const cpporm_sqldriver::SqlDatabase &const_db_handle = session.getDbHandle();
            if (const_db_handle.driver()) {
                std::string drv_name_full = const_db_handle.driverName();
                std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std), [](unsigned char c) {
                    return std::toupper(c);
                });
            }

            if (models_to_backfill_from.size() == 1 && total_rows_affected_by_query >= 1) {
                ModelBase *single_model = nullptr;
                for (ModelBase *m : models_to_backfill_from) {
                    if (m && m->_is_persisted) {
                        single_model = m;
                        break;
                    }
                }

                if (single_model) {
                    std::any pk_any_val;
                    bool conv_ok = false;
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned int))
                        pk_any_val = first_id_sql_val.toUInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(unsigned long long))
                        pk_any_val = first_id_sql_val.toUInt64(&conv_ok);
                    else if (pk_cpp_type == typeid(std::string))
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    else if (pk_cpp_type == typeid(QByteArray))
                        pk_any_val = first_id_sql_val.toByteArray(&conv_ok);
                    else {
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    }

                    if (conv_ok) {
                        Error set_err = single_model->setFieldValue(pk_cpp_name_str, pk_any_val);
                        if (set_err) {
                            qWarning() << "backfillIdsFromLastInsertId (single): Error setting PK value for table " << QString::fromStdString(meta.table_name) << ", field " << QString::fromStdString(pk_cpp_name_str) << ". Error: " << QString::fromStdString(set_err.toString());
                        } else {
                            successfully_backfilled_models.push_back(single_model);
                        }
                    } else {
                        qWarning() << "backfillIdsFromLastInsertId (single): PK backfill conversion failed. SqlValue type:" << first_id_sql_val.typeName() << " to C++ type " << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                    }
                }
            } else if ((db_driver_name_upper_std.find("MYSQL") != std::string::npos || db_driver_name_upper_std.find("MARIADB") != std::string::npos) && total_rows_affected_by_query > 0 && total_rows_affected_by_query <= static_cast<long long>(models_to_backfill_from.size()) &&
                       (!active_conflict_clause || (active_conflict_clause && (active_conflict_clause->action == OnConflictClause::Action::UpdateAllExcluded || active_conflict_clause->action == OnConflictClause::Action::UpdateSpecific)))) {
                bool ok_first_id_ll;
                long long first_id_ll = first_id_sql_val.toInt64(&ok_first_id_ll);
                if (!ok_first_id_ll) {
                    qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): lastInsertId could not be converted to long long for table " << QString::fromStdString(meta.table_name);
                    return successfully_backfilled_models;
                }

                if (total_rows_affected_by_query == static_cast<long long>(models_to_backfill_from.size())) {
                    size_t persisted_model_idx = 0;
                    for (ModelBase *current_model : models_to_backfill_from) {
                        if (!current_model || !current_model->_is_persisted) continue;

                        long long current_model_id_ll = first_id_ll + static_cast<long long>(persisted_model_idx);
                        // Explicitly cast to the correct integer type for SqlValue constructor
                        cpporm_sqldriver::SqlValue current_id_sv(static_cast<int64_t>(current_model_id_ll));
                        std::any pk_any_val_seq;
                        bool conv_ok_seq = false;

                        if (pk_cpp_type == typeid(int))
                            pk_any_val_seq = current_id_sv.toInt32(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(long long))
                            pk_any_val_seq = current_id_sv.toInt64(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(unsigned int))
                            pk_any_val_seq = current_id_sv.toUInt32(&conv_ok_seq);
                        else if (pk_cpp_type == typeid(unsigned long long))
                            pk_any_val_seq = current_id_sv.toUInt64(&conv_ok_seq);
                        else {
                            pk_any_val_seq = current_id_sv.toString(&conv_ok_seq);
                        }

                        if (conv_ok_seq) {
                            Error set_err = current_model->setFieldValue(pk_cpp_name_str, pk_any_val_seq);
                            if (set_err) {
                                qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): Error setting PK value for table " << QString::fromStdString(meta.table_name) << ". Error: " << QString::fromStdString(set_err.toString());
                            } else {
                                successfully_backfilled_models.push_back(current_model);
                            }
                        } else {
                            qWarning() << "backfillIdsFromLastInsertId (MySQL Batch): PK backfill conversion failed for sequential ID. SqlValue type:" << current_id_sv.typeName() << " to C++ type " << pk_cpp_type.name() << " for table " << QString::fromStdString(meta.table_name);
                        }
                        persisted_model_idx++;
                    }
                } else if (total_rows_affected_by_query > 0) {
                    ModelBase *first_persisted_model = nullptr;
                    for (ModelBase *m : models_to_backfill_from) {
                        if (m && m->_is_persisted) {
                            first_persisted_model = m;
                            break;
                        }
                    }

                    if (first_persisted_model) {
                        std::any pk_any_val;
                        bool conv_ok = false;
                        if (pk_cpp_type == typeid(int))
                            pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                        else if (pk_cpp_type == typeid(long long))
                            pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                        else {
                            pk_any_val = first_id_sql_val.toString(&conv_ok);
                        }
                        if (conv_ok) {
                            Error set_err = first_persisted_model->setFieldValue(pk_cpp_name_str, pk_any_val);
                            if (!set_err) successfully_backfilled_models.push_back(first_persisted_model);
                        }
                    }
                    qWarning() << "backfillIdsFromLastInsertId: lastInsertId may not be reliable for all rows (MySQL batch). Rows affected (" << total_rows_affected_by_query << ") != models persisted/attempted in batch (" << models_to_backfill_from.size()
                               << "). Table: " << QString::fromStdString(meta.table_name);
                }

            } else if (db_driver_name_upper_std.find("SQLITE") != std::string::npos && total_rows_affected_by_query == 1 && !models_to_backfill_from.empty()) {
                ModelBase *model_to_set = nullptr;
                for (ModelBase *m : models_to_backfill_from) {
                    if (m && m->_is_persisted) {
                        model_to_set = m;
                        break;
                    }
                }

                if (model_to_set) {
                    std::any pk_any_val;
                    bool conv_ok = false;
                    if (pk_cpp_type == typeid(int))
                        pk_any_val = first_id_sql_val.toInt32(&conv_ok);
                    else if (pk_cpp_type == typeid(long long))
                        pk_any_val = first_id_sql_val.toInt64(&conv_ok);
                    else {
                        pk_any_val = first_id_sql_val.toString(&conv_ok);
                    }

                    if (conv_ok) {
                        Error set_err = model_to_set->setFieldValue(pk_cpp_name_str, pk_any_val);
                        if (!set_err) successfully_backfilled_models.push_back(model_to_set);
                    }
                }
            } else {
                qWarning() << "backfillIdsFromLastInsertId: lastInsertId is not reliably applicable for this batch operation on driver " << QString::fromStdString(db_driver_name_upper_std) << " for table " << QString::fromStdString(meta.table_name)
                           << ". Models processed: " << models_to_backfill_from.size() << ", Rows affected by query: " << total_rows_affected_by_query;
            }
            return successfully_backfilled_models;
        }

    }  // namespace internal_batch_helpers
}  // namespace cpporm#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_priv_batch_helpers.h" // 包含声明和 FriendAccess 定义

#include <QDebug>
#include <QStringList> // Still used for constructing SQL parts like "(?,?,?)"
#include <QVariant>    // QVariantList for suffix bindings, if QueryBuilder::buildInsertSQLSuffix still uses it

// SqlDriver specific includes
#include "cpporm_sqldriver/sql_value.h"


namespace cpporm {
namespace internal_batch_helpers {

std::pair<std::vector<ModelBase *>, Error> prepareModelsAndSqlPlaceholders(
    Session &session, const std::vector<ModelBase *> &models_in_provider_chunk,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache, // IN
    BatchSqlParts &out_sql_parts                                        // OUT
) {
    std::vector<ModelBase *> models_prepared_for_sql_build;
    models_prepared_for_sql_build.reserve(models_in_provider_chunk.size());
    Error first_prepare_error = make_ok();

    out_sql_parts.all_values_flattened.clear(); // This will now be std::vector<SqlValue>
    out_sql_parts.row_placeholders.clear();     // This is QStringList

    std::string db_driver_name_upper_std;
    if(session.getDbHandle().driver()){
        std::string drv_name_full = session.getDbHandle().driverName();
        std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std),
                       [](unsigned char c){ return std::toupper(c); });
    }


    for (ModelBase *model_ptr : models_in_provider_chunk) {
        if (!model_ptr) continue;

        Error hook_err = model_ptr->beforeCreate(session);
        if (hook_err) {
            if (first_prepare_error.isOk()) first_prepare_error = hook_err;
            qWarning() << "prepareModelsAndSqlPlaceholders: beforeCreate hook failed for model (table: "
                       << QString::fromStdString(meta.table_name) << "): " << QString::fromStdString(hook_err.toString());
            continue; // Skip this model if hook fails
        }
        FriendAccess::callAutoSetTimestamps(session, *model_ptr, meta, true);

        // extractModelData now returns map<std::string, SqlValue> for fields_to_write
        internal::SessionModelDataForWrite model_data_struct =
            FriendAccess::callExtractModelData(session, *model_ptr, meta, false, true);

        QStringList current_model_placeholders_segment_qsl; // For "(?,?,?)" part
        bool model_can_be_inserted_this_pass = false;

        bool is_pure_auto_inc_pk_current_model = batch_ordered_db_field_names_cache.empty() &&
                                               meta.getPrimaryField() &&
                                               has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);


        if (!batch_ordered_db_field_names_cache.empty()) {
            model_can_be_inserted_this_pass = true;
            for (const std::string &field_db_name : batch_ordered_db_field_names_cache) {
                auto it = model_data_struct.fields_to_write.find(field_db_name); // Key is std::string
                // out_sql_parts.all_values_flattened is now std::vector<SqlValue>
                out_sql_parts.all_values_flattened.push_back(
                    it != model_data_struct.fields_to_write.end() ? it->second : cpporm_sqldriver::SqlValue() /* Null SqlValue */
                );
                current_model_placeholders_segment_qsl.append("?");
            }
            out_sql_parts.row_placeholders.append(QString("(%1)").arg(current_model_placeholders_segment_qsl.join(",")));
        } else if (is_pure_auto_inc_pk_current_model) {
            model_can_be_inserted_this_pass = true;
            // For pure auto-inc PK, SQL syntax (DEFAULT VALUES or empty VALUES ()) depends on DB.
            // Placeholders for values are not typically used for this case, but the VALUES () or DEFAULT VALUES part is built.
            // If PostgreSQL and only one such model in the batch, specific "DEFAULT VALUES" SQL is used later.
            // For multi-row pure auto-inc for PG, or other DBs, often "()" is used per row.
            if (db_driver_name_upper_std.find("PSQL") == std::string::npos || models_in_provider_chunk.size() > 1) {
                 out_sql_parts.row_placeholders.append("()"); // For MySQL, SQLite, or multi-row PG auto-inc
            }
            // For single PG auto-inc, row_placeholders might remain empty, handled by buildFullBatchSqlStatement.
        }


        if (model_can_be_inserted_this_pass) {
            models_prepared_for_sql_build.push_back(model_ptr);
        } else {
            if (first_prepare_error.isOk()) {
                first_prepare_error = Error(ErrorCode::MappingError,
                                           "Model (table: " + meta.table_name +
                                           ", C++ type: " + typeid(*model_ptr).name() +
                                           ") could not be prepared for batch insertion (no insertable fields).");
            }
             qWarning() << "prepareModelsAndSqlPlaceholders: Model " << QString::fromStdString(typeid(*model_ptr).name())
                        << " for table " << QString::fromStdString(meta.table_name)
                        << " could not be prepared for batch insertion (no insertable fields determined or pure-auto-inc logic issue).";
        }
    }
    return {models_prepared_for_sql_build, first_prepare_error};
}

Error buildFullBatchSqlStatement(
    const Session &session, // const Session& is fine here as we only read db_handle properties
    const QueryBuilder &qb_prototype,
    const ModelMeta &meta,
    const std::vector<std::string> &batch_ordered_db_field_names_cache, // Already sorted std::string
    const OnConflictClause *active_conflict_clause,
    BatchSqlParts &in_out_sql_parts // IN/OUT
) {
    in_out_sql_parts.can_proceed = false;
    std::string db_driver_name_upper_std;
    if(session.getDbHandle().driver()){
        std::string drv_name_full = session.getDbHandle().driverName();
        std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(db_driver_name_upper_std),
                       [](unsigned char c){ return std::toupper(c); });
    }

    std::string sql_verb_std = "INSERT"; // Use std::string
    if (active_conflict_clause && active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
        if (db_driver_name_upper_std.find("MYSQL") != std::string::npos || db_driver_name_upper_std.find("MARIADB") != std::string::npos) {
            sql_verb_std = "INSERT IGNORE";
        }
        // For SQLite "INSERT OR IGNORE", or PG "ON CONFLICT DO NOTHING", suffix is preferred.
        // If suffix builder for SQLite returns empty for DO NOTHING, then verb needs to change.
        // For now, assume suffix handles it if possible.
    }

    bool is_pure_auto_inc_pk_case = batch_ordered_db_field_names_cache.empty() &&
                                  meta.getPrimaryField() &&
                                  has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);

    std::string table_name_quoted_std = QueryBuilder::quoteSqlIdentifier(meta.table_name);
    std::ostringstream sql_base_oss; // Use ostringstream for std::string

    if (is_pure_auto_inc_pk_case) {
        if (db_driver_name_upper_std.find("PSQL") != std::string::npos && in_out_sql_parts.row_placeholders.isEmpty()) {
            // Single row PG INSERT ... DEFAULT VALUES
            sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " DEFAULT VALUES";
            in_out_sql_parts.all_values_flattened.clear(); // No values for DEFAULT VALUES
        } else if (!in_out_sql_parts.row_placeholders.isEmpty()) {
            // MySQL, SQLite, or multi-row PG: INSERT INTO ... () VALUES (),()...
            sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " () VALUES "
                         << in_out_sql_parts.row_placeholders.join(",").toStdString();
            in_out_sql_parts.all_values_flattened.clear(); // No explicit values for "()"
        } else {
             qWarning() << "buildFullBatchSqlStatement: Inconsistent state for pure auto-inc PK case. Placeholders: "
                        << in_out_sql_parts.row_placeholders.join(",") << ", Driver: " << QString::fromStdString(db_driver_name_upper_std);
            return Error(ErrorCode::StatementPreparationError, "Pure auto-inc batch SQL build inconsistency.");
        }
    } else if (!batch_ordered_db_field_names_cache.empty() && !in_out_sql_parts.row_placeholders.isEmpty()) {
        sql_base_oss << sql_verb_std << " INTO " << table_name_quoted_std << " (";
        for (size_t i = 0; i < batch_ordered_db_field_names_cache.size(); ++i) {
            sql_base_oss << QueryBuilder::quoteSqlIdentifier(batch_ordered_db_field_names_cache[i])
                         << (i < batch_ordered_db_field_names_cache.size() - 1 ? ", " : "");
        }
        sql_base_oss << ") VALUES " << in_out_sql_parts.row_placeholders.join(",").toStdString();
    } else {
        return Error(ErrorCode::StatementPreparationError, "Cannot build batch INSERT SQL: missing field names or placeholders for table " + meta.table_name);
    }
    in_out_sql_parts.sql_insert_base = QString::fromStdString(sql_base_oss.str());


    in_out_sql_parts.sql_on_conflict_suffix.clear();
    in_out_sql_parts.conflict_suffix_bindings.clear(); // This is QVariantList

    if (active_conflict_clause && !(sql_verb_std != "INSERT" && active_conflict_clause->action == OnConflictClause::Action::DoNothing)) {
        QueryBuilder temp_qb_for_suffix_build(nullptr, session.getConnectionName(), &meta);
        temp_qb_for_suffix_build.getState_().on_conflict_clause_ = std::make_unique<OnConflictClause>(*active_conflict_clause);

        auto suffix_pair_result = temp_qb_for_suffix_build.buildInsertSQLSuffix(batch_ordered_db_field_names_cache);
        in_out_sql_parts.sql_on_conflict_suffix = suffix_pair_result.first; // QString
        in_out_sql_parts.conflict_suffix_bindings = suffix_pair_result.second; // QVariantList
    }

    in_out_sql_parts.final_sql_statement = in_out_sql_parts.sql_insert_base.toStdString(); // Start with std::string
    if(!in_out_sql_parts.sql_on_conflict_suffix.isEmpty()){
        in_out_sql_parts.final_sql_statement += " " + in_out_sql_parts.sql_on_conflict_suffix.toStdString();
    }

    // final_bindings is std::vector<SqlValue>
    in_out_sql_parts.final_bindings = in_out_sql_parts.all_values_flattened; // Already SqlValue vector
    for (const QVariant &qv_suffix_bind : in_out_sql_parts.conflict_suffix_bindings) {
        in_out_sql_parts.final_bindings.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv_suffix_bind)));
    }


    bool has_pk_for_returning = meta.getPrimaryField() &&
                                has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement) &&
                                !meta.getPrimaryField()->db_name.empty();
    bool use_returning = (session.getDbHandle().hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId) &&
                         (db_driver_name_upper_std.find("PSQL") != std::string::npos || db_driver_name_upper_std.find("SQLITE") != std::string::npos) &&
                         has_pk_for_returning &&
                         (!active_conflict_clause || active_conflict_clause->action != OnConflictClause::Action::DoNothing));

    if (use_returning) {
        in_out_sql_parts.final_sql_statement += " RETURNING " + QueryBuilder::quoteSqlIdentifier(meta.getPrimaryField()->db_name);
    }

    in_out_sql_parts.can_proceed = true;
    return make_ok();
}

} // namespace internal_batch_helpers
} // namespace cpporm#include "cpporm/model_base.h"     // For ModelBase, ModelMeta
#include "cpporm/query_builder.h"  // QueryBuilder 构造函数已更新
#include "cpporm/session.h"        // 主头文件

namespace cpporm {

    // --- Model/Table selection implementation ---
    QueryBuilder Session::Model(const ModelBase *model_instance_hint) {
        if (!model_instance_hint) {
            // QueryBuilder 构造函数接收 std::string connection_name_
            return QueryBuilder(this, this->connection_name_, nullptr);
        }
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, &(model_instance_hint->_getOwnModelMeta()));
    }

    QueryBuilder Session::Model(const ModelMeta &meta) {
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, &meta);
    }

    QueryBuilder Session::Table(const std::string &table_name) {
        // QueryBuilder 构造函数接收 std::string connection_name_
        QueryBuilder qb(this, this->connection_name_, nullptr);
        qb.Table(table_name);  // QueryBuilder::Table takes std::string
        return qb;
    }

    QueryBuilder Session::MakeQueryBuilder() {
        // QueryBuilder 构造函数接收 std::string connection_name_
        return QueryBuilder(this, this->connection_name_, nullptr);
    }

    // --- OnConflict clause setters implementation ---
    Session &Session::OnConflictUpdateAllExcluded() {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        temp_on_conflict_clause_->action = OnConflictClause::Action::UpdateAllExcluded;
        temp_on_conflict_clause_->update_assignments.clear();
        temp_on_conflict_clause_->conflict_target_columns_db_names.clear();  // 确保目标也清除
        return *this;
    }

    Session &Session::OnConflictDoNothing() {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        temp_on_conflict_clause_->action = OnConflictClause::Action::DoNothing;
        temp_on_conflict_clause_->update_assignments.clear();
        // conflict_target_columns_db_names 保持不变，用户可能已设置
        return *this;
    }

    Session &Session::OnConflictUpdateSpecific(std::function<void(SessionOnConflictUpdateSetter &)> updater_fn) {
        if (!temp_on_conflict_clause_) {
            temp_on_conflict_clause_ = std::make_unique<OnConflictClause>();
        }
        // SessionOnConflictUpdateSetter 构造函数会设置 action = UpdateSpecific
        SessionOnConflictUpdateSetter setter(*temp_on_conflict_clause_);
        updater_fn(setter);
        return *this;
    }

}  // namespace cpporm// Base/CppOrm/Source/session_create_batch_ops.cpp
#include "cpporm/session.h"
// #include <QSqlDriver> // Removed: No longer directly needed, use SqlDatabase::hasFeature
#include <QDebug>      // For qInfo, qWarning
#include <QSqlError>   // For QSqlError in old debug messages if any, should be SqlError
#include <QSqlQuery>   // For BatchExecutionMode (if used, but likely not from here directly)
#include <QVariant>    // For QVariantList for suffix bindings if buildInsertSQLSuffix still uses it

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"               // For OnConflictClause in Session, QueryBuilder state access
#include "cpporm/session_priv_batch_helpers.h"  // FriendAccess is defined here

// SqlDriver specific includes
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_enums.h"  // For Feature::LastInsertId, Feature::InsertAndReturnId
#include "cpporm_sqldriver/sql_query.h"  // For cpporm_sqldriver::SqlQuery
#include "cpporm_sqldriver/sql_value.h"  // For cpporm_sqldriver::SqlValue

namespace cpporm {

    // CreateBatchWithMeta 现在返回 std::expected<size_t, Error>
    std::expected<size_t, Error> Session::CreateBatchWithMeta(const ModelMeta &meta,
                                                              const std::vector<ModelBase *> &models,  // Pointers to models
                                                              size_t internal_batch_processing_size_hint,
                                                              const OnConflictClause *conflict_options_override) {
        if (models.empty()) {
            return 0UL;
        }
        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateBatchWithMeta: ModelMeta has no table name."));
        }
        if (internal_batch_processing_size_hint == 0) {
            internal_batch_processing_size_hint = 100;            // Default batch size
        } else if (internal_batch_processing_size_hint > 1000) {  // Safety cap
            internal_batch_processing_size_hint = 1000;
        }

        size_t total_successfully_created_count = 0;
        Error first_error_encountered = make_ok();

        QueryBuilder qb_proto = this->Model(meta);  // QB for prototype

        size_t current_provider_idx = 0;
        auto data_provider_lambda = [&]() -> std::optional<std::vector<ModelBase *>> {
            if (current_provider_idx >= models.size()) {
                return std::nullopt;
            }
            std::vector<ModelBase *> chunk;
            size_t end_idx = std::min(models.size(), current_provider_idx + internal_batch_processing_size_hint);
            for (size_t i = current_provider_idx; i < end_idx; ++i) {
                if (models[i]) {  // Ensure pointer is not null
                    chunk.push_back(models[i]);
                }
            }
            current_provider_idx = end_idx;
            if (chunk.empty()) return std::nullopt;
            return chunk;
        };

        auto completion_callback_lambda = [&total_successfully_created_count, &first_error_encountered](const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error) {
            if (batch_error) {
                if (first_error_encountered.isOk()) {
                    first_error_encountered = batch_error;
                }
            } else {
                for (const auto *m_ptr : processed_batch_models_with_ids) {
                    if (m_ptr && m_ptr->_is_persisted) {  // Count only if truly persisted
                        total_successfully_created_count++;
                    }
                }
            }
        };

        Error provider_loop_error = this->CreateBatchProviderInternal(qb_proto, data_provider_lambda, completion_callback_lambda, conflict_options_override);

        if (provider_loop_error) {  // Error from the provider loop itself
            return std::unexpected(provider_loop_error);
        }
        if (first_error_encountered) {  // Error from one of the batch DB operations or hooks
            return std::unexpected(first_error_encountered);
        }

        return total_successfully_created_count;
    }

    Error Session::CreateBatchProviderInternal(QueryBuilder qb_prototype,  // Pass by value as it might be modified
                                               std::function<std::optional<std::vector<ModelBase *>>()> data_batch_provider_base,
                                               std::function<void(const std::vector<ModelBase *> &processed_batch_models_with_ids, Error batch_error)> per_db_batch_completion_callback,
                                               const OnConflictClause *conflict_options_override) {
        const ModelMeta *meta_ptr = qb_prototype.getModelMeta();
        if (!meta_ptr) {
            return Error(ErrorCode::InvalidConfiguration, "CreateBatchProviderInternal: QueryBuilder prototype has no ModelMeta.");
        }
        const ModelMeta &meta = *meta_ptr;

        // Determine active OnConflictClause
        const OnConflictClause *active_conflict_clause = conflict_options_override;
        if (!active_conflict_clause && qb_prototype.getOnConflictClause()) {
            active_conflict_clause = qb_prototype.getOnConflictClause();
        }
        if (!active_conflict_clause && temp_on_conflict_clause_) {
            active_conflict_clause = temp_on_conflict_clause_.get();
        }
        bool clear_temp_clause_at_end = (active_conflict_clause == temp_on_conflict_clause_.get() && !conflict_options_override && !qb_prototype.getOnConflictClause());

        std::vector<std::string> batch_ordered_db_field_names_cache;
        bool is_pure_auto_inc_pk_model_type = data_batch_provider_base && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement) && meta.fields.size() == 1; 

        if (!is_pure_auto_inc_pk_model_type) {
            batch_ordered_db_field_names_cache.clear();
            for (const auto &field_meta_obj : meta.fields) {
                if (has_flag(field_meta_obj.flags, FieldFlag::Association)) continue;
                // For INSERT, AutoIncrement PKs are usually NOT included in the column list (DB generates them)
                if (has_flag(field_meta_obj.flags, FieldFlag::AutoIncrement) && has_flag(field_meta_obj.flags, FieldFlag::PrimaryKey)) continue;
                if (field_meta_obj.db_name.empty()) continue;
                batch_ordered_db_field_names_cache.push_back(field_meta_obj.db_name);
            }
            std::sort(batch_ordered_db_field_names_cache.begin(), batch_ordered_db_field_names_cache.end());
            if (batch_ordered_db_field_names_cache.empty() && !is_pure_auto_inc_pk_model_type) {
                 qWarning() << "CreateBatchProviderInternal: No insertable fields determined for non-pure-auto-inc model" << QString::fromStdString(meta.table_name)
                           << ". This might be valid if DB supports INSERT ... DEFAULT VALUES for such cases.";
            }
        }
        
        std::optional<std::vector<ModelBase *>> current_batch_models_opt;
        while ((current_batch_models_opt = data_batch_provider_base()).has_value()) {
            if (!current_batch_models_opt.has_value() || current_batch_models_opt->empty()) {
                break;
            }
            std::vector<ModelBase *> &models_in_current_chunk = *current_batch_models_opt;
            if (models_in_current_chunk.empty()) continue;

            internal_batch_helpers::BatchSqlParts sql_parts_for_chunk;
            Error batch_prep_error;
            std::vector<ModelBase *> models_prepared_for_this_db_batch;

            auto prep_result = internal_batch_helpers::prepareModelsAndSqlPlaceholders(*this, models_in_current_chunk, meta, batch_ordered_db_field_names_cache, sql_parts_for_chunk);
            models_prepared_for_this_db_batch = prep_result.first;
            batch_prep_error = prep_result.second;

            if (batch_prep_error) {
                if (per_db_batch_completion_callback) {
                    per_db_batch_completion_callback({}, batch_prep_error);
                }
                continue; 
            }
            if (models_prepared_for_this_db_batch.empty()) {
                if (per_db_batch_completion_callback) { 
                    per_db_batch_completion_callback({}, make_ok());
                }
                continue;
            }

            Error build_sql_err = internal_batch_helpers::buildFullBatchSqlStatement(*this, qb_prototype, meta, batch_ordered_db_field_names_cache, active_conflict_clause, sql_parts_for_chunk);

            if (build_sql_err || !sql_parts_for_chunk.can_proceed) {
                if (per_db_batch_completion_callback) {
                    per_db_batch_completion_callback({}, build_sql_err.isOk() ? Error(ErrorCode::StatementPreparationError, "SQL construction failed sanity check.") : build_sql_err);
                }
                continue;
            }
            
            internal_batch_helpers::ExecutionResult exec_res = internal_batch_helpers::executeBatchSql(
                *this, 
                sql_parts_for_chunk.final_sql_statement, // Pass std::string directly
                sql_parts_for_chunk.final_bindings,     // Pass std::vector<SqlValue>
                models_prepared_for_this_db_batch, 
                active_conflict_clause);

            std::vector<ModelBase *> successfully_backfilled_models;
            if (!exec_res.db_error) {
                bool driver_has_returning = db_handle_.hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId);
                bool driver_has_last_insert_id = db_handle_.hasFeature(cpporm_sqldriver::Feature::LastInsertId);
                std::string pk_cpp_name_for_backfill;
                std::type_index pk_cpp_type_for_backfill = typeid(void);
                if (meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement)) {
                    pk_cpp_name_for_backfill = meta.getPrimaryField()->cpp_name;
                    pk_cpp_type_for_backfill = meta.getPrimaryField()->cpp_type;
                }

                if (!pk_cpp_name_for_backfill.empty()) {
                    if (sql_parts_for_chunk.final_sql_statement.find(" RETURNING ") != std::string::npos && driver_has_returning) {
                        successfully_backfilled_models = internal_batch_helpers::backfillIdsFromReturning(exec_res.query_object, meta, exec_res.models_potentially_persisted, pk_cpp_name_for_backfill, pk_cpp_type_for_backfill);
                    } else if (driver_has_last_insert_id) {
                        successfully_backfilled_models = internal_batch_helpers::backfillIdsFromLastInsertId(exec_res.query_object, *this, meta, exec_res.models_potentially_persisted, exec_res.rows_affected, pk_cpp_name_for_backfill, pk_cpp_type_for_backfill, active_conflict_clause);
                    }
                } else { 
                    successfully_backfilled_models = exec_res.models_potentially_persisted;
                }

                Error first_hook_error = make_ok();
                internal_batch_helpers::callAfterCreateHooks(*this, successfully_backfilled_models, first_hook_error);
                if (first_hook_error && exec_res.db_error.isOk()) { 
                    exec_res.db_error = first_hook_error;
                }
            }

            if (per_db_batch_completion_callback) {
                per_db_batch_completion_callback(successfully_backfilled_models, exec_res.db_error);
            }
        }

        if (clear_temp_clause_at_end) this->clearTempOnConflictClause();
        return make_ok();
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant types in QueryValue
#include <QDebug>     // qWarning
#include <QMetaType>  // For QVariant to std::any conversion types
#include <QVariant>   // QVariantList, QueryValue can hold QVariant types
#include <algorithm>  // For std::transform in driver name to upper

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/i_sql_driver.h"  // ISqlDriver for hasFeature
#include "cpporm_sqldriver/sql_enums.h"     // Feature::LastInsertId, Feature::InsertAndReturnId
#include "cpporm_sqldriver/sql_query.h"     // SqlQuery
#include "cpporm_sqldriver/sql_value.h"     // SqlValue

namespace cpporm {

    // Session 的 IQueryExecutor::CreateImpl 实现 (单个模型创建)
    // 返回 std::expected<SqlValue, Error>
    std::expected<cpporm_sqldriver::SqlValue, Error> Session::CreateImpl(const QueryBuilder &qb, ModelBase &model_instance, const OnConflictClause *conflict_options_override) {
        const OnConflictClause *active_conflict_clause = conflict_options_override;
        if (!active_conflict_clause && qb.getOnConflictClause()) {
            active_conflict_clause = qb.getOnConflictClause();
        }
        if (!active_conflict_clause && temp_on_conflict_clause_) {  // Check session's temp clause
            active_conflict_clause = temp_on_conflict_clause_.get();
        }

        bool clear_temp_on_conflict_at_end = (active_conflict_clause == temp_on_conflict_clause_.get() && !conflict_options_override && !qb.getOnConflictClause());

        const ModelMeta *meta_ptr = qb.getModelMeta();
        if (!meta_ptr) {  // If QB doesn't have meta, get from model
            meta_ptr = &(model_instance._getOwnModelMeta());
        }
        if (!meta_ptr || meta_ptr->table_name.empty()) {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CreateImpl: ModelMeta is not valid or table name is empty."));
        }
        const ModelMeta &meta = *meta_ptr;

        Error hook_err = model_instance.beforeCreate(*this);
        if (hook_err) {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(hook_err);
        }

        this->autoSetTimestamps(model_instance, meta, true);
        // extractModelData 返回 SessionModelDataForWrite，其字段值类型已更新为 SqlValue
        internal::SessionModelDataForWrite data_to_write = this->extractModelData(model_instance, meta, false, true);

        if (data_to_write.fields_to_write.empty() && !data_to_write.has_auto_increment_pk) {
            // 检查是否为纯自增主键模型（例如只有一个自增ID字段）
            bool is_simple_auto_inc_model = data_to_write.has_auto_increment_pk && meta.fields.size() == 1 && meta.getPrimaryField() && has_flag(meta.getPrimaryField()->flags, FieldFlag::AutoIncrement);
            if (!is_simple_auto_inc_model) {
                if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
                return std::unexpected(Error(ErrorCode::MappingError,
                                             "No fields to insert for Create operation "
                                             "and not a simple auto-increment model. Table: " +
                                                 meta.table_name));
            }
        }

        std::vector<std::string> field_names_std_vec;
        std::vector<cpporm_sqldriver::SqlValue> values_to_bind_sqlvalue;
        std::vector<std::string> placeholders_std_vec;
        std::vector<std::string> ordered_db_field_names_vec;

        std::string driverNameStdUpper;
        if (db_handle_.driver()) {
            std::string drv_name_full = db_handle_.driverName();
            std::transform(drv_name_full.begin(), drv_name_full.end(), std::back_inserter(driverNameStdUpper), [](unsigned char c) {
                return std::toupper(c);
            });
        }

        for (const auto &[db_name_std, sql_val] : data_to_write.fields_to_write) {
            ordered_db_field_names_vec.push_back(db_name_std);
            field_names_std_vec.push_back(QueryBuilder::quoteSqlIdentifier(db_name_std));
            values_to_bind_sqlvalue.push_back(sql_val);

            bool placeholder_handled = false;
            if (driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) {
                const FieldMeta *fm = meta.findFieldByDbName(db_name_std);
                if (fm && (fm->db_type_hint == "POINT" || fm->db_type_hint == "GEOMETRY" || fm->db_type_hint == "LINESTRING" || fm->db_type_hint == "POLYGON" || fm->db_type_hint == "MULTIPOINT" || fm->db_type_hint == "MULTILINESTRING" || fm->db_type_hint == "MULTIPOLYGON" ||
                           fm->db_type_hint == "GEOMETRYCOLLECTION")) {
                    placeholders_std_vec.push_back("ST_GeomFromText(?)");
                    placeholder_handled = true;
                }
            }
            // Add similar for PG (ST_GeomFromEWKT) or SQLite (GeomFromText) if needed
            if (!placeholder_handled) {
                placeholders_std_vec.push_back("?");
            }
        }

        std::string sql_verb = "INSERT";
        if (active_conflict_clause && active_conflict_clause->action == OnConflictClause::Action::DoNothing) {
            if (driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) {
                sql_verb = "INSERT IGNORE";
            } else if (driverNameStdUpper.find("SQLITE") != std::string::npos) {
                // SQLite can use ON CONFLICT DO NOTHING suffix, or INSERT OR IGNORE verb.
                // If buildInsertSQLSuffix handles "ON CONFLICT DO NOTHING" for SQLite, keep INSERT.
                // If we prefer "INSERT OR IGNORE", change sql_verb here and ensure suffix is not added.
                // For now, assume suffix is preferred if available, so sql_verb remains INSERT.
                // If suffix builder returns empty for SQLite DO NOTHING, then change verb:
                // sql_verb = "INSERT OR IGNORE";
            }
        }

        std::string sql_query_base_std;
        std::ostringstream sql_builder_stream;

        if (!field_names_std_vec.empty()) {
            sql_builder_stream << sql_verb << " INTO " << QueryBuilder::quoteSqlIdentifier(meta.table_name) << " (";
            for (size_t i = 0; i < field_names_std_vec.size(); ++i) {
                sql_builder_stream << field_names_std_vec[i] << (i < field_names_std_vec.size() - 1 ? ", " : "");
            }
            sql_builder_stream << ") VALUES (";
            for (size_t i = 0; i < placeholders_std_vec.size(); ++i) {
                sql_builder_stream << placeholders_std_vec[i] << (i < placeholders_std_vec.size() - 1 ? ", " : "");
            }
            sql_builder_stream << ")";
            sql_query_base_std = sql_builder_stream.str();

        } else if (data_to_write.has_auto_increment_pk) {                // Only auto-inc PK, no other fields
            if (driverNameStdUpper.find("PSQL") != std::string::npos) {  // PostgreSQL
                sql_query_base_std = "INSERT INTO " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " DEFAULT VALUES";
            } else {  // MySQL, SQLite, etc.
                sql_query_base_std = sql_verb + " INTO " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " () VALUES ()";
            }
            values_to_bind_sqlvalue.clear();  // No values to bind in this specific case
        } else {
            if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();
            return std::unexpected(Error(ErrorCode::MappingError, "Cannot construct INSERT: no fields and no auto-inc PK. Table: " + meta.table_name));
        }

        QString sql_on_conflict_suffix_qstr;
        QVariantList suffix_qbindings;

        if (active_conflict_clause) {
            // If sql_verb was changed to INSERT IGNORE/OR IGNORE, we might not want a suffix.
            bool skip_suffix_due_to_verb = (sql_verb != "INSERT" && active_conflict_clause->action == OnConflictClause::Action::DoNothing);
            if (!skip_suffix_due_to_verb) {
                QueryBuilder temp_qb_for_suffix(nullptr, this->connection_name_, &meta);
                temp_qb_for_suffix.getState_().on_conflict_clause_ = std::make_unique<OnConflictClause>(*active_conflict_clause);
                auto suffix_pair = temp_qb_for_suffix.buildInsertSQLSuffix(ordered_db_field_names_vec);
                sql_on_conflict_suffix_qstr = suffix_pair.first;
                suffix_qbindings = suffix_pair.second;
            }
        }

        std::string final_sql_query_std = sql_query_base_std;
        if (!sql_on_conflict_suffix_qstr.isEmpty()) {
            final_sql_query_std += " " + sql_on_conflict_suffix_qstr.toStdString();
        }

        std::vector<cpporm_sqldriver::SqlValue> all_bindings_sqlvalue = values_to_bind_sqlvalue;
        for (const QVariant &qv_suffix_bind : suffix_qbindings) {
            all_bindings_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv_suffix_bind)));
        }

        bool driver_can_return_last_id = db_handle_.hasFeature(cpporm_sqldriver::Feature::LastInsertId);
        bool use_returning_clause_feature = db_handle_.hasFeature(cpporm_sqldriver::Feature::InsertAndReturnId);

        bool use_returning_for_this_op = false;
        if (use_returning_clause_feature && data_to_write.has_auto_increment_pk && !data_to_write.auto_increment_pk_name_db.empty() && (!active_conflict_clause || active_conflict_clause->action != OnConflictClause::Action::DoNothing)) {
            // PostgreSQL and SQLite (>=3.35) support RETURNING
            if (driverNameStdUpper.find("PSQL") != std::string::npos || driverNameStdUpper.find("SQLITE") != std::string::npos) {
                use_returning_for_this_op = true;
            }
        }

        if (use_returning_for_this_op) {
            final_sql_query_std += " RETURNING " + QueryBuilder::quoteSqlIdentifier(data_to_write.auto_increment_pk_name_db);
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, final_sql_query_std, all_bindings_sqlvalue);

        if (clear_temp_on_conflict_at_end) this->clearTempOnConflictClause();

        if (exec_err) return std::unexpected(exec_err);

        long long rows_affected = sql_query_obj.numRowsAffected();
        model_instance._is_persisted = (rows_affected > 0 || (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing && rows_affected >= 0));

        cpporm_sqldriver::SqlValue returned_id_sv;

        bool was_pure_insert_action = (sql_verb == "INSERT" && !active_conflict_clause);  // True insert without conflict clause
        bool was_insert_ignore_action = (sql_verb == "INSERT IGNORE" || sql_verb == "INSERT OR IGNORE");
        bool was_upsert_action = (active_conflict_clause && active_conflict_clause->action != OnConflictClause::Action::DoNothing);

        if (use_returning_for_this_op && (was_pure_insert_action || was_upsert_action) && rows_affected > 0) {
            if (sql_query_obj.next()) returned_id_sv = sql_query_obj.value(0);
        } else if (data_to_write.has_auto_increment_pk && driver_can_return_last_id && (was_pure_insert_action || was_insert_ignore_action) && rows_affected == 1) {
            returned_id_sv = sql_query_obj.lastInsertId();
        } else if (data_to_write.has_auto_increment_pk && driver_can_return_last_id && was_upsert_action && rows_affected > 0) {
            // MySQL ON DUPLICATE KEY UPDATE: rows_affected=1 for INSERT, 2 for UPDATE. lastInsertId() is new ID for INSERT.
            if ((driverNameStdUpper.find("MYSQL") != std::string::npos || driverNameStdUpper.find("MARIADB") != std::string::npos) && rows_affected == 1) {
                returned_id_sv = sql_query_obj.lastInsertId();
            }
            // SQLite ON CONFLICT DO UPDATE: lastInsertId() is rowid of updated/inserted row.
            else if (driverNameStdUpper.find("SQLITE") != std::string::npos) {
                returned_id_sv = sql_query_obj.lastInsertId();
            }
        }

        if (returned_id_sv.isValid() && !returned_id_sv.isNull() && data_to_write.has_auto_increment_pk) {
            std::any pk_val_any;
            bool conversion_ok = false;
            const auto &pk_type = data_to_write.pk_cpp_type_for_autoincrement;
            const std::string &pk_cpp_name = data_to_write.pk_cpp_name_for_autoincrement;

            // Convert SqlValue to std::any. mapRowToModel has similar logic.
            if (pk_type == typeid(int))
                pk_val_any = returned_id_sv.toInt32(&conversion_ok);
            else if (pk_type == typeid(long long))
                pk_val_any = returned_id_sv.toInt64(&conversion_ok);
            else if (pk_type == typeid(unsigned int))
                pk_val_any = returned_id_sv.toUInt32(&conversion_ok);
            else if (pk_type == typeid(unsigned long long))
                pk_val_any = returned_id_sv.toUInt64(&conversion_ok);
            else if (pk_type == typeid(std::string))
                pk_val_any = returned_id_sv.toString(&conversion_ok);
            // Add other types if PK can be them (e.g. UUID as string)
            else {
                qWarning() << "CreateImpl: PK backfill for type " << pk_type.name() << " is not directly supported. Attempting string conversion.";
                pk_val_any = returned_id_sv.toString(&conversion_ok);
            }

            if (conversion_ok) {
                Error set_pk_err = model_instance.setFieldValue(pk_cpp_name, pk_val_any);
                if (set_pk_err) qWarning() << "CreateImpl: Error setting auto-incremented PK '" << QString::fromStdString(pk_cpp_name) << "': " << QString::fromStdString(set_pk_err.toString());
            } else {
                std::string sv_str_val = returned_id_sv.toString();
                qWarning() << "CreateImpl: Conversion failed for PK backfill. DB val (SqlValue):" << QString::fromStdString(sv_str_val) << " (type: " << returned_id_sv.typeName() << ") to C++ type " << pk_type.name();
            }
        }

        if (model_instance._is_persisted) {  // Only call afterCreate if model is actually persisted
            hook_err = model_instance.afterCreate(*this);
            if (hook_err) return std::unexpected(hook_err);
        }

        if (returned_id_sv.isValid() && !returned_id_sv.isNull()) return returned_id_sv;
        return cpporm_sqldriver::SqlValue(static_cast<int64_t>(rows_affected));
    }

    std::expected<cpporm_sqldriver::SqlValue, Error> Session::Create(ModelBase &model, const OnConflictClause *conflict_options_override) {
        QueryBuilder qb = this->Model(&model);
        return this->CreateImpl(qb, model, conflict_options_override);
    }

}  // namespace cpporm#include <QDateTime>  // For soft delete timestamp
#include <QDebug>     // qWarning, qInfo
#include <QVariant>   // QVariantList from QueryBuilder
#include <algorithm>  // std::min, std::transform

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_query.h"  // SqlQuery
#include "cpporm_sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::DeleteImpl(const QueryBuilder &qb_const) {
        QueryBuilder qb = qb_const;  // Work with a copy

        const ModelMeta *meta = qb.getModelMeta();

        if (meta && qb.isSoftDeleteScopeActive()) {
            bool can_soft_delete_this_target = false;
            if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
                const std::string &from_name = std::get<std::string>(qb.getFromClauseSource());
                if ((!from_name.empty() && from_name == meta->table_name) || (from_name.empty() && !meta->table_name.empty())) {
                    can_soft_delete_this_target = true;
                }
            }

            if (can_soft_delete_this_target) {
                if (const FieldMeta *deletedAtField = meta->findFieldWithFlag(FieldFlag::DeletedAt)) {
                    if (deletedAtField->cpp_type == typeid(QDateTime)) {  // Assuming QDateTime for DeletedAt
                        std::map<std::string, QueryValue> updates_for_soft_delete;
                        updates_for_soft_delete[deletedAtField->db_name] = QDateTime::currentDateTimeUtc();

                        // Also update 'updated_at' if it exists
                        if (const FieldMeta *updatedAtField = meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
                            if (updatedAtField->cpp_type == typeid(QDateTime)) {
                                updates_for_soft_delete[updatedAtField->db_name] = QDateTime::currentDateTimeUtc();
                            } else {
                                qWarning("Session::DeleteImpl (Soft Delete): Model %s has UpdatedAt field (%s) but it's not QDateTime. It won't be auto-updated during soft delete.", meta->table_name.c_str(), updatedAtField->db_name.c_str());
                            }
                        }
                        // Create a new QueryBuilder for the UPDATE operation, ensuring soft delete scope is off.
                        QueryBuilder update_qb_for_soft_delete = qb;  // Copy original conditions
                        update_qb_for_soft_delete.Unscoped();         // Disable soft delete for the UPDATE itself
                        return this->UpdatesImpl(update_qb_for_soft_delete, updates_for_soft_delete);
                    } else {
                        qWarning("Session::DeleteImpl: Model %s has DeletedAt field (%s) but it's not QDateTime. Soft delete skipped. Hard delete will proceed.", meta->table_name.c_str(), deletedAtField->db_name.c_str());
                    }
                }
            }
        }

        // Proceed with hard delete
        auto [sql_qstr, params_qvariantlist] = qb.buildDeleteSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for hard Delete operation."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) return std::unexpected(exec_err);

        return sql_query_obj.numRowsAffected();
    }

    std::expected<long long, Error> Session::Delete(QueryBuilder qb) {
        if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
            qWarning(
                "Session::Delete(QueryBuilder): QueryBuilder was associated with "
                "a different executor. The operation will use THIS session's context "
                "by calling its DeleteImpl. Ensure this is intended.");
        }
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::Delete(const ModelBase &model_condition) {
        const ModelMeta &meta = model_condition._getOwnModelMeta();
        QueryBuilder qb = this->Model(meta);

        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "Delete by model_condition: No PK defined for model " + meta.table_name));
        }

        std::map<std::string, QueryValue> pk_conditions;
        for (const auto &pk_name : meta.primary_keys_db_names) {
            const FieldMeta *fm = meta.findFieldByDbName(pk_name);
            if (!fm) return std::unexpected(Error(ErrorCode::InternalError, "PK field meta not found for DB name '" + pk_name + "' in Delete by model_condition for table " + meta.table_name));
            std::any val = model_condition.getFieldValue(fm->cpp_name);
            if (!val.has_value()) return std::unexpected(Error(ErrorCode::MappingError, "PK value for '" + fm->cpp_name + "' not set in model_condition for Delete on table " + meta.table_name));

            QueryValue qv_pk = Session::anyToQueryValueForSessionConvenience(val);
            if (std::holds_alternative<std::nullptr_t>(qv_pk) && val.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Delete by model_condition: Unsupported PK type (" + std::string(val.type().name()) + ") for field " + fm->cpp_name));
            }
            pk_conditions[pk_name] = qv_pk;
        }

        if (pk_conditions.empty() || pk_conditions.size() != meta.primary_keys_db_names.size()) return std::unexpected(Error(ErrorCode::MappingError, "Could not extract all PKs for Delete by model_condition on table " + meta.table_name));

        qb.Where(pk_conditions);
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::Delete(const ModelMeta &meta, const std::map<std::string, QueryValue> &conditions) {
        QueryBuilder qb = this->Model(meta);
        if (!conditions.empty()) {
            qb.Where(conditions);
        }  // If conditions are empty, buildDeleteSQL will warn about missing WHERE if applicable
        return this->DeleteImpl(qb);
    }

    std::expected<long long, Error> Session::DeleteBatch(const ModelMeta &meta, const std::vector<std::map<std::string, QueryValue>> &primary_keys_list, size_t batch_delete_size_hint) {
        if (primary_keys_list.empty()) {
            return 0LL;
        }
        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "DeleteBatch: ModelMeta does not have a valid table name."));
        }
        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "DeleteBatch: Model " + meta.table_name + " has no primary keys defined."));
        }

        long long total_rows_affected_accumulator = 0;
        Error first_error_encountered = make_ok();
        bool an_error_occurred_in_any_batch = false;

        size_t actual_batch_size = batch_delete_size_hint > 0 ? batch_delete_size_hint : 100;  // Default to 100 if 0
        if (primary_keys_list.empty())
            actual_batch_size = 0;  // No batches if list is empty
        else if (actual_batch_size == 0)
            actual_batch_size = 1;  // Ensure at least 1 if list not empty and hint was 0

        if (actual_batch_size > 500) actual_batch_size = 500;  // Cap batch size for safety

        for (size_t i = 0; i < primary_keys_list.size(); i += actual_batch_size) {
            QueryBuilder qb_for_this_batch(this, this->connection_name_, &meta);

            size_t current_batch_end_idx = std::min(i + actual_batch_size, primary_keys_list.size());
            if (current_batch_end_idx <= i) continue;  // Should not happen with proper loop

            if (meta.primary_keys_db_names.size() == 1) {  // Single PK
                const std::string &pk_col_db_name = meta.primary_keys_db_names[0];
                std::vector<QueryValue> pk_values_for_in_clause;
                pk_values_for_in_clause.reserve(current_batch_end_idx - i);

                for (size_t k = i; k < current_batch_end_idx; ++k) {
                    const auto &pk_map_for_item = primary_keys_list[k];
                    auto it = pk_map_for_item.find(pk_col_db_name);
                    if (it != pk_map_for_item.end()) {
                        pk_values_for_in_clause.push_back(it->second);
                    } else {
                        qWarning("DeleteBatch: PK '%s' not found in map for item at index %zu. Skipping this item.", pk_col_db_name.c_str(), k);
                    }
                }
                if (!pk_values_for_in_clause.empty()) {
                    qb_for_this_batch.In(pk_col_db_name, pk_values_for_in_clause);
                } else {
                    continue;  // No valid PKs in this sub-batch
                }
            } else {  // Composite PKs
                std::vector<std::string> or_conditions_str_parts;
                std::vector<QueryValue> all_composite_pk_bindings;
                or_conditions_str_parts.reserve(current_batch_end_idx - i);

                for (size_t k = i; k < current_batch_end_idx; ++k) {
                    std::string current_item_pk_condition_group_str = "(";
                    bool first_col_in_group = true;
                    bool current_item_pk_group_valid = true;
                    std::vector<QueryValue> bindings_for_current_item_group;
                    bindings_for_current_item_group.reserve(meta.primary_keys_db_names.size());

                    for (const std::string &pk_col_db_name_part : meta.primary_keys_db_names) {
                        const auto &pk_map_for_item = primary_keys_list[k];
                        auto it = pk_map_for_item.find(pk_col_db_name_part);
                        if (it == pk_map_for_item.end()) {
                            qWarning("DeleteBatch: Composite PK part '%s' not found for item at index %zu. Skipping this item.", pk_col_db_name_part.c_str(), k);
                            current_item_pk_group_valid = false;
                            break;
                        }
                        if (!first_col_in_group) {
                            current_item_pk_condition_group_str += " AND ";
                        }
                        current_item_pk_condition_group_str += QueryBuilder::quoteSqlIdentifier(pk_col_db_name_part) + " = ?";
                        bindings_for_current_item_group.push_back(it->second);
                        first_col_in_group = false;
                    }
                    current_item_pk_condition_group_str += ")";

                    if (current_item_pk_group_valid && !bindings_for_current_item_group.empty()) {
                        or_conditions_str_parts.push_back(current_item_pk_condition_group_str);
                        all_composite_pk_bindings.insert(all_composite_pk_bindings.end(), std::make_move_iterator(bindings_for_current_item_group.begin()), std::make_move_iterator(bindings_for_current_item_group.end()));
                    }
                }
                if (!or_conditions_str_parts.empty()) {
                    std::string final_or_where_clause_str;
                    for (size_t o_idx = 0; o_idx < or_conditions_str_parts.size(); ++o_idx) {
                        final_or_where_clause_str += or_conditions_str_parts[o_idx];
                        if (o_idx < or_conditions_str_parts.size() - 1) {
                            final_or_where_clause_str += " OR ";
                        }
                    }
                    qb_for_this_batch.Where(final_or_where_clause_str, all_composite_pk_bindings);
                } else {
                    continue;  // No valid composite PKs in this sub-batch
                }
            }

            auto batch_delete_result = this->DeleteImpl(qb_for_this_batch);

            if (batch_delete_result.has_value()) {
                total_rows_affected_accumulator += batch_delete_result.value();
            } else {
                if (!an_error_occurred_in_any_batch) {
                    first_error_encountered = batch_delete_result.error();
                }
                an_error_occurred_in_any_batch = true;  // Mark that an error occurred
                qWarning("DeleteBatch: Error in sub-batch for table %s. Error: %s", meta.table_name.c_str(), batch_delete_result.error().toString().c_str());
                // Optionally break or continue processing other batches
            }
        }

        if (an_error_occurred_in_any_batch) return std::unexpected(first_error_encountered);
        return total_rows_affected_accumulator;
    }

}  // namespace cpporm#include <QDebug>  // qWarning

#include "cpporm/model_base.h"                    // FriendAccess 可能需要 ModelBase/ModelMeta
#include "cpporm/session.h"                       // 主头文件
#include "cpporm/session_priv_batch_helpers.h"    // For FriendAccess definition & internal::SessionModelDataForWrite
#include "cpporm_sqldriver/sql_database.h"        // For SqlDatabase
#include "cpporm_sqldriver/sql_driver_manager.h"  // For SqlDriverManager::database()
#include "cpporm_sqldriver/sql_enums.h"           // For Feature::Transactions
#include "cpporm_sqldriver/sql_error.h"           // For SqlError (used by execute_query_internal)
#include "cpporm_sqldriver/sql_query.h"           // For SqlQuery (used by execute_query_internal)

namespace cpporm {

    // --- Session 构造函数、析构函数、移动操作 ---

    // 构造函数使用 std::string 连接名
    Session::Session(const std::string &connection_name)
        : connection_name_(connection_name),
          // 从 SqlDriverManager 获取数据库实例
          db_handle_(cpporm_sqldriver::SqlDriverManager::database(connection_name_, false /*don't auto-open*/)),
          is_explicit_transaction_handle_(false),
          temp_on_conflict_clause_(nullptr) {
        if (!db_handle_.isValid()) {
            // SqlDatabase::lastError() 会提供更多信息
            cpporm_sqldriver::SqlError err = db_handle_.lastError();
            qWarning() << "cpporm Session: Constructed with invalid SqlDatabase for "
                          "connection name:"
                       << QString::fromStdString(connection_name_) << ". Last DB error: " << QString::fromStdString(err.text());
        }
    }

    // 构造函数接受一个 SqlDatabase 右值引用 (通常用于事务)
    Session::Session(cpporm_sqldriver::SqlDatabase &&db_handle_rval)
        : connection_name_(db_handle_rval.connectionName()),  // 从传入的句柄获取连接名
          db_handle_(std::move(db_handle_rval)),              // 移动构造
          is_explicit_transaction_handle_(true),              // 假定传入的句柄是用于事务的
          temp_on_conflict_clause_(nullptr) {
        if (!db_handle_.isValid()) {
            qWarning() << "cpporm Session: Constructed with an invalid SqlDatabase "
                          "handle (rvalue) for connection:"
                       << QString::fromStdString(connection_name_);
        }
    }

    Session::~Session() {
        if (is_explicit_transaction_handle_ && db_handle_.isValid() && db_handle_.isOpen() && db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            // 检查事务是否仍然活跃，如果是则回滚
            if (db_handle_.isTransactionActive()) {  // isTransactionActive 是 SqlDatabase 的方法
                qWarning() << "cpporm Session: Destructor called for an active "
                              "transaction on connection"
                           << QString::fromStdString(connection_name_) << ". Rolling back automatically.";
                db_handle_.rollback();
            }
        }
    }

    Session::Session(Session &&other) noexcept
        : connection_name_(std::move(other.connection_name_)),
          db_handle_(std::move(other.db_handle_)),  // SqlDatabase 支持移动
          is_explicit_transaction_handle_(other.is_explicit_transaction_handle_),
          temp_on_conflict_clause_(std::move(other.temp_on_conflict_clause_)) {
        other.is_explicit_transaction_handle_ = false;
        // other.db_handle_ 在移动后处于有效但未指定的状态，不需要额外操作
    }

    Session &Session::operator=(Session &&other) noexcept {
        if (this != &other) {
            // 先处理当前对象的事务状态
            if (is_explicit_transaction_handle_ && db_handle_.isValid() && db_handle_.isOpen() && db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
                if (db_handle_.isTransactionActive()) {
                    db_handle_.rollback();
                }
            }
            connection_name_ = std::move(other.connection_name_);
            db_handle_ = std::move(other.db_handle_);  // SqlDatabase 支持移动赋值
            is_explicit_transaction_handle_ = other.is_explicit_transaction_handle_;
            temp_on_conflict_clause_ = std::move(other.temp_on_conflict_clause_);
            other.is_explicit_transaction_handle_ = false;
        }
        return *this;
    }

    // --- Accessors implementation ---
    // 返回 const std::string&
    const std::string &Session::getConnectionName() const {
        return connection_name_;
    }

    // 返回 cpporm_sqldriver::SqlDatabase&
    cpporm_sqldriver::SqlDatabase &Session::getDbHandle() {
        return db_handle_;
    }
    const OnConflictClause *Session::getTempOnConflictClause() const {
        return temp_on_conflict_clause_.get();
    }
    void Session::clearTempOnConflictClause() {
        temp_on_conflict_clause_.reset();
    }

    // --- internal_batch_helpers::FriendAccess implementations ---
    // 这些方法使得 internal_batch_helpers 命名空间中的函数能够访问 Session 的私有成员。

    cpporm::internal::SessionModelDataForWrite internal_batch_helpers::FriendAccess::callExtractModelData(Session &s, const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null) {
        return s.extractModelData(model_instance, meta, for_update, include_timestamps_even_if_null);
    }

    std::pair<cpporm_sqldriver::SqlQuery, Error> internal_batch_helpers::FriendAccess::callExecuteQueryInternal(cpporm_sqldriver::SqlDatabase &db_ref, const std::string &sql,
                                                                                                                const std::vector<cpporm_sqldriver::SqlValue> &params) {  // <--- 修正了这里的参数名
        // Session::execute_query_internal 是 Session 的私有静态成员，FriendAccess 提供对其的调用
        return Session::execute_query_internal(db_ref, sql, params);
    }

    void internal_batch_helpers::FriendAccess::callAutoSetTimestamps(Session &s, ModelBase &model_instance, const ModelMeta &meta, bool is_create_op) {
        s.autoSetTimestamps(model_instance, meta, is_create_op);
    }

}  // namespace cpporm#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QDebug>
#include <QMetaType>

#include "cpporm/model_base.h"
#include "cpporm/session.h"
// #include <QSqlRecord> // No longer using QSqlRecord
#include <QTime>
#include <QVariant>  // Still used for std::any <-> QueryValue <-> SqlValue intermediate if needed

#include "cpporm_sqldriver/sql_field.h"   // SqlField (from SqlRecord)
#include "cpporm_sqldriver/sql_query.h"   // SqlQuery
#include "cpporm_sqldriver/sql_record.h"  // SqlRecord (from SqlQuery)
#include "cpporm_sqldriver/sql_value.h"   // SqlValue

namespace cpporm {

    Error Session::mapRowToModel(cpporm_sqldriver::SqlQuery &query, ModelBase &model, const ModelMeta &meta) {
        cpporm_sqldriver::SqlRecord record_meta = query.recordMetadata();  // Get metadata once
        if (record_meta.isEmpty()) {
            qWarning() << "cpporm Session::mapRowToModel: Query returned no record metadata for table " << QString::fromStdString(meta.table_name);
            return Error(ErrorCode::MappingError, "Query returned no record metadata.");
        }

        for (int i = 0; i < record_meta.count(); ++i) {
            cpporm_sqldriver::SqlField col_meta_field = record_meta.field(i);  // SqlRecord::field()
            std::string db_col_name_std = col_meta_field.name();

            const FieldMeta *model_field_meta = meta.findFieldByDbName(db_col_name_std);

            if (!model_field_meta) {
                continue;  // Column from DB not mapped in model
            }
            if (has_flag(model_field_meta->flags, FieldFlag::Association)) {
                continue;  // Skip association placeholder fields
            }

            cpporm_sqldriver::SqlValue sql_val = query.value(i);  // SqlQuery::value()
            std::any cpp_value;
            bool conversion_ok = false;

            if (sql_val.isNull()) {
                conversion_ok = true;  // std::any will be empty, representing NULL
            } else {
                // Convert SqlValue to std::any. This requires knowing the target C++ type.
                // SqlValue has toType() methods. We'll use those.
                // This is similar to qvariantToAny but starts from SqlValue.
                const std::type_index &target_cpp_type = model_field_meta->cpp_type;

                if (target_cpp_type == typeid(int)) {
                    cpp_value = sql_val.toInt32(&conversion_ok);
                } else if (target_cpp_type == typeid(long long)) {
                    cpp_value = sql_val.toInt64(&conversion_ok);
                } else if (target_cpp_type == typeid(unsigned int)) {
                    cpp_value = sql_val.toUInt32(&conversion_ok);
                } else if (target_cpp_type == typeid(unsigned long long)) {
                    cpp_value = sql_val.toUInt64(&conversion_ok);
                } else if (target_cpp_type == typeid(double)) {
                    cpp_value = sql_val.toDouble(&conversion_ok);
                } else if (target_cpp_type == typeid(float)) {
                    cpp_value = sql_val.toFloat(&conversion_ok);
                } else if (target_cpp_type == typeid(bool)) {
                    cpp_value = sql_val.toBool(&conversion_ok);
                } else if (target_cpp_type == typeid(std::string)) {
                    cpp_value = sql_val.toString(&conversion_ok);
                } else if (target_cpp_type == typeid(QDateTime)) {
                    cpp_value = sql_val.toDateTime(&conversion_ok);
                } else if (target_cpp_type == typeid(QDate)) {
                    cpp_value = sql_val.toDate(&conversion_ok);
                } else if (target_cpp_type == typeid(QTime)) {
                    cpp_value = sql_val.toTime(&conversion_ok);
                } else if (target_cpp_type == typeid(QByteArray)) {
                    cpp_value = sql_val.toByteArray(&conversion_ok);
                } else {
                    qWarning() << "cpporm Session::mapRowToModel: Unsupported C++ type for field" << QString::fromStdString(model_field_meta->cpp_name) << "Type:" << model_field_meta->cpp_type.name();
                    continue;
                }
            }

            if (!conversion_ok) {
                std::string sv_str = sql_val.isNull() ? "NULL" : sql_val.toString();
                qWarning() << "cpporm Session::mapRowToModel: SqlValue to C++ type conversion failed for field" << QString::fromStdString(model_field_meta->cpp_name) << ". DB value (as string):" << QString::fromStdString(sv_str) << "(SqlValue type:" << sql_val.typeName()
                           << ", Target C++ type:" << model_field_meta->cpp_type.name() << ")";
                // Set to empty std::any to indicate failed conversion for a non-null value
                Error set_err = model.setFieldValue(model_field_meta->cpp_name, std::any{});
                if (set_err) { /* Log or handle */
                }
                continue;
            }

            Error set_err = model.setFieldValue(model_field_meta->cpp_name, cpp_value);
            if (set_err) {
                qWarning() << "cpporm Session::mapRowToModel: Error setting field" << QString::fromStdString(model_field_meta->cpp_name) << "after conversion:" << set_err.toString().c_str();
            }
        }
        model._is_persisted = true;  // Mark model as persisted after successful mapping
        return make_ok();
    }

    cpporm::internal::SessionModelDataForWrite Session::extractModelData(const ModelBase &model_instance, const ModelMeta &meta, bool for_update, bool include_timestamps_even_if_null) {
        cpporm::internal::SessionModelDataForWrite data;  // Holds SqlValue now

        for (const auto &field_meta : meta.fields) {
            if (has_flag(field_meta.flags, FieldFlag::Association)) {
                continue;
            }

            bool is_pk = has_flag(field_meta.flags, FieldFlag::PrimaryKey);
            bool is_auto_inc = has_flag(field_meta.flags, FieldFlag::AutoIncrement);

            std::any val_any = model_instance.getFieldValue(field_meta.cpp_name);
            cpporm_sqldriver::SqlValue sql_val_to_write;

            if (!val_any.has_value()) {
                sql_val_to_write = cpporm_sqldriver::SqlValue();  // Null SqlValue
            } else {
                // Convert std::any to SqlValue using its type
                const auto &type = val_any.type();
                if (type == typeid(int))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<int32_t>(std::any_cast<int>(val_any)));
                else if (type == typeid(long long))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<int64_t>(std::any_cast<long long>(val_any)));
                else if (type == typeid(unsigned int))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<uint32_t>(std::any_cast<unsigned int>(val_any)));
                else if (type == typeid(unsigned long long))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(static_cast<uint64_t>(std::any_cast<unsigned long long>(val_any)));
                else if (type == typeid(double))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<double>(val_any));
                else if (type == typeid(float))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<float>(val_any));
                else if (type == typeid(bool))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<bool>(val_any));
                else if (type == typeid(std::string))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<std::string>(val_any));
                else if (type == typeid(QDateTime))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QDateTime>(val_any));
                else if (type == typeid(QDate))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QDate>(val_any));
                else if (type == typeid(QTime))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QTime>(val_any));
                else if (type == typeid(QByteArray))
                    sql_val_to_write = cpporm_sqldriver::SqlValue(std::any_cast<QByteArray>(val_any));
                else {
                    qWarning() << "cpporm Session::extractModelData: Unsupported C++ type " << QString::fromLocal8Bit(type.name()) << " in model field " << QString::fromStdString(field_meta.cpp_name) << "for SqlValue conversion.";
                    continue;  // Skip this field
                }
            }

            if (is_pk) {
                if (sql_val_to_write.isValid() && !sql_val_to_write.isNull()) {
                    // primary_key_fields map uses std::string as key
                    data.primary_key_fields[field_meta.db_name] = sql_val_to_write;
                }
                if (is_auto_inc) {
                    data.has_auto_increment_pk = true;
                    // auto_increment_pk_name_db is std::string
                    data.auto_increment_pk_name_db = field_meta.db_name;
                    data.pk_cpp_name_for_autoincrement = field_meta.cpp_name;
                    data.pk_cpp_type_for_autoincrement = field_meta.cpp_type;
                }
            }

            if (for_update) {  // Update operation
                if (is_pk || has_flag(field_meta.flags, FieldFlag::CreatedAt)) {
                    continue;  // Skip PKs and CreatedAt for updates
                }
                // For UpdatedAt, include it if it's non-null OR if include_timestamps_even_if_null is true
                if (has_flag(field_meta.flags, FieldFlag::UpdatedAt) && !include_timestamps_even_if_null && sql_val_to_write.isNull()) {
                    continue;
                }
            } else {  // Create operation
                if (is_auto_inc && is_pk) {
                    continue;  // Skip auto-increment PK for creates (DB handles it)
                }
                // For CreatedAt/UpdatedAt on create, include if non-null OR if include_timestamps_even_if_null
                if ((has_flag(field_meta.flags, FieldFlag::CreatedAt) || has_flag(field_meta.flags, FieldFlag::UpdatedAt)) && !include_timestamps_even_if_null && sql_val_to_write.isNull()) {
                    continue;
                }
            }
            // fields_to_write map uses std::string as key
            data.fields_to_write[field_meta.db_name] = sql_val_to_write;
        }
        return data;
    }

    void Session::autoSetTimestamps(ModelBase &model_instance, const ModelMeta &meta, bool is_create_op) {
        // QDateTime is still used as the C++ type for timestamps
        QDateTime current_ts = QDateTime::currentDateTimeUtc();

        if (is_create_op) {
            if (const FieldMeta *created_at_field = meta.findFieldWithFlag(FieldFlag::CreatedAt)) {
                if (created_at_field->cpp_type == typeid(QDateTime)) {
                    std::any current_val = model_instance.getFieldValue(created_at_field->cpp_name);
                    // Set if current value is not set (empty any) or if it's an invalid QDateTime
                    if (!current_val.has_value() || (current_val.type() == typeid(QDateTime) && !std::any_cast<QDateTime>(current_val).isValid())) {
                        model_instance.setFieldValue(created_at_field->cpp_name, current_ts);
                    }
                }
            }
        }

        if (const FieldMeta *updated_at_field = meta.findFieldWithFlag(FieldFlag::UpdatedAt)) {
            if (updated_at_field->cpp_type == typeid(QDateTime)) {
                model_instance.setFieldValue(updated_at_field->cpp_name, current_ts);
            }
        }
    }

}  // namespace cpporm// Base/CppOrm/Source/session_migrate_column_ops.cpp
#include <QDebug>
#include <algorithm>

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_field.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_record.h"

namespace cpporm {
    namespace internal {

        std::string normalizeDbType(const std::string &db_type_raw, const QString &driverNameUpper);

        std::map<std::string, DbColumnInfo> getTableColumnsInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper) {
            std::map<std::string, DbColumnInfo> columns;
            cpporm_sqldriver::SqlQuery query(session.getDbHandle());
            std::string sql_std;
            std::string tableNameStd = tableNameQString.toStdString();

            if (driverNameUpper == "QSQLITE") {
                sql_std = "PRAGMA table_xinfo(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";
                if (!query.exec(sql_std)) {
                    sql_std = "PRAGMA table_info(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";
                    if (!query.exec(sql_std)) {
                        qWarning() << "getTableColumnsInfo (SQLite): Failed to query PRAGMA "
                                      "table_info/table_xinfo for table"
                                   << tableNameQString << ":" << QString::fromStdString(query.lastError().text());
                        return columns;
                    }
                }
            } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                sql_std = "SHOW FULL COLUMNS FROM " + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ";";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableColumnsInfo (MySQL): Failed to query SHOW FULL "
                                  "COLUMNS for table"
                               << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return columns;
                }
            } else if (driverNameUpper == "QPSQL") {
                sql_std =
                    "SELECT column_name, data_type, udt_name, is_nullable, "
                    "column_default, "
                    "character_maximum_length, numeric_precision, numeric_scale, "
                    "collation_name "
                    "FROM information_schema.columns WHERE table_schema = "
                    "current_schema() AND table_name = '" +
                    tableNameStd + "';";  // Table name is string literal here
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableColumnsInfo (PostgreSQL): Failed to query "
                                  "information_schema.columns for table"
                               << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return columns;
                }
            } else {
                qWarning() << "getTableColumnsInfo: Unsupported driver for detailed column info:" << driverNameUpper;
                return columns;
            }

            cpporm_sqldriver::SqlRecord rec_meta = query.recordMetadata();
            while (query.next()) {
                DbColumnInfo colInfo;
                if (driverNameUpper == "QSQLITE") {
                    colInfo.name = query.value(rec_meta.indexOf("name")).toString().toStdString();
                    colInfo.type = query.value(rec_meta.indexOf("type")).toString().toStdString();
                    colInfo.is_nullable = !query.value(rec_meta.indexOf("notnull")).toBool();
                    cpporm_sqldriver::SqlValue dflt_val_sv = query.value(rec_meta.indexOf("dflt_value"));
                    colInfo.default_value = dflt_val_sv.isNull() ? "" : dflt_val_sv.toString().toStdString();
                    colInfo.column_key = query.value(rec_meta.indexOf("pk")).toInt32() > 0 ? "PRI" : "";
                } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                    colInfo.name = query.value(rec_meta.indexOf("Field")).toString().toStdString();
                    colInfo.type = query.value(rec_meta.indexOf("Type")).toString().toStdString();
                    colInfo.is_nullable = (query.value(rec_meta.indexOf("Null")).toString().toUpper() == "YES");  // QString::toUpper()
                    cpporm_sqldriver::SqlValue defVal_sv = query.value(rec_meta.indexOf("Default"));
                    colInfo.default_value = defVal_sv.isNull() ? "" : defVal_sv.toString().toStdString();
                    colInfo.collation_name = query.value(rec_meta.indexOf("Collation")).toString().toStdString();
                    colInfo.column_key = query.value(rec_meta.indexOf("Key")).toString().toStdString();
                    colInfo.extra = query.value(rec_meta.indexOf("Extra")).toString().toStdString();
                } else if (driverNameUpper == "QPSQL") {
                    colInfo.name = query.value(rec_meta.indexOf("column_name")).toString().toStdString();
                    std::string pg_udt_name = query.value(rec_meta.indexOf("udt_name")).toString().toStdString();
                    std::string pg_data_type = query.value(rec_meta.indexOf("data_type")).toString().toStdString();

                    if (pg_data_type.rfind("ARRAY", 0) == 0) {
                        colInfo.type = pg_udt_name;
                        if (colInfo.type.rfind('_', 0) == 0) colInfo.type.erase(0, 1);
                        colInfo.type += "[]";
                    } else if (pg_udt_name.empty() || pg_udt_name == "anyelement" || pg_udt_name == "anyarray") {
                        colInfo.type = pg_data_type;
                    } else {
                        colInfo.type = pg_udt_name;
                    }
                    colInfo.is_nullable = (query.value(rec_meta.indexOf("is_nullable")).toString().toUpper() == "YES");  // QString::toUpper()
                    colInfo.default_value = query.value(rec_meta.indexOf("column_default")).toString().toStdString();
                    colInfo.collation_name = query.value(rec_meta.indexOf("collation_name")).toString().toStdString();
                }
                if (!colInfo.name.empty()) {
                    colInfo.normalized_type = normalizeDbType(colInfo.type, driverNameUpper);
                    columns[colInfo.name] = colInfo;
                }
            }
            return columns;
        }

        Error migrateModifyColumns(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            qInfo() << "migrateModifyColumns: Checking columns for table '" << QString::fromStdString(meta.table_name) << "'...";
            std::map<std::string, DbColumnInfo> existing_db_columns = getTableColumnsInfo(session, QString::fromStdString(meta.table_name), driverNameUpper);

            for (const auto &model_field : meta.fields) {
                if (has_flag(model_field.flags, FieldFlag::Association) || model_field.db_name.empty()) {
                    continue;
                }

                std::string model_sql_type_str = Session::getSqlTypeForCppType(model_field, driverNameUpper);
                std::string model_normalized_sql_type = normalizeDbType(model_sql_type_str, driverNameUpper);

                auto it_db_col = existing_db_columns.find(model_field.db_name);
                if (it_db_col == existing_db_columns.end()) {
                    qInfo() << "migrateModifyColumns: Column '" << QString::fromStdString(model_field.db_name) << "' not found in table '" << QString::fromStdString(meta.table_name) << "'. Attempting to ADD.";

                    std::string add_col_sql_str = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " ADD COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " + model_sql_type_str;

                    if (has_flag(model_field.flags, FieldFlag::NotNull)) add_col_sql_str += " NOT NULL";
                    if (has_flag(model_field.flags, FieldFlag::Unique) && !has_flag(model_field.flags, FieldFlag::PrimaryKey)) {
                        add_col_sql_str += " UNIQUE";
                    }
                    add_col_sql_str += ";";

                    qInfo() << "migrateModifyColumns (ADD DDL): " << QString::fromStdString(add_col_sql_str);
                    auto [_, add_err] = execute_ddl_query(session.getDbHandle(), add_col_sql_str);
                    if (add_err) {
                        qWarning() << "migrateModifyColumns: Failed to ADD column '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(add_err.toString());
                    }

                } else {
                    DbColumnInfo &db_col = it_db_col->second;
                    bool needs_alter = false;

                    if (model_normalized_sql_type != db_col.normalized_type) {
                        needs_alter = true;
                        if (driverNameUpper == "QSQLITE" && ((model_normalized_sql_type == "text" && db_col.normalized_type == "varchar") || (model_normalized_sql_type == "varchar" && db_col.normalized_type == "text"))) {
                            needs_alter = false;
                        } else if ((model_normalized_sql_type == "int" && db_col.normalized_type == "bigint") || (model_normalized_sql_type == "smallint" && (db_col.normalized_type == "int" || db_col.normalized_type == "bigint"))) {
                            qInfo() << "migrateModifyColumns: Model requests narrowing integer conversion for column '" << QString::fromStdString(model_field.db_name) << "' from DB type '" << QString::fromStdString(db_col.type) << "' to model type '" << QString::fromStdString(model_sql_type_str)
                                    << "'. Skipping automatic type alteration.";
                            needs_alter = false;
                        }
                    }

                    if (needs_alter) {
                        qInfo() << "migrateModifyColumns: Type mismatch or desired change for column '" << QString::fromStdString(model_field.db_name) << "'. DB type: '" << QString::fromStdString(db_col.type) << "' (norm: " << QString::fromStdString(db_col.normalized_type) << "), Model type: '"
                                << QString::fromStdString(model_sql_type_str) << "' (norm: " << QString::fromStdString(model_normalized_sql_type) << "). Attempting to MODIFY.";

                        std::string alter_col_sql_str = "ALTER TABLE " + QueryBuilder::quoteSqlIdentifier(meta.table_name);
                        if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                            alter_col_sql_str += " MODIFY COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " " + model_sql_type_str;
                            if (has_flag(model_field.flags, FieldFlag::NotNull))
                                alter_col_sql_str += " NOT NULL";
                            else
                                alter_col_sql_str += " NULL";
                        } else if (driverNameUpper == "QPSQL") {
                            alter_col_sql_str += " ALTER COLUMN " + QueryBuilder::quoteSqlIdentifier(model_field.db_name) + " TYPE " + model_sql_type_str;
                        } else if (driverNameUpper == "QSQLITE") {
                            qWarning() << "migrateModifyColumns: SQLite has very limited ALTER TABLE support for modifying column types. Type change for '" << QString::fromStdString(model_field.db_name) << "' skipped.";
                            continue;
                        } else {
                            qWarning() << "migrateModifyColumns: Don't know how to alter column type for driver " << driverNameUpper << ". Column '" << QString::fromStdString(model_field.db_name) << "' type alteration skipped.";
                            continue;
                        }
                        alter_col_sql_str += ";";

                        qInfo() << "migrateModifyColumns (MODIFY DDL): " << QString::fromStdString(alter_col_sql_str);
                        auto [_, alter_err] = execute_ddl_query(session.getDbHandle(), alter_col_sql_str);
                        if (alter_err) {
                            qWarning() << "migrateModifyColumns: Failed to MODIFY column '" << QString::fromStdString(model_field.db_name) << "': " << QString::fromStdString(alter_err.toString());
                        }
                    }
                }
            }
            return make_ok();
        }

        // Definition of normalizeDbType from before
        std::string normalizeDbType(const std::string &db_type_raw, const QString &driverNameUpper) {
            std::string lower_type = db_type_raw;
            std::transform(lower_type.begin(), lower_type.end(), lower_type.begin(), [](unsigned char c) {
                return std::tolower(c);
            });

            if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                if (lower_type.rfind("int", 0) == 0 && lower_type.find("unsigned") == std::string::npos && lower_type != "tinyint(1)") return "int";
                if (lower_type.rfind("int unsigned", 0) == 0) return "int unsigned";
                if (lower_type.rfind("bigint", 0) == 0 && lower_type.find("unsigned") == std::string::npos) return "bigint";
                if (lower_type.rfind("bigint unsigned", 0) == 0) return "bigint unsigned";
                if (lower_type == "tinyint(1)") return "boolean";
                if (lower_type.rfind("varchar", 0) == 0) return "varchar";
                if (lower_type.rfind("char", 0) == 0 && lower_type.find("varchar") == std::string::npos) return "char";
                if (lower_type == "text" || lower_type == "tinytext" || lower_type == "mediumtext" || lower_type == "longtext") return "text";
                if (lower_type == "datetime") return "datetime";
                if (lower_type == "timestamp") return "timestamp";
                if (lower_type == "date") return "date";
                if (lower_type == "time") return "time";
                if (lower_type == "float") return "float";
                if (lower_type == "double" || lower_type == "real") return "double";
                if (lower_type.rfind("decimal", 0) == 0 || lower_type.rfind("numeric", 0) == 0) return "decimal";
                if (lower_type == "blob" || lower_type == "tinyblob" || lower_type == "mediumblob" || lower_type == "longblob" || lower_type == "varbinary" || lower_type == "binary") return "blob";
            } else if (driverNameUpper == "QPSQL") {
                if (lower_type == "integer" || lower_type == "int4") return "int";
                if (lower_type == "bigint" || lower_type == "int8") return "bigint";
                if (lower_type == "smallint" || lower_type == "int2") return "smallint";
                if (lower_type == "boolean" || lower_type == "bool") return "boolean";
                if (lower_type.rfind("character varying", 0) == 0) return "varchar";
                if ((lower_type.rfind("character(", 0) == 0 || lower_type.rfind("char(", 0) == 0) && lower_type.find("varying") == std::string::npos) return "char";
                if (lower_type == "text") return "text";
                if (lower_type == "timestamp without time zone" || lower_type == "timestamp") return "timestamp";
                if (lower_type == "timestamp with time zone") return "timestamptz";
                if (lower_type == "date") return "date";
                if (lower_type == "time without time zone" || lower_type == "time") return "time";
                if (lower_type == "time with time zone") return "timetz";
                if (lower_type == "real" || lower_type == "float4") return "float";
                if (lower_type == "double precision" || lower_type == "float8") return "double";
                if (lower_type == "numeric" || lower_type == "decimal") return "decimal";
                if (lower_type == "bytea") return "blob";
            } else if (driverNameUpper == "QSQLITE") {
                if (lower_type.find("int") != std::string::npos) return "int";
                if (lower_type == "text" || lower_type.find("char") != std::string::npos || lower_type.find("clob") != std::string::npos) return "text";
                if (lower_type == "blob" || lower_type.empty()) return "blob";
                if (lower_type == "real" || lower_type.find("floa") != std::string::npos || lower_type.find("doub") != std::string::npos) return "double";
                if (lower_type == "numeric" || lower_type.find("deci") != std::string::npos || lower_type.find("bool") != std::string::npos || lower_type.find("date") != std::string::npos || lower_type.find("datetime") != std::string::npos) return "numeric";
            }
            return lower_type;
        }

    }  // namespace internal
}  // namespace cpporm// Base/CppOrm/Source/session_migrate_index_ops.cpp
#include <QDebug>
#include <QRegularExpression>
#include <algorithm>
#include <set>

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_field.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_record.h"

namespace cpporm {
    namespace internal {

        bool areIndexDefinitionsEquivalent(const DbIndexInfo &db_idx, const IndexDefinition &model_idx_def, const QString &driverNameUpper);

        std::map<std::string, DbIndexInfo> getTableIndexesInfo(Session &session, const QString &tableNameQString, const QString &driverNameUpper) {
            std::map<std::string, DbIndexInfo> indexes;
            cpporm_sqldriver::SqlQuery query(session.getDbHandle());
            std::string sql_std;
            std::string tableNameStd = tableNameQString.toStdString();

            if (driverNameUpper == "QSQLITE") {
                sql_std = "PRAGMA index_list(" + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ");";  // Quote table name
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (SQLite): Failed to get index list for" << tableNameQString << ":" << QString::fromStdString(query.lastError().text());
                    return indexes;
                }
                std::vector<DbIndexInfo> temp_index_list_sqlite;
                cpporm_sqldriver::SqlRecord rec_meta_idxlist = query.recordMetadata();
                while (query.next()) {
                    DbIndexInfo idx_base_info;
                    idx_base_info.index_name = query.value(rec_meta_idxlist.indexOf("name")).toString().toStdString();
                    idx_base_info.is_unique = query.value(rec_meta_idxlist.indexOf("unique")).toInt32() == 1;
                    QString origin = query.value(rec_meta_idxlist.indexOf("origin")).toString();
                    if (QString::fromStdString(idx_base_info.index_name).startsWith("sqlite_autoindex_") || origin == "pk" || origin == "u") {
                        idx_base_info.is_primary_key = (origin == "pk");
                        continue;
                    }
                    temp_index_list_sqlite.push_back(idx_base_info);
                }

                for (DbIndexInfo &idx_info_ref : temp_index_list_sqlite) {
                    std::string idx_info_sql_std = "PRAGMA index_xinfo(" + QueryBuilder::quoteSqlIdentifier(idx_info_ref.index_name) + ");";  // Quote index name
                    if (!query.exec(idx_info_sql_std)) {
                        idx_info_sql_std = "PRAGMA index_info(" + QueryBuilder::quoteSqlIdentifier(idx_info_ref.index_name) + ");";  // Quote index name
                        if (!query.exec(idx_info_sql_std)) {
                            qWarning() << "getTableIndexesInfo (SQLite): Failed to get info for index" << QString::fromStdString(idx_info_ref.index_name) << ":" << QString::fromStdString(query.lastError().text());
                            continue;
                        }
                    }
                    std::vector<std::pair<int, std::string>> col_order_pairs;
                    cpporm_sqldriver::SqlRecord rec_meta_idxinfo = query.recordMetadata();
                    bool use_cid = rec_meta_idxinfo.contains("cid");

                    while (query.next()) {
                        col_order_pairs.push_back({query.value(rec_meta_idxinfo.indexOf(use_cid ? "cid" : "seqno")).toInt32(), query.value(rec_meta_idxinfo.indexOf("name")).toString().toStdString()});
                    }
                    std::sort(col_order_pairs.begin(), col_order_pairs.end());
                    for (const auto &p : col_order_pairs) idx_info_ref.column_names.push_back(p.second);

                    if (!idx_info_ref.column_names.empty()) indexes[idx_info_ref.index_name] = idx_info_ref;
                }

            } else if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                sql_std = "SHOW INDEX FROM " + QueryBuilder::quoteSqlIdentifier(tableNameStd) + ";";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (MySQL): Failed for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text());
                    return indexes;
                }

                std::map<std::string, DbIndexInfo> temp_building_indexes;
                cpporm_sqldriver::SqlRecord rec_meta_mysql = query.recordMetadata();
                while (query.next()) {
                    std::string idx_name_str = query.value(rec_meta_mysql.indexOf("Key_name")).toString().toStdString();
                    DbIndexInfo ¤t_idx_ref = temp_building_indexes[idx_name_str];  // Use reference

                    if (current_idx_ref.index_name.empty()) {
                        current_idx_ref.index_name = idx_name_str;
                        current_idx_ref.is_unique = (query.value(rec_meta_mysql.indexOf("Non_unique")).toInt32() == 0);
                        current_idx_ref.is_primary_key = (idx_name_str == "PRIMARY");
                        current_idx_ref.type_method = query.value(rec_meta_mysql.indexOf("Index_type")).toString().toStdString();
                    }
                    current_idx_ref.column_names.push_back(query.value(rec_meta_mysql.indexOf("Column_name")).toString().toStdString());
                }
                for (const auto &pair_val : temp_building_indexes) {
                    if (pair_val.second.is_primary_key) continue;
                    if (!pair_val.second.column_names.empty()) indexes[pair_val.first] = pair_val.second;
                }

            } else if (driverNameUpper == "QPSQL") {
                sql_std =
                    "SELECT idx.relname AS index_name, att.attname AS column_name, "
                    "i.indisunique AS is_unique, "
                    "       i.indisprimary AS is_primary, am.amname AS index_type, "
                    "       (SELECT pg_get_indexdef(i.indexrelid, k + 1, true) "
                    "FROM generate_subscripts(i.indkey, 1) k WHERE i.indkey[k] = att.attnum) as col_def_in_idx, "
                    "       array_position(i.indkey, att.attnum) as column_seq "
                    "FROM   pg_index i "
                    "JOIN   pg_class tbl ON tbl.oid = i.indrelid "
                    "JOIN   pg_class idx ON idx.oid = i.indexrelid "
                    "JOIN   pg_attribute att ON att.attrelid = tbl.oid AND att.attnum = ANY(i.indkey) "
                    "LEFT JOIN pg_am am ON am.oid = idx.relam "
                    "WHERE  tbl.relname = '" +
                    tableNameStd +
                    "' AND tbl.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = current_schema()) "
                    "ORDER BY index_name, column_seq;";
                if (!query.exec(sql_std)) {
                    qWarning() << "getTableIndexesInfo (PostgreSQL): Failed for table" << tableNameQString << ":" << QString::fromStdString(query.lastError().text()) << "SQL:" << QString::fromStdString(sql_std);
                    return indexes;
                }

                std::map<std::string, DbIndexInfo> temp_building_indexes_pg;
                cpporm_sqldriver::SqlRecord rec_meta_pg = query.recordMetadata();
                while (query.next()) {
                    std::string idx_name_str = query.value(rec_meta_pg.indexOf("index_name")).toString().toStdString();
                    DbIndexInfo ¤t_idx_ref = temp_building_indexes_pg[idx_name_str];  // Use reference

                    if (current_idx_ref.index_name.empty()) {
                        current_idx_ref.index_name = idx_name_str;
                        current_idx_ref.is_unique = query.value(rec_meta_pg.indexOf("is_unique")).toBool();
                        current_idx_ref.is_primary_key = query.value(rec_meta_pg.indexOf("is_primary")).toBool();
                        current_idx_ref.type_method = query.value(rec_meta_pg.indexOf("index_type")).toString().toStdString();
                    }
                    current_idx_ref.column_names.push_back(query.value(rec_meta_pg.indexOf("column_name")).toString().toStdString());
                }
                for (const auto &pair_val : temp_building_indexes_pg) {
                    if (pair_val.second.is_primary_key) continue;
                    if (!pair_val.second.column_names.empty()) indexes[pair_val.first] = pair_val.second;
                }
            } else {
                qWarning() << "getTableIndexesInfo: Unsupported driver for index info:" << driverNameUpper;
            }
            return indexes;
        }

        Error migrateManageIndexes(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            qInfo() << "migrateManageIndexes: Managing indexes for table '" << QString::fromStdString(meta.table_name) << "'...";
            std::map<std::string, DbIndexInfo> existing_db_indexes = getTableIndexesInfo(session, QString::fromStdString(meta.table_name), driverNameUpper);

            std::set<std::string> model_index_names_processed;

            for (const auto &model_idx_def_const : meta.indexes) {
                IndexDefinition model_idx_def = model_idx_def_const;
                if (model_idx_def.db_column_names.empty()) {
                    qWarning() << "migrateManageIndexes: Model index definition for table '" << QString::fromStdString(meta.table_name) << "' (intended name: '" << QString::fromStdString(model_idx_def.index_name) << "') has no columns. Skipping.";
                    continue;
                }

                if (model_idx_def.index_name.empty()) {
                    std::string auto_name_str = (model_idx_def.is_unique ? "uix_" : "idx_") + meta.table_name;
                    for (const auto &col_name_std : model_idx_def.db_column_names) {
                        std::string temp_col_name = col_name_std;
                        std::replace_if(
                            temp_col_name.begin(),
                            temp_col_name.end(),
                            [](char c) {
                                return !std::isalnum(c) && c != '_';
                            },
                            '_');
                        auto_name_str += "_" + temp_col_name;
                    }
                    if (auto_name_str.length() > 60) {
                        QString q_auto_name_str = QString::fromStdString(auto_name_str);
                        QString hash_suffix = QString::number(qHash(q_auto_name_str + QString::number(model_idx_def.is_unique)), 16).left(8);
                        auto_name_str = q_auto_name_str.left(60 - 1 - hash_suffix.length()).toStdString() + "_" + hash_suffix.toStdString();
                    }
                    model_idx_def.index_name = auto_name_str;
                }
                model_index_names_processed.insert(model_idx_def.index_name);

                auto it_db_idx = existing_db_indexes.find(model_idx_def.index_name);
                bool needs_create = true;
                bool needs_drop_first = false;

                if (it_db_idx != existing_db_indexes.end()) {
                    if (it_db_idx->second.is_primary_key) {
                        qInfo() << "migrateManageIndexes: Model index '" << QString::fromStdString(model_idx_def.index_name) << "' matches a DB PRIMARY KEY. Explicit index management skipped.";
                        needs_create = false;
                    } else if (areIndexDefinitionsEquivalent(it_db_idx->second, model_idx_def, driverNameUpper)) {
                        qInfo() << "migrateManageIndexes: Index '" << QString::fromStdString(model_idx_def.index_name) << "' matches existing DB index. No changes.";
                        needs_create = false;
                    } else {
                        qInfo() << "migrateManageIndexes: Index '" << QString::fromStdString(model_idx_def.index_name) << "' exists but definition differs. Will DROP and RECREATE.";
                        needs_drop_first = true;
                        needs_create = true;
                    }
                }

                if (needs_drop_first) {
                    std::string drop_sql_std = "DROP INDEX " + QueryBuilder::quoteSqlIdentifier(model_idx_def.index_name);
                    if (driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") {
                        drop_sql_std += " ON " + QueryBuilder::quoteSqlIdentifier(meta.table_name);
                    }
                    drop_sql_std += ";";
                    qInfo() << "migrateManageIndexes (DROP DDL): " << QString::fromStdString(drop_sql_std);
                    auto [_, drop_err] = execute_ddl_query(session.getDbHandle(), drop_sql_std);
                    if (drop_err) {
                        qWarning() << "migrateManageIndexes: Failed to DROP index '" << QString::fromStdString(model_idx_def.index_name) << "': " << QString::fromStdString(drop_err.toString());
                    }
                }

                if (needs_create) {
                    std::string cols_sql_part;
                    for (size_t i = 0; i < model_idx_def.db_column_names.size(); ++i) {
                        cols_sql_part += QueryBuilder::quoteSqlIdentifier(model_idx_def.db_column_names[i]);
                        if (i < model_idx_def.db_column_names.size() - 1) cols_sql_part += ", ";
                    }

                    std::string create_sql_std = "CREATE " + std::string(model_idx_def.is_unique ? "UNIQUE " : "") + "INDEX ";
                    if (driverNameUpper == "QSQLITE" || driverNameUpper == "QPSQL") {
                        create_sql_std += "IF NOT EXISTS ";
                    }
                    create_sql_std += QueryBuilder::quoteSqlIdentifier(model_idx_def.index_name) + " ON " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " (" + cols_sql_part + ")";

                    if (!model_idx_def.type_str.empty() && (driverNameUpper == "QPSQL" || driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB")) {
                        create_sql_std += " USING " + model_idx_def.type_str;
                    }
                    if (!model_idx_def.condition_str.empty() && driverNameUpper == "QPSQL") {
                        create_sql_std += " WHERE (" + model_idx_def.condition_str + ")";
                    }
                    create_sql_std += ";";

                    qInfo() << "migrateManageIndexes (CREATE DDL): " << QString::fromStdString(create_sql_std);
                    auto [_, create_err] = execute_ddl_query(session.getDbHandle(), create_sql_std);
                    if (create_err) {
                        bool ignorable = false;
                        std::string err_msg_lower = create_err.message;
                        std::transform(err_msg_lower.begin(), err_msg_lower.end(), err_msg_lower.begin(), ::tolower);

                        if (((driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") && create_err.native_db_error_code == 1061 /*ER_DUP_KEYNAME*/) || (driverNameUpper == "QSQLITE" && err_msg_lower.find("already exists") != std::string::npos) ||
                            (driverNameUpper == "QPSQL" && (create_err.sql_state == "42P07" || create_err.sql_state == "42710"))) {
                            ignorable = true;
                        }

                        if (ignorable && !needs_drop_first) {
                            qInfo() << "migrateManageIndexes: Index " << QString::fromStdString(model_idx_def.index_name) << " likely already exists (error caught on create): " << QString::fromStdString(create_err.toString());
                        } else if (!ignorable) {
                            qWarning() << "migrateManageIndexes: Failed to CREATE index '" << QString::fromStdString(model_idx_def.index_name) << "': " << QString::fromStdString(create_err.toString());
                        }
                    }
                }
            }
            return make_ok();
        }

        bool areIndexDefinitionsEquivalent(const DbIndexInfo &db_idx, const IndexDefinition &model_idx_def, const QString &driverNameUpper) {
            (void)driverNameUpper;

            if (db_idx.is_unique != model_idx_def.is_unique) return false;
            if (db_idx.column_names.size() != model_idx_def.db_column_names.size()) return false;

            for (size_t i = 0; i < db_idx.column_names.size(); ++i) {
                std::string db_col_lower = db_idx.column_names[i];
                std::string model_col_lower = model_idx_def.db_column_names[i];
                std::transform(db_col_lower.begin(), db_col_lower.end(), db_col_lower.begin(), ::tolower);
                std::transform(model_col_lower.begin(), model_col_lower.end(), model_col_lower.begin(), ::tolower);
                if (db_col_lower != model_col_lower) return false;
            }

            if (!model_idx_def.type_str.empty() && !db_idx.type_method.empty()) {
                std::string model_type_lower = model_idx_def.type_str;
                std::string db_type_lower = db_idx.type_method;
                std::transform(model_type_lower.begin(), model_type_lower.end(), model_type_lower.begin(), ::tolower);
                std::transform(db_type_lower.begin(), db_type_lower.end(), db_type_lower.begin(), ::tolower);
                if (model_type_lower != db_type_lower) {
                    if (!model_idx_def.type_str.empty()) {
                        return false;
                    }
                }
            }
            return true;
        }

    }  // namespace internal
}  // namespace cpporm// Base/CppOrm/Source/session_migrate_ops.cpp
#include "cpporm/model_base.h"
// #include "cpporm/qt_db_manager.h" // Replaced
#include <QDebug>

#include "cpporm/db_manager.h"  // Use new DbManager
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"
// #include <QSqlDriver> // Replaced by cpporm_sqldriver features
// #include <QSqlError> // Replaced by cpporm_sqldriver::SqlError
// #include <QSqlQuery> // Replaced by cpporm_sqldriver::SqlQuery
// #include <QSqlRecord> // Replaced by cpporm_sqldriver::SqlRecord
#include <algorithm>
#include <set>

// Include cpporm_sqldriver types
#include "cpporm_sqldriver/sql_database.h"

namespace cpporm {

    Error Session::AutoMigrate(const ModelMeta &meta) {
        // db_handle_ is now cpporm_sqldriver::SqlDatabase
        if (!db_handle_.isOpen()) {
            if (!db_handle_.open()) {                                     // SqlDatabase::open()
                cpporm_sqldriver::SqlError err = db_handle_.lastError();  // SqlDatabase::lastError()
                return Error(ErrorCode::ConnectionNotOpen,
                             "Cannot AutoMigrate: Database connection is not open and "
                             "failed to open: " +
                                 err.text());  // SqlError::text()
            }
        }
        if (meta.table_name.empty()) {
            return Error(ErrorCode::InvalidConfiguration, "Cannot AutoMigrate: ModelMeta has no table name.");
        }
        qInfo() << "AutoMigrate: Starting migration for table '" << QString::fromStdString(meta.table_name) << "'...";

        // SqlDatabase::driverName() returns std::string
        QString driverNameUpper = QString::fromStdString(db_handle_.driverName()).toUpper();

        Error table_err = internal::migrateCreateTable(*this, meta, driverNameUpper);
        if (table_err) {
            qWarning() << "AutoMigrate: Failed during table creation for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(table_err.toString());
            return table_err;
        }
        qInfo() << "AutoMigrate: Table creation/check phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        Error column_err = internal::migrateModifyColumns(*this, meta, driverNameUpper);
        if (column_err) {
            qWarning() << "AutoMigrate: Failed during column modification for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(column_err.toString());
            return column_err;
        }
        qInfo() << "AutoMigrate: Column modification phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        Error index_err = internal::migrateManageIndexes(*this, meta, driverNameUpper);
        if (index_err) {
            qWarning() << "AutoMigrate: Failed during index management for '" << QString::fromStdString(meta.table_name) << "': " << QString::fromStdString(index_err.toString());
            return index_err;
        }
        qInfo() << "AutoMigrate: Index management phase completed for '" << QString::fromStdString(meta.table_name) << "'.";

        qInfo() << "AutoMigrate: Migration successfully completed for table '" << QString::fromStdString(meta.table_name) << "'.";
        return make_ok();
    }

    Error Session::AutoMigrate(const std::vector<const ModelMeta *> &metas_vec) {
        for (const auto *m_ptr : metas_vec) {
            if (m_ptr) {
                if (auto e_obj = AutoMigrate(*m_ptr)) {
                    return e_obj;
                }
            } else {
                qWarning() << "AutoMigrate (vector): Encountered a null ModelMeta "
                              "pointer. Skipping.";
            }
        }
        qInfo() << "AutoMigrate: Batch migration completed for" << metas_vec.size() << "models.";
        return make_ok();
    }

}  // namespace cpporm// Base/CppOrm/Source/session_migrate_table_ops.cpp
#include <QDebug>

#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm/session_migrate_priv.h"
// #include <QSqlDriver> // Replaced by cpporm_sqldriver features
// #include <QSqlError> // Replaced by cpporm_sqldriver::SqlError
// #include <QSqlQuery> // Replaced by cpporm_sqldriver::SqlQuery
#include <mutex>

// Include cpporm_sqldriver types needed for execute_ddl_query
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_error.h"
#include "cpporm_sqldriver/sql_query.h"

namespace cpporm {
    namespace internal {

        Error migrateCreateTable(Session &session, const ModelMeta &meta, const QString &driverNameUpper) {
            if (meta.table_name.empty()) {
                return Error(ErrorCode::InvalidConfiguration, "migrateCreateTable: ModelMeta has no table name.");
            }

            std::vector<std::string> column_definitions_sql;
            std::vector<std::string> pk_col_db_names_for_constraint;
            std::vector<std::string> table_constraints_sql;

            for (const auto &field : meta.fields) {
                if (has_flag(field.flags, FieldFlag::Association) || field.db_name.empty()) {
                    continue;
                }

                std::string col_def_str = QueryBuilder::quoteSqlIdentifier(field.db_name);
                col_def_str += " " + Session::getSqlTypeForCppType(field, driverNameUpper);

                if (has_flag(field.flags, FieldFlag::PrimaryKey)) {
                    pk_col_db_names_for_constraint.push_back(field.db_name);
                    if ((driverNameUpper == "QMYSQL" || driverNameUpper == "QMARIADB") && has_flag(field.flags, FieldFlag::AutoIncrement)) {
                        col_def_str += " AUTO_INCREMENT";
                    }
                }
                if (has_flag(field.flags, FieldFlag::NotNull)) {
                    col_def_str += " NOT NULL";
                }
                if (has_flag(field.flags, FieldFlag::Unique) && !has_flag(field.flags, FieldFlag::PrimaryKey)) {
                    col_def_str += " UNIQUE";
                }
                column_definitions_sql.push_back(col_def_str);
            }

            if (!pk_col_db_names_for_constraint.empty()) {
                std::string pk_constraint_str = "PRIMARY KEY (";
                for (size_t i = 0; i < pk_col_db_names_for_constraint.size(); ++i) {
                    pk_constraint_str += QueryBuilder::quoteSqlIdentifier(pk_col_db_names_for_constraint[i]);
                    if (i < pk_col_db_names_for_constraint.size() - 1) pk_constraint_str += ", ";
                }
                pk_constraint_str += ")";
                table_constraints_sql.push_back(pk_constraint_str);
            }

            for (const auto &assoc : meta.associations) {
                if (assoc.type == AssociationType::BelongsTo && !assoc.foreign_key_db_name.empty()) {
                    std::string fk_col_on_curr_table = assoc.foreign_key_db_name;
                    std::string target_table_name_str;
                    std::string target_pk_col_name_str;

                    cpporm::internal::ModelFactory factory_fn;
                    {
                        std::lock_guard<std::mutex> lock(cpporm::internal::getGlobalModelFactoryRegistryMutex());
                        auto it_factory = cpporm::internal::getGlobalModelFactoryRegistry().find(assoc.target_model_type);
                        if (it_factory != cpporm::internal::getGlobalModelFactoryRegistry().end()) {
                            factory_fn = it_factory->second;
                        }
                    }
                    if (factory_fn) {
                        auto temp_target_model = factory_fn();
                        if (temp_target_model) {
                            const ModelMeta &target_meta = temp_target_model->_getOwnModelMeta();
                            target_table_name_str = target_meta.table_name;
                            if (!assoc.target_model_pk_db_name.empty()) {
                                target_pk_col_name_str = assoc.target_model_pk_db_name;
                            } else if (!target_meta.primary_keys_db_names.empty()) {
                                target_pk_col_name_str = target_meta.primary_keys_db_names[0];
                            }
                        }
                    }

                    if (!target_table_name_str.empty() && !target_pk_col_name_str.empty()) {
                        std::string fk_sql = "FOREIGN KEY (" + QueryBuilder::quoteSqlIdentifier(fk_col_on_curr_table) + ")" + " REFERENCES " + QueryBuilder::quoteSqlIdentifier(target_table_name_str) + " (" + QueryBuilder::quoteSqlIdentifier(target_pk_col_name_str) + ")";
                        // Add ON DELETE, ON UPDATE clauses if specified in AssociationMeta
                        // e.g. if (assoc.on_delete_action == "CASCADE") fk_sql += " ON DELETE CASCADE";
                        table_constraints_sql.push_back(fk_sql);
                    } else {
                        qWarning() << "migrateCreateTable (FK): Could not determine target "
                                      "table/PK for BelongsTo association '"
                                   << QString::fromStdString(assoc.cpp_field_name) << "' on table '" << QString::fromStdString(meta.table_name) << "'. FK constraint not created.";
                    }
                }
            }

            std::string all_definitions_sql_str;
            for (size_t i = 0; i < column_definitions_sql.size(); ++i) {
                all_definitions_sql_str += column_definitions_sql[i];
                if (i < column_definitions_sql.size() - 1 || !table_constraints_sql.empty()) {
                    all_definitions_sql_str += ", ";
                }
            }
            for (size_t i = 0; i < table_constraints_sql.size(); ++i) {
                all_definitions_sql_str += table_constraints_sql[i];
                if (i < table_constraints_sql.size() - 1) {
                    all_definitions_sql_str += ", ";
                }
            }

            if (!all_definitions_sql_str.empty()) {
                bool ends_with_comma_space = true;
                while (ends_with_comma_space && !all_definitions_sql_str.empty()) {
                    if (all_definitions_sql_str.back() == ',' || all_definitions_sql_str.back() == ' ') {
                        all_definitions_sql_str.pop_back();
                    } else {
                        ends_with_comma_space = false;
                    }
                }
            }
            if (all_definitions_sql_str.empty()) {
                return Error(ErrorCode::InvalidConfiguration,
                             "migrateCreateTable: No column definitions or constraints "
                             "generated for table '" +
                                 meta.table_name + "'.");
            }

            std::string create_table_ddl_std = "CREATE TABLE IF NOT EXISTS " + QueryBuilder::quoteSqlIdentifier(meta.table_name) + " (" + all_definitions_sql_str + ");";

            qInfo() << "migrateCreateTable (DDL for " << QString::fromStdString(meta.table_name) << "): " << QString::fromStdString(create_table_ddl_std);

            auto [_, err_obj] = execute_ddl_query(session.getDbHandle(), create_table_ddl_std);  // Pass SqlDatabase& and std::string
            return err_obj;
        }

        // Implementation of the modified execute_ddl_query
        std::pair<cpporm_sqldriver::SqlQuery, Error> execute_ddl_query(cpporm_sqldriver::SqlDatabase &db,  // Pass by reference
                                                                       const std::string &ddl_sql_std) {
            if (!db.isOpen()) {
                if (!db.open()) {
                    cpporm_sqldriver::SqlError err = db.lastError();
                    qWarning() << "execute_ddl_query: Failed to open database for DDL:" << QString::fromStdString(err.text()) << "SQL:" << QString::fromStdString(ddl_sql_std);
                    return {cpporm_sqldriver::SqlQuery(db),  // Return an invalid query object associated with db
                            Error(ErrorCode::ConnectionNotOpen, "Failed to open database for DDL: " + err.text(), err.nativeErrorCodeNumeric())};
                }
            }
            // Session::execute_query_internal is static and handles generic query execution
            // It's suitable for DDL too, as DDL statements don't typically have bound parameters.
            return Session::execute_query_internal(db, ddl_sql_std, {});
        }

    }  // namespace internal
}  // namespace cpporm// cpporm/session_migrate_utils.cpp (新文件 - 目前为空或只包含辅助声明)
#include "cpporm/session_migrate_priv.h" // For DbColumnInfo, DbIndexInfo potentially if utils are complex

// This file can contain utility functions shared across migration operations.
// For example:
// - More sophisticated DB type normalization.
// - Helpers to parse specific DB information (e.g., default values, constraints
// from strings).
// - If getSqlTypeForCppType is made a free function, it could live here.

namespace cpporm {
namespace internal {

// Example: If getSqlTypeForCppType were moved here:
/*
std::string getSqlTypeForModelField_utility_moved(const FieldMeta &field_meta,
const QString &driverNameUpper) {
    // ... implementation ...
    if (!field_meta.db_type_hint.empty()) return field_meta.db_type_hint;
    // ... rest of type mapping logic ...
    return "TEXT"; // Fallback
}
*/

// Currently, most logic is within the _column_ops.cpp and _index_ops.cpp.
// If common patterns emerge during their full implementation, they can be
// refactored here.

} // namespace internal
} // namespace cpporm#include <QDebug>     // For qWarning
#include <algorithm>  // For std::transform
#include <any>
#include <map>
#include <memory>
#include <mutex>  // For global registry lock
#include <set>    // Not used in current version of this file
#include <string>
#include <vector>

#include "cpporm/i_query_executor.h"  // Not directly used here, but Session uses it
#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"

// SqlDriver types are not directly used in this file's logic after Session methods are called,
// but Session's FindImpl will use them internally.

namespace cpporm {

    // any_to_string_for_map_key_in_preload_util remains largely the same,
    // as it converts C++ types from model fields to string keys.
    // QVariant types like QDateTime, QDate are still valid C++ field types.
    static std::string any_to_string_for_map_key_in_preload_util(const std::any &val) {
        if (!val.has_value()) return "__cpporm_NULL_KEY__";

        const auto &type = val.type();
        if (type == typeid(int)) return "i_" + std::to_string(std::any_cast<int>(val));
        if (type == typeid(long long)) return "ll_" + std::to_string(std::any_cast<long long>(val));
        if (type == typeid(unsigned int)) return "ui_" + std::to_string(std::any_cast<unsigned int>(val));
        if (type == typeid(unsigned long long)) return "ull_" + std::to_string(std::any_cast<unsigned long long>(val));
        if (type == typeid(std::string)) return "s_" + std::any_cast<std::string>(val);
        if (type == typeid(const char *)) return "s_" + std::string(std::any_cast<const char *>(val));
        if (type == typeid(QDateTime)) return "dt_" + std::any_cast<QDateTime>(val).toUTC().toString(Qt::ISODateWithMs).toStdString();
        if (type == typeid(QDate)) return "d_" + std::any_cast<QDate>(val).toString(Qt::ISODate).toStdString();
        if (type == typeid(bool)) return "b_" + std::string(std::any_cast<bool>(val) ? "true" : "false");
        if (type == typeid(double)) return "dbl_" + std::to_string(std::any_cast<double>(val));
        if (type == typeid(float)) return "flt_" + std::to_string(std::any_cast<float>(val));
        // Add QByteArray if it can be a key
        if (type == typeid(QByteArray)) {  // UUIDs might be QByteArray or string
            // Convert QByteArray to hex string for a stable key
            return "ba_" + std::any_cast<QByteArray>(val).toHex().toStdString();
        }

        qWarning() << "any_to_string_for_map_key_in_preload_util: Unsupported std::any type ('" << val.type().name() << "') for map key generation during preload. ";
        return "__cpporm_UNSUPPORTED_KEY_TYPE_" + std::string(val.type().name()) + "__";
    }

    Error Session::processPreloadsInternal(const QueryBuilder &qb, std::vector<ModelBase *> &parent_models_raw_ptr) {
        const std::vector<PreloadRequest> &preload_requests = qb.getPreloadRequests();
        const ModelMeta *main_model_meta_ptr = qb.getModelMeta();

        if (!main_model_meta_ptr) {
            return Error(ErrorCode::InvalidConfiguration, "processPreloadsInternal: QueryBuilder has no ModelMeta for main model.");
        }
        const ModelMeta &main_model_meta = *main_model_meta_ptr;

        if (preload_requests.empty() || parent_models_raw_ptr.empty()) {
            return make_ok();
        }

        for (const auto &request : preload_requests) {
            std::string association_to_load = request.association_cpp_field_name;
            // Basic nested preload handling (can be expanded)
            // For "Orders.OrderItems", current_association_name becomes "Orders",
            // remaining_preload_path becomes "OrderItems".
            std::string remaining_preload_path;
            size_t dot_pos = association_to_load.find('.');
            if (dot_pos != std::string::npos) {
                remaining_preload_path = association_to_load.substr(dot_pos + 1);
                association_to_load = association_to_load.substr(0, dot_pos);
            }

            const AssociationMeta *assoc_meta = main_model_meta.findAssociationByCppName(association_to_load);
            if (!assoc_meta) {
                qWarning() << "Session::processPreloadsInternal: Association '" << QString::fromStdString(association_to_load) << "' not found in model '" << QString::fromStdString(main_model_meta.table_name) << "' for preloading.";
                continue;
            }

            Error err = executePreloadForAssociation(*assoc_meta, main_model_meta, parent_models_raw_ptr, remaining_preload_path);
            if (err) {
                qWarning() << "Session::processPreloadsInternal: Error preloading association '" << QString::fromStdString(association_to_load) << "': " << QString::fromStdString(err.toString());
                return err;  // Stop on first error for now
            }
        }
        return make_ok();
    }

    Error Session::processPreloads(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &loaded_models_unique_ptr) {
        if (loaded_models_unique_ptr.empty() || qb.getPreloadRequests().empty()) {
            return make_ok();
        }
        std::vector<ModelBase *> raw_ptr_vec;
        raw_ptr_vec.reserve(loaded_models_unique_ptr.size());
        for (const auto &u_ptr : loaded_models_unique_ptr) {
            if (u_ptr) {
                raw_ptr_vec.push_back(u_ptr.get());
            }
        }
        if (raw_ptr_vec.empty()) {  // All unique_ptrs were null
            return make_ok();
        }
        return processPreloadsInternal(qb, raw_ptr_vec);
    }

    // Added remaining_nested_preload_path parameter
    Error Session::executePreloadForAssociation(const AssociationMeta &assoc_meta, const ModelMeta &parent_model_meta, std::vector<ModelBase *> &parent_models_raw_ptr,
                                                const std::string &remaining_nested_preload_path) {  // New parameter

        if (parent_models_raw_ptr.empty()) {
            return make_ok();
        }

        cpporm::internal::ModelFactory target_model_factory_fn;
        {
            std::lock_guard<std::mutex> lock(internal::getGlobalModelFactoryRegistryMutex());
            auto it_factory = internal::getGlobalModelFactoryRegistry().find(assoc_meta.target_model_type);
            if (it_factory == internal::getGlobalModelFactoryRegistry().end()) {
                return Error(ErrorCode::InternalError, "Preload Error: Target model factory not found for type_index: " + std::string(assoc_meta.target_model_type.name()) + " for association '" + assoc_meta.cpp_field_name + "'.");
            }
            target_model_factory_fn = it_factory->second;
        }

        std::unique_ptr<ModelBase> temp_target_instance_uptr = target_model_factory_fn();
        if (!temp_target_instance_uptr) {
            return Error(ErrorCode::InternalError, "Preload Error: Target model factory failed to create instance for type: " + std::string(assoc_meta.target_model_type.name()) + " for association '" + assoc_meta.cpp_field_name + "'.");
        }
        const ModelMeta &target_model_meta = temp_target_instance_uptr->_getOwnModelMeta();
        if (target_model_meta.table_name.empty()) {
            return Error(ErrorCode::InvalidConfiguration, "Preload Error: Target model '" + std::string(assoc_meta.target_model_type.name()) + "' has an empty table name in its metadata.");
        }

        std::string parent_model_key_cpp_name;  // C++ name on parent model of the key used for joining
        std::string target_model_key_db_name;   // DB name on target model of the key used for joining

        if (assoc_meta.type == AssociationType::HasMany || assoc_meta.type == AssociationType::HasOne) {
            const FieldMeta *pk_field_on_parent = nullptr;
            if (!assoc_meta.primary_key_db_name_on_current_model.empty()) {
                pk_field_on_parent = parent_model_meta.findFieldByDbName(assoc_meta.primary_key_db_name_on_current_model);
            } else if (!parent_model_meta.primary_keys_db_names.empty()) {
                pk_field_on_parent = parent_model_meta.findFieldByDbName(parent_model_meta.primary_keys_db_names[0]);  // Default to first PK
            } else {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Parent model '" + parent_model_meta.table_name + "' has no primary keys defined for association '" + assoc_meta.cpp_field_name + "'.");
            }
            if (!pk_field_on_parent) {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Parent reference key DB name could not be resolved on parent model '" + parent_model_meta.table_name + "' for association '" + assoc_meta.cpp_field_name + "'.");
            }
            parent_model_key_cpp_name = pk_field_on_parent->cpp_name;
            target_model_key_db_name = assoc_meta.foreign_key_db_name;  // This is the FK on the target model referencing parent's PK
            if (target_model_key_db_name.empty()) {
                return Error(ErrorCode::MappingError, "Preload Error (HasMany/HasOne): Foreign key on target model not specified for association '" + assoc_meta.cpp_field_name + "'.");
            }
        } else if (assoc_meta.type == AssociationType::BelongsTo) {
            const FieldMeta *fk_field_on_parent = parent_model_meta.findFieldByDbName(assoc_meta.foreign_key_db_name);  // FK on current (parent) model
            if (!fk_field_on_parent) {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Foreign key DB name '" + assoc_meta.foreign_key_db_name + "' not found on parent model '" + parent_model_meta.table_name + "' for association '" + assoc_meta.cpp_field_name + "'.");
            }
            parent_model_key_cpp_name = fk_field_on_parent->cpp_name;  // This is the FK field on the parent
            if (!assoc_meta.target_model_pk_db_name.empty()) {         // PK on target model that FK on parent references
                target_model_key_db_name = assoc_meta.target_model_pk_db_name;
            } else if (!target_model_meta.primary_keys_db_names.empty()) {
                target_model_key_db_name = target_model_meta.primary_keys_db_names[0];  // Default to first PK of target
            } else {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Target model '" + target_model_meta.table_name + "' has no primary keys defined for association '" + assoc_meta.cpp_field_name + "'.");
            }
            if (target_model_key_db_name.empty()) {
                return Error(ErrorCode::MappingError, "Preload Error (BelongsTo): Referenced key on target model not specified or determinable for association '" + assoc_meta.cpp_field_name + "'.");
            }
        } else if (assoc_meta.type == AssociationType::ManyToMany) {
            return Error(ErrorCode::UnsupportedFeature, "Preload Error: ManyToMany preloading for association '" + assoc_meta.cpp_field_name + "' is not yet implemented.");
        } else {
            return Error(ErrorCode::InternalError, "Preload Error: Unknown association type for '" + assoc_meta.cpp_field_name + "'.");
        }

        if (parent_model_key_cpp_name.empty() || target_model_key_db_name.empty()) {
            return Error(ErrorCode::MappingError, "Preload Error: Could not determine one or both join key names for association '" + assoc_meta.cpp_field_name + "'. ParentKeyCppName: '" + parent_model_key_cpp_name + "', TargetKeyDbName: '" + target_model_key_db_name + "'.");
        }

        std::vector<QueryValue> parent_key_values_for_in_clause;
        parent_key_values_for_in_clause.reserve(parent_models_raw_ptr.size());
        for (const auto parent_model_ptr : parent_models_raw_ptr) {
            if (parent_model_ptr) {
                std::any key_any = parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
                if (key_any.has_value()) {
                    QueryValue qv = Session::anyToQueryValueForSessionConvenience(key_any);
                    if (std::holds_alternative<std::nullptr_t>(qv) && key_any.has_value()) { /* Warning logged by anyToQV */
                        continue;
                    }
                    if (!std::holds_alternative<std::nullptr_t>(qv)) {  // Don't add actual nulls to IN clause
                        parent_key_values_for_in_clause.push_back(qv);
                    }
                }
            }
        }

        if (parent_key_values_for_in_clause.empty()) {  // No valid keys from parents to query for
            // Still need to set empty associations on parents
            for (auto parent_model_ptr : parent_models_raw_ptr) {
                if (!parent_model_ptr) continue;
                if (assoc_meta.type == AssociationType::HasMany && assoc_meta.data_setter_vector) {
                    std::vector<std::shared_ptr<ModelBase>> empty_vec;
                    assoc_meta.data_setter_vector(parent_model_ptr, empty_vec);
                } else if ((assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) && assoc_meta.data_setter_single) {
                    assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                }
            }
            return make_ok();
        }

        QueryBuilder qb_preload(this, this->connection_name_, &target_model_meta);
        // Add nested preloads to this QueryBuilder if remaining_nested_preload_path is not empty
        if (!remaining_nested_preload_path.empty()) {
            qb_preload.Preload(remaining_nested_preload_path);
        }

        std::string quoted_target_key_db_name = QueryBuilder::quoteSqlIdentifier(target_model_key_db_name);
        qb_preload.In(quoted_target_key_db_name, parent_key_values_for_in_clause);  // Use QueryBuilder::In

        std::vector<std::unique_ptr<ModelBase>> associated_results_unique_ptr_vec;
        // FindImpl will internally call processPreloads if qb_preload has preload requests.
        Error find_err = this->FindImpl(qb_preload, associated_results_unique_ptr_vec, target_model_factory_fn);

        if (find_err) {
            return Error(find_err.code, "Preload Error: Failed to fetch associated models for '" + assoc_meta.cpp_field_name + "' from table '" + target_model_meta.table_name + "': " + find_err.message);
        }

        const FieldMeta *target_model_key_field_meta = target_model_meta.findFieldByDbName(target_model_key_db_name);
        if (!target_model_key_field_meta) {
            return Error(ErrorCode::MappingError, "Preload Error: Target model's join key C++ field meta not found for DB name: '" + target_model_key_db_name + "' on table '" + target_model_meta.table_name + "'. Cannot map results.");
        }

        std::map<std::string, std::vector<std::shared_ptr<ModelBase>>> map_associated_by_their_link_key_value;
        for (auto &assoc_model_uptr : associated_results_unique_ptr_vec) {  // Iterate over unique_ptr
            if (assoc_model_uptr) {
                std::any link_key_val_any = assoc_model_uptr->getFieldValue(target_model_key_field_meta->cpp_name);
                std::string link_key_val_str_key = any_to_string_for_map_key_in_preload_util(link_key_val_any);

                if (link_key_val_str_key.rfind("__cpporm_UNSUPPORTED_KEY_TYPE_", 0) == 0 || link_key_val_str_key == "__cpporm_NULL_KEY__") {
                    qWarning() << "Preload Warning: Could not get or convert foreign key value to string for mapping associated model for " << QString::fromStdString(assoc_meta.cpp_field_name) << ". Skipping this associated model.";
                    continue;
                }
                // Move unique_ptr to shared_ptr for storage in map (or if setter expects shared_ptr)
                map_associated_by_their_link_key_value[link_key_val_str_key].push_back(std::move(assoc_model_uptr));
            }
        }
        associated_results_unique_ptr_vec.clear();  // All valid unique_ptrs are moved

        for (auto parent_model_ptr : parent_models_raw_ptr) {
            if (!parent_model_ptr) continue;
            std::any parent_key_val_any = parent_model_ptr->getFieldValue(parent_model_key_cpp_name);
            std::string parent_key_val_str_key = any_to_string_for_map_key_in_preload_util(parent_key_val_any);

            auto it_found_associated = map_associated_by_their_link_key_value.find(parent_key_val_str_key);

            if (it_found_associated != map_associated_by_their_link_key_value.end()) {
                std::vector<std::shared_ptr<ModelBase>> &associated_for_this_parent_sptrs = it_found_associated->second;
                if (assoc_meta.type == AssociationType::HasMany) {
                    if (assoc_meta.data_setter_vector) {
                        assoc_meta.data_setter_vector(parent_model_ptr, associated_for_this_parent_sptrs);
                    } else { /* qWarning */
                    }
                } else if (assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) {
                    if (assoc_meta.data_setter_single) {
                        if (!associated_for_this_parent_sptrs.empty()) {
                            assoc_meta.data_setter_single(parent_model_ptr, associated_for_this_parent_sptrs.front());
                        } else {
                            assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                        }  // Should not happen if key matched
                    } else { /* qWarning */
                    }
                }
            } else {  // No associated models found for this parent's key
                if (assoc_meta.type == AssociationType::HasMany && assoc_meta.data_setter_vector) {
                    std::vector<std::shared_ptr<ModelBase>> empty_sptr_vec;
                    assoc_meta.data_setter_vector(parent_model_ptr, empty_sptr_vec);
                } else if ((assoc_meta.type == AssociationType::HasOne || assoc_meta.type == AssociationType::BelongsTo) && assoc_meta.data_setter_single) {
                    assoc_meta.data_setter_single(parent_model_ptr, nullptr);
                }
            }
        }
        return make_ok();
    }

}  // namespace cpporm#include <QDebug>        // qWarning
#include <QString>       // For QString in ExecRaw interface
#include <QVariantList>  // For QVariantList in ExecRaw interface

#include "cpporm/error.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_query.h"  // SqlQuery
#include "cpporm_sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    // ExecRaw 保持接收 QString 和 QVariantList 的接口以方便 Qt 用户，内部转换为 SqlDriver 类型。
    std::expected<long long, Error> Session::ExecRaw(const QString &sql_qstr, const QVariantList &args_qvariantlist) {
        std::string sql_std_str = sql_qstr.toStdString();
        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Raw SQL query string is empty."));
        }

        std::vector<cpporm_sqldriver::SqlValue> args_sqlvalue;
        args_sqlvalue.reserve(args_qvariantlist.size());
        for (const QVariant &qv : args_qvariantlist) {
            // QueryBuilder::qvariantToQueryValue 应该是一个公共静态方法
            // Session::queryValueToSqlValue 也是公共静态方法
            args_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, args_sqlvalue);

        if (exec_err) {
            qWarning() << "Session::ExecRaw: Execution failed for SQL:" << sql_qstr << "Args:" << args_qvariantlist << "Error:" << QString::fromStdString(exec_err.toString());
            return std::unexpected(exec_err);
        }

        long long rows_affected = sql_query_obj.numRowsAffected();

        // numRowsAffected() 对于非 DML 语句（如 SELECT）可能返回 -1，这是正常的。
        // 对于 DDL，行为可能因驱动而异。
        // if (rows_affected == -1) {
        //     qInfo() << "Session::ExecRaw: numRowsAffected is -1. SQL: " << sql_qstr
        //             << ". This may be normal for SELECT or DDL statements.";
        // }
        return rows_affected;
    }

}  // namespace cpporm#include <QDebug>     // qWarning, qInfo
#include <QVariant>   // QVariantList for QueryBuilder, and conversion helpers
#include <algorithm>  // For std::transform etc.

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"               // 主头文件
#include "cpporm_sqldriver/sql_query.h"   // SqlQuery
#include "cpporm_sqldriver/sql_record.h"  // SqlRecord
#include "cpporm_sqldriver/sql_value.h"   // SqlValue

namespace cpporm {

    Error Session::FirstImpl(const QueryBuilder &qb, ModelBase &result_model) {
        const ModelMeta *meta = qb.getModelMeta();
        if (!meta) {
            // 如果 QB 没有 meta，尝试从 result_model 获取
            meta = &(result_model._getOwnModelMeta());
            if (!meta || meta->table_name.empty()) {  // 检查从模型获取的 meta 是否有效
                return Error(ErrorCode::InvalidConfiguration, "FirstImpl: Could not determine ModelMeta for query.");
            }
        }

        QueryBuilder local_qb = qb;                                   // 创建副本以修改
        if (local_qb.getModelMeta() == nullptr && meta != nullptr) {  // 如果副本 QB 没有 meta，但我们有，则设置它
            local_qb.Model(*meta);
        }
        local_qb.Limit(1);

        auto [sql_qstr, params_qvariantlist] = local_qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return Error(ErrorCode::StatementPreparationError, "Failed to build SQL for First operation.");
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);

        if (exec_err) {
            return exec_err;
        }

        if (sql_query_obj.next()) {
            Error map_err = mapRowToModel(sql_query_obj, result_model, *meta);
            if (map_err) {
                qWarning() << "cpporm Session::FirstImpl: Error mapping row:" << QString::fromStdString(map_err.toString());
                return map_err;
            }
            // result_model._is_persisted = true; // mapRowToModel 应该设置这个
            Error hook_err = result_model.afterFind(*this);
            if (hook_err) return hook_err;

            if (!qb.getPreloadRequests().empty()) {
                std::vector<ModelBase *> models_for_preload = {&result_model};
                Error preload_err = this->processPreloadsInternal(qb, models_for_preload);
                if (preload_err) {
                    qWarning() << "Session::FirstImpl: Preloading failed after fetching model: " << QString::fromStdString(preload_err.toString());
                    // return preload_err; // Decide if this is fatal
                }
            }
            return make_ok();
        } else {
            return Error(ErrorCode::RecordNotFound, "No record found for First operation.");
        }
    }

    Error Session::FindImpl(const QueryBuilder &qb, std::vector<std::unique_ptr<ModelBase>> &results_vector, std::function<std::unique_ptr<ModelBase>()> element_type_factory) {
        if (!element_type_factory) {
            return Error(ErrorCode::InternalError, "Element type factory function is null for Find operation.");
        }

        const ModelMeta *meta_for_query = qb.getModelMeta();
        QueryBuilder local_qb = qb;  // 创建副本以可能修改

        if (!meta_for_query) {
            auto temp_instance = element_type_factory();
            if (temp_instance && !temp_instance->_getOwnModelMeta().table_name.empty()) {
                meta_for_query = &(temp_instance->_getOwnModelMeta());
                if (local_qb.getModelMeta() == nullptr) {  // 如果副本 QB 没有 meta，则设置它
                    local_qb.Model(*meta_for_query);
                }
            } else {
                return Error(ErrorCode::InvalidConfiguration,
                             "FindImpl: Could not determine ModelMeta for query from "
                             "QueryBuilder or factory.");
            }
        }

        auto [sql_qstr, params_qvariantlist] = local_qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return Error(ErrorCode::StatementPreparationError, "Failed to build SQL for Find operation.");
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) {
            return exec_err;
        }

        results_vector.clear();
        while (sql_query_obj.next()) {
            std::unique_ptr<ModelBase> new_element = element_type_factory();
            if (!new_element) {
                return Error(ErrorCode::InternalError, "Element factory returned nullptr inside Find loop.");
            }
            Error map_err = mapRowToModel(sql_query_obj, *new_element, *meta_for_query);
            if (map_err) {
                qWarning() << "cpporm Session::FindImpl: Error mapping row: " << QString::fromStdString(map_err.toString()) << ". SQL was: " << QString::fromStdString(sql_std_str);
                // return map_err; // 通常不应因单行映射失败而中止整个查找
                continue;  // 跳过此行
            }
            // new_element->_is_persisted = true; // mapRowToModel 应该设置这个
            Error hook_err = new_element->afterFind(*this);
            if (hook_err) {
                qWarning() << "cpporm Session::FindImpl: afterFind hook failed for an element: " << QString::fromStdString(hook_err.toString());
                // return hook_err; // Decide if this is fatal
            }
            results_vector.push_back(std::move(new_element));
        }

        if (!results_vector.empty() && !qb.getPreloadRequests().empty()) {
            Error preload_err = this->processPreloads(qb, results_vector);
            if (preload_err) {
                qWarning() << "cpporm Session::FindImpl: Preloading failed: " << QString::fromStdString(preload_err.toString());
                // return preload_err; // Decide if this is fatal
            }
        }
        return make_ok();
    }

    std::expected<int64_t, Error> Session::CountImpl(const QueryBuilder &qb_const) {
        QueryBuilder qb = qb_const;  // 创建副本
        // 如果 QB 没有 ModelMeta，尝试从一个临时模型实例推断（如果可能，但不直接可行）
        // Count 通常需要知道 FROM 子句。如果 QB 没设置 Model/Table，buildSelectSQL 会失败。
        if (!qb.getModelMeta() && qb.getFromSourceName().isEmpty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "CountImpl: QueryBuilder has no Model or Table set."));
        }

        if (!qb.getGroupClause().empty()) {
            qWarning(
                "cpporm Session::CountImpl: Count() called with existing GROUP "
                "BY clause. Clearing GROUP BY for total count.");
            qb.Group("");
        }
        qb.Select("COUNT(*)");
        qb.Order("");
        qb.Limit(-1);
        qb.Offset(-1);
        if (!qb.getState_().preload_requests_.empty()) {                                    // 直接访问 state_ 来修改
            QueryBuilderState &mutable_state = const_cast<QueryBuilder &>(qb).getState_();  // 需要 const_cast 来修改副本的状态
            mutable_state.preload_requests_.clear();
        }

        auto [sql_qstr, params_qvariantlist] = qb.buildSelectSQL();
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError, "Failed to build SQL for Count operation."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (err) {
            return std::unexpected(err);
        }

        if (sql_query_obj.next()) {
            bool ok_conversion;
            cpporm_sqldriver::SqlValue count_sv = sql_query_obj.value(0);
            int64_t count_val = count_sv.toInt64(&ok_conversion);
            if (ok_conversion) {
                return count_val;
            } else {
                std::string sv_str_val = count_sv.toString();
                return std::unexpected(Error(ErrorCode::MappingError, "Failed to convert COUNT(*) result to integer. Value: " + sv_str_val));
            }
        } else {
            qWarning() << "cpporm Session::CountImpl: COUNT(*) query returned no rows "
                          "(unexpected). SQL:"
                       << QString::fromStdString(sql_std_str);
            return std::unexpected(Error(ErrorCode::QueryExecutionError, "COUNT(*) query returned no rows."));
        }
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant in QueryValue
#include <QDebug>     // qWarning, qInfo
#include <QMetaType>  // For QVariant -> QueryValue helper
#include <QVariant>   // QueryValue helper

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::SaveImpl(const QueryBuilder &qb_param, ModelBase &model_instance) {
        const ModelMeta *meta_from_qb = qb_param.getModelMeta();
        const ModelMeta &meta = meta_from_qb ? *meta_from_qb : model_instance._getOwnModelMeta();

        if (meta.table_name.empty()) {
            return std::unexpected(Error(ErrorCode::InvalidConfiguration, "SaveImpl: ModelMeta does not have a valid table_name."));
        }

        Error hook_err = model_instance.beforeSave(*this);
        if (hook_err) return std::unexpected(hook_err);

        bool has_defined_pk = !meta.primary_keys_db_names.empty();
        bool model_has_all_pks_set_and_non_default = false;
        if (has_defined_pk) {
            model_has_all_pks_set_and_non_default = true;
            for (const auto &pk_db_name : meta.primary_keys_db_names) {
                const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
                if (pk_field) {
                    std::any pk_val_any = model_instance.getFieldValue(pk_field->cpp_name);
                    if (!pk_val_any.has_value()) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    // Check for "zero" or "empty" values more robustly
                    QueryValue pk_qv = Session::anyToQueryValueForSessionConvenience(pk_val_any);
                    if (std::holds_alternative<std::nullptr_t>(pk_qv)) {  // Covers uninitialized or unconvertible types
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<int>(pk_qv) && std::get<int>(pk_qv) == 0) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<long long>(pk_qv) && std::get<long long>(pk_qv) == 0) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    if (std::holds_alternative<std::string>(pk_qv) && std::get<std::string>(pk_qv).empty()) {
                        model_has_all_pks_set_and_non_default = false;
                        break;
                    }
                    // Add checks for other PK types if necessary (e.g., QDate for 0000-00-00)
                } else {
                    model_has_all_pks_set_and_non_default = false;
                    qWarning() << "SaveImpl: PK field meta not found for" << QString::fromStdString(pk_db_name);
                    break;
                }
            }
        }

        bool attempt_update = (model_instance._is_persisted || model_has_all_pks_set_and_non_default) && has_defined_pk;

        if (attempt_update) {
            this->autoSetTimestamps(model_instance, meta, false);                                                         // false for update
            internal::SessionModelDataForWrite data_to_write = this->extractModelData(model_instance, meta, true, true);  // true for update, true for include_timestamps

            if (data_to_write.primary_key_fields.empty() && has_defined_pk) {
                return std::unexpected(Error(ErrorCode::MappingError, "SaveImpl (Update path): Failed to extract valid primary key values for WHERE clause. Table: " + meta.table_name));
            }

            if (data_to_write.fields_to_write.empty()) {
                qInfo("SaveImpl (Update path): No fields (including timestamps) to update for table %s. Skipping DB operation.", meta.table_name.c_str());
                // Still run hooks if appropriate for a "no-op save that was an update attempt"
                hook_err = model_instance.beforeUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterSave(*this);
                if (hook_err) return std::unexpected(hook_err);
                return 0LL;  // 0 rows affected
            }

            hook_err = model_instance.beforeUpdate(*this);
            if (hook_err) return std::unexpected(hook_err);

            QueryBuilder update_qb(this, this->connection_name_, &meta);
            for (const auto &pk_name_std : meta.primary_keys_db_names) {
                auto it = data_to_write.primary_key_fields.find(pk_name_std);
                if (it != data_to_write.primary_key_fields.end() && it->second.isValid() && !it->second.isNull()) {
                    update_qb.Where(pk_name_std + " = ?", {Session::sqlValueToQueryValue(it->second)});
                } else {
                    return std::unexpected(Error(ErrorCode::MappingError, "SaveImpl (Update path): PK '" + pk_name_std + "' missing or invalid in extracted PKs for WHERE clause. Table: " + meta.table_name));
                }
            }

            std::map<std::string, QueryValue> updates_for_impl;
            for (const auto &pair : data_to_write.fields_to_write) {
                // Do not include PKs in the SET clause of an UPDATE
                bool is_this_field_a_pk = false;
                for (const auto &pk_col_name : meta.primary_keys_db_names) {
                    if (pk_col_name == pair.first) {
                        is_this_field_a_pk = true;
                        break;
                    }
                }
                if (!is_this_field_a_pk) {
                    updates_for_impl[pair.first] = Session::sqlValueToQueryValue(pair.second);
                }
            }

            if (updates_for_impl.empty()) {  // If only PKs were in fields_to_write (unlikely due to timestamp logic)
                qInfo("SaveImpl (Update path): After removing PKs, no fields left to update for table %s. Skipping DB operation.", meta.table_name.c_str());
                hook_err = model_instance.afterUpdate(*this);
                if (hook_err) return std::unexpected(hook_err);
                hook_err = model_instance.afterSave(*this);
                if (hook_err) return std::unexpected(hook_err);
                return 0LL;
            }

            auto update_result = this->UpdatesImpl(update_qb, updates_for_impl);

            if (!update_result.has_value()) return std::unexpected(update_result.error());
            if (update_result.value() > 0)
                model_instance._is_persisted = true;  // If rows were affected, it's persisted
            else if (update_result.value() == 0 && model_instance._is_persisted) {
                // No rows affected, but it was already persisted (e.g., no actual data change)
            } else if (update_result.value() == 0 && !model_instance._is_persisted && model_has_all_pks_set_and_non_default) {
                // PKs were set, but no matching row found for update. This means it's not persisted.
                // This Save should have gone to Create path.
                // This case indicates a potential issue if we expected an update.
                // GORM might then attempt an INSERT. For now, we don't auto-switch.
                qWarning("SaveImpl (Update path): Update affected 0 rows for model (table: %s) with PKs set but not previously marked persisted. Record may not exist.", meta.table_name.c_str());
            }

            hook_err = model_instance.afterUpdate(*this);
            if (hook_err) return std::unexpected(hook_err);
            hook_err = model_instance.afterSave(*this);
            if (hook_err) return std::unexpected(hook_err);
            return update_result.value();

        } else {  // Attempt a CREATE
            // hook_err = model_instance.beforeCreate(*this); // CreateImpl handles this
            // if (hook_err) return std::unexpected(hook_err);
            // this->autoSetTimestamps(model_instance, meta, true); // CreateImpl handles this

            const OnConflictClause *final_conflict_options = nullptr;
            std::unique_ptr<OnConflictClause> save_upsert_clause_ptr;

            if (qb_param.getOnConflictClause()) {
                final_conflict_options = qb_param.getOnConflictClause();
            } else if (this->getTempOnConflictClause()) {
                final_conflict_options = this->getTempOnConflictClause();
            } else if (has_defined_pk && model_has_all_pks_set_and_non_default) {
                // If PKs are set and it's not persisted, default to upsert (update all excluded)
                save_upsert_clause_ptr = std::make_unique<OnConflictClause>(OnConflictClause::Action::UpdateAllExcluded);
                // Set conflict target to PKs for databases like PostgreSQL/SQLite
                if (!meta.primary_keys_db_names.empty() && save_upsert_clause_ptr->conflict_target_columns_db_names.empty()) {
                    save_upsert_clause_ptr->conflict_target_columns_db_names = meta.primary_keys_db_names;
                }
                final_conflict_options = save_upsert_clause_ptr.get();
            }

            auto create_result_sv_expected = this->CreateImpl(qb_param, model_instance, final_conflict_options);

            if (this->getTempOnConflictClause() && !qb_param.getOnConflictClause() && final_conflict_options == this->getTempOnConflictClause()) {
                this->clearTempOnConflictClause();
            }

            if (!create_result_sv_expected.has_value()) return std::unexpected(create_result_sv_expected.error());

            // model_instance._is_persisted and afterCreate hook are handled by CreateImpl

            hook_err = model_instance.afterSave(*this);  // afterSave is specific to Save operation
            if (hook_err) return std::unexpected(hook_err);

            // Determine return value for Save (usually 1 for create/update, 0 for no-op)
            // create_result_sv_expected.value() contains rows_affected or last_insert_id from CreateImpl
            cpporm_sqldriver::SqlValue sv_from_create = create_result_sv_expected.value();
            long long rows_affected_from_create = -1;
            bool ok_conv = false;
            if (sv_from_create.type() == cpporm_sqldriver::SqlValueType::Int64) {  // If it was rows_affected
                rows_affected_from_create = sv_from_create.toInt64(&ok_conv);
            }

            if (final_conflict_options && final_conflict_options->action == OnConflictClause::Action::DoNothing) {
                // If DO NOTHING occurred, and CreateImpl reported 0 rows affected (meaning it existed),
                // _is_persisted should reflect that (CreateImpl should set it true if conflict handler ran).
                // Save operation should return 0 if it was a DO NOTHING on existing.
                // If it was a genuine insert (conflict didn't happen), rows_affected would be > 0.
                if (ok_conv && rows_affected_from_create == 0 && model_instance._is_persisted) return 0LL;  // No-op due to conflict
                if (model_instance._is_persisted) return 1LL;                                               // Actual insert or update from conflict
                return 0LL;                                                                                 // Fallback if not persisted after DO NOTHING attempt
            }
            return model_instance._is_persisted ? 1LL : 0LL;  // 1 if persisted (newly or via upsert), 0 otherwise
        }
    }

    std::expected<long long, Error> Session::Save(ModelBase &model_instance) {
        QueryBuilder qb = this->Model(&model_instance);
        return this->SaveImpl(qb, model_instance);
    }

}  // namespace cpporm// Base/CppOrm/Source/session_static_utils.cpp
#include <QDebug>
#include <QMetaType>
#include <QVariant>
#include <any>
#include <variant>

#include "cpporm/error.h"
#include "cpporm/model_base.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_error.h"
#include "cpporm_sqldriver/sql_query.h"
#include "cpporm_sqldriver/sql_value.h"

namespace cpporm {

    std::string Session::getSqlTypeForCppType(const FieldMeta &field_meta, const QString &driverName_upper_qstr) {
        std::string driverName_upper = driverName_upper_qstr.toStdString();
        if (!field_meta.db_type_hint.empty()) {
            return field_meta.db_type_hint;
        }
        const std::type_index &cpp_type = field_meta.cpp_type;

        if (cpp_type == typeid(int)) return "INT";
        if (cpp_type == typeid(unsigned int)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "INTEGER";
            return "INT UNSIGNED";
        }
        if (cpp_type == typeid(long long)) return "BIGINT";
        if (cpp_type == typeid(unsigned long long)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "BIGINT";
            return "BIGINT UNSIGNED";
        }
        if (cpp_type == typeid(float)) return "FLOAT";
        if (cpp_type == typeid(double)) return "DOUBLE PRECISION";
        if (cpp_type == typeid(bool)) {
            if (driverName_upper == "QPSQL" || driverName_upper == "QSQLITE") return "BOOLEAN";
            if (driverName_upper == "QMYSQL" || driverName_upper == "QMARIADB") return "TINYINT(1)";
            return "BOOLEAN";
        }
        if (cpp_type == typeid(std::string)) return "TEXT";
        if (cpp_type == typeid(QDateTime)) {
            if (driverName_upper == "QPSQL") return "TIMESTAMP WITH TIME ZONE";
            if (driverName_upper == "QSQLITE") return "DATETIME";
            return "DATETIME";
        }
        if (cpp_type == typeid(QDate)) return "DATE";
        if (cpp_type == typeid(QTime)) return "TIME";
        if (cpp_type == typeid(QByteArray)) {
            if (driverName_upper == "QPSQL") return "BYTEA";
            if (driverName_upper == "QSQLITE") return "BLOB";
            return "BLOB";
        }

        qWarning() << "Session::getSqlTypeForCppType: Unknown C++ type " << QString::fromLocal8Bit(field_meta.cpp_type.name()) << " for field '" << QString::fromStdString(field_meta.cpp_name) << "'. Defaulting to TEXT. Driver: " << driverName_upper_qstr;
        return "TEXT";
    }

    void Session::qvariantToAny(const QVariant &qv, const std::type_index &target_cpp_type, std::any &out_any, bool &out_conversion_ok) {
        out_conversion_ok = false;
        out_any.reset();

        if (qv.isNull() || !qv.isValid() ||
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
            qv.typeId() == QMetaType::UnknownType
#else
            qv.type() == QVariant::Invalid || qv.userType() == QMetaType::UnknownType
#endif
        ) {
            out_conversion_ok = true;
            return;
        }
        if (target_cpp_type == typeid(int)) {
            out_any = qv.toInt(&out_conversion_ok);
        } else if (target_cpp_type == typeid(long long)) {
            out_any = qv.toLongLong(&out_conversion_ok);
        } else if (target_cpp_type == typeid(unsigned int)) {
            out_any = qv.toUInt(&out_conversion_ok);
        } else if (target_cpp_type == typeid(unsigned long long)) {
            out_any = qv.toULongLong(&out_conversion_ok);
        } else if (target_cpp_type == typeid(double)) {
            out_any = qv.toDouble(&out_conversion_ok);
        } else if (target_cpp_type == typeid(float)) {
            out_any = qv.toFloat(&out_conversion_ok);
        } else if (target_cpp_type == typeid(bool)) {
            out_any = qv.toBool();
            out_conversion_ok = true;
        } else if (target_cpp_type == typeid(std::string)) {
            if (
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                QMetaType(qv.typeId()).flags().testFlag(QMetaType::IsPointer) ||  // Check if it's a pointer type
                QMetaType(qv.typeId()).flags().testFlag(QMetaType::IsGadget)      // Or a gadget
#else
                qv.type() == QVariant::UserType  // Check if it's a user type (often pointers or gadgets in Qt 5)
#endif
                // Add more specific checks if needed for custom types stored in QVariant
            ) {
                qWarning() << "Session::qvariantToAny: Attempting to convert a complex QVariant type" << qv.typeName() << "to std::string. This might not be meaningful.";
                // Fallback or specific handling if you know how to stringify it
                out_any = qv.toString().toStdString();  // Fallback to QVariant::toString()
                out_conversion_ok = true;               // Assume QVariant::toString() is always "successful"
            } else if (qv.canConvert<QString>()) {
                out_any = qv.toString().toStdString();
                out_conversion_ok = true;
            } else if (
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                qv.typeId() == QMetaType::QByteArray
#else
                qv.type() == QVariant::ByteArray
#endif
            ) {
                QByteArray ba = qv.toByteArray();
                out_any = std::string(ba.constData(), static_cast<size_t>(ba.size()));
                out_conversion_ok = true;
            } else {
                qWarning() << "Session::qvariantToAny: Cannot convert QVariant type" << qv.typeName() << "to std::string for target type" << QString::fromLocal8Bit(target_cpp_type.name());
            }
        } else if (target_cpp_type == typeid(QDateTime)) {
            if (qv.canConvert<QDateTime>()) {
                out_any = qv.toDateTime();
                out_conversion_ok = qv.toDateTime().isValid();
            }
        } else if (target_cpp_type == typeid(QDate)) {
            if (qv.canConvert<QDate>()) {
                out_any = qv.toDate();
                out_conversion_ok = qv.toDate().isValid();
            }
        } else if (target_cpp_type == typeid(QTime)) {
            if (qv.canConvert<QTime>()) {
                out_any = qv.toTime();
                out_conversion_ok = qv.toTime().isValid();
            }
        } else if (target_cpp_type == typeid(QByteArray)) {
            if (qv.canConvert<QByteArray>()) {
                out_any = qv.toByteArray();
                out_conversion_ok = true;
            }
        } else {
            qWarning() << "Session::qvariantToAny: Unsupported C++ target type for "
                          "QVariant conversion: "
                       << QString::fromLocal8Bit(target_cpp_type.name()) << "from QVariant type" << qv.typeName();
        }
        if (!out_conversion_ok && qv.isValid() && !qv.isNull()) {
            qWarning() << "Session::qvariantToAny: Conversion failed for QVariant value [" << qv.toString() << "] of type" << qv.typeName() << "to C++ type" << QString::fromLocal8Bit(target_cpp_type.name());
        }
    }

    QueryValue Session::anyToQueryValueForSessionConvenience(const std::any &val) {
        if (!val.has_value()) return nullptr;
        const auto &type = val.type();
        if (type == typeid(int)) return std::any_cast<int>(val);
        if (type == typeid(long long)) return std::any_cast<long long>(val);
        if (type == typeid(double)) return std::any_cast<double>(val);
        if (type == typeid(std::string)) return std::any_cast<std::string>(val);
        if (type == typeid(bool)) return std::any_cast<bool>(val);
        if (type == typeid(QDateTime)) return std::any_cast<QDateTime>(val);
        if (type == typeid(QDate)) return std::any_cast<QDate>(val);
        if (type == typeid(QTime)) return std::any_cast<QTime>(val);
        if (type == typeid(QByteArray)) return std::any_cast<QByteArray>(val);
        if (type == typeid(const char *)) return std::string(std::any_cast<const char *>(val));
        if (type == typeid(std::nullptr_t)) return nullptr;
        if (type == typeid(float)) return static_cast<double>(std::any_cast<float>(val));
        if (type == typeid(short)) return static_cast<int>(std::any_cast<short>(val));
        if (type == typeid(char)) {
            return static_cast<int>(std::any_cast<char>(val));
        }
        if (type == typeid(unsigned char)) return static_cast<int>(std::any_cast<unsigned char>(val));
        if (type == typeid(unsigned short)) return static_cast<int>(std::any_cast<unsigned short>(val));
        if (type == typeid(unsigned int)) return static_cast<long long>(std::any_cast<unsigned int>(val));
        if (type == typeid(unsigned long long)) return static_cast<long long>(std::any_cast<unsigned long long>(val));

        qWarning() << "Session::anyToQueryValueForSessionConvenience: Unhandled "
                      "std::any type:"
                   << QString::fromLocal8Bit(val.type().name());
        return nullptr;
    }

    cpporm_sqldriver::SqlValue Session::queryValueToSqlValue(const QueryValue &qv) {
        if (std::holds_alternative<std::nullptr_t>(qv)) return cpporm_sqldriver::SqlValue();
        if (std::holds_alternative<int>(qv)) return cpporm_sqldriver::SqlValue(static_cast<int32_t>(std::get<int>(qv)));
        if (std::holds_alternative<long long>(qv)) return cpporm_sqldriver::SqlValue(static_cast<int64_t>(std::get<long long>(qv)));
        if (std::holds_alternative<double>(qv)) return cpporm_sqldriver::SqlValue(std::get<double>(qv));
        if (std::holds_alternative<std::string>(qv)) return cpporm_sqldriver::SqlValue(std::get<std::string>(qv));
        if (std::holds_alternative<bool>(qv)) return cpporm_sqldriver::SqlValue(std::get<bool>(qv));
        if (std::holds_alternative<QDateTime>(qv)) return cpporm_sqldriver::SqlValue(std::get<QDateTime>(qv));
        if (std::holds_alternative<QDate>(qv)) return cpporm_sqldriver::SqlValue(std::get<QDate>(qv));
        if (std::holds_alternative<QTime>(qv)) return cpporm_sqldriver::SqlValue(std::get<QTime>(qv));
        if (std::holds_alternative<QByteArray>(qv)) return cpporm_sqldriver::SqlValue(std::get<QByteArray>(qv));
        if (std::holds_alternative<SubqueryExpression>(qv)) {
            qWarning("Session::queryValueToSqlValue: SubqueryExpression cannot be directly converted to a single SqlValue for binding. This usually indicates a logic error where a subquery is being treated as a simple bind value.");
            return cpporm_sqldriver::SqlValue();
        }
        qWarning("Session::queryValueToSqlValue: Unhandled QueryValue variant type during conversion to SqlValue.");
        return cpporm_sqldriver::SqlValue();
    }

    QueryValue Session::sqlValueToQueryValue(const cpporm_sqldriver::SqlValue &sv) {
        if (sv.isNull()) return nullptr;
        bool ok = false;
        switch (sv.type()) {
            case cpporm_sqldriver::SqlValueType::Bool:
                return sv.toBool(&ok);
            case cpporm_sqldriver::SqlValueType::Int8:
            case cpporm_sqldriver::SqlValueType::UInt8:
            case cpporm_sqldriver::SqlValueType::Int16:
            case cpporm_sqldriver::SqlValueType::UInt16:
            case cpporm_sqldriver::SqlValueType::Int32:
                return sv.toInt32(&ok);
            case cpporm_sqldriver::SqlValueType::UInt32:
                return static_cast<long long>(sv.toUInt32(&ok));
            case cpporm_sqldriver::SqlValueType::Int64:
                return sv.toInt64(&ok);
            case cpporm_sqldriver::SqlValueType::UInt64:
                return static_cast<long long>(sv.toUInt64(&ok));
            case cpporm_sqldriver::SqlValueType::Float:
            case cpporm_sqldriver::SqlValueType::Double:
            case cpporm_sqldriver::SqlValueType::LongDouble:
                return sv.toDouble(&ok);
            case cpporm_sqldriver::SqlValueType::String:
            case cpporm_sqldriver::SqlValueType::FixedString:
            case cpporm_sqldriver::SqlValueType::CharacterLargeObject:
                return sv.toString(&ok);
            case cpporm_sqldriver::SqlValueType::ByteArray:
            case cpporm_sqldriver::SqlValueType::BinaryLargeObject:
                return sv.toByteArray(&ok);
            case cpporm_sqldriver::SqlValueType::Date:
                return sv.toDate(&ok);
            case cpporm_sqldriver::SqlValueType::Time:
                return sv.toTime(&ok);
            case cpporm_sqldriver::SqlValueType::DateTime:
            case cpporm_sqldriver::SqlValueType::Timestamp:
                return sv.toDateTime(&ok);
            case cpporm_sqldriver::SqlValueType::Decimal:
            case cpporm_sqldriver::SqlValueType::Numeric:
                {
                    double d_val = sv.toDouble(&ok);
                    if (ok) return d_val;
                    std::string s_val = sv.toString(&ok);
                    if (ok) return s_val;
                    qWarning() << "Session::sqlValueToQueryValue: Could not convert Decimal/Numeric SqlValue to double or string.";
                }
                break;
            case cpporm_sqldriver::SqlValueType::Json:
                return sv.toString(&ok);
            default:
                qWarning() << "Session::sqlValueToQueryValue: Unhandled SqlValueType: " << static_cast<int>(sv.type()) << " (" << sv.typeName() << "). Attempting toString().";
                std::string s_val = sv.toString(&ok);
                if (ok) return s_val;
        }
        if (!ok && !sv.isNull()) {
            qWarning() << "Session::sqlValueToQueryValue: Conversion from SqlValue (type: " << sv.typeName() << ", value: " << QString::fromStdString(sv.toString()) << ") to a QueryValue alternative failed.";
        }
        return nullptr;
    }

    std::pair<cpporm_sqldriver::SqlQuery, Error> Session::execute_query_internal(cpporm_sqldriver::SqlDatabase &db_handle, const std::string &sql_std_str, const std::vector<cpporm_sqldriver::SqlValue> &bound_params) {
        if (!db_handle.isOpen()) {
            qWarning() << "Session::execute_query_internal: Database handle for connection '" << QString::fromStdString(db_handle.connectionName()) << "' is not open. Attempting to open...";
            if (!db_handle.open()) {
                cpporm_sqldriver::SqlError err = db_handle.lastError();
                return std::make_pair(cpporm_sqldriver::SqlQuery(db_handle),
                                      Error(ErrorCode::ConnectionNotOpen,
                                            "execute_query_internal: Failed to open database for query "
                                            "execution on connection '" +
                                                db_handle.connectionName() + "': " + err.text(),
                                            err.nativeErrorCodeNumeric()));
            }
        }

        cpporm_sqldriver::SqlQuery query(db_handle);

        if (!query.prepare(sql_std_str)) {
            cpporm_sqldriver::SqlError prepareError = query.lastError();
            return std::make_pair(std::move(query), Error(ErrorCode::StatementPreparationError, "Failed to prepare SQL query: " + prepareError.text() + " SQL: " + sql_std_str, prepareError.nativeErrorCodeNumeric()));
        }

        for (size_t i = 0; i < bound_params.size(); ++i) {
            query.bindValue(static_cast<int>(i), bound_params[i]);
        }

        if (!query.exec()) {
            cpporm_sqldriver::SqlError execError = query.lastError();
            std::string params_debug_str;
            for (const auto &p_sv : bound_params) {
                bool conv_ok = false;
                params_debug_str += p_sv.toString(&conv_ok) + ", ";
            }
            if (!params_debug_str.empty()) params_debug_str.resize(params_debug_str.length() - 2);

            return std::make_pair(std::move(query),
                                  Error(ErrorCode::QueryExecutionError, "SQL query execution failed: " + execError.text() + " (Native Code: " + execError.nativeErrorCode() + ")" + "\nSQL: " + sql_std_str + "\nParams: [" + params_debug_str + "]", execError.nativeErrorCodeNumeric(), ""));
        }
        return std::make_pair(std::move(query), make_ok());
    }

}  // namespace cpporm// Base/CppOrm/Source/session_transaction.cpp
// #include "cpporm/qt_db_manager.h" // No longer needed
#include <QDebug>

#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_database.h"
#include "cpporm_sqldriver/sql_driver_manager.h"
#include "cpporm_sqldriver/sql_enums.h"
#include "cpporm_sqldriver/sql_error.h"
// #include <QSqlDatabase> // No longer used directly
// #include <QSqlDriver>   // No longer used directly
// #include <QSqlError>    // No longer used directly

namespace cpporm {

    std::expected<std::unique_ptr<Session>, Error> Session::Begin() {
        if (is_explicit_transaction_handle_) {
            qWarning() << "cpporm Session::Begin: Attempting to Begin() on an already "
                          "transactional Session. This usually implies a logical error or need "
                          "for savepoints (not directly supported by Begin() for new Session).";
            return std::unexpected(Error(ErrorCode::TransactionError, "Session is already explicitly transactional. Nested Begin() to create a new Session is not supported. Use savepoints on the existing session if needed."));
        }

        if (!db_handle_.isValid()) {
            return std::unexpected(Error(ErrorCode::ConnectionInvalid, "Cannot begin transaction: Session's SqlDatabase handle is invalid."));
        }
        if (!db_handle_.isOpen()) {
            qInfo() << "Session::Begin: Database handle for connection '" << QString::fromStdString(db_handle_.connectionName()) << "' was not open. Attempting to open...";
            if (!db_handle_.open()) {
                cpporm_sqldriver::SqlError open_err = db_handle_.lastError();
                return std::unexpected(Error(ErrorCode::ConnectionNotOpen, "Failed to open database for transaction: " + open_err.text(), open_err.nativeErrorCodeNumeric()));
            }
        }

        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            return std::unexpected(Error(ErrorCode::UnsupportedFeature, "Database driver for connection '" + connection_name_ + "' does not support transactions."));
        }

        // Use SqlDatabase::beginTransaction() which delegates to ISqlDriver
        if (db_handle_.beginTransaction()) {
            // Create a new Session object for this transaction.
            // This new Session gets a SqlDatabase handle to the *same* underlying connection.
            // The is_explicit_transaction_handle_ flag ensures it will manage commit/rollback.
            auto tx_session = std::make_unique<Session>(connection_name_);
            tx_session->is_explicit_transaction_handle_ = true;

            // The transaction has been started on the underlying connection referenced by
            // this->db_handle_ and also by tx_session->db_handle_ (as they point to the same connection managed by SqlDriverManager).
            return tx_session;

        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            return std::unexpected(Error(ErrorCode::TransactionError, "Failed to begin transaction on connection '" + connection_name_ + "': " + q_error.text() + " (Driver Text: " + q_error.driverText() + ", DB Text: " + q_error.databaseText() + ")", q_error.nativeErrorCodeNumeric()));
        }
    }

    Error Session::Commit() {
        if (!is_explicit_transaction_handle_) {
            return Error(ErrorCode::TransactionError, "Commit called on a non-transactional Session. Call Begin() first.");
        }
        if (!db_handle_.isValid()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionInvalid, "Cannot commit: SqlDatabase handle is invalid.");
        }
        if (!db_handle_.isOpen()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionNotOpen, "Cannot commit: Database connection is not open.");
        }
        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::UnsupportedFeature, "Cannot commit: Driver does not support transactions.");
        }

        // Use SqlDatabase::commit() which delegates to ISqlDriver::commitTransaction()
        if (db_handle_.commit()) {
            is_explicit_transaction_handle_ = false;
            return make_ok();
        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            return Error(ErrorCode::TransactionError, "Failed to commit transaction: " + q_error.text() + " (Driver: " + q_error.driverText() + ", DB: " + q_error.databaseText() + ")", q_error.nativeErrorCodeNumeric());
        }
    }

    Error Session::Rollback() {
        if (!is_explicit_transaction_handle_) {
            return Error(ErrorCode::TransactionError, "Rollback called on a non-transactional Session. Call Begin() first.");
        }
        if (!db_handle_.isValid()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionInvalid, "Cannot rollback: SqlDatabase handle is invalid.");
        }
        if (!db_handle_.isOpen()) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::ConnectionNotOpen, "Cannot rollback: Database connection is not open.");
        }
        if (!db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::UnsupportedFeature, "Cannot rollback: Driver does not support transactions.");
        }

        // Use SqlDatabase::rollback() which delegates to ISqlDriver::rollbackTransaction()
        if (db_handle_.rollback()) {
            is_explicit_transaction_handle_ = false;
            return make_ok();
        } else {
            cpporm_sqldriver::SqlError q_error = db_handle_.lastError();
            is_explicit_transaction_handle_ = false;
            return Error(ErrorCode::TransactionError, "Failed to rollback transaction: " + q_error.text() + " (Driver: " + q_error.driverText() + ", DB: " + q_error.databaseText() + ")", q_error.nativeErrorCodeNumeric());
        }
    }

    bool Session::IsTransaction() const {
        if (is_explicit_transaction_handle_) {
            if (db_handle_.isValid() && db_handle_.isOpen() && db_handle_.hasFeature(cpporm_sqldriver::Feature::Transactions)) {
                return db_handle_.isTransactionActive();
            } else {
                qWarning(
                    "Session::IsTransaction: Session is marked as transactional, but DB "
                    "handle is invalid, closed, or driver lost. Inconsistent state.");
                return false;
            }
        }
        return false;
    }

}  // namespace cpporm#include <QDateTime>  // For timestamp logic, QVariant types in QueryValue
#include <QDebug>     // qInfo, qWarning
#include <QVariant>   // QVariantList from QueryBuilder
#include <algorithm>  // For std::transform

#include "cpporm/model_base.h"
#include "cpporm/query_builder.h"
#include "cpporm/session.h"
#include "cpporm_sqldriver/sql_query.h"  // SqlQuery
#include "cpporm_sqldriver/sql_value.h"  // SqlValue

namespace cpporm {

    std::expected<long long, Error> Session::UpdatesImpl(const QueryBuilder &qb_const, const std::map<std::string, QueryValue> &updates_map_in) {
        QueryBuilder qb = qb_const;  // Work with a copy

        if (updates_map_in.empty()) {
            qInfo("cpporm Session::UpdatesImpl: No update values provided.");
            return 0LL;
        }

        std::map<std::string, QueryValue> final_updates = updates_map_in;
        const ModelMeta *meta = qb.getModelMeta();

        if (meta) {
            bool update_model_table_directly = false;
            if (std::holds_alternative<std::string>(qb.getFromClauseSource())) {
                const std::string &from_name = std::get<std::string>(qb.getFromClauseSource());
                if ((!from_name.empty() && from_name == meta->table_name) || (from_name.empty() && !meta->table_name.empty())) {
                    update_model_table_directly = true;
                }
            }

            if (update_model_table_directly) {
                if (const FieldMeta *updatedAtField = meta->findFieldWithFlag(FieldFlag::UpdatedAt)) {
                    if (updatedAtField->cpp_type == typeid(QDateTime)) {
                        final_updates[updatedAtField->db_name] = QDateTime::currentDateTimeUtc();
                    }
                }
            }
        }

        auto [sql_qstr, params_qvariantlist] = qb.buildUpdateSQL(final_updates);
        std::string sql_std_str = sql_qstr.toStdString();

        if (sql_std_str.empty()) {
            return std::unexpected(Error(ErrorCode::StatementPreparationError,
                                         "Failed to build SQL for Updates operation. Target might be "
                                         "invalid or table name missing."));
        }

        std::vector<cpporm_sqldriver::SqlValue> params_sqlvalue;
        params_sqlvalue.reserve(params_qvariantlist.size());
        for (const QVariant &qv : params_qvariantlist) {
            params_sqlvalue.push_back(Session::queryValueToSqlValue(QueryBuilder::qvariantToQueryValue(qv)));
        }

        auto [sql_query_obj, exec_err] = execute_query_internal(this->db_handle_, sql_std_str, params_sqlvalue);
        if (exec_err) {
            return std::unexpected(exec_err);
        }

        return sql_query_obj.numRowsAffected();
    }

    std::expected<long long, Error> Session::Updates(QueryBuilder qb, const std::map<std::string, QueryValue> &updates) {
        if (qb.getExecutor() != this && qb.getExecutor() != nullptr) {
            qWarning(
                "Session::Updates(QueryBuilder, ...): QueryBuilder was associated "
                "with a different executor. The operation will use THIS session's context "
                "by calling its UpdatesImpl. Ensure this is intended.");
        }
        // Always call this session's Impl to ensure correct context and timestamp handling
        return this->UpdatesImpl(qb, updates);
    }

    std::expected<long long, Error> Session::Updates(const ModelMeta &meta, const std::map<std::string, QueryValue> &updates_map, const std::map<std::string, QueryValue> &conditions) {
        if (updates_map.empty()) {
            qInfo("cpporm Session::Updates (by meta): No update values provided.");
            return 0LL;
        }
        QueryBuilder qb = this->Model(meta);
        if (!conditions.empty()) {
            qb.Where(conditions);
        }
        return this->UpdatesImpl(qb, updates_map);
    }

    std::expected<long long, Error> Session::Updates(const ModelBase &model_condition, const std::map<std::string, QueryValue> &updates_map) {
        if (updates_map.empty()) {
            qInfo("cpporm Session::Updates (by model): No update values provided.");
            return 0LL;
        }
        const ModelMeta &meta = model_condition._getOwnModelMeta();
        QueryBuilder qb = this->Model(meta);

        if (meta.primary_keys_db_names.empty()) {
            return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: No primary key defined for model " + meta.table_name));
        }

        std::map<std::string, QueryValue> pk_conditions;
        for (const auto &pk_db_name : meta.primary_keys_db_names) {
            const FieldMeta *pk_field = meta.findFieldByDbName(pk_db_name);
            if (!pk_field) {
                return std::unexpected(Error(ErrorCode::InternalError, "Updates by model instance: PK field meta not found for " + pk_db_name));
            }
            std::any pk_val_any = model_condition.getFieldValue(pk_field->cpp_name);
            if (!pk_val_any.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: PK value for " + pk_db_name + " is not set in the model."));
            }
            QueryValue qv_pk = Session::anyToQueryValueForSessionConvenience(pk_val_any);
            if (std::holds_alternative<std::nullptr_t>(qv_pk) && pk_val_any.has_value()) {
                return std::unexpected(Error(ErrorCode::MappingError, "Updates by model_condition: Unsupported PK type (" + std::string(pk_val_any.type().name()) + ") for field " + pk_db_name));
            }
            pk_conditions[pk_db_name] = qv_pk;
        }

        if (pk_conditions.empty()) {  // Should be caught by !pk_val_any.has_value() or conversion failure
            return std::unexpected(Error(ErrorCode::MappingError, "Updates by model instance: Failed to extract valid PK conditions."));
        }
        qb.Where(pk_conditions);
        return this->UpdatesImpl(qb, updates_map);
    }

}  // namespace cpporm