# CMakeLists.txt for BoltProtocol module

# Since this module is purely for protocol logic and data structures,
# it might not have complex dependencies beyond standard C++.
# If PackStream or other parts need external libs (e.g., for specific data types),
# they would be added here.

file(GLOB_RECURSE BOLT_PROTOCOL_SOURCES
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(BoltProtocol ${BOLT_PROTOCOL_SOURCES})

target_include_directories(BoltProtocol
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(BoltProtocol PUBLIC Boost::asio OpenSSL::SSL OpenSSL::Crypto)

# build example, no condition
add_subdirectory(Example)

# BoltProtocol itself likely doesn't link to socket libraries.
# It provides structures and serialization/deserialization logic.
# The Neo4jBoltDriver will link the socket library and use BoltProtocol.

# Example of how other modules would link against BoltProtocol:
# target_link_libraries(Neo4jBoltDriver PRIVATE BoltProtocol)# BoltProtocol 库简介

欢迎使用 BoltProtocol 库！这是一个C++实现的底层库，用于处理 Neo4j Bolt 协议的编码、解码和核心交互逻辑。它旨在为构建功能完善的 Neo4j C++ 驱动程序或直接与 Bolt 协议交互的工具提供坚实的基础。

## 目标

*   **协议合规性**: 严格遵循 Neo4j Bolt 协议规范的各个版本。
*   **灵活性**: 提供底层的序列化和反序列化原语，同时也支持强类型的特定数据结构。
*   **可移植性**: 依赖标准 C++。
*   **错误处理**: 提供清晰的错误码和状态反馈。

## 主要功能概述

本库提供以下核心功能：

*   **PackStream 序列化与反序列化**:
    *   支持 Bolt 协议使用的 PackStream V1 数据格式的所有类型（Null, Boolean, Integer, Float, String, List, Map, Structure）。
    *   通过 `boltprotocol::Value` 类型在 C++ 中统一表示 PackStream 数据。
*   **Bolt 握手 (Handshake)**:
    *   实现客户端与服务器之间的 Bolt 协议版本协商。
    *   提供 `boltprotocol::versions::Version` 结构体表示版本。
    *   函数 `boltprotocol::perform_handshake` 执行完整握手流程。
*   **消息分块 (Chunking)**:
    *   通过 `boltprotocol::ChunkedWriter` 将完整的 Bolt 消息分块写入输出流。
    *   通过 `boltprotocol::ChunkedReader` 从输入流读取分块数据并重组为完整消息。
*   **Bolt 消息定义与处理**:
    *   **消息标签**: `boltprotocol::MessageTag` 枚举定义了所有标准 Bolt 消息类型。
    *   **消息参数结构体**: 为每种 Bolt 消息（如 HELLO, RUN, SUCCESS 等）定义了相应的 C++ `struct` (例如 `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`) 来表示其参数。这些结构体通常包含 `std::string`, `int64_t`, `std::optional`, `std::vector`, `std::map<std::string, boltprotocol::Value>` 等成员。
    *   **客户端消息序列化**: 提供函数将 C++ 参数结构体序列化为 Bolt 消息字节流 (例如 `boltprotocol::serialize_hello_message`)。
    *   **服务器响应反序列化**: 提供函数将服务器响应字节流反序列化为 C++ 参数结构体 (例如 `boltprotocol::deserialize_success_message`)。
    *   **服务器端请求反序列化**: 提供函数供服务器解析客户端请求字节流 (例如 `boltprotocol::deserialize_hello_message_request`)。
*   **特定 PackStream 结构类型支持**:
    *   为常见的图元（Node, Relationship, Path）和数据类型（Date, Time, DateTime, Point 等）定义了强类型的 C++ `struct` (例如 `boltprotocol::BoltNode`, `boltprotocol::BoltDate`)。
    *   提供转换函数在这些强类型结构与通用的 `boltprotocol::PackStreamStructure` 之间进行转换 (例如 `boltprotocol::from_packstream`, `boltprotocol::to_packstream`)。

## 如何开始

要开始使用 BoltProtocol 库，您通常需要：

1.  **包含主头文件**:
    *   `#include "boltprotocol/message_defs.h"`: 这是最主要的聚合头文件，它包含了：
        *   核心数据类型 (`Value`, `BoltMap`, `BoltList`, `PackStreamStructure`)
        *   错误枚举 (`BoltError`)
        *   版本结构 (`versions::Version`) 和相关常量
        *   消息标签 (`MessageTag`)
        *   所有消息参数结构体 (`HelloMessageParams` 等)
        *   特定结构类型 (`BoltNode`, `BoltDate` 等，通过包含 `bolt_structure_types.h`)
    *   `#include "boltprotocol/message_serialization.h"`: 获取所有消息序列化和反序列化函数的声明。
    *   `#include "boltprotocol/handshake.h"`: 获取握手相关函数的声明。
    *   `#include "boltprotocol/chunking.h"`: 获取分块读写器的声明。
    *   `#include "boltprotocol/bolt_structure_serialization.h"`: 获取特定 PackStream 结构类型（如 `BoltNode`）与通用 `PackStreamStructure` 之间转换函数的声明。
2.  **理解核心概念**: 熟悉 PackStream、Bolt 消息、握手和分块机制（详见本文档后续章节）。
3.  **查阅后续文档**: 详细了解如何使用特定功能，如消息序列化、反序列化、特定结构转换和错误处理。

## 模块结构概览 (供库开发者参考)

为了方便维护和理解，本库的内部实现分布在不同的目录和文件中：

*   **`Include/boltprotocol/`**: 包含所有公共头文件。
    *   `detail/`: 包含库内部使用的辅助头文件，不应被库用户直接包含。
    *   `message_defs.h`: 聚合了核心类型定义。
    *   其他 `.h` 文件对应各个功能模块。
*   **`Source/`**: 包含所有 `.cpp` 实现文件。
    *   文件按功能模块组织 (例如 `packstream_reader_*.cpp`, `message_serialization_client_*.cpp`, `bolt_structure_*.cpp`)。

让我们深入了解核心概念，开始构建您的 Bolt 应用！# BoltProtocol 核心概念

理解 Bolt 协议的几个核心概念对于有效使用本库至关重要。

## 1. PackStream

PackStream 是 Bolt 协议用于在网络上传输数据的一种二进制序列化格式。它支持多种数据类型，本库对这些类型提供了相应的 C++ 表示。

### C++ 中的 PackStream 类型表示

所有 PackStream 类型最终都可以通过 `boltprotocol::Value` 来表示。这是一个 `std::variant`，能够持有以下C++类型，对应不同的 PackStream 类型：

*   **`std::nullptr_t`**:
    *   对应 PackStream `Null`。
*   **`bool`**:
    *   对应 PackStream `Boolean` (`true` 或 `false`)。
*   **`int64_t`**:
    *   对应所有 PackStream `Integer` 类型 (TinyInt, Int8, Int16, Int32, Int64)。库会自动处理不同大小整数的编码和解码。
*   **`double`**:
    *   对应 PackStream `Float` (64位浮点数)。
*   **`std::string`**:
    *   对应 PackStream `String` (UTF-8 编码)。
*   **`std::shared_ptr<boltprotocol::BoltList>`**:
    *   对应 PackStream `List`。
    *   `boltprotocol::BoltList` 结构体包含一个成员：
        *   `std::vector<boltprotocol::Value> elements;`
*   **`std::shared_ptr<boltprotocol::BoltMap>`**:
    *   对应 PackStream `Map`。
    *   `boltprotocol::BoltMap` 结构体包含一个成员：
        *   `std::map<std::string, boltprotocol::Value> pairs;`
*   **`std::shared_ptr<boltprotocol::PackStreamStructure>`**:
    *   对应 PackStream `Structure`。这是 Bolt 协议中用于表示消息和复杂数据类型（如图节点、日期时间等）的基础。
    *   `boltprotocol::PackStreamStructure` 结构体包含成员：
        *   `uint8_t tag;`：一个字节的标签，用于标识该结构的具体类型（例如，消息类型或特定数据如 Node、Date 的类型）。
        *   `std::vector<boltprotocol::Value> fields;`：一个包含该结构所有字段值的列表。

**注意**: 您通常不需要手动创建或解析底层的 `Value`、`BoltList`、`BoltMap` 或 `PackStreamStructure` 对象来构造或解析 Bolt 消息。库提供了更高级别的消息参数结构体 (`XxxMessageParams`) 和针对特定 PackStream 结构（如 `BoltNode`）的强类型 C++ `struct`，以及相应的序列化/反序列化函数来处理这些转换。

## 2. Bolt 消息

Bolt 协议通过客户端和服务器之间的请求-响应消息交换进行通信。

*   **请求消息 (Request Message)**: 由客户端发送给服务器。
*   **响应消息 (Response Message)**: 由服务器发送给客户端。一个完整的响应通常由以下组成：
    *   零个或多个 **详情消息 (Detail Message)**: 例如 `RECORD` 消息，用于流式传输结果数据。
    *   恰好一个 **总结消息 (Summary Message)**: 例如 `SUCCESS` 或 `FAILURE`，标志着请求处理的结束和最终状态。

每条 Bolt 消息（无论是请求还是响应）都被编码为一个 **PackStream Structure**。

### 消息标签 (`boltprotocol::MessageTag`)

`boltprotocol::MessageTag` 是一个 `enum class`，定义了所有标准 Bolt 消息的唯一类型标签 (一个字节的整数)。这个标签值被用作相应消息的 `PackStreamStructure` 的 `tag` 字段。

*   **一些重要的消息标签示例**:
    *   `MessageTag::HELLO` (0x01): 客户端发送，用于初始化连接。
    *   `MessageTag::LOGON` (0x6A): 客户端发送，用于认证 (Bolt 5.1+)。
    *   `MessageTag::RUN` (0x10): 客户端发送，用于执行 Cypher 查询。
    *   `MessageTag::PULL` (0x3F): 客户端发送，用于拉取 `RUN` 查询的结果。
    *   `MessageTag::BEGIN` (0x11): 客户端发送，用于开始一个显式事务。
    *   `MessageTag::COMMIT` (0x12): 客户端发送，用于提交一个显式事务。
    *   `MessageTag::SUCCESS` (0x70): 服务器发送，表示请求成功。
    *   `MessageTag::FAILURE` (0x7F): 服务器发送，表示请求失败。
    *   `MessageTag::RECORD` (0x71): 服务器发送，包含一条结果记录。
    *   `MessageTag::IGNORED` (0x7E): 服务器发送，表示请求被忽略。
    *   ... (更多标签请参见规范或后续文档)

### 消息参数结构体 (`boltprotocol::*MessageParams`)

为了方便在 C++ 中构造和处理消息的参数，本库为大多数 Bolt 消息定义了对应的参数结构体。这些结构体以 `MessageParams` 结尾，例如 `boltprotocol::HelloMessageParams`, `boltprotocol::RunMessageParams`, `boltprotocol::SuccessMessageParams`。

*   这些结构体通常包含与消息字段对应的成员，使用标准的 C++ 类型如 `std::string`, `int64_t`, `std::vector`, `std::map`, 以及 `std::optional` (用于可选字段) 和 `boltprotocol::Value` (用于可变类型字段)。
*   **例如, `boltprotocol::RunMessageParams` 可能包含**:
    *   `std::string cypher_query;`
    *   `std::map<std::string, boltprotocol::Value> parameters;`
    *   `std::optional<std::vector<std::string>> bookmarks;`
    *   `std::optional<std::string> db;`
    *   ... 等等。
*   您可以通过填充这些结构体的成员来准备要发送的消息，或者在反序列化服务器响应（或客户端请求）后从这些结构体中读取参数。

## 3. 特定 PackStream 结构 (图元和数据类型)

除了 Bolt 消息本身，PackStream 还用于在消息字段中序列化 Neo4j 的特定数据类型，例如图节点、关系、路径、日期、时间、空间点等。

本库为这些常见的 PackStream Structure 定义了强类型的 C++ `struct`，例如：

*   `boltprotocol::BoltNode` (对应 PackStream Structure tag `0x4E 'N'`)
*   `boltprotocol::BoltRelationship` (tag `0x52 'R'`)
*   `boltprotocol::BoltPath` (tag `0x50 'P'`)
*   `boltprotocol::BoltDate` (tag `0x44 'D'`)
*   `boltprotocol::BoltTime` (tag `0x54 'T'`)
*   `boltprotocol::BoltDateTime` (tag `0x49 'I'` 或遗留的 `0x46 'F'`)
*   ... 等等。

这些强类型结构及其与通用 `PackStreamStructure` (`Value` 中持有的 `std::shared_ptr<PackStreamStructure>`) 之间的转换函数将在 `06-structure-types-and-conversions.md` 中详细介绍。这些转换函数通常会考虑不同 Bolt 版本对这些结构字段定义的影响。

## 总结

*   Bolt 协议的数据交换基于 **PackStream** 二进制序列化格式。
*   在 C++ 中，通用的 PackStream 数据由 `boltprotocol::Value` (一个 `std::variant`) 表示，它可以包含基本类型、`BoltList`、`BoltMap` 或 `PackStreamStructure`。
*   **Bolt 消息** 本质上是带有特定 `MessageTag` 的 `PackStreamStructure`。
*   使用库定义的 **`XxxMessageParams`** 结构体来方便地构造和访问消息的参数。
*   常见的图元和数据类型也有对应的 **强类型 C++ `struct`** (如 `BoltNode`)，并提供了与通用 `PackStreamStructure` 之间的转换机制。

理解这些核心概念是高效使用本库进行 Bolt 协议编程的基础。好的，这是第三个文档文件 `03-handshake-and-chunking.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/03-handshake-and-chunking.md`**

```markdown
# Bolt 握手与消息分块

在任何 Bolt 消息交换开始之前，客户端和服务器必须执行一次握手来协商协议版本。在握手成功后，所有消息的传输都将采用分块编码。本章详细介绍如何使用 BoltProtocol 库处理这两个过程。

## 1. Bolt 握手 (Handshake)

握手是 Bolt 连接的第一个步骤，用于客户端和服务器就后续通信将使用的 Bolt 协议版本达成一致。此过程不依赖于特定的 Bolt 消息版本。

### 版本表示 (`boltprotocol::versions::Version`)

Bolt 协议版本由 `boltprotocol::versions::Version` 结构体表示，其定义（概念性）如下：

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 主版本号
        uint8_t minor; // 次版本号

        // 构造函数，例如 Version(5, 4) 代表 Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        // 比较操作符 (<, ==, !=)
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;

        // 将版本转换为握手时发送的4字节数组 (大端序, 00 00 Maj Min)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 从服务器响应的4字节数组解析版本
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    // 预定义的版本常量，例如:
    // extern const Version V5_4; // (5,4)
    // extern const Version V5_3; // (5,3)
    // ... 等
} // namespace versions
} // namespace boltprotocol
```
您可以直接使用这些预定义的常量，如 `boltprotocol::versions::V5_4`。

### 握手相关函数

所有握手相关的函数和类型都在 `#include "boltprotocol/handshake.h"` 中声明。

*   **`std::vector<boltprotocol::versions::Version> boltprotocol::versions::get_default_proposed_versions();`**
    *   **描述**: 返回一个库预设的、客户端可以向服务器提议的 Bolt 版本列表。列表按偏好顺序（通常是最新的、最受支持的在前）排列。
    *   **返回值**: 一个包含 `Version` 对象的 `std::vector`。

*   **`boltprotocol::BoltError boltprotocol::perform_handshake(std::ostream& client_output_stream, std::istream& client_input_stream, const std::vector<boltprotocol::versions::Version>& proposed_versions, boltprotocol::versions::Version& out_negotiated_version);`**
    *   **描述**: 执行完整的 Bolt 握手流程。此函数会：
        1.  根据 `proposed_versions` 构建握手请求。
        2.  通过 `client_output_stream` 将20字节的握手请求（包括魔法序列 `6060B017` 和最多4个提议版本）发送给服务器。
        3.  通过 `client_input_stream` 从服务器读取4字节的握手响应。
        4.  解析服务器响应，并将协商成功的版本存储在 `out_negotiated_version` 中。
    *   **参数**:
        *   `client_output_stream`: 一个 `std::ostream&`，代表客户端向服务器发送数据的流（例如，网络套接字的输出流部分）。
        *   `client_input_stream`: 一个 `std::istream&`，代表客户端从服务器接收数据的流（例如，网络套接字的输入流部分）。
        *   `proposed_versions`: 一个 `const std::vector<boltprotocol::versions::Version>&`，包含客户端希望提议的协议版本。通常使用 `get_default_proposed_versions()` 的结果。
        *   `out_negotiated_version`: 一个 `boltprotocol::versions::Version&` 的引用，用于接收握手成功后服务器选择的版本。
    *   **返回值**:
        *   `boltprotocol::BoltError::SUCCESS`: 握手成功，`out_negotiated_version` 已填充。
        *   `boltprotocol::BoltError::INVALID_ARGUMENT`: 如果 `proposed_versions` 为空。
        *   `boltprotocol::BoltError::NETWORK_ERROR`: 在流读写过程中发生错误。
        *   `boltprotocol::BoltError::HANDSHAKE_NO_COMMON_VERSION`: 服务器返回全零 (`00 00 00 00`)，表示不支持客户端提议的任何版本。
        *   `boltprotocol::BoltError::UNSUPPORTED_PROTOCOL_VERSION`: 服务器返回的响应格式无法解析为一个有效的 Bolt 版本。
        *   其他可能的错误码。

### 握手流程示例

```cpp
#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h" // For BoltError and versions::Version constants
#include <iostream>
#include <sstream>   // 用于模拟网络流
#include <vector>
#include <array>     // 用于模拟服务器响应

int main() {
    std::stringstream client_to_server_pipe; 
    std::stringstream server_to_client_pipe; 
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError err;

    // 1. 客户端获取提议版本列表
    std::vector<boltprotocol::versions::Version> client_proposals = 
        boltprotocol::versions::get_default_proposed_versions();

    if (client_proposals.empty()) {
        std::cerr << "Client: No versions to propose." << std::endl;
        return 1;
    }
    std::cout << "Client: Proposing versions: ";
    for (const auto& v : client_proposals) {
        std::cout << (int)v.major << "." << (int)v.minor << " ";
    }
    std::cout << std::endl;

    // --- 模拟服务器端行为 ---
    // 假设服务器支持客户端提议的第一个版本 (例如 Bolt 5.4)
    boltprotocol::versions::Version server_supported_choice = client_proposals[0]; 
    std::array<uint8_t, boltprotocol::HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_data = 
        server_supported_choice.to_handshake_bytes();
    
    // 服务器将响应写入 "server_to_client_pipe"
    server_to_client_pipe.write(
        reinterpret_cast<const char*>(server_response_data.data()), 
        server_response_data.size()
    );
    // 模拟完毕后，确保服务器端的流准备好被客户端读取
    server_to_client_pipe.seekg(0); 
    // --- 服务器端行为模拟结束 ---

    // 2. 客户端执行握手
    std::cout << "Client: Performing handshake..." << std::endl;
    err = boltprotocol::perform_handshake(
        client_to_server_pipe,   // 客户端写数据到这里
        server_to_client_pipe,   // 客户端从这里读数据
        client_proposals,
        negotiated_version
    );

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "Client: Handshake successful!" << std::endl;
        std::cout << "Client: Negotiated Bolt Protocol Version: "
                  << static_cast<int>(negotiated_version.major) << "."
                  << static_cast<int>(negotiated_version.minor) << std::endl;
        // 后续通信应使用 negotiated_version
    } else {
        std::cerr << "Client: Handshake failed. Error code: " << static_cast<int>(err) << std::endl;
        // 根据错误码进行相应处理
        return 1;
    }

    // 此时，client_to_server_pipe 中包含了客户端发送的20字节握手数据
    // server_to_client_pipe 中的4字节响应数据已被 perform_handshake 读取完毕

    return 0;
}
```

## 2. 消息分块 (Chunking)

在成功的握手之后，所有 Bolt 消息（包括 HELLO 消息）都必须使用分块编码进行传输。分块机制允许将一条逻辑消息分割成一个或多个物理块进行传输。

### 分块规则

*   **块结构**: 每个块以一个 **2字节的块头** 开始。这个头部是一个无符号的、大端序的16位整数，表示紧随其后的数据块负载的大小（以字节为单位）。因此，单个块的最大负载大小是 65,535 字节 (0xFFFF)。
*   **消息结束标记**: 每条完整的 Bolt 消息在其所有数据块之后，必须以一个**零大小的块**作为结束。这个标记由两个字节 `00 00`（即块头声明大小为0）表示。它用于向接收方指示消息的边界。
*   **NOOP Chunk (Bolt 4.1+)**: 一个零大小的块 (`00 00`) 也可以在消息之间作为 NOOP (No Operation) 块发送，通常用于连接保活 (keep-alive)。

### 分块读写器接口

本库在 `#include "boltprotocol/chunking.h"` 中提供了处理分块的类。

*   **`boltprotocol::ChunkedWriter`**: 用于将一条完整的、已经过 PackStream 序列化的 Bolt 消息分块并写入输出流。
    *   **构造函数**: `ChunkedWriter(std::ostream& output_stream);`
        *   `output_stream`: 将分块数据写入的目标流。
    *   **核心方法**: `boltprotocol::BoltError write_message(const std::vector<uint8_t>& full_message_payload);`
        *   `full_message_payload`: 一个包含单条、完整、已 PackStream 序列化的 Bolt 消息的字节向量。
        *   此方法会自动将 `full_message_payload` 分割成一个或多个数据块（每个块不超过最大尺寸），为每个块添加2字节的块头，并在所有数据块之后写入 `00 00` 结束标记。
        *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::NETWORK_ERROR`）。

*   **`boltprotocol::ChunkedReader`**: 用于从输入流中读取分块数据，并将它们重新组装成一条完整的 Bolt 消息。
    *   **构造函数**: `ChunkedReader(std::istream& input_stream);`
        *   `input_stream`: 从中读取分块数据的来源流。
    *   **核心方法**: `boltprotocol::BoltError read_message(std::vector<uint8_t>& out_reconstructed_payload);`
        *   此方法会持续读取块（块头 + 块数据），直到遇到零大小的块 (`00 00`)。
        *   所有读取到的块负载数据会被聚合并存储在 `out_reconstructed_payload` 中。
        *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::NETWORK_ERROR`, `BoltError::CHUNK_DECODING_ERROR`, `BoltError::MESSAGE_TOO_LARGE`）。
        *   如果连续读取到 `00 00`（例如，一个消息结束标记后紧跟着一个 NOOP chunk），当为 NOOP chunk 调用 `read_message` 时，`out_reconstructed_payload` 将为空。

### 分块使用流程

1.  **准备消息负载**: 使用本库的消息序列化函数 (例如 `serialize_hello_message`) 将消息参数对象转换为 `std::vector<uint8_t>` 形式的 PackStream 字节流。
2.  **发送分块消息**:
    a.  创建 `ChunkedWriter` 实例，绑定到网络输出流。
    b.  调用 `writer.write_message()`，传入准备好的消息负载。
    c.  检查错误。
3.  **接收分块消息**:
    a.  创建 `ChunkedReader` 实例，绑定到网络输入流。
    b.  创建一个空的 `std::vector<uint8_t>` 来存储重组后的消息。
    c.  调用 `reader.read_message()`。
    d.  检查错误。
    e.  如果成功且接收到的向量不为空，这些字节就是完整的 PackStream 编码的 Bolt 消息，可以传递给相应的消息反序列化函数 (例如 `deserialize_success_message`) 进行处理。

**示例代码已在 `01-introduction.md` 中通过模拟流展示，请参考该示例了解具体调用方式。**

正确地使用握手和分块是 Bolt 协议通信的基础。本库的 `perform_handshake`, `ChunkedWriter`, 和 `ChunkedReader` 封装了这些过程的复杂性。
```好的，这是第四个文档文件 `04-message-serialization.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/04-message-serialization.md`**

```markdown
# Bolt 客户端消息序列化

本章详细介绍如何使用 BoltProtocol 库将 C++ 中的消息参数结构体序列化为可以通过网络发送给服务器的 Bolt 消息字节流。所有 Bolt 消息都使用 PackStream V1 格式进行序列化，并通过分块机制传输（分块处理见 `03-handshake-and-chunking.md`）。

所有客户端请求消息的序列化函数都在头文件 `#include "boltprotocol/message_serialization.h"` 中声明。

## 通用序列化流程

对于客户端发送的每一个请求消息，序列化过程通常如下：

1.  **包含必要的头文件**:
    ```cpp
    #include "boltprotocol/message_defs.h"     // 提供 XxxMessageParams 结构体, Value, versions::Version, MessageTag 等
    #include "boltprotocol/message_serialization.h" // 提供 serialize_xxx_message 函数声明
    #include "boltprotocol/packstream_writer.h"   // 提供 PackStreamWriter 类
    #include <vector>                           // 用于存储序列化后的字节
    ```
2.  **创建并填充参数结构体**:
    根据您要发送的消息类型，创建并填充相应的 `boltprotocol::XxxMessageParams` 结构体。例如，对于 `RUN` 消息，使用 `boltprotocol::RunMessageParams`。请参考每个消息的具体文档或 `bolt_message_params.h` 中的定义来了解其成员。
3.  **准备 `PackStreamWriter`**:
    实例化一个 `boltprotocol::PackStreamWriter` 对象。它需要一个输出目标来写入序列化后的字节。通常，这是一个 `std::vector<uint8_t>`。
    ```cpp
    std::vector<uint8_t> serialized_message_bytes;
    boltprotocol::PackStreamWriter writer(serialized_message_bytes);
    ```
4.  **调用序列化函数**:
    调用与消息类型对应的 `boltprotocol::serialize_xxx_message()` 函数。将准备好的参数结构体实例和 `PackStreamWriter` 实例传递给它。
    *   **版本依赖性**: 某些消息（如 `HELLO`, `RUN`, `BEGIN`, `ROUTE`）的结构或其 `extra` 字典中的字段会根据 Bolt 协议版本而变化。因此，这些消息的序列化函数需要一个额外的 `const boltprotocol::versions::Version& target_bolt_version` 参数，以指明应按照哪个 Bolt 版本的规范来构造消息。通常，这个版本是客户端与服务器握手后协商得到的版本，或者是客户端在发送 `HELLO` 时意图使用的版本。
5.  **错误检查**:
    所有序列化函数都返回一个 `boltprotocol::BoltError`。务必检查此返回值。如果不是 `boltprotocol::BoltError::SUCCESS`，则表示序列化过程中发生了错误。`PackStreamWriter` 对象内部也会记录错误状态，可以通过其 `has_error()` 和 `get_error()` 方法查询。
6.  **获取序列化数据**:
    如果序列化成功，并且 `PackStreamWriter` 的目标是 `std::vector<uint8_t>`，那么这个向量现在就包含了完整的、PackStream 编码的 Bolt 消息的字节负载。
    ```cpp
    // ... (接上例)
    // serialized_message_bytes 现在包含了可以发送给 ChunkedWriter 的数据。
    ```

## 支持的客户端请求消息及其序列化

以下是本库支持序列化的主要客户端请求消息的列表、它们的参数结构体关键成员以及对应的序列化函数签名。

---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)
*用于初始化连接，进行认证（Bolt < 5.1）和能力协商。*

*   **参数结构体**: `boltprotocol::HelloMessageParams`
    *   `user_agent` (std::string): **必需**. 客户端应用程序的用户代理字符串。
    *   `auth_scheme` (std::optional<std::string>): 认证方案，如 "basic", "none", "kerberos"。主要用于 Bolt < 5.1。
    *   `auth_principal` (std::optional<std::string>): 用户名，用于 "basic" 等方案。
    *   `auth_credentials` (std::optional<std::string>): 凭证（如密码），用于 "basic" 等方案。
    *   `auth_scheme_specific_tokens` (std::optional<std::map<std::string, Value>>): 其他特定认证方案的参数。
    *   `routing_context` (std::optional<std::map<std::string, Value>>): Bolt 4.1+。用于传递路由信息，例如 `{"address": "initial.host:port"}`。
    *   `patch_bolt` (std::optional<std::vector<std::string>>): Bolt 4.3-4.4。用于请求协议补丁，例如 `{"utc"}`。
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+。设置最小通知级别。
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+。禁用特定类别的通知。
    *   `bolt_agent` (std::optional<BoltAgentInfo>): Bolt 5.3+ **必需**. 包含驱动/库自身的信息。
        *   `BoltAgentInfo::product` (std::string): **必需**. 例如 "MyCppDriver/1.0"。
        *   `BoltAgentInfo::platform` (std::optional<std::string>): 例如 "Linux x86_64"。
        *   `BoltAgentInfo::language` (std::optional<std::string>): 例如 "C++20"。
        *   `BoltAgentInfo::language_details` (std::optional<std::string>): 例如 "GCC 11.3"。
    *   `other_extra_tokens` (std::map<std::string, Value>): 用于任何其他非标准或未来版本的 `extra` 字典参数。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_hello_message(
        const boltprotocol::HelloMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& client_target_version
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)
*用于 Bolt 5.1+ 的身份验证。*

*   **参数结构体**: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>): **必需**. 包含 `"scheme"` (必需, String) 以及该 scheme 所需的其他认证信息，例如：
        *   对于 `"basic"` scheme: `"principal"` (String), `"credentials"` (String).
        *   对于 `"bearer"` scheme: `"credentials"` (String, 包含 token).
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_logon_message(
        const boltprotocol::LogonMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)
*用于 Bolt 5.1+ 注销当前用户。*

*   **参数结构体**: `boltprotocol::LogoffMessageParams` (此结构体为空，因为 LOGOFF 消息没有参数字段。)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_logoff_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
    *注意*: 此函数不需要 `LogoffMessageParams` 类型的参数，因为它序列化的是一个没有字段的 PackStream Structure。

---

### 4. `RUN` (MessageTag::RUN - `0x10`)
*用于执行一个 Cypher 查询，可以用于自动提交事务或在显式事务内。*

*   **参数结构体**: `boltprotocol::RunMessageParams`
    *   `cypher_query` (std::string): **必需**. 要执行的 Cypher 查询语句。
    *   `parameters` (std::map<std::string, Value>): Cypher 查询的参数。
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+. 用于因果一致性的书签列表。
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+. 事务超时时间（毫秒）。
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+. 事务相关的元数据。
    *   `mode` (std::optional<std::string>): Bolt 3+. 事务访问模式 ("r" 表示只读，"w" 表示读写，默认为 "w")。仅用于自动提交事务。
    *   `db` (std::optional<std::string>): Bolt 4.0+. 指定要操作的数据库名称。
    *   `imp_user` (std::optional<std::string>): Bolt 4.4+. 模拟用户（仅用于自动提交的 RUN）。
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>): 其他自定义的 `extra` 字典字段。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_run_message(
        const boltprotocol::RunMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```
*   **注意**: `target_bolt_version` 用于确定 `extra` 字典中应包含哪些版本特定的字段。显式事务中的 `RUN` 消息的 `extra` 字段为空。

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)
*用于开始一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::BeginMessageParams`
    *   `bookmarks` (std::optional<std::vector<std::string>>): Bolt 3+.
    *   `tx_timeout` (std::optional<int64_t>): Bolt 3+.
    *   `tx_metadata` (std::optional<std::map<std::string, Value>>): Bolt 3+.
    *   `mode` (std::optional<std::string>): Bolt 3+ (默认为 "w" 如果不指定)。
    *   `db` (std::optional<std::string>): Bolt 4.0+.
    *   `imp_user` (std::optional<std::string>): Bolt 4.0+.
    *   `notifications_min_severity` (std::optional<std::string>): Bolt 5.2+.
    *   `notifications_disabled_categories` (std::optional<std::vector<std::string>>): Bolt 5.2+.
    *   `other_extra_fields` (std::map<std::string, Value>): 其他自定义 `extra` 字段。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_begin_message(
        const boltprotocol::BeginMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& target_bolt_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)
*用于从服务器拉取由 `RUN` 启动的查询结果流。在 Bolt 4.0 之前被称为 `PULL_ALL` 且无参数。*

*   **参数结构体**: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+)**. 要获取的记录数。`-1` 表示获取所有剩余记录。
    *   `qid` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+ 显式事务中的 PULL)**. 查询ID，用于标识要从哪个结果流拉取数据。对于自动提交事务或 Bolt 4.0 之前的 `PULL_ALL`，此字段可能不那么关键或默认为 `-1`。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_pull_message(
        const boltprotocol::PullMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 此函数序列化为 Bolt 4.0+ 的 PULL 格式（包含一个 `extra` map）。对于 Bolt < 4.0 的 `PULL_ALL`（没有字段），客户端需要发送一个空的 PSS (tag PULL, 0 fields)，这需要一个不同的序列化逻辑或此函数的版本判断。目前此函数假定 Bolt 4.0+ 格式。

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)
*用于丢弃服务器上由 `RUN` 启动的查询结果流中剩余的记录。在 Bolt 4.0 之前被称为 `DISCARD_ALL` 且无参数。*

*   **参数结构体**: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+)**. 要丢弃的记录数。`-1` 表示丢弃所有剩余记录。
    *   `qid` (std::optional<int64_t>): **必需 (对于 Bolt 4.0+ 显式事务中的 DISCARD)**. 查询ID。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_discard_message(
        const boltprotocol::DiscardMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 同 PULL。

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)
*用于提交一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::CommitMessageParams` (空结构体)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_commit_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: COMMIT 消息的 PackStream Structure 包含一个字段，该字段是一个空的 PackStream Map `{}`。

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)
*用于回滚一个显式事务 (Bolt 3+)。*

*   **参数结构体**: `boltprotocol::RollbackMessageParams` (空结构体)
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_rollback_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: 与 COMMIT 类似，包含一个空 map 字段。

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)
*用于将连接重置回初始状态（通常是 `READY` 或 `AUTHENTICATION` 状态，取决于版本）。*

*   **参数结构体**: 无
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_reset_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: RESET 消息的 PackStream Structure 没有字段。

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)
*客户端通知服务器它将优雅地关闭连接 (Bolt 3+)。服务器通常不响应此消息。*

*   **参数结构体**: 无
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_goodbye_message(
        boltprotocol::PackStreamWriter& writer
    );
    ```
*   **注意**: GOODBYE 消息的 PackStream Structure 没有字段。

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)
*用于从服务器获取路由信息 (Bolt 4.3+)。*

*   **参数结构体**: `boltprotocol::RouteMessageParams`
    *   `routing_table_context` (std::map<std::string, Value>): 包含路由上下文信息，如客户端的初始连接地址。对于 ROUTE V2，此 map 可能包含 `"db"` 和 `"imp_user"`。
    *   `bookmarks` (std::vector<std::string>): 用于会话一致性的书签。
    *   `db_name_for_v43` (std::optional<std::string>): **仅用于 Bolt 4.3**。作为 PackStream Structure 的第三个顶级字段。
    *   `extra_for_v44_plus` (std::optional<std::map<std::string, Value>>): **用于 Bolt 4.4+**。作为 PackStream Structure 的第三个顶级字段，此 map 可包含 `"db"` 和/或 `"imp_user"`。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_route_message(
        const boltprotocol::RouteMessageParams& params, 
        boltprotocol::PackStreamWriter& writer, 
        const boltprotocol::versions::Version& negotiated_bolt_version
    );
    ```
*   **注意**: `negotiated_bolt_version` 用于决定第三个顶级字段的结构（是 `db_name_for_v43` 还是 `extra_for_v44_plus`）。

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)
*用于向服务器发送驱动 API 使用情况的遥测数据 (Bolt 5.4+)。*

*   **参数结构体**: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>): **必需**. 必须包含一个键为 `"api"`，值为 `Integer` 的条目，表示使用的 API 类型。
*   **序列化函数**:
    ```cpp
    boltprotocol::BoltError serialize_telemetry_message(
        const boltprotocol::TelemetryMessageParams& params, 
        boltprotocol::PackStreamWriter& writer
    );
    ```

## 示例：序列化 HELLO 消息

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h" // For HelloMessageParams, Value, versions::Version etc.
#include "boltprotocol/packstream_writer.h"
#include <vector>
#include <iostream>

int main() {
    boltprotocol::HelloMessageParams hello_p;
    // 假设客户端目标版本是 Bolt 5.3
    boltprotocol::versions::Version target_version(5, 3);

    hello_p.user_agent = "MyAwesomeCppApp/1.0";
    
    // Bolt 5.3+ 需要 bolt_agent
    boltprotocol::HelloMessageParams::BoltAgentInfo agent;
    agent.product = "MyDriver/0.1";
    agent.platform = "Linux x64";
    agent.language = "C++20";
    hello_p.bolt_agent = agent;

    // Bolt 5.3 HELLO 中不包含认证信息 (应使用 LOGON)
    // hello_p.auth_scheme = "basic"; 
    // hello_p.auth_principal = "user";
    // hello_p.auth_credentials = "pass";

    std::map<std::string, boltprotocol::Value> routing_ctx;
    routing_ctx["address"] = boltprotocol::Value(std::string("client.initial.host:7687"));
    hello_p.routing_context = routing_ctx; // For Bolt 4.1+

    std::vector<uint8_t> serialized_bytes;
    boltprotocol::PackStreamWriter writer(serialized_bytes);

    boltprotocol::BoltError err = boltprotocol::serialize_hello_message(hello_p, writer, target_version);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "HELLO message serialized. Size: " << serialized_bytes.size() << std::endl;
        // serialized_bytes 可以传递给 ChunkedWriter
    } else {
        std::cerr << "HELLO serialization failed: " << static_cast<int>(err) << std::endl;
    }

    return 0;
}

```

通过使用这些函数和参数结构体，您可以方便地为各种 Bolt 客户端请求构建符合协议规范的 PackStream 字节流。务必根据您正在交互的服务器所支持的 Bolt 版本以及消息本身的规范来正确填充参数。
```好的，这是第五个文档文件 `05-message-deserialization.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/05-message-deserialization.md`**

```markdown
# Bolt 消息反序列化

本章详细介绍如何使用 BoltProtocol 库将从网络接收到的 Bolt 消息字节流（已通过 `ChunkedReader` 重组为完整的 PackStream 消息）反序列化为 C++ 中的参数结构体。这包括客户端解析服务器的响应消息，以及服务器端解析客户端的请求消息。

所有消息的反序列化函数都在头文件 `#include "boltprotocol/message_serialization.h"` 中声明。

## 通用反序列化流程

无论是客户端接收服务器响应，还是服务器接收客户端请求，反序列化一条 Bolt 消息通常遵循以下步骤：

1.  **包含必要的头文件**:
    ```cpp
    #include "boltprotocol/message_defs.h"     // 提供 XxxMessageParams 结构体, Value, versions::Version, MessageTag 等
    #include "boltprotocol/message_serialization.h" // 提供 deserialize_xxx_message 函数声明
    #include "boltprotocol/packstream_reader.h"   // 提供 PackStreamReader 类
    #include <vector>                           // 通常用于存储从 ChunkedReader 获取的字节
    ```
2.  **获取完整的消息字节**:
    使用 `boltprotocol::ChunkedReader` 从输入流中读取一个完整的、已去分块的 Bolt 消息，这将得到一个 `std::vector<uint8_t>` 类型的 `received_message_bytes`。
3.  **准备 `PackStreamReader`**:
    实例化一个 `boltprotocol::PackStreamReader` 对象，将其绑定到包含完整消息字节的向量。
    ```cpp
    // std::vector<uint8_t> received_message_bytes = ... (from ChunkedReader)
    boltprotocol::PackStreamReader reader(received_message_bytes);
    ```
4.  **确定消息类型并调用反序列化函数**:
    *   **如果已知道期望的消息类型**: 直接调用相应的 `boltprotocol::deserialize_xxx_message()` (用于客户端解析响应) 或 `boltprotocol::deserialize_xxx_message_request()` (用于服务器解析请求) 函数。这些函数内部会验证消息标签是否匹配。
    *   **如果需要动态判断消息类型**:
        a.  先读取通用的 `boltprotocol::Value`，并检查它是否为一个 `std::shared_ptr<boltprotocol::PackStreamStructure>`。
        b.  如果是，获取其 `tag` 字段，转换为 `boltprotocol::MessageTag`。
        c.  根据 `tag` 分发到对应的反序列化函数。
        d.  **重要**: 如果采用这种方式，在调用特定消息的反序列化函数之前，需要**重新**用原始的 `received_message_bytes` 构建一个新的 `PackStreamReader`，因为第一次读取 `Value` 会消耗流。或者，`deserialize_message_structure_prelude` 可以被用来更安全地提取顶层结构而不完全消耗，但这主要用于反序列化函数内部。对于外部判断，通常是读一次，然后根据类型决定下一步。更稳健的方式是有一个通用的消息分派机制。
    *   **版本依赖性**: 某些消息的反序列化函数（如 `HELLO`, `RUN`, `BEGIN`, `ROUTE` 的请求反序列化，以及特定结构如 `BoltDateTime` 的转换）需要传递当前连接协商的 Bolt 版本 (`const boltprotocol::versions::Version& negotiated_version`)，因为消息的字段或其解释可能依赖于此版本。

5.  **错误检查**:
    所有反序列化函数都返回一个 `boltprotocol::BoltError`。务必检查此返回值。如果不是 `boltprotocol::BoltError::SUCCESS`，则表示反序列化过程中发生了错误（例如，格式错误、数据不完整、标签不匹配、字段数量不对等）。`PackStreamReader` 对象内部也会记录错误状态。
6.  **访问反序列化后的参数**:
    如果反序列化成功，传递给函数的输出参数结构体（例如 `SuccessMessageParams& out_params`）现在就包含了从消息字节中解析出来的数据。

## A. 客户端解析服务器响应消息

这些函数由客户端用于解析从服务器接收到的响应。

---

### 1. `SUCCESS` (MessageTag::SUCCESS - `0x70`)
*表示请求已成功处理。*

*   **参数结构体 (输出)**: `boltprotocol::SuccessMessageParams`
    *   `metadata` (std::map<std::string, Value>): 包含服务器返回的各种元数据。具体内容取决于产生此 `SUCCESS` 的原始请求和 Bolt 版本。常见的键包括：
        *   `"fields"` (List<String>): 对于 `RUN` 的响应，列出结果集的字段名。
        *   `"qid"` (Integer): 对于显式事务中的 `RUN`，返回查询ID。
        *   `"t_first"` (Integer): 第一个记录可用的时间 (毫秒)。
        *   `"server"` (String): 服务器代理字符串 (例如 "Neo4j/5.10.0")。通常在 `HELLO` 的响应中。
        *   `"connection_id"` (String): 服务器端的连接标识符。通常在 `HELLO` 的响应中。
        *   `"bookmark"` (String): 对于自动提交事务或 `COMMIT` 的响应，返回事务书签。
        *   `"has_more"` (Boolean): 对于 `PULL`/`DISCARD` 的响应 (Bolt 4.0+)，指示是否还有更多记录。
        *   `"patch_bolt"` (List<String>): 对于 `HELLO` 的响应 (Bolt 4.3-4.4)，确认服务器接受的协议补丁。
        *   `"hints"` (Map): 对于 `HELLO` 的响应 (Bolt 4.3+)，服务器配置提示。
        *   ... 以及其他如 `type`, `db`, `plan`, `profile`, `stats` 等。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_success_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::SuccessMessageParams& out_params
    );
    ```

---

### 2. `FAILURE` (MessageTag::FAILURE - `0x7F`)
*表示请求处理失败。*

*   **参数结构体 (输出)**: `boltprotocol::FailureMessageParams`
    *   `metadata` (std::map<std::string, Value>): 包含错误信息。常见的键包括：
        *   `"code"` (String): Neo4j 错误码 (Bolt < 5.7)。
        *   `"message"` (String): 人类可读的错误描述。
        *   `"neo4j_code"` (String): Neo4j 错误码 (Bolt 5.7+)。
        *   `"gql_status"` (String): GQL 状态码 (Bolt 5.7+)。
        *   `"description"` (String): GQL 状态描述 (Bolt 5.7+)。
        *   `"diagnostic_record"` (Map): 诊断信息 (Bolt 5.7+)。
        *   `"cause"` (Map): 错误的内部原因 (Bolt 5.7+)。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_failure_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::FailureMessageParams& out_params
    );
    ```

---

### 3. `RECORD` (MessageTag::RECORD - `0x71`)
*包含查询结果集中的一条记录。*

*   **参数结构体 (输出)**: `boltprotocol::RecordMessageParams`
    *   `fields` (std::vector<Value>): 一个包含该记录所有字段值的列表。值的顺序与 `RUN` 响应的 `SUCCESS` 消息中 `"fields"` 元数据定义的顺序一致。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_record_message(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RecordMessageParams& out_params
    );
    ```

---

### 4. `IGNORED` (MessageTag::IGNORED - `0x7E`)
*表示服务器忽略了对应的请求（例如，当连接处于 `FAILED` 或 `INTERRUPTED` 状态时）。*

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_ignored_message(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: IGNORED 消息的 PackStream Structure 可以有0个字段，或者1个包含元数据 map 的字段。此函数主要验证消息结构。

---

## B. 服务器解析客户端请求消息

这些函数由服务器端用于解析从客户端接收到的请求。

---

### 1. `HELLO` (MessageTag::HELLO - `0x01`)

*   **参数结构体 (输出)**: `boltprotocol::HelloMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_hello_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::HelloMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version // 服务器期望或已协商的版本
    );
    ```

---

### 2. `LOGON` (MessageTag::LOGON - `0x6A`)

*   **参数结构体 (输出)**: `boltprotocol::LogonMessageParams`
    *   `auth_tokens` (std::map<std::string, Value>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_logon_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::LogonMessageParams& out_params
    );
    ```

---

### 3. `LOGOFF` (MessageTag::LOGOFF - `0x6B`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_logoff_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```

---

### 4. `RUN` (MessageTag::RUN - `0x10`)

*   **参数结构体 (输出)**: `boltprotocol::RunMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_run_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RunMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 5. `BEGIN` (MessageTag::BEGIN - `0x11`)

*   **参数结构体 (输出)**: `boltprotocol::BeginMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_begin_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::BeginMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```

---

### 6. `PULL` (MessageTag::PULL - `0x3F`)

*   **参数结构体 (输出)**: `boltprotocol::PullMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_pull_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::PullMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 此函数会根据 `server_negotiated_version` 判断是 Bolt < 4.0 的 `PULL_ALL` (0个字段) 还是 Bolt 4.0+ 的 `PULL` (1个 `extra` map 字段)。

---

### 7. `DISCARD` (MessageTag::DISCARD - `0x2F`)

*   **参数结构体 (输出)**: `boltprotocol::DiscardMessageParams`
    *   `n` (std::optional<int64_t>)
    *   `qid` (std::optional<int64_t>)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_discard_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::DiscardMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 同 PULL。

---

### 8. `COMMIT` (MessageTag::COMMIT - `0x12`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_commit_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为1个字段（空 map）。

---

### 9. `ROLLBACK` (MessageTag::ROLLBACK - `0x13`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_rollback_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 同 COMMIT。

---

### 10. `RESET` (MessageTag::RESET - `0x0F`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_reset_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为0个字段。

---

### 11. `GOODBYE` (MessageTag::GOODBYE - `0x02`)

*   **参数结构体**: 无。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_goodbye_message_request(
        boltprotocol::PackStreamReader& reader
    );
    ```
*   **注意**: 验证 PackStream Structure 为0个字段。

---

### 12. `ROUTE` (MessageTag::ROUTE - `0x66`)

*   **参数结构体 (输出)**: `boltprotocol::RouteMessageParams` (成员已在客户端序列化部分描述)
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_route_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::RouteMessageParams& out_params, 
        const boltprotocol::versions::Version& server_negotiated_version
    );
    ```
*   **注意**: 根据 `server_negotiated_version` 解析第三个字段是 `db_name` (Bolt 4.3) 还是 `extra` map (Bolt 4.4+)。

---

### 13. `TELEMETRY` (MessageTag::TELEMETRY - `0x54`)

*   **参数结构体 (输出)**: `boltprotocol::TelemetryMessageParams`
    *   `metadata` (std::map<std::string, Value>): 应包含 `"api"` (Integer) 键。
*   **反序列化函数**:
    ```cpp
    boltprotocol::BoltError deserialize_telemetry_message_request(
        boltprotocol::PackStreamReader& reader, 
        boltprotocol::TelemetryMessageParams& out_params
    );
    ```

## 反序列化示例 (客户端解析 RECORD 消息)

```cpp
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include <vector>
#include <iostream>

// 假设 received_record_bytes 是从 ChunkedReader 获取的 RECORD 消息的字节
// std::vector<uint8_t> received_record_bytes = ...; 

void process_record_message(const std::vector<uint8_t>& received_record_bytes) {
    boltprotocol::PackStreamReader reader(received_record_bytes);
    boltprotocol::RecordMessageParams record_data;
    boltprotocol::BoltError err = boltprotocol::deserialize_record_message(reader, record_data);

    if (err == boltprotocol::BoltError::SUCCESS) {
        std::cout << "RECORD message deserialized. Number of fields: " << record_data.fields.size() << std::endl;
        for (size_t i = 0; i < record_data.fields.size(); ++i) {
            const auto& fieldValue = record_data.fields[i];
            // 根据 fieldValue 的实际类型 (通过 std::holds_alternative 和 std::get) 进行处理
            if (std::holds_alternative<std::string>(fieldValue)) {
                std::cout << "  Field " << i << " (String): " << std::get<std::string>(fieldValue) << std::endl;
            } else if (std::holds_alternative<int64_t>(fieldValue)) {
                std::cout << "  Field " << i << " (Integer): " << std::get<int64_t>(fieldValue) << std::endl;
            } // ... 其他类型 ...
        }
    } else {
        std::cerr << "Failed to deserialize RECORD message, error: " << static_cast<int>(err) << std::endl;
    }
}
```
正确使用这些反序列化函数，并结合版本信息（如果需要），可以帮助您的应用程序或服务器正确地解析和理解 Bolt 协议消息。
```好的，这是第六个文档文件 `06-structure-types-and-conversions.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/06-structure-types-and-conversions.md`**

```markdown
# 特定 PackStream 结构类型与转换

Bolt 协议不仅使用 PackStream 传输顶层的请求和响应消息，还在这些消息的字段中（例如，`RECORD` 消息的数据，或 `RUN` 消息的参数）使用 PackStream Structure 来表示图数据库中的核心实体（如节点、关系、路径）以及特定的数据类型（如日期、时间、空间点等）。

为了方便在 C++ 中以类型安全和面向对象的方式操作这些常见的结构化数据，BoltProtocol 库提供了：

1.  **强类型的 C++ 结构体**: 为每种标准的 PackStream Structure 定义了对应的 C++ `struct`。
2.  **转换函数**: 用于在通用的 `boltprotocol::PackStreamStructure` (通常通过 `std::shared_ptr` 持有，并包含在 `boltprotocol::Value` 中) 与这些强类型 C++ 结构体之间进行双向转换。

所有强类型结构体定义在 `#include "boltprotocol/bolt_structure_types.h"` (它被聚合头文件 `boltprotocol/message_defs.h` 包含)。
所有转换函数声明在 `#include "boltprotocol/bolt_structure_serialization.h"`。

## 1. 支持的强类型 C++ 结构体

以下是本库目前支持的强类型 C++ 结构体及其对应的 PackStream 标签和关键成员。请注意，某些结构的字段会随 Bolt 版本变化（例如 `element_id` 在 Bolt 5.0+ 中为图元添加）。转换函数会考虑这些版本差异。

### 图元 (Graph Primitives)

*   **`boltprotocol::BoltNode`** (PackStream Tag: `0x4E 'N'`)
    *   `int64_t id;`
    *   `std::vector<std::string> labels;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltRelationship`** (PackStream Tag: `0x52 'R'`)
    *   `int64_t id;`
    *   `int64_t start_node_id;`
    *   `int64_t end_node_id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> start_node_element_id;` (Bolt 5.0+)
    *   `std::optional<std::string> end_node_element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltUnboundRelationship`** (PackStream Tag: `0x72 'r'`)
    *   *用于 `BoltPath` 内部，表示不含端点的关系。*
    *   `int64_t id;`
    *   `std::string type;`
    *   `std::map<std::string, Value> properties;`
    *   `std::optional<std::string> element_id;` (Bolt 5.0+)

*   **`boltprotocol::BoltPath`** (PackStream Tag: `0x50 'P'`)
    *   `std::vector<BoltNode> nodes;`
    *   `std::vector<BoltUnboundRelationship> rels;`
    *   `std::vector<int64_t> indices;` (描述路径如何由节点和关系构成)

### 时间类型 (Temporal Types)

*   **`boltprotocol::BoltDate`** (PackStream Tag: `0x44 'D'`)
    *   `int64_t days_since_epoch;` (自 Unix 纪元以来的天数)

*   **`boltprotocol::BoltTime`** (PackStream Tag: `0x54 'T'`)
    *   `int64_t nanoseconds_since_midnight;` (相对于给定偏移量的午夜以来的纳秒数)
    *   `int32_t tz_offset_seconds;` (距 UTC 的秒数偏移量)

*   **`boltprotocol::BoltLocalTime`** (PackStream Tag: `0x74 't'`)
    *   `int64_t nanoseconds_since_midnight;` (本地午夜以来的纳秒数，无时区信息)

*   **`boltprotocol::BoltDateTime`** (PackStream Tag: `0x49 'I'` (现代) / `0x46 'F'` (遗留))
    *   `int64_t seconds_epoch_utc;` (自 Unix 纪元以来的 UTC 秒数)
    *   `int32_t nanoseconds_of_second;` (秒内的纳秒部分, 0-999,999,999)
    *   `int32_t tz_offset_seconds;` (原始时间的 UTC 秒数偏移量)

*   **`boltprotocol::BoltDateTimeZoneId`** (PackStream Tag: `0x69 'i'` (现代) / `0x66 'f'` (遗留))
    *   `int64_t seconds_epoch_utc;` (自 Unix 纪元以来的 UTC 秒数。**注意**: 对于从遗留 'f' 格式反序列化，此字段可能包含已调整的秒数，而非纯 UTC，需上层结合 TZDB 处理。)
    *   `int32_t nanoseconds_of_second;`
    *   `std::string tz_id;` (时区标识符，如 "Europe/Paris")

*   **`boltprotocol::BoltLocalDateTime`** (PackStream Tag: `0x64 'd'`)
    *   `int64_t seconds_epoch_local;` (自 Unix 纪元以来的秒数，解释为本地日期时间)
    *   `int32_t nanoseconds_of_second;`

*   **`boltprotocol::BoltDuration`** (PackStream Tag: `0x45 'E'`)
    *   `int64_t months;`
    *   `int64_t days;`
    *   `int64_t seconds;`
    *   `int32_t nanoseconds;` (秒的纳秒调整部分)

### 空间类型 (Spatial Types)

*   **`boltprotocol::BoltPoint2D`** (PackStream Tag: `0x58 'X'`)
    *   `uint32_t srid;` (空间参考系统标识符)
    *   `double x;`
    *   `double y;`

*   **`boltprotocol::BoltPoint3D`** (PackStream Tag: `0x59 'Y'`)
    *   `uint32_t srid;`
    *   `double x;`
    *   `double y;`
    *   `double z;`

## 2. 转换函数

这些函数用于在通用的 `boltprotocol::PackStreamStructure` 和上述强类型 C++ 结构体之间进行转换。

### A. 从 `PackStreamStructure` 转换为强类型 (`from_packstream`)

这些函数通常在接收到包含特定结构的数据后（例如，在 `RECORD` 消息的字段中）调用。

*   **通用函数签名模式**:
    ```cpp
    boltprotocol::BoltError from_packstream(
        const boltprotocol::PackStreamStructure& pss, 
        TypedStruct& out_struct, 
        /* 可选参数: const boltprotocol::versions::Version& bolt_version (用于版本依赖的结构) */
    );
    ```
    *   `pss`: 输入的、从 PackStream 反序列化得到的通用结构。
    *   `out_struct`: 输出参数，用于填充转换后的强类型结构数据。
    *   `bolt_version`: 对于字段随 Bolt 版本变化的结构（如 `BoltNode`, `BoltRelationship`, `BoltDateTime`），需要提供此参数。
    *   **返回值**: `BoltError::SUCCESS` 或错误码（如 `BoltError::INVALID_MESSAGE_FORMAT` 如果标签或字段不匹配）。

*   **示例函数**:
    *   `from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDate& out_date);`
    *   `from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);`
    *   ... (其他类型的对应函数)

### B. 将强类型转换为 `PackStreamStructure` (`to_packstream`)

这些函数用于客户端需要构造特定类型的结构（例如，作为 Cypher 查询的参数）并将其发送给服务器的场景。

*   **通用函数签名模式**:
    ```cpp
    boltprotocol::BoltError to_packstream(
        const TypedStruct& typed_struct, 
        /* 可选参数: const boltprotocol::versions::Version& bolt_version, */
        /* 可选参数: bool utc_patch_active_for_4_4, (仅用于 BoltDateTime/ZoneId 和 Bolt 4.4) */
        std::shared_ptr<PackStreamStructure>& out_pss_sptr 
    );
    ```
    *   `typed_struct`: 输入的强类型 C++ 结构体实例。
    *   `bolt_version`, `utc_patch_active_for_4_4`: 用于确保序列化为目标 Bolt 版本兼容的格式，特别是对于 DateTime 和 DateTimeZoneId。
    *   `out_pss_sptr`: 输出参数，将被填充为一个新创建的、包含序列化数据的 `std::shared_ptr<PackStreamStructure>`。这个 `shared_ptr` 可以包装在 `Value` 中用于更高层的消息构造。
    *   **返回值**: `BoltError::SUCCESS` 或错误码。

*   **示例函数**:
    *   `to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   `to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);`
    *   ... (其他类型的对应函数)

### C. 从 `Value` 到强类型的便捷模板 (`value_to_typed_struct`)

为了简化从一个通用的 `boltprotocol::Value`（它可能持有一个 `std::shared_ptr<PackStreamStructure>`）到强类型结构的转换，提供了一个模板函数：

*   **函数签名**:
    ```cpp
    // 主要版本，用于需要版本和/或补丁信息的类型
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct, 
        const boltprotocol::versions::Version& bolt_version, 
        bool utc_patch_active_for_4_4 = false // 默认为false
    );

    // 重载版本，用于不需要版本或补丁信息的简单类型 (如 BoltDate)
    template<typename T_StrongType>
    boltprotocol::BoltError value_to_typed_struct(
        const boltprotocol::Value& value, 
        T_StrongType& out_typed_struct
    );
    ```
*   **行为**:
    1.  检查 `value` 是否确实持有一个 `std::shared_ptr<PackStreamStructure>`。
    2.  如果是，并且指针非空，则调用相应的 `from_packstream` 重载。
    3.  返回 `from_packstream` 的结果。
*   **使用示例**:
    ```cpp
    // 假设 record_field 是从 RecordMessageParams::fields 中获取的一个 Value
    // boltprotocol::Value record_field = ...;
    // boltprotocol::versions::Version current_bolt_version = ...;
    // bool is_utc_patch_active_for_4_4 = ...; // (例如从会话状态获取)

    boltprotocol::BoltNode node;
    boltprotocol::BoltError err_node = boltprotocol::value_to_typed_struct(record_field, node, current_bolt_version);
    if (err_node == boltprotocol::BoltError::SUCCESS) {
        // 使用 node
    }

    boltprotocol::BoltDate date_obj;
    boltprotocol::BoltError err_date = boltprotocol::value_to_typed_struct(record_field, date_obj); // Date转换不需要版本
    if (err_date == boltprotocol::BoltError::SUCCESS) {
        // 使用 date_obj
    }

    boltprotocol::BoltDateTime datetime_obj;
    // DateTime 转换需要版本，并且如果 bolt_version 是 4.4，还需要 utc_patch_active_for_4_4
    boltprotocol::BoltError err_dt = boltprotocol::value_to_typed_struct(record_field, datetime_obj, current_bolt_version, is_utc_patch_active_for_4_4);
    if (err_dt == boltprotocol::BoltError::SUCCESS) {
        // 使用 datetime_obj (注意，from_packstream for DateTime/ZoneId 本身是基于标签的，utc_patch主要影响to_packstream)
        // 但提供版本信息给from_packstream总是个好习惯，以防未来有更细微的版本依赖。
    }
    ```

## 版本和补丁的注意事项

*   **图元版本**: `BoltNode`, `BoltRelationship`, `BoltUnboundRelationship` 的字段（特别是 `element_id` 相关的）在 Bolt 5.0 中有变化。它们的转换函数需要 `bolt_version` 参数。
*   **DateTime 和 DateTimeZoneId**:
    *   Bolt 5.0 引入了新的结构 (tag 'I' 和 'i') 取代了遗留的结构 (tag 'F' 和 'f')。
    *   Bolt 4.4 版本可以通过 `HELLO` 消息协商 `"utc"` 补丁来使用新的（现代的）结构。
    *   `from_packstream` 函数会根据读取到的 PackStream Structure 的**标签**来决定按现代还是遗留格式解析。
    *   `to_packstream` 函数则需要 `bolt_version` 和 `utc_patch_active_for_4_4` (当版本为4.4时) 参数来决定序列化为哪种格式（现代还是遗留）。
    *   **遗留 `DateTimeZoneId` (tag 'f') 的复杂性**: 将其 `seconds` 字段（它是本地调整过的秒数）正确转换为纯 UTC 秒数，或者从纯 UTC 秒数和 `tz_id` 正确构造出遗留格式所需的本地调整秒数，都需要访问时区数据库 (TZDB)。本库不包含 TZDB，因此在处理遗留 `DateTimeZoneId` 时存在固有的不精确性，相关函数实现中已包含注释说明。

通过使用这些强类型结构和转换函数，可以极大地简化应用程序与 Bolt 协议中这些常见数据结构交互的复杂性，并提高代码的类型安全性和可读性。
```

---

**7. `Base/Protocol/BoltProtocol/Document/07-error-handling.md`** (已在上一轮提供，保持不变)
**8. `Base/Protocol/BoltProtocol/Document/08-versioning.md`** (已在上一轮提供，保持不变)

这些文档应该能让用户在不直接查阅头文件的情况下，理解如何使用库的核心功能，包括特定结构类型的处理。好的，这是第七个文档文件 `07-error-handling.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/07-error-handling.md`**

```markdown
# BoltProtocol 库错误处理

BoltProtocol 库采用基于返回值的错误处理机制，以确保与各种项目（包括不使用或有特定异常处理策略的项目）的良好集成性。所有可能失败的操作都会返回一个 `boltprotocol::BoltError` 枚举类型的值。

## 1. `boltprotocol::BoltError` 枚举

`BoltError` 枚举定义了库中可能发生的各种错误情况。它在头文件 `boltprotocol/bolt_errors_versions.h` 中定义（该头文件由聚合头文件 `boltprotocol/message_defs.h` 包含）。

以下是一些关键的错误码及其含义：

*   **`BoltError::SUCCESS` (值为 0)**:
    *   表示操作成功完成，没有发生错误。

*   **通用错误**:
    *   `BoltError::UNKNOWN_ERROR`: 发生了未分类或意外的错误。
    *   `BoltError::INVALID_ARGUMENT`: 提供给函数的参数无效（例如，空指针、超出范围的值）。
    *   `BoltError::OUT_OF_MEMORY`: 在操作过程中无法分配所需的内存。

*   **序列化/反序列化错误**:
    *   `BoltError::SERIALIZATION_ERROR`: 将 C++ 对象序列化为 PackStream 字节流时出错（例如，字符串过长、数据结构不符合规范）。
    *   `BoltError::DESERIALIZATION_ERROR`: 从 PackStream 字节流反序列化为 C++ 对象时出错（例如，数据格式损坏、意外的字节序列、数据不完整）。
    *   `BoltError::INVALID_MESSAGE_FORMAT`: 接收到的消息的 PackStream Structure 不符合预期（例如，消息标签错误、字段数量不正确、字段类型不匹配）。
    *   `BoltError::RECURSION_DEPTH_EXCEEDED`: 在解析或序列化深度嵌套的 PackStream 结构（如 List, Map, Structure）时，超出了库设定的最大递归深度，以防止栈溢出。
    *   `BoltError::MESSAGE_TOO_LARGE`: 尝试处理的消息（或其组成部分，如字符串）的大小超出了实现或协议的限制。

*   **网络与连接错误**:
    *   `BoltError::NETWORK_ERROR`: 底层网络流操作（读/写）失败。这可能表示连接已关闭、网络中断或其他 I/O 问题。

*   **握手 (Handshake) 错误**:
    *   `BoltError::HANDSHAKE_FAILED`: 握手过程总体失败。
    *   `BoltError::HANDSHAKE_NO_COMMON_VERSION`: 服务器不支持客户端提议的任何 Bolt 协议版本。
    *   `BoltError::HANDSHAKE_MAGIC_MISMATCH`: （理论上，如果实现此检查）客户端发送的魔法序列与 Bolt 协议不符。
    *   `BoltError::UNSUPPORTED_PROTOCOL_VERSION`: 服务器返回了一个无法识别或不支持的协议版本格式。

*   **分块 (Chunking) 错误**:
    *   `BoltError::CHUNK_TOO_LARGE`: （理论上）单个数据块声明的大小超过了允许的最大值 (65535 字节)。
    *   `BoltError::CHUNK_ENCODING_ERROR`: 在将消息编码为分块时发生内部错误。
    *   `BoltError::CHUNK_DECODING_ERROR`: 在从分块数据重组消息时发生错误（例如，块大小与实际数据不符）。

## 2. 检查函数返回值

库中绝大多数执行实际操作的函数（如序列化、反序列化、握手、分块读写）都会返回一个 `BoltError` 类型的值。**使用者必须检查这些函数的返回值，以确定操作是否成功。**

**标准用法**:
```cpp
#include "boltprotocol/message_defs.h" // For BoltError
#include <iostream>

// 假设 some_bolt_operation 是库中的一个函数
// boltprotocol::BoltError result = some_bolt_operation(args...);

// if (result != boltprotocol::BoltError::SUCCESS) {
//     std::cerr << "Bolt operation failed with error code: " 
//               << static_cast<int>(result) << std::endl;
//     // 在此根据具体的 result 值采取相应的错误处理措施，
//     // 例如记录日志、重试、关闭连接或向上传递错误。
// } else {
//     // 操作成功，可以继续。
// }
```

## 3. `PackStreamReader` 和 `PackStreamWriter` 的内部错误状态

`PackStreamReader` 和 `PackStreamWriter` 对象（以及 `ChunkedReader` 和 `ChunkedWriter`）内部维护一个错误状态。一旦在其操作过程中发生错误，它们的内部错误状态会被设置。后续对同一对象的读/写操作通常会立即失败，并返回之前记录的错误码（或一个新的相关错误码）。

您可以使用以下成员函数来查询这些对象的错误状态：

*   **`bool has_error() const;`**:
    *   如果对象内部已记录错误，则返回 `true`，否则返回 `false`。
*   **`boltprotocol::BoltError get_error() const;`**:
    *   返回对象内部记录的 `BoltError` 值。如果 `has_error()` 为 `false`，则此函数返回 `BoltError::SUCCESS`。

**使用示例**:
```cpp
#include "boltprotocol/packstream_writer.h"
#include "boltprotocol/message_defs.h" // For Value, BoltError
#include <vector>
#include <string>
#include <iostream>

// std::vector<uint8_t> buffer;
// boltprotocol::PackStreamWriter writer(buffer);
// boltprotocol::Value val1(std::string("test"));
// boltprotocol::Value val2(12345LL);

// writer.write(val1); // 假设第一次写入成功
// writer.write(val2); // 假设第二次写入也成功

// // 可以在一系列操作后检查最终状态
// if (writer.has_error()) {
//     boltprotocol::BoltError final_error = writer.get_error();
//     std::cerr << "PackStreamWriter encountered an error during operations: " 
//               << static_cast<int>(final_error) << std::endl;
// } else {
//     std::cout << "All PackStream writes successful." << std::endl;
// }
```
虽然每个单独的 `write` 或 `read` 操作都会返回错误码，但在执行了一系列操作后检查对象的整体错误状态也是一种有用的模式。

## 4. 关于 C++ 异常

BoltProtocol 库的设计目标是**不主动向上层调用者抛出 C++ 异常**。它通过返回 `BoltError` 枚举值来报告所有已知的操作失败。

然而，库的内部实现依赖于标准 C++ 库，例如 `std::vector`, `std::string`, `std::map` 的内存分配，以及流操作。在极端情况下（例如系统内存耗尽），这些标准库组件可能会抛出异常（最常见的是 `std::bad_alloc`）。

*   **库内部的异常捕获**: 本库会尽力在其内部实现中捕获由标准库操作（特别是内存分配）直接引起的常见异常，如 `std::bad_alloc`，并将其转换为相应的 `BoltError`（例如 `BoltError::OUT_OF_MEMORY`）返回给调用者。
*   **未捕获的异常**: 如果发生了库未能预见或捕获的异常，或者异常源于用户代码（例如，在提供给库的回调函数中，尽管本库目前不采用回调模式），则这些异常可能会传播到库的调用者之外。应用程序应具备处理此类情况的常规异常处理机制。

总而言之，您应该主要依赖检查 `BoltError` 返回值来处理本库的错误，而不是期望捕获来自本库的特定 C++ 异常。

## 5. 错误恢复策略 (上层应用的职责)

本库提供错误信息，但具体的错误恢复策略由使用本库的上层应用程序或驱动程序来决定。

*   **可恢复错误**: 某些错误可能是暂时的（例如，某些类型的 `BoltError::NETWORK_ERROR` 可能通过重试解决）。
*   **致命错误**: 许多错误，特别是与协议格式、序列化/反序列化相关的错误（如 `BoltError::INVALID_MESSAGE_FORMAT`, `BoltError::DESERIALIZATION_ERROR`）或严重的连接问题，通常被认为是致命的，至少对于当前的 Bolt 会话/连接而言。在这种情况下，推荐的策略通常是：
    1.  记录详细的错误信息。
    2.  安全地关闭当前的 Bolt 连接。
    3.  （可选）尝试建立一个新的连接和会话。
    4.  向上层或用户报告错误。

## 总结

*   **检查返回值**: 这是使用 BoltProtocol 库时最重要的错误处理步骤。
*   **理解错误码**: 熟悉 `BoltError` 枚举中不同值的含义。
*   **读写器状态**: 可以使用 `has_error()` 和 `get_error()` 检查读写器对象的累积错误状态。
*   **异常**: 库本身不抛出异常，但依赖的标准库在极端情况下可能抛出。

通过仔细处理 `BoltError` 返回值，您可以构建出能够稳健处理各种通信和数据处理问题的应用程序。
```好的，这是第八个文档文件 `08-versioning.md` 的完整内容。

---

**`Base/Protocol/BoltProtocol/Document/08-versioning.md`**

```markdown
# Bolt 版本处理

Bolt 协议是一个多版本协议，客户端和服务器需要在通信开始时通过握手过程协商一个共同支持的协议版本。这个协商得到的版本将决定后续消息交换的格式和行为。BoltProtocol 库提供了处理版本信息和版本相关逻辑的机制。

## 1. 版本表示 (`boltprotocol::versions::Version`)

Bolt 协议版本由 `boltprotocol::versions::Version` 结构体表示，其定义（在 `boltprotocol/bolt_errors_versions.h` 中，通过 `boltprotocol/message_defs.h` 聚合包含）如下：

```cpp
namespace boltprotocol {
namespace versions {
    struct Version {
        uint8_t major; // 主版本号
        uint8_t minor; // 次版本号

        // 默认构造函数 (通常初始化为 0.0 或无效状态)
        Version(); 

        // 构造特定版本，例如 Version(5, 4) 代表 Bolt 5.4
        constexpr Version(uint8_t maj, uint8_t min);

        // 比较操作符
        bool operator<(const Version& other) const;
        bool operator==(const Version& other) const;
        bool operator!=(const Version& other) const;
        // >=, >, <= 可以通过 < 和 == 组合实现，或显式提供

        // 用于握手：将版本对象转换为4字节大端序数组 (格式通常为 00 00 Major Minor)
        std::array<uint8_t, 4> to_handshake_bytes() const;

        // 用于握手：从服务器响应的4字节数组解析版本对象
        static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
    };

    // 预定义的常见 Bolt 版本常量
    extern const Version V5_4; // (5,4)
    extern const Version V5_3; // (5,3)
    extern const Version V5_2; // (5,2)
    extern const Version V5_1; // (5,1)
    extern const Version V5_0; // (5,0)
    extern const Version V4_4; // (4,4)
    // ... 以及其他可能定义的版本

    // 获取库推荐的客户端提议版本列表
    extern const std::vector<Version>& get_default_proposed_versions();

} // namespace versions
} // namespace boltprotocol
```

您可以使用这些预定义的常量（如 `boltprotocol::versions::V5_4`）或构造自己的 `Version` 对象。比较操作符允许您轻松地判断版本的先后。

## 2. 握手与版本协商

连接建立后的第一步是**握手**，其目的是协商后续通信所使用的 Bolt 协议版本。详细的握手过程和 API 使用方法在 `03-handshake-and-chunking.md` 中有详细描述。

关键函数是 `boltprotocol::perform_handshake()`，它会：
1.  接收客户端希望提议的版本列表 (`std::vector<boltprotocol::versions::Version>`)。
2.  向服务器发送握手请求。
3.  接收服务器的响应。
4.  将服务器选择的、双方共同支持的版本填充到输出参数 `boltprotocol::versions::Version& out_negotiated_version` 中。

这个 `out_negotiated_version` **至关重要**，因为库中的许多后续操作（特别是消息的序列化和反序列化）都需要这个版本信息来确保与服务器的兼容性。

## 3. 版本对消息结构和行为的影响

Bolt 协议的许多方面都会随版本而演变。了解这些差异并使用协商得到的版本信息是正确实现 Bolt 通信的基础。本库在内部处理了许多这样的版本差异，但需要您在调用相关函数时提供正确的版本上下文。

主要受版本影响的方面包括：

*   **消息结构与字段**:
    *   **`HELLO` 消息**:
        *   Bolt 5.1 之前：认证信息（scheme, principal, credentials）在 HELLO 的 `extra` map 中。
        *   Bolt 5.1 及之后：认证信息移至单独的 `LOGON` 消息。
        *   Bolt 4.1+：`extra` map 中可包含 `routing` 字典。
        *   Bolt 4.3-4.4：`extra` map 中可包含 `patch_bolt` 列表 (如 `"utc"`)。
        *   Bolt 5.2+：`extra` map 中可包含 `notifications_minimum_severity` 和 `notifications_disabled_categories`。
        *   Bolt 5.3+：`extra` map 中**必须**包含 `bolt_agent` 字典。
    *   **`RUN` 和 `BEGIN` 消息**: 其 `extra` map 中可包含的字段（如 `db`, `imp_user`, `tx_timeout`, `mode`, `bookmarks`, `notifications_...`）在不同 Bolt 版本中被引入。
    *   **`PULL` 和 `DISCARD` 消息**:
        *   Bolt 4.0 之前：被称为 `PULL_ALL` 和 `DISCARD_ALL`，其 PackStream Structure 没有字段。
        *   Bolt 4.0 及之后：重命名为 `PULL` 和 `DISCARD`，其 PackStream Structure 包含一个 `extra` map 字段，该 map 包含 `n` 和 `qid` 参数。
    *   **`ROUTE` 消息**:
        *   Bolt 4.3：PackStream Structure 的第三个字段是 `db` (String 或 Null)。
        *   Bolt 4.4 及之后：PackStream Structure 的第三个字段是一个 `extra` Map (可包含 `db`, `imp_user`)。
    *   **`LOGON`, `LOGOFF`, `TELEMETRY`**: 这些消息是在特定 Bolt 版本之后才引入的。

*   **PackStream 特定结构体字段**:
    *   例如，`BoltNode`, `BoltRelationship`, `BoltUnboundRelationship` 结构体中的 `element_id` 相关字段是在 Bolt 5.0 中添加的。
    *   `BoltDateTime` 和 `BoltDateTimeZoneId` 结构：Bolt 5.0 引入了新的、修正了问题的结构 (标签 'I', 'i')，取代了旧的遗留结构 (标签 'F', 'f')。Bolt 4.4 版本可以通过协商 `"utc"` patch 来使用新的结构。

*   **服务器行为**:
    *   例如，服务器对 `ROUTE` 消息的响应（特别是 `rt` 路由表中的 `db` 字段）在 Bolt 4.4 中有变化。
    *   服务器对 `SUCCESS` 和 `FAILURE` 消息 `metadata` 中返回的字段也随版本演变（例如 `FAILURE` 中的 `gql_status` 在 Bolt 5.7+ 引入）。

## 4. 在 BoltProtocol 库中使用版本信息

为了处理上述版本差异，本库的许多 API 都要求传递协商得到的 `boltprotocol::versions::Version` 对象。

*   **客户端消息序列化**:
    *   `serialize_hello_message(params, writer, client_target_version)`: `client_target_version` 指示客户端希望或能够支持的最高版本，用于构造符合该版本预期的 HELLO 消息。
    *   `serialize_run_message(params, writer, negotiated_version)`
    *   `serialize_begin_message(params, writer, negotiated_version)`
    *   `serialize_route_message(params, writer, negotiated_version)`
    *   这些函数会使用 `negotiated_version` 来决定序列化哪些可选字段或采用哪种结构。

*   **服务器端请求消息反序列化**:
    *   `deserialize_hello_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_run_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_begin_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_pull_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_discard_message_request(reader, out_params, server_negotiated_version)`
    *   `deserialize_route_message_request(reader, out_params, server_negotiated_version)`
    *   这些函数使用 `server_negotiated_version` 来正确解析和填充参数结构体。

*   **特定 PackStream 结构转换**:
    *   `from_packstream(pss, out_node, bolt_version)`
    *   `to_packstream(node, bolt_version, out_pss)`
    *   `to_packstream(datetime, bolt_version, utc_patch_active_for_4_4, out_pss)`
    *   这些函数使用版本信息（以及 `utc_patch_active_for_4_4` 标志）来处理结构字段的版本差异和 DateTime/DateTimeZoneId 的现代/遗留格式选择。

## 5. 上层应用的职责

使用本 BoltProtocol 库的上层应用（如驱动程序或服务器）需要：

1.  **执行握手**: 在连接建立后立即调用 `perform_handshake`。
2.  **存储协商版本**: 保存 `perform_handshake` 返回的 `negotiated_version`。
3.  **传递版本信息**: 在调用本库中依赖版本的序列化、反序列化或结构转换函数时，正确传递存储的 `negotiated_version`。
4.  **处理服务器能力**: 对于 `HELLO` 的 `SUCCESS` 响应，解析其 `metadata` 中的 `patch_bolt` 列表（以确定如 "utc" patch 是否激活）和 `hints`/`configuration_hints`（以了解服务器的特定能力，如对 ROUTE V2 上下文的支持）。这些信息将指导上层应用如何构造后续消息的参数（例如，如何填充 `RouteMessageParams` 的 `routing_table_context`，或在调用 `to_packstream` 时传递 `utc_patch_active_for_4_4` 标志）。

## 总结

Bolt 协议的版本控制是其核心特性之一。本库通过要求在关键 API 中传递协商版本信息，并在内部逻辑中根据此版本进行调整，来支持与不同版本 Bolt 服务器的兼容通信。正确管理和使用版本信息是上层应用程序确保互操作性的关键。
```#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "client_example_session.h"  // For ClientSession struct
#include "client_example_utils.h"    // For print_bolt_error_details_client if main directly reports an error

// Include new transaction step headers
#include "boltprotocol/message_defs.h"  // For BoltError, Value
#include "client_example_tx_begin.h"
#include "client_example_tx_commit.h"
#include "client_example_tx_pull.h"
#include "client_example_tx_run.h"

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Client Example (No-Exception, Refactored TX)" << std::endl;
    std::cout << "-----------------------------------------------------------" << std::endl;

    ClientSession session;  // Manages streams, negotiated_version, last_error

    // --- 0. Perform Handshake ---
    std::cout << "\n--- Performing Handshake ---" << std::endl;
    if (session.perform_handshake_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- 1. Client Sends HELLO Message ---
    std::cout << "\n--- Client Sending HELLO ---" << std::endl;
    if (session.send_hello_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    // --- Transaction Block ---
    std::cout << "\n--- Starting Transaction Block ---" << std::endl;
    if (ClientTransaction::begin_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }

    int64_t query_id = -1;
    std::string test_query = "CREATE (a:Person {name: 'Alice'}) RETURN id(a)";
    std::map<std::string, Value> test_params;

    // std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl; // Moved into function
    if (ClientTransaction::run_query_in_transaction(session, test_query, test_params, query_id) != BoltError::SUCCESS) {
        // Consider ROLLBACK here
        session.send_goodbye_sequence();
        return 1;
    }

    if (query_id != -1) {
        std::vector<RecordMessageParams> records;
        // std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << query_id << " ---" << std::endl; // Moved
        if (ClientTransaction::pull_all_results_in_transaction(session, query_id, records) != BoltError::SUCCESS) {
            session.send_goodbye_sequence();
            return 1;
        }
        std::cout << "Client: PULL sequence successful. Received " << records.size() << " records." << std::endl;
        for (const auto& record_param : records) {
            std::cout << "  Record: ";
            for (const auto& field_value : record_param.fields) {
                if (std::holds_alternative<int64_t>(field_value)) {
                    std::cout << std::get<int64_t>(field_value) << " ";
                } else if (std::holds_alternative<std::string>(field_value)) {
                    std::cout << "\"" << std::get<std::string>(field_value) << "\" ";
                } else {
                    std::cout << "[type_idx:" << field_value.index() << "] ";
                }
            }
            std::cout << std::endl;
        }
    } else {
        std::cout << "Client: No valid qid from RUN, or qid indicates no results to pull. Skipping PULL." << std::endl;
    }

    // std::cout << "\n--- Client Sending COMMIT ---" << std::endl; // Moved
    if (ClientTransaction::commit_transaction(session) != BoltError::SUCCESS) {
        session.send_goodbye_sequence();
        return 1;
    }
    std::cout << "--- Transaction Block Finished ---" << std::endl;

    // --- 5. Client Sends GOODBYE ---
    std::cout << "\n--- Client Sending GOODBYE ---" << std::endl;
    if (session.send_goodbye_sequence() != BoltError::SUCCESS) {
        return 1;
    }

    std::cout << "\nClient example finished successfully." << std::endl;
    return 0;
}// Base/Protocol/BoltProtocol/Example/client_example_session.cpp
#include "client_example_session.h"

#include <array>  // For std::array in manual handshake simulation

#include "boltprotocol/bolt_errors_versions.h"
#include "boltprotocol/message_defs.h"

// Anonymous namespace for implementation details or helpers local to this file
namespace {

    boltprotocol::BoltError prepare_hello_message_bytes(const boltprotocol::versions::Version& target_version, std::vector<uint8_t>& out_bytes) {
        using namespace boltprotocol;
        using versions::V5_1;
        using versions::V5_3;

        out_bytes.clear();
        PackStreamWriter ps_writer(out_bytes);

        HelloMessageParams hello_params;
        bool prep_ok = true;
        try {
            hello_params.user_agent = DEFAULT_USER_AGENT_FORMAT_STRING + " (Bolt " + std::to_string(target_version.major) + "." + std::to_string(target_version.minor) + ")";

            if (target_version < V5_1) {
                hello_params.auth_scheme = "basic";
                hello_params.auth_principal = "neo4j";
                hello_params.auth_credentials = "password";
            }

            if (target_version == V5_3 || !(target_version < V5_3)) {  // Equivalent to target_version >= V5_3
                HelloMessageParams::BoltAgentInfo agent_info;
                agent_info.product = "MyExampleClientLib/0.1";
                agent_info.platform = "Cpp/LinuxGeneric";
                hello_params.bolt_agent = agent_info;
            }

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("alloc HELLO params", BoltError::OUT_OF_MEMORY);
            prep_ok = false;
        } catch (const std::exception& e) {
            std::cerr << "StdExc HELLO params: " << e.what() << std::endl;
            print_bolt_error_details_client("prep HELLO params", BoltError::UNKNOWN_ERROR);
            prep_ok = false;
        }
        if (!prep_ok) return BoltError::UNKNOWN_ERROR;

        BoltError err = serialize_hello_message(hello_params, ps_writer, target_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing HELLO", err, nullptr, &ps_writer);
        }
        return err;
    }

}  // anonymous namespace

boltprotocol::BoltError ClientSession::perform_handshake_sequence() {
    using namespace boltprotocol;
    client_to_server_stream.clear();  // Clear flags
    client_to_server_stream.str("");  // Clear content
    server_to_client_stream.clear();  // Clear flags
    server_to_client_stream.str("");  // Clear content

    std::vector<versions::Version> proposed_versions = versions::get_default_proposed_versions();
    if (proposed_versions.empty()) {
        print_bolt_error_details_client("perform_handshake_sequence: proposed_versions empty", BoltError::INVALID_ARGUMENT);
        last_error = BoltError::INVALID_ARGUMENT;
        return last_error;
    }

    // Simulate server choosing the first proposed version
    versions::Version server_chosen_version_sim = proposed_versions[0];
    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_b = server_chosen_version_sim.to_handshake_bytes();
    server_to_client_stream.write(reinterpret_cast<const char*>(server_response_b.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    server_to_client_stream.seekg(0);  // Rewind for client to read

    // For std::stringstream, we need to pass them directly to a perform_handshake
    // that is overloaded or templated to accept std::istream and std::ostream.
    // The current template `perform_handshake(SyncReadWriteStream& stream, ...)`
    // will not work directly with two separate std::stringstream.
    // The previous attempt to call it with two std::stringstream instances was due to a
    // misunderstanding of the template after it was changed from (ostream, istream, ...) form.

    // Since client_example uses std::stringstream, and perform_handshake is now
    // templated for a single SyncReadWriteStream (which std::stringstream does not model
    // in the way Boost.ASIO sockets do, e.g. no write_some/read_some for asio::write/read free functions),
    // we must manually implement the handshake byte exchange for the example.
    // OR, we could create a simple wrapper for std::stringstream that *does* satisfy
    // SyncReadWriteStream, but that's more involved for just an example.

    std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes_content;
    last_error = build_handshake_request(proposed_versions, handshake_request_bytes_content);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Building handshake request for example", last_error);
        return last_error;
    }

    client_to_server_stream.write(reinterpret_cast<const char*>(handshake_request_bytes_content.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
    if (client_to_server_stream.fail()) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Writing handshake to client_to_server_stream", last_error);
        return last_error;
    }
    client_to_server_stream.flush();  // Ensure it's "sent"

    std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes_read;
    server_to_client_stream.read(reinterpret_cast<char*>(server_response_bytes_read.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
    if (server_to_client_stream.fail() || static_cast<size_t>(server_to_client_stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
        last_error = BoltError::NETWORK_ERROR;
        print_bolt_error_details_client("Example: Reading handshake response from server_to_client_stream", last_error);
        return last_error;
    }

    last_error = parse_handshake_response(server_response_bytes_read, negotiated_version);
    if (last_error != BoltError::SUCCESS) {
        print_bolt_error_details_client("Example: Parsing handshake response", last_error);
        return last_error;
    }

    std::cout << "Client: Handshake successful! Negotiated version: " << static_cast<int>(negotiated_version.major) << "." << static_cast<int>(negotiated_version.minor) << std::endl;
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_hello_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    last_error = prepare_hello_message_bytes(negotiated_version, raw_message_bytes_storage);
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = simulate_server_simple_success_response(server_to_client_stream, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "HELLO");
    if (last_error != BoltError::SUCCESS) return last_error;

    if (raw_response_bytes_storage.empty()) {
        print_bolt_error_details_client("HELLO resp empty", BoltError::DESERIALIZATION_ERROR);
        last_error = BoltError::DESERIALIZATION_ERROR;
        return last_error;
    }
    SuccessMessageParams hello_success_params;
    {
        PackStreamReader hello_response_reader(raw_response_bytes_storage);
        last_error = deserialize_success_message(hello_response_reader, hello_success_params);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("deser HELLO SUCCESS", last_error, &hello_response_reader);
            return last_error;
        }
    }
    std::cout << "Client: HELLO SUCCESS deserialized." << std::endl;
    auto it_conn_id = hello_success_params.metadata.find("connection_id");
    if (it_conn_id != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_conn_id->second))) {
            std::cout << "Client: Received connection_id: " << *str_val << std::endl;
        }
    }
    auto it_server_agent = hello_success_params.metadata.find("server");
    if (it_server_agent != hello_success_params.metadata.end()) {
        if (const auto* str_val = std::get_if<std::string>(&(it_server_agent->second))) {
            std::cout << "Client: Server agent: " << *str_val << std::endl;
        }
    }
    return BoltError::SUCCESS;
}

boltprotocol::BoltError ClientSession::send_goodbye_sequence() {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_message_bytes_storage;
    std::vector<uint8_t> raw_response_bytes_storage;

    {
        PackStreamWriter ps_writer(raw_message_bytes_storage);
        last_error = serialize_goodbye_message(ps_writer);
        if (last_error != BoltError::SUCCESS) {
            print_bolt_error_details_client("serializing GOODBYE", last_error, nullptr, &ps_writer);
            return last_error;
        }
    }
    last_error = send_and_receive_raw_message_client(client_to_server_stream, server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "GOODBYE", false);
    if (last_error != BoltError::SUCCESS) {
        return last_error;
    }
    std::cout << "Client: GOODBYE sent." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_SESSION_H
#define CLIENT_EXAMPLE_SESSION_H

#include <array>  // For handshake
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/handshake.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For helpers

struct ClientSession {
    std::stringstream client_to_server_stream;
    std::stringstream server_to_client_stream;
    boltprotocol::versions::Version negotiated_version;
    boltprotocol::BoltError last_error = boltprotocol::BoltError::SUCCESS;

    ClientSession() = default;

    boltprotocol::BoltError perform_handshake_sequence();
    boltprotocol::BoltError send_hello_sequence();
    boltprotocol::BoltError send_goodbye_sequence();
};

#endif  // CLIENT_EXAMPLE_SESSION_H#include "client_example_tx_begin.h"

#include "boltprotocol/message_serialization.h"  // For serialize_begin_message
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"  // For simulate_server_simple_success_response, send_and_receive_raw_message_client

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending BEGIN ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            BeginMessageParams begin_params;
            // Populate begin_params with specific fields if needed, e.g., based on session.negotiated_version
            // begin_params.tx_timeout = 5000; // Example
            session.last_error = serialize_begin_message(begin_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing BEGIN", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "BEGIN");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("BEGIN resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams begin_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, begin_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser BEGIN SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: BEGIN SUCCESS deserialized." << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_BEGIN_H
#define CLIENT_EXAMPLE_TX_BEGIN_H

#include "boltprotocol/message_defs.h"  // For BoltError
#include "client_example_session.h"     // For ClientSession

namespace ClientTransaction {

    boltprotocol::BoltError begin_transaction(ClientSession& session);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_BEGIN_H#include "client_example_tx_commit.h"

#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;

        std::cout << "\n--- Client Sending COMMIT ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            session.last_error = serialize_commit_message(ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing COMMIT", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "COMMIT");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("COMMIT resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams commit_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, commit_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser COMMIT SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }
        std::cout << "Client: COMMIT SUCCESS deserialized." << std::endl;
        // Check for bookmark from commit_success_params.metadata if needed
        auto it_bookmark = commit_success_params.metadata.find("bookmark");
        if (it_bookmark != commit_success_params.metadata.end()) {
            if (const auto* str_val = std::get_if<std::string>(&(it_bookmark->second))) {
                std::cout << "Client: Received bookmark from COMMIT: " << *str_val << std::endl;
            }
        }
        return BoltError::SUCCESS;
    }

    // Implement rollback_transaction here if needed in the future
    /*
    boltprotocol::BoltError rollback_transaction(ClientSession& session) {
        // ... similar to commit_transaction but sends ROLLBACK and expects SUCCESS
        return BoltError::SUCCESS;
    }
    */

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_COMMIT_H
#define CLIENT_EXAMPLE_TX_COMMIT_H

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError commit_transaction(ClientSession& session);
    // boltprotocol::BoltError rollback_transaction(ClientSession& session); // For future

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_COMMIT_H#include "client_example_tx_pull.h"

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server sending a RECORD message
    boltprotocol::BoltError simulate_server_record_response(std::stringstream& server_pipe, const std::vector<boltprotocol::Value>& record_fields) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            RecordMessageParams rec_p;
            try {
                rec_p.fields = record_fields;  // Copy
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            PackStreamStructure pss_rec_obj;
            pss_rec_obj.tag = static_cast<uint8_t>(MessageTag::RECORD);
            std::shared_ptr<BoltList> list_sptr;
            try {
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(rec_p.fields);
                pss_rec_obj.fields.emplace_back(Value(list_sptr));
            } catch (...) {
                return BoltError::OUT_OF_MEMORY; /* Simplified */
            }

            std::shared_ptr<PackStreamStructure> pss_rec_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_rec_obj));
            if (!pss_rec_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_rec_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RECORD", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RECORD", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RECORD response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_pull_message_bytes;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_records.clear();

        std::cout << "\n--- Client Sending PULL (in transaction) for qid: " << qid << " ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_pull_message_bytes);
            PullMessageParams pull_params;
            pull_params.n = -1;  // PULL ALL
            if (qid != -1) {     // qid is mandatory for PULL in explicit transaction
                pull_params.qid = qid;
            } else {
                // This is an issue if qid is expected.
                print_bolt_error_details_client("PULL: qid is -1, which is invalid for explicit TX PULL", BoltError::INVALID_ARGUMENT);
                session.last_error = BoltError::INVALID_ARGUMENT;
                return session.last_error;
            }

            session.last_error = serialize_pull_message(pull_params, ps_writer);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing PULL", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        bool first_pull_interaction = true;
        bool has_more_server_says = true;

        while (has_more_server_says) {
            // --- Simulate Server Response for PULL ---
            // This simulation sends one record, then a SUCCESS summary.
            // A real server might send many records before a SUCCESS with has_more:true,
            // or end with has_more:false.
            if (first_pull_interaction) {
                // Simulate server sending one RECORD
                std::vector<Value> record_data;
                try {
                    record_data.emplace_back(Value(static_cast<int64_t>(12345)));
                }  // Dummy ID
                catch (...) {
                    session.last_error = BoltError::OUT_OF_MEMORY;
                    return session.last_error;
                }
                session.last_error = simulate_server_record_response(session.server_to_client_stream, record_data);
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            } else {
                // After the first (and only in this sim) record, server sends SUCCESS summary
                // Simulate has_more:false to end the loop.
                // In a real scenario, server might send SUCCESS with has_more:true if there are more batches.
                session.last_error = simulate_server_simple_success_response(session.server_to_client_stream, "PULL summary (final)", qid);
                // To make it more realistic, the success response should include "has_more":false
                // We'd need to modify simulate_server_simple_success_response or use a more specific one.
                // For now, our client loop will break when it gets a SUCCESS.
                if (session.last_error != BoltError::SUCCESS) return session.last_error;
            }

            // --- Client Sends PULL (first time) and Receives Response ---
            std::vector<uint8_t> message_to_send_this_iteration;
            if (first_pull_interaction) {
                message_to_send_this_iteration = raw_pull_message_bytes;
            }

            session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, message_to_send_this_iteration, raw_response_bytes_storage, first_pull_interaction ? "PULL (for RECORD)" : "PULL (for summary)");
            if (session.last_error != BoltError::SUCCESS) return session.last_error;
            first_pull_interaction = false;

            if (raw_response_bytes_storage.empty()) {
                print_bolt_error_details_client("PULL response empty", BoltError::DESERIALIZATION_ERROR);
                session.last_error = BoltError::DESERIALIZATION_ERROR;
                return session.last_error;
            }

            // --- Client Deserializes Response ---
            Value peek_value;
            PackStreamStructure received_pss;  // To store the actual structure
            {
                PackStreamReader peek_reader(raw_response_bytes_storage);
                // We need to get the actual PSS, not just the shared_ptr from Value for tag checking.
                BoltError temp_err = deserialize_message_structure_prelude(peek_reader, MessageTag::HELLO, 0, 1, received_pss);  // Tag doesn't matter for just getting fields
                if (peek_reader.has_error() && temp_err == BoltError::SUCCESS) temp_err = peek_reader.get_error();               // ensure err state is from reader if prelude was ok

                if (temp_err != BoltError::SUCCESS && temp_err != BoltError::INVALID_MESSAGE_FORMAT) {  // Allow tag mismatch
                    print_bolt_error_details_client("Peeking PULL response structure", temp_err, &peek_reader);
                    session.last_error = temp_err;
                    return session.last_error;
                }
                // If it was INVALID_MESSAGE_FORMAT due to tag, that's fine, we check tag below.
                // If it was another error (e.g. not a PSS at all), that's a problem.
                if (!peek_reader.has_error() && received_pss.fields.empty() && received_pss.tag == 0) {  // deserialize_message_structure_prelude failed to get a PSS
                    print_bolt_error_details_client("Peeking PULL response: not a valid PSS", BoltError::DESERIALIZATION_ERROR, &peek_reader);
                    session.last_error = BoltError::DESERIALIZATION_ERROR;
                    return session.last_error;
                }
            }

            if (static_cast<MessageTag>(received_pss.tag) == MessageTag::RECORD) {
                RecordMessageParams rec_params;
                PackStreamReader record_reader(raw_response_bytes_storage);
                session.last_error = deserialize_record_message(record_reader, rec_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing RECORD from PULL", session.last_error, &record_reader);
                    return session.last_error;
                }
                out_records.push_back(std::move(rec_params));
                std::cout << "Client: RECORD deserialized from PULL." << std::endl;
                // Check for "has_more" in record metadata if present (uncommon, usually in SUCCESS)
                // For this simulation, we assume has_more_server_says is true until SUCCESS says otherwise
            } else if (static_cast<MessageTag>(received_pss.tag) == MessageTag::SUCCESS) {
                SuccessMessageParams summary_params;
                PackStreamReader summary_reader(raw_response_bytes_storage);
                session.last_error = deserialize_success_message(summary_reader, summary_params);
                if (session.last_error != BoltError::SUCCESS) {
                    print_bolt_error_details_client("Deserializing SUCCESS summary from PULL", session.last_error, &summary_reader);
                    return session.last_error;
                }
                std::cout << "Client: PULL summary SUCCESS deserialized." << std::endl;

                // Check for "has_more" in the SUCCESS metadata
                auto it_has_more = summary_params.metadata.find("has_more");
                if (it_has_more != summary_params.metadata.end() && std::holds_alternative<bool>(it_has_more->second)) {
                    has_more_server_says = std::get<bool>(it_has_more->second);
                    std::cout << "Client: PULL summary has_more=" << (has_more_server_says ? "true" : "false") << std::endl;
                } else {
                    has_more_server_says = false;  // If not present, assume no more (Bolt 3 behavior)
                    std::cout << "Client: PULL summary 'has_more' not found or not bool, assuming false." << std::endl;
                }
            } else {
                print_bolt_error_details_client("PULL response unexpected PSS tag: " + std::to_string(received_pss.tag), BoltError::INVALID_MESSAGE_FORMAT);
                session.last_error = BoltError::INVALID_MESSAGE_FORMAT;
                return session.last_error;
            }
        }
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_PULL_H
#define CLIENT_EXAMPLE_TX_PULL_H

#include <vector>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError pull_all_results_in_transaction(ClientSession& session, int64_t qid, std::vector<boltprotocol::RecordMessageParams>& out_records);

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_PULL_H#include "client_example_tx_run.h"

#include "boltprotocol/chunking.h"  // For ChunkedWriter if server sim uses it directly
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "client_example_utils.h"

namespace ClientTransaction {

    // Helper to simulate server RUN response (SUCCESS with fields and qid)
    // This could also live in client_example_utils.cpp if it's more general
    boltprotocol::BoltError simulate_server_run_response_fields(std::stringstream& server_pipe, const std::vector<std::string>& field_names, int64_t qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_server_response_bytes;
        BoltError err;
        {
            PackStreamWriter srv_ps_writer(raw_server_response_bytes);
            SuccessMessageParams fields_s_p;
            bool prep_ok = true;
            try {
                auto fields_list_sptr = std::make_shared<BoltList>();
                for (const auto& field_name : field_names) {
                    fields_list_sptr->elements.emplace_back(Value(field_name));
                }
                fields_s_p.metadata.emplace("fields", Value(fields_list_sptr));
                if (qid != -1) {
                    fields_s_p.metadata.emplace("qid", Value(qid));
                }
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields alloc", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc Sim Srv: RUN SUCCESS fields: " << e.what() << std::endl;
                print_bolt_error_details_client("Sim Srv: RUN SUCCESS fields stdexc", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                return BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return BoltError::UNKNOWN_ERROR;

            PackStreamStructure pss_obj;
            pss_obj.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            std::shared_ptr<BoltMap> meta_map_sptr;
            try {
                meta_map_sptr = std::make_shared<BoltMap>();
                meta_map_sptr->pairs = std::move(fields_s_p.metadata);
                pss_obj.fields.emplace_back(Value(meta_map_sptr));
            } catch (...) {
                return BoltError::UNKNOWN_ERROR; /* Simplified error */
            }

            std::shared_ptr<PackStreamStructure> pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj));
            if (!pss_to_write_sptr) {
                return BoltError::OUT_OF_MEMORY;
            }

            err = srv_ps_writer.write(Value(pss_to_write_sptr));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: serializing RUN SUCCESS fields", err, nullptr, &srv_ps_writer);
                return err;
            }
        }
        // Prime server_pipe with the response
        server_pipe.clear();
        server_pipe.str("");
        {
            ChunkedWriter srv_c_writer(server_pipe);
            err = srv_c_writer.write_message(raw_server_response_bytes);
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_client("Sim Srv: chunking RUN SUCCESS fields", err, nullptr, nullptr, nullptr, &srv_c_writer);
                return err;
            }
        }
        std::cout << "Server (Simulated): Sent RUN SUCCESS (fields, qid=" << qid << ") response." << std::endl;
        return BoltError::SUCCESS;
    }

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params, int64_t& out_qid) {
        using namespace boltprotocol;
        std::vector<uint8_t> raw_message_bytes_storage;
        std::vector<uint8_t> raw_response_bytes_storage;
        out_qid = -1;

        std::cout << "\n--- Client Sending RUN (in transaction) ---" << std::endl;
        {
            PackStreamWriter ps_writer(raw_message_bytes_storage);
            RunMessageParams run_params;
            bool prep_ok = true;
            try {
                run_params.cypher_query = query;
                run_params.parameters = params;
                // Example of setting specific extra fields for RUN
                // run_params.db = "mydb"; // If appropriate for the version
            } catch (const std::bad_alloc&) {
                print_bolt_error_details_client("alloc RUN_IN_TX params", BoltError::OUT_OF_MEMORY);
                prep_ok = false;
                session.last_error = BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e) {
                std::cerr << "StdExc RUN_IN_TX params: " << e.what() << std::endl;
                print_bolt_error_details_client("prep RUN_IN_TX params", BoltError::UNKNOWN_ERROR);
                prep_ok = false;
                session.last_error = BoltError::UNKNOWN_ERROR;
            }
            if (!prep_ok) return session.last_error;

            session.last_error = serialize_run_message(run_params, ps_writer, session.negotiated_version);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("serializing RUN_IN_TX", session.last_error, nullptr, &ps_writer);
                return session.last_error;
            }
        }

        int64_t simulated_qid = 2;                              // Server would generate this
        std::vector<std::string> simulated_fields = {"id(a)"};  // Match "CREATE (a:Person {name: 'Alice'}) RETURN id(a)"
        session.last_error = simulate_server_run_response_fields(session.server_to_client_stream, simulated_fields, simulated_qid);
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        session.last_error = send_and_receive_raw_message_client(session.client_to_server_stream, session.server_to_client_stream, raw_message_bytes_storage, raw_response_bytes_storage, "RUN_IN_TX");
        if (session.last_error != BoltError::SUCCESS) return session.last_error;

        if (raw_response_bytes_storage.empty()) {
            print_bolt_error_details_client("RUN_IN_TX resp empty", BoltError::DESERIALIZATION_ERROR);
            session.last_error = BoltError::DESERIALIZATION_ERROR;
            return session.last_error;
        }
        SuccessMessageParams run_in_tx_success_params;
        {
            PackStreamReader r(raw_response_bytes_storage);
            session.last_error = deserialize_success_message(r, run_in_tx_success_params);
            if (session.last_error != BoltError::SUCCESS) {
                print_bolt_error_details_client("deser RUN_IN_TX SUCCESS", session.last_error, &r);
                return session.last_error;
            }
        }

        auto it_qid = run_in_tx_success_params.metadata.find("qid");
        if (it_qid != run_in_tx_success_params.metadata.end() && std::holds_alternative<int64_t>(it_qid->second)) {
            out_qid = std::get<int64_t>(it_qid->second);
        } else {
            std::cout << "Client: Warning - qid not found or not int64 in RUN SUCCESS metadata for TX." << std::endl;
            // For auto-commit RUN, qid might not be present if no results are expected or version is old.
            // For explicit TX RUN, qid is usually expected.
        }
        std::cout << "Client: RUN_IN_TX SUCCESS (fields) deserialized. qid: " << out_qid << std::endl;
        return BoltError::SUCCESS;
    }

}  // namespace ClientTransaction#ifndef CLIENT_EXAMPLE_TX_RUN_H
#define CLIENT_EXAMPLE_TX_RUN_H

#include <map>
#include <string>

#include "boltprotocol/message_defs.h"
#include "client_example_session.h"

namespace ClientTransaction {

    boltprotocol::BoltError run_query_in_transaction(ClientSession& session, const std::string& query, const std::map<std::string, boltprotocol::Value>& params,
                                                     int64_t& out_qid);  // Output parameter for query ID

}  // namespace ClientTransaction

#endif  // CLIENT_EXAMPLE_TX_RUN_H#include "client_example_utils.h"

// Helper to print BoltError and associated reader/writer errors
void print_bolt_error_details_client(const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer, boltprotocol::ChunkedReader* chunk_reader, boltprotocol::ChunkedWriter* chunk_writer) {
    std::cerr << "Error (Client) " << context << ": " << static_cast<int>(err_code);
    if (reader && reader->has_error() && reader->get_error() != err_code) {
        std::cerr << " (PackStreamReader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err_code) {
        std::cerr << " (PackStreamWriter specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    if (chunk_reader && chunk_reader->has_error() && chunk_reader->get_error() != err_code) {
        std::cerr << " (ChunkedReader specific error: " << static_cast<int>(chunk_reader->get_error()) << ")";
    }
    if (chunk_writer && chunk_writer->has_error() && chunk_writer->get_error() != err_code) {
        std::cerr << " (ChunkedWriter specific error: " << static_cast<int>(chunk_writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

// Helper function to print a byte vector
void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}

// Simulate sending a raw message (PackStream bytes) via ChunkedWriter
// and receiving a raw response (PackStream bytes) via ChunkedReader.
boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response) {
    using namespace boltprotocol;
    BoltError err;

    // --- Client Sends Message ---
    std::cout << "Client: Preparing to send " << message_description_for_log << "..." << std::endl;
    print_bytes_client("Client: Raw " + message_description_for_log + " to send: ", raw_message_to_send);

    // Clear client_to_server_pipe for this message (caller responsibility to manage overall pipe lifetime)
    // For this helper, we assume it's okay to clear before writing.
    if (!raw_message_to_send.empty()) {  // Only clear if we are actually sending something
        client_to_server_pipe.clear();
        client_to_server_pipe.str("");
    }

    if (!raw_message_to_send.empty()) {  // Only write if there's a message
        ChunkedWriter chunk_writer(client_to_server_pipe);
        err = chunk_writer.write_message(raw_message_to_send);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("ChunkedWriter writing " + message_description_for_log, err, nullptr, nullptr, nullptr, &chunk_writer);
            return err;
        }
        std::cout << "Client: " << message_description_for_log << " written to client_to_server_pipe (chunked)." << std::endl;
    } else if (expect_response) {  // If sending nothing but expecting response (e.g. implicit PULL after RUN)
        std::cout << "Client: Sending no explicit message, but expecting response for " << message_description_for_log << "." << std::endl;
    } else {  // Sending nothing, expecting nothing
        std::cout << "Client: No message to send and no response expected for " << message_description_for_log << "." << std::endl;
    }

    // --- Client Receiving Response (if expected) ---
    if (!expect_response) {
        std::cout << "Client: No response expected for " << message_description_for_log << "." << std::endl;
        // Even if no response expected, server_pipe might have old data; clear it.
        server_to_client_pipe.clear();
        server_to_client_pipe.str("");
        return BoltError::SUCCESS;
    }

    std::cout << "Client: Waiting for server response to " << message_description_for_log << "..." << std::endl;
    // Check if the server pipe is empty *before* trying to read.
    // Need to peek to see if there's content, as str() doesn't reflect read position.
    server_to_client_pipe.peek();  // This updates EOF state if at end
    if (server_to_client_pipe.str().empty() && server_to_client_pipe.eof()) {
        std::cout << "Client: Server_to_client_pipe is empty and at EOF. No response to read for " << message_description_for_log << "." << std::endl;
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log + " (pipe was empty)", BoltError::NETWORK_ERROR);
        return BoltError::NETWORK_ERROR;
    }

    out_raw_response_received.clear();
    ChunkedReader chunk_reader(server_to_client_pipe);
    err = chunk_reader.read_message(out_raw_response_received);

    if (err != BoltError::SUCCESS) {
        // If read_message fails, it might be due to an empty pipe that wasn't caught above, or actual error.
        print_bolt_error_details_client("ChunkedReader reading response to " + message_description_for_log, err, nullptr, nullptr, &chunk_reader);
        return err;
    }
    print_bytes_client("Client: Raw response received for " + message_description_for_log + ": ", out_raw_response_received);

    // Clear the server_to_client_pipe after successful read, ready for next simulated server response.
    server_to_client_pipe.clear();
    server_to_client_pipe.str("");

    return BoltError::SUCCESS;
}

// Helper to simulate server sending a simple SUCCESS {} response
boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid) {
    using namespace boltprotocol;
    std::vector<uint8_t> raw_server_response_bytes;
    BoltError err;
    {
        PackStreamWriter ps_writer(raw_server_response_bytes);
        SuccessMessageParams success_p;
        bool prep_ok = true;
        try {
            if (qid != -1) {
                success_p.metadata.emplace("qid", Value(qid));
            }
            // Add other common success fields if needed for simulation
            // success_p.metadata.emplace("type", Value(std::string("r"))); // For query summary
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        PackStreamStructure success_pss;
        success_pss.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
        std::shared_ptr<BoltMap> meta_map_sptr;
        try {
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_p.metadata);  // Move if success_p not used after
            success_pss.fields.emplace_back(Value(meta_map_sptr));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") SUCCESS PSS alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(success_pss));
        } catch (const std::bad_alloc&) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr alloc", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "StdExc Sim Srv (" + context_log + ") PSS sptr: " << e_std.what() << std::endl;
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr stdexc", BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            print_bolt_error_details_client("Sim Srv (" + context_log + ") PSS sptr null", BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        err = ps_writer.write(Value(std::move(pss_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: serializing " + context_log + " SUCCESS", err, nullptr, &ps_writer);
            return err;
        }
    }
    // "Server" puts its response into the server_pipe
    server_pipe.clear();
    server_pipe.str("");  // Clear for this specific response
    {
        ChunkedWriter server_chunk_writer(server_pipe);
        err = server_chunk_writer.write_message(raw_server_response_bytes);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_client("Sim Srv: chunk writing " + context_log + " SUCCESS", err, nullptr, nullptr, nullptr, &server_chunk_writer);
            return err;
        }
    }
    std::cout << "Server (Simulated): Sent " << context_log << " SUCCESS response." << std::endl;
    return BoltError::SUCCESS;
}#ifndef CLIENT_EXAMPLE_UTILS_H
#define CLIENT_EXAMPLE_UTILS_H

#include <cstdint>    // For uint8_t
#include <exception>  // For std::bad_alloc, std::exception
#include <iomanip>    // For std::setw, std::setfill
#include <iostream>
#include <map>     // For std::map
#include <memory>  // For std::shared_ptr, std::make_shared
#include <sstream>
#include <string>
#include <vector>

#include "boltprotocol/chunking.h"
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"  // Needed for PackStreamReader in print_bolt_error_details_client
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_client(
    const std::string& context, boltprotocol::BoltError err_code, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr, boltprotocol::ChunkedReader* chunk_reader = nullptr, boltprotocol::ChunkedWriter* chunk_writer = nullptr);

void print_bytes_client(const std::string& prefix, const std::vector<uint8_t>& bytes);

boltprotocol::BoltError send_and_receive_raw_message_client(
    std::stringstream& client_to_server_pipe, std::stringstream& server_to_client_pipe, const std::vector<uint8_t>& raw_message_to_send, std::vector<uint8_t>& out_raw_response_received, const std::string& message_description_for_log, bool expect_response = true);

boltprotocol::BoltError simulate_server_simple_success_response(std::stringstream& server_pipe, const std::string& context_log, int64_t qid = -1);

#endif  // CLIENT_EXAMPLE_UTILS_H# CMakeLists.txt for BoltProtocol module examples

add_executable(client_example
    client_example_main.cpp
    client_example_utils.h
    client_example_utils.cpp
    client_example_session.h
    client_example_session.cpp
    # client_example_transaction.h # This header is now split
    # client_example_transaction.cpp # This source is now split
    client_example_tx_begin.h
    client_example_tx_begin.cpp
    client_example_tx_run.h
    client_example_tx_run.cpp
    client_example_tx_pull.h
    client_example_tx_pull.cpp
    client_example_tx_commit.h
    client_example_tx_commit.cpp
)
target_link_libraries(client_example PUBLIC BoltProtocol)

add_executable(server_example
    server_example_main.cpp
    server_example_utils.h
    server_example_utils.cpp
    server_example_handlers.h
    server_example_handlers.cpp
)
target_link_libraries(server_example PUBLIC BoltProtocol)#include "server_example_handlers.h"

#include <exception>
#include <optional>
#include <variant>

#include "boltprotocol/message_defs.h"  // For versions::Version from bolt_errors_versions.h

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version) {
        using namespace boltprotocol;
        std::cout << "  Server processing HELLO message from: " << parsed_hello_params.user_agent << std::endl;
        if (parsed_hello_params.bolt_agent.has_value()) {
            std::cout << "    Bolt Agent Product: " << parsed_hello_params.bolt_agent.value().product << std::endl;
        }
        if (parsed_hello_params.auth_scheme.has_value()) {
            std::cout << "    Auth Scheme: " << parsed_hello_params.auth_scheme.value() << std::endl;
        }

        SuccessMessageParams success_for_hello_params;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;
        bool server_resp_ok = true;

        try {
            success_for_hello_params.metadata.emplace("connection_id", Value(std::string("server-conn-xyz")));
            success_for_hello_params.metadata.emplace("server", Value(std::string("MyExampleBoltServer/0.1 (Bolt ") + std::to_string(server_negotiated_version.major) + "." + std::to_string(server_negotiated_version.minor) + ")"));

            if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
                if (parsed_hello_params.patch_bolt.has_value()) {
                    for (const auto& patch : parsed_hello_params.patch_bolt.value()) {
                        if (patch == "utc") {
                            auto agreed_patches_list = std::make_shared<BoltList>();
                            agreed_patches_list->elements.emplace_back(Value(std::string("utc")));
                            success_for_hello_params.metadata.emplace("patch_bolt", Value(agreed_patches_list));
                            std::cout << "    Server agreed to 'utc' patch." << std::endl;
                            break;
                        }
                    }
                }
            }

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(success_for_hello_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));
            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("server HELLO SUCCESS resp (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            server_resp_ok = false;
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server HELLO SUCCESS resp: " << e_std.what() << std::endl;
            print_bolt_error_details_server("server HELLO SUCCESS resp (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            server_resp_ok = false;
            return BoltError::UNKNOWN_ERROR;
        }

        if (!server_resp_ok || !pss_to_write_sptr) {
            if (server_resp_ok && !pss_to_write_sptr) {
                print_bolt_error_details_server("server HELLO SUCCESS resp (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
            }
            return response_writer.get_error();
        }

        BoltError err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server serializing SUCCESS for HELLO", err, nullptr, &response_writer);
        }
        return err;
    }

    // handle_run_message now receives fully parsed RunMessageParams.
    // It no longer needs to deserialize from a raw PackStreamStructure itself.
    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Already parsed
                                               boltprotocol::PackStreamWriter& response_writer) {
        using namespace boltprotocol;
        std::cout << "  Server processing RUN query: '" << run_params.cypher_query << "'" << std::endl;

        // Access typed optional fields
        if (run_params.db.has_value()) {
            std::cout << "    For database: " << run_params.db.value() << std::endl;
        }
        if (run_params.tx_timeout.has_value()) {
            std::cout << "    With tx_timeout: " << run_params.tx_timeout.value() << "ms" << std::endl;
        }

        // Access cypher parameters
        auto limit_it = run_params.parameters.find("limit");
        if (limit_it != run_params.parameters.end()) {
            if (const auto* limit_val_ptr = std::get_if<int64_t>(&(limit_it->second))) {
                std::cout << "    With limit parameter: " << *limit_val_ptr << std::endl;
            }
        }
        // Access other_extra_fields if needed
        if (!run_params.other_extra_fields.empty()) {
            std::cout << "    With other extra fields:" << std::endl;
            for (const auto& pair : run_params.other_extra_fields) {
                std::cout << "      " << pair.first << ": (type " << pair.second.index() << ")" << std::endl;
            }
        }

        BoltError err = BoltError::SUCCESS;
        PackStreamStructure pss_obj_on_stack;
        std::shared_ptr<BoltMap> meta_map_sptr;
        std::shared_ptr<BoltList> list_sptr;
        std::shared_ptr<PackStreamStructure> pss_to_write_sptr;

        // 1. Send SUCCESS for RUN (contains field names)
        try {
            SuccessMessageParams run_success_params;
            list_sptr = std::make_shared<BoltList>();
            list_sptr->elements.emplace_back(Value(std::string("name")));
            run_success_params.metadata.emplace("fields", Value(list_sptr));
            // Optionally add qid for explicit transactions, or t_first for auto-commit
            // run_success_params.metadata.emplace("t_first", Value(static_cast<int64_t>(10))); // Example

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();

            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(run_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing RUN SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing RUN SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing RUN SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing RUN SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS for RUN", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS for RUN (with fields)." << std::endl;

        // 2. Send RECORD messages (dummy data)
        for (int i = 0; i < 2; ++i) {
            try {
                RecordMessageParams record_params;
                record_params.fields.emplace_back(Value(std::string("Node " + std::to_string(i))));

                pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::RECORD);
                pss_obj_on_stack.fields.clear();
                list_sptr = std::make_shared<BoltList>();
                list_sptr->elements = std::move(record_params.fields);
                pss_obj_on_stack.fields.emplace_back(Value(list_sptr));

                pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

            } catch (const std::bad_alloc&) {
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            } catch (const std::exception& e_std) {
                std::cerr << "Std exception server preparing RECORD " << std::to_string(i) << ": " << e_std.what() << std::endl;
                print_bolt_error_details_server("preparing RECORD " + std::to_string(i) + " (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
                response_writer.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }

            if (!pss_to_write_sptr) {
                print_bolt_error_details_server("preparing RECORD (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
                response_writer.set_error(BoltError::OUT_OF_MEMORY);
                return BoltError::OUT_OF_MEMORY;
            }
            err = response_writer.write(Value(std::move(pss_to_write_sptr)));
            if (err != BoltError::SUCCESS) {
                print_bolt_error_details_server("serializing RECORD " + std::to_string(i), err, nullptr, &response_writer);
                return err;
            }
            std::cout << "  Server sent RECORD " << i << "." << std::endl;
        }
        // 3. Send final SUCCESS (summary)
        try {
            SuccessMessageParams summary_success_params;
            summary_success_params.metadata.emplace("type", Value(std::string("r")));
            // For auto-commit that's now finished:
            // summary_success_params.metadata.emplace("bookmark", Value(std::string("neo4j:bookmark:v1:tx42")));
            // summary_success_params.metadata.emplace("has_more", Value(false)); // If Bolt 4.0+

            pss_obj_on_stack.tag = static_cast<uint8_t>(MessageTag::SUCCESS);
            pss_obj_on_stack.fields.clear();
            meta_map_sptr = std::make_shared<BoltMap>();
            meta_map_sptr->pairs = std::move(summary_success_params.metadata);
            pss_obj_on_stack.fields.emplace_back(Value(meta_map_sptr));

            pss_to_write_sptr = std::make_shared<PackStreamStructure>(std::move(pss_obj_on_stack));

        } catch (const std::bad_alloc&) {
            print_bolt_error_details_server("preparing summary SUCCESS (bad_alloc)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            std::cerr << "Std exception server preparing summary SUCCESS: " << e_std.what() << std::endl;
            print_bolt_error_details_server("preparing summary SUCCESS (std::exception)", BoltError::UNKNOWN_ERROR, nullptr, &response_writer);
            response_writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_to_write_sptr) {
            print_bolt_error_details_server("preparing summary SUCCESS (null pss_to_write_sptr)", BoltError::OUT_OF_MEMORY, nullptr, &response_writer);
            response_writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        err = response_writer.write(Value(std::move(pss_to_write_sptr)));
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("serializing SUCCESS summary", err, nullptr, &response_writer);
            return err;
        }
        std::cout << "  Server sent SUCCESS summary." << std::endl;
        return BoltError::SUCCESS;
    }

    // This helper is no longer strictly needed if server_example_main.cpp directly uses
    // deserialize_run_message_request. If it were kept, it would need significant rework
    // to populate the new RunMessageParams structure correctly from a raw PackStreamStructure.
    // For now, let's comment it out as its functionality is superseded.
    /*
    boltprotocol::BoltError deserialize_run_params_from_struct(
        const boltprotocol::PackStreamStructure& run_struct,
        boltprotocol::RunMessageParams& out_params) {
        // ... This would need to parse run_struct.fields and populate the new
        //     std::optional members of out_params and other_extra_fields ...
        print_bolt_error_details_server("deserialize_run_params_from_struct is deprecated", boltprotocol::BoltError::UNKNOWN_ERROR);
        return boltprotocol::BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace ServerHandlers#ifndef SERVER_EXAMPLE_HANDLERS_H
#define SERVER_EXAMPLE_HANDLERS_H

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_utils.h"

namespace ServerHandlers {

    boltprotocol::BoltError handle_hello_message(const boltprotocol::HelloMessageParams& parsed_hello_params, boltprotocol::PackStreamWriter& response_writer, const boltprotocol::versions::Version& server_negotiated_version);

    boltprotocol::BoltError handle_run_message(const boltprotocol::RunMessageParams& run_params,  // Now receives fully parsed params
                                               boltprotocol::PackStreamWriter& response_writer
                                               // const boltprotocol::versions::Version& server_negotiated_version // Optional: if needed
    );

    // Removed deserialize_run_params_from_struct as its functionality is now
    // part of deserialize_run_message_request from the core library.

}  // namespace ServerHandlers

#endif  // SERVER_EXAMPLE_HANDLERS_H#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/bolt_errors_versions.h"  // For direct use of versions::V5_X
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"
#include "server_example_handlers.h"
#include "server_example_utils.h"

// Helper to simulate client sending a HELLO message
boltprotocol::BoltError simulate_client_hello(const boltprotocol::versions::Version& client_simulated_target_version, std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_hello_writer(out_raw_bytes);

    HelloMessageParams client_hello_params;
    bool client_prep_ok = true;
    try {
        client_hello_params.user_agent = "MyExampleCppClient/1.0 (Simulated)";

        if (client_simulated_target_version < versions::V5_1) {
            client_hello_params.auth_scheme = "basic";
            client_hello_params.auth_principal = "neo4j";
            client_hello_params.auth_credentials = "password";
        }
        if (!(client_simulated_target_version < versions::V5_3)) {  // client_simulated_target_version >= V5_3
            HelloMessageParams::BoltAgentInfo agent_info;
            agent_info.product = "SimulatedClientDriver/0.5";
            client_hello_params.bolt_agent = agent_info;
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim HELLO (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim HELLO: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim HELLO (std::exception)", BoltError::UNKNOWN_ERROR);
        client_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_prep_ok) return BoltError::UNKNOWN_ERROR;

    BoltError err = serialize_hello_message(client_hello_params, client_hello_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing HELLO", err, nullptr, &client_hello_writer);
    }
    return err;
}

// Helper to simulate client sending a RUN message
boltprotocol::BoltError simulate_client_run(const boltprotocol::versions::Version& client_simulated_target_version,  // Added version
                                            std::vector<uint8_t>& out_raw_bytes) {
    using namespace boltprotocol;
    out_raw_bytes.clear();
    PackStreamWriter client_run_writer(out_raw_bytes);
    RunMessageParams client_run_params;
    bool client_run_prep_ok = true;
    try {
        client_run_params.cypher_query = "MATCH (n) RETURN n.name AS name LIMIT $limit";
        client_run_params.parameters.emplace("limit", Value(static_cast<int64_t>(5)));
        // Example: Populate some typed extra fields if simulating a client that sends them
        if (client_simulated_target_version.major >= 4) {
            client_run_params.db = "system";
        }
    } catch (const std::bad_alloc&) {
        print_bolt_error_details_server("client sim RUN (bad_alloc)", BoltError::OUT_OF_MEMORY);
        client_run_prep_ok = false;
        return BoltError::OUT_OF_MEMORY;
    } catch (const std::exception& e_std) {
        std::cerr << "Std exception client sim RUN: " << e_std.what() << std::endl;
        print_bolt_error_details_server("client sim RUN (std::exception)", BoltError::UNKNOWN_ERROR);
        client_run_prep_ok = false;
        return BoltError::UNKNOWN_ERROR;
    }
    if (!client_run_prep_ok) return BoltError::UNKNOWN_ERROR;

    // Pass the target version for RUN serialization
    BoltError err = serialize_run_message(client_run_params, client_run_writer, client_simulated_target_version);
    if (err != BoltError::SUCCESS) {
        print_bolt_error_details_server("client sim serializing RUN", err, nullptr, &client_run_writer);
    }
    return err;
}

int main() {
    using namespace boltprotocol;

    std::cout << "Bolt Protocol Server Example (Refactored, No-Exception Mode)" << std::endl;
    std::cout << "------------------------------------------------------------" << std::endl;

    std::vector<uint8_t> server_receive_buffer_storage;
    std::vector<uint8_t> server_send_buffer_storage;
    BoltError err = BoltError::SUCCESS;

    versions::Version server_assumed_negotiated_version = versions::V5_3;  // Example version server operates as

    std::cout << "\nServer expecting HELLO message (simulating client targeting v" << static_cast<int>(server_assumed_negotiated_version.major) << "." << static_cast<int>(server_assumed_negotiated_version.minor) << ") ..." << std::endl;

    err = simulate_client_hello(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for HELLO (raw): ", server_receive_buffer_storage);

    HelloMessageParams actual_hello_params;
    {
        PackStreamReader hello_reader(server_receive_buffer_storage);
        err = deserialize_hello_message_request(hello_reader, actual_hello_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing HELLO request", err, &hello_reader);
            return 1;
        }
    }
    std::cout << "Server: HELLO message structure received and parsed." << std::endl;
    std::cout << "  User Agent from HELLO: " << actual_hello_params.user_agent << std::endl;
    if (actual_hello_params.bolt_agent.has_value()) {
        std::cout << "  Bolt Agent Product: " << actual_hello_params.bolt_agent.value().product << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter success_hello_writer(server_send_buffer_storage);
        err = ServerHandlers::handle_hello_message(actual_hello_params, success_hello_writer, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending SUCCESS (for HELLO) (raw): ", server_send_buffer_storage);

    // === Stage 2: Client sends RUN, Server processes and responds ===
    std::cout << "\nServer expecting RUN message..." << std::endl;
    // Client also simulates RUN targeting the assumed negotiated version
    err = simulate_client_run(server_assumed_negotiated_version, server_receive_buffer_storage);
    if (err != BoltError::SUCCESS) return 1;
    print_bytes_server("Server received bytes for RUN (raw): ", server_receive_buffer_storage);

    RunMessageParams actual_run_params;
    {
        PackStreamReader run_reader(server_receive_buffer_storage);
        // Server deserializes RUN based on the version it negotiated
        err = deserialize_run_message_request(run_reader, actual_run_params, server_assumed_negotiated_version);
        if (err != BoltError::SUCCESS) {
            print_bolt_error_details_server("Server deserializing RUN request", err, &run_reader);
            return 1;
        }
    }
    std::cout << "Server: RUN message structure received and parsed." << std::endl;
    if (actual_run_params.db.has_value()) {
        std::cout << "  RUN request for database: " << actual_run_params.db.value() << std::endl;
    }

    server_send_buffer_storage.clear();
    {
        PackStreamWriter run_response_writer(server_send_buffer_storage);
        // Pass the negotiated version to the handler if it needs to make version-specific decisions
        // For now, handle_run_message doesn't use it, but good practice.
        err = ServerHandlers::handle_run_message(actual_run_params, run_response_writer /*, server_assumed_negotiated_version */);
        if (err != BoltError::SUCCESS) {
            return 1;
        }
    }
    print_bytes_server("Server sending full response stream for RUN (raw): ", server_send_buffer_storage);

    std::cout << "\nServer example finished." << std::endl;
    return 0;
}#include "server_example_utils.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader, boltprotocol::PackStreamWriter* writer) {
    std::cerr << "Error (Server) " << context << ": " << static_cast<int>(err);
    if (reader && reader->has_error() && reader->get_error() != err) {
        std::cerr << " (Reader specific error: " << static_cast<int>(reader->get_error()) << ")";
    }
    if (writer && writer->has_error() && writer->get_error() != err) {
        std::cerr << " (Writer specific error: " << static_cast<int>(writer->get_error()) << ")";
    }
    std::cerr << std::endl;
}

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes) {
    std::cout << prefix;
    if (bytes.empty()) {
        std::cout << "(empty)" << std::endl;
        return;
    }
    for (uint8_t byte : bytes) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << " (size: " << bytes.size() << ")" << std::endl;
}#ifndef SERVER_EXAMPLE_UTILS_H
#define SERVER_EXAMPLE_UTILS_H

#include <cstdint>  // For uint8_t
#include <iomanip>  // For std::setw, std::setfill
#include <iostream>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

void print_bolt_error_details_server(const std::string& context, boltprotocol::BoltError err, boltprotocol::PackStreamReader* reader = nullptr, boltprotocol::PackStreamWriter* writer = nullptr);

void print_bytes_server(const std::string& prefix, const std::vector<uint8_t>& bytes);

#endif  // SERVER_EXAMPLE_UTILS_H#ifndef BOLTPROTOCOL_CORE_TYPES_H
#define BOLTPROTOCOL_CORE_TYPES_H

#include <cstdint>  // For uintXX_t types
#include <map>
#include <memory>  // For std::shared_ptr
#include <string>
#include <variant>  // For std::variant
#include <vector>

// Forward declarations within this file if mutually dependent, or include necessary headers
// For now, PackStreamStructure, BoltList, BoltMap are defined before Value uses them with shared_ptr.

namespace boltprotocol {

    // Forward declarations for Value variant members
    struct BoltList;
    struct BoltMap;
    struct PackStreamStructure;

    // Core PackStream Value type
    using Value = std::variant<std::nullptr_t, bool, int64_t, double, std::string, std::shared_ptr<BoltList>, std::shared_ptr<BoltMap>, std::shared_ptr<PackStreamStructure> >;

    // Definition for BoltList
    struct BoltList {
        std::vector<Value> elements;
        bool operator==(const BoltList& other) const {
            // Simple comparison, might need deep comparison for shared_ptr<Value> elements if Value itself can be complex.
            // Current Value::operator== handles shared_ptr comparison correctly.
            return elements == other.elements;
        }
    };

    // Definition for BoltMap
    struct BoltMap {
        std::map<std::string, Value> pairs;
        bool operator==(const BoltMap& other) const {
            return pairs == other.pairs;
        }
    };

    // Definition for PackStreamStructure
    struct PackStreamStructure {
        uint8_t tag = 0;
        std::vector<Value> fields;
        bool operator==(const PackStreamStructure& other) const {
            return tag == other.tag && fields == other.fields;
        }
    };

    // Global operator== for Value, needs full definitions of BoltList, BoltMap, PackStreamStructure
    // This declaration should ideally be where Value is fully defined or usable.
    // If moved to a .cpp, it needs to be declared here.
    // Keeping it here for header-only convenience if types are simple enough.
    // bool operator==(const Value& lhs, const Value& rhs); // Definition will be in message_defs.cpp (or a new core_types.cpp)

    // Global Constants
    constexpr uint32_t BOLT_MAGIC_PREAMBLE = 0x6060B017;
    // extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING; // Declaration here, definition in a .cpp file
    constexpr uint16_t MAX_CHUNK_PAYLOAD_SIZE = 65535;
    constexpr uint16_t CHUNK_HEADER_SIZE = 2;

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CORE_TYPES_H#ifndef BOLTPROTOCOL_ERRORS_VERSIONS_H
#define BOLTPROTOCOL_ERRORS_VERSIONS_H

#include <array>
#include <cstdint>
#include <string>  // For Version::to_string (建议添加)
#include <vector>

namespace boltprotocol {

    enum class BoltError {
        SUCCESS = 0,
        UNKNOWN_ERROR,
        INVALID_ARGUMENT,
        SERIALIZATION_ERROR,
        DESERIALIZATION_ERROR,
        INVALID_MESSAGE_FORMAT,
        UNSUPPORTED_PROTOCOL_VERSION,
        NETWORK_ERROR,
        HANDSHAKE_FAILED,
        HANDSHAKE_NO_COMMON_VERSION,
        HANDSHAKE_MAGIC_MISMATCH,
        CHUNK_TOO_LARGE,
        CHUNK_ENCODING_ERROR,
        CHUNK_DECODING_ERROR,
        OUT_OF_MEMORY,
        RECURSION_DEPTH_EXCEEDED,
        MESSAGE_TOO_LARGE
    };

    namespace versions {
        struct Version {
            uint8_t major = 0;
            uint8_t minor = 0;

            Version() = default;
            constexpr Version(uint8_t maj, uint8_t min) : major(maj), minor(min) {
            }

            // 核心比较操作符
            bool operator<(const Version& other) const;
            bool operator==(const Version& other) const;

            // 从核心操作符派生的其他比较操作符
            bool operator!=(const Version& other) const;
            bool operator>(const Version& other) const;
            bool operator<=(const Version& other) const;
            bool operator>=(const Version& other) const;

            std::string to_string() const;  // 便于调试

            std::array<uint8_t, 4> to_handshake_bytes() const;
            static BoltError from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version);
        };

        // 声明版本常量
        extern const Version V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3;  // 确保 V4_3 也被声明
        // extern const Version V4_2, V4_1, V4_0, V3_0;

        // 声明函数以获取默认建议版本
        extern const std::vector<Version>& get_default_proposed_versions();
    }  // namespace versions

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_ERRORS_VERSIONS_H#ifndef BOLTPROTOCOL_MESSAGE_PARAMS_H
#define BOLTPROTOCOL_MESSAGE_PARAMS_H

#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Message Parameter Structures ---

    struct HelloMessageParams {
        std::string user_agent;
        std::optional<std::string> auth_scheme;
        std::optional<std::string> auth_principal;
        std::optional<std::string> auth_credentials;
        std::optional<std::map<std::string, Value>> auth_scheme_specific_tokens;  // For complex schemes like custom
        std::optional<std::map<std::string, Value>> routing_context;
        std::optional<std::vector<std::string>> patch_bolt;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        struct BoltAgentInfo {
            std::string product;
            std::optional<std::string> platform;
            std::optional<std::string> language;
            std::optional<std::string> language_details;
        };
        std::optional<BoltAgentInfo> bolt_agent;
        std::map<std::string, Value> other_extra_tokens;  // For any other non-standard tokens
    };

    struct RunMessageParams {
        std::string cypher_query;
        std::map<std::string, Value> parameters;
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the implicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the implicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt < 5.0)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct DiscardMessageParams {
        std::optional<int64_t> n;    // Number of records to discard (-1 for all)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct PullMessageParams {
        std::optional<int64_t> n;    // Number of records to pull (-1 for all remaining in current batch context)
        std::optional<int64_t> qid;  // Query ID for Bolt 4.0+
    };
    struct BeginMessageParams {
        std::optional<std::vector<std::string>> bookmarks;
        std::optional<int64_t> tx_timeout;                        // Timeout for the explicit transaction
        std::optional<std::map<std::string, Value>> tx_metadata;  // Metadata for the explicit transaction
        std::optional<std::string> mode;                          // "r" for read (Bolt 5.0+)
        std::optional<std::string> db;
        std::optional<std::string> imp_user;
        std::optional<std::string> notifications_min_severity;
        std::optional<std::vector<std::string>> notifications_disabled_categories;
        std::map<std::string, Value> other_extra_fields;  // For any other non-standard fields
    };

    struct CommitMessageParams { /* PSS field is an empty map {} */
    };
    struct RollbackMessageParams { /* PSS field is an empty map {} */
    };

    struct RouteMessageParams {
        std::map<std::string, Value> routing_table_context;
        std::vector<std::string> bookmarks;
        std::optional<std::string> db_name_for_v43;  // Bolt 4.3: db (String or null)
        // Bolt 4.4+: extra map (can contain "db" and/or "imp_user")
        // Bolt 5.1+: extra map can also contain "notifications_min_severity", "notifications_disabled_categories"
        std::optional<std::map<std::string, Value>> extra_for_v44_plus;
    };

    struct TelemetryMessageParams {
        std::map<std::string, Value> metadata;  // api (int)
    };
    struct LogonMessageParams {
        std::map<std::string, Value> auth_tokens;
    };
    struct LogoffMessageParams { /* No fields */
    };

    struct SuccessMessageParams {
        std::map<std::string, Value> metadata;
    };
    struct RecordMessageParams {
        std::vector<Value> fields;
    };
    struct FailureMessageParams {
        std::map<std::string, Value> metadata;  // code (String), message (String)
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_PARAMS_H#ifndef BOLTPROTOCOL_MESSAGE_TAGS_H
#define BOLTPROTOCOL_MESSAGE_TAGS_H

#include <cstdint>

namespace boltprotocol {

    enum class MessageTag : uint8_t {
        HELLO = 0x01,
        RUN = 0x10,
        DISCARD = 0x2F,
        PULL = 0x3F,
        BEGIN = 0x11,
        COMMIT = 0x12,
        ROLLBACK = 0x13,
        RESET = 0x0F,
        GOODBYE = 0x02,
        ROUTE = 0x66,
        TELEMETRY = 0x54,
        LOGON = 0x6A,
        LOGOFF = 0x6B,
        SUCCESS = 0x70,
        RECORD = 0x71,
        IGNORED = 0x7E,
        FAILURE = 0x7F,
        // INIT = 0x01, // Same as HELLO tag
        // ACK_FAILURE = 0x0E // Bolt v1/v2 only
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_TAGS_H#ifndef BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H
#define BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_structure_types.h"

namespace boltprotocol {

    // --- Conversion from PackStreamStructure to Typed Struct ---

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    // For from_packstream, utc_patch_active might not be strictly needed if we rely on the tag ('I' vs 'F') primarily.
    // However, for to_packstream, it's crucial for Bolt 4.4.
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version /*, bool utc_patch_active_for_4_4 = false (tag driven)*/);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);

    // --- Conversion from Typed Struct to PackStreamStructure ---

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);               // <--- MODIFIED
    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss);  // <--- MODIFIED
    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss);

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss);
    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss);

    // Convenience template to extract from Value
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct, const versions::Version& bolt_version, bool utc_patch_active_for_4_4 = false) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Dispatch to the correct from_packstream overload based on T
        if constexpr (std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId> || std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath>) {
            // These types' from_packstream take bolt_version.
            // For DateTime/DateTimeZoneId, utc_patch_active is not directly used by from_packstream (tag driven).
            return from_packstream(*pss_sptr, out_typed_struct, bolt_version);
        } else {
            // For types like BoltDate, BoltTime, etc., that don't need bolt_version for from_packstream.
            return from_packstream(*pss_sptr, out_typed_struct);
        }
    }
    // Keep the overload for types not needing version or patch info for deserialization (tag-driven)
    template <typename T>
    BoltError value_to_typed_struct(const Value& value, T& out_typed_struct) {
        if (!std::holds_alternative<std::shared_ptr<PackStreamStructure>>(value)) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(value);
        if (!pss_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // This simple overload is suitable for types whose from_packstream does not need a version.
        // For version-dependent types, the other overload must be used.
        return from_packstream(*pss_sptr, out_typed_struct);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_SERIALIZATION_H#ifndef BOLTPROTOCOL_STRUCTURE_TYPES_H
#define BOLTPROTOCOL_STRUCTURE_TYPES_H

#include <cstdint>
#include <map>
#include <memory>  // For std::shared_ptr in Path
#include <optional>
#include <string>
#include <vector>

#include "bolt_core_types.h"  // For Value, BoltMap, BoltList, PackStreamStructure
// bolt_errors_versions.h might be needed if version checks are done during construction/conversion
#include "bolt_errors_versions.h"

namespace boltprotocol {

    // --- Graph Primitives ---

    // Tag: 0x4E ('N')
    struct BoltNode {
        int64_t id;                               // Field 0: id (Integer)
        std::vector<std::string> labels;          // Field 1: labels (List<String>)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        // Default constructor
        BoltNode() : id(0) {
        }

        bool operator==(const BoltNode& other) const {
            return id == other.id && labels == other.labels && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x52 ('R')
    struct BoltRelationship {
        int64_t id;                                        // Field 0: id (Integer)
        int64_t start_node_id;                             // Field 1: startNodeId (Integer)
        int64_t end_node_id;                               // Field 2: endNodeId (Integer)
        std::string type;                                  // Field 3: type (String)
        std::map<std::string, Value> properties;           // Field 4: properties (Map)
        std::optional<std::string> element_id;             // Field 5: element_id (String, Bolt 5.0+)
        std::optional<std::string> start_node_element_id;  // Field 6: start_node_element_id (String, Bolt 5.0+)
        std::optional<std::string> end_node_element_id;    // Field 7: end_node_element_id (String, Bolt 5.0+)

        BoltRelationship() : id(0), start_node_id(0), end_node_id(0) {
        }

        bool operator==(const BoltRelationship& other) const {
            return id == other.id && start_node_id == other.start_node_id && end_node_id == other.end_node_id && type == other.type && properties == other.properties && element_id == other.element_id && start_node_element_id == other.start_node_element_id &&
                   end_node_element_id == other.end_node_element_id;
        }
    };

    // Tag: 0x72 ('r') - Unbound Relationship (used within Path)
    struct BoltUnboundRelationship {
        int64_t id;                               // Field 0: id (Integer)
        std::string type;                         // Field 1: type (String)
        std::map<std::string, Value> properties;  // Field 2: properties (Map)
        std::optional<std::string> element_id;    // Field 3: element_id (String, Bolt 5.0+)

        BoltUnboundRelationship() : id(0) {
        }

        bool operator==(const BoltUnboundRelationship& other) const {
            return id == other.id && type == other.type && properties == other.properties && element_id == other.element_id;
        }
    };

    // Tag: 0x50 ('P')
    struct BoltPath {
        std::vector<BoltNode> nodes;                // Field 0: nodes (List<Node>)
        std::vector<BoltUnboundRelationship> rels;  // Field 1: rels (List<UnboundRelationship>)
        std::vector<int64_t> indices;               // Field 2: indices (List<Integer>)
        // Note: For Path, nodes and rels are lists of *actual* BoltNode/BoltUnboundRelationship objects,
        // not shared_ptr<PackStreamStructure>. The conversion logic will handle this.

        bool operator==(const BoltPath& other) const {
            return nodes == other.nodes && rels == other.rels && indices == other.indices;
        }
    };

    // --- Temporal Types ---

    // Tag: 0x44 ('D') - Date
    struct BoltDate {
        int64_t days_since_epoch;  // days since Unix epoch (1970-01-01)

        BoltDate(int64_t days = 0) : days_since_epoch(days) {
        }
        bool operator==(const BoltDate& other) const {
            return days_since_epoch == other.days_since_epoch;
        }
    };

    // Tag: 0x54 ('T') - Time (with offset)
    struct BoltTime {
        int64_t nanoseconds_since_midnight;  // nanoseconds since midnight for the given offset
        int32_t tz_offset_seconds;           // offset in seconds from UTC

        BoltTime(int64_t nanos = 0, int32_t offset = 0) : nanoseconds_since_midnight(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x74 ('t') - LocalTime
    struct BoltLocalTime {
        int64_t nanoseconds_since_midnight;

        BoltLocalTime(int64_t nanos = 0) : nanoseconds_since_midnight(nanos) {
        }
        bool operator==(const BoltLocalTime& other) const {
            return nanoseconds_since_midnight == other.nanoseconds_since_midnight;
        }
    };

    // Tag: 0x49 ('I') - DateTime (with offset, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTime (tag 0x46 'F')
    struct BoltDateTime {
        int64_t seconds_epoch_utc;      // seconds since Unix epoch (UTC)
        int32_t nanoseconds_of_second;  // nanoseconds within the second (0 to 999,999,999)
        int32_t tz_offset_seconds;      // offset in seconds from UTC for the original instant

        BoltDateTime(int64_t secs = 0, int32_t nanos = 0, int32_t offset = 0) : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_offset_seconds(offset) {
        }
        bool operator==(const BoltDateTime& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_offset_seconds == other.tz_offset_seconds;
        }
    };

    // Tag: 0x69 ('i') - DateTimeZoneId (with named zone, Bolt 5.0+ and 4.4 with "utc" patch)
    // Replaces Legacy DateTimeZoneId (tag 0x66 'f')
    struct BoltDateTimeZoneId {
        int64_t seconds_epoch_utc;
        int32_t nanoseconds_of_second;
        std::string tz_id;  // Timezone ID string (e.g., "Europe/Paris")

        BoltDateTimeZoneId(int64_t secs = 0, int32_t nanos = 0, std::string id = "") : seconds_epoch_utc(secs), nanoseconds_of_second(nanos), tz_id(std::move(id)) {
        }
        bool operator==(const BoltDateTimeZoneId& other) const {
            return seconds_epoch_utc == other.seconds_epoch_utc && nanoseconds_of_second == other.nanoseconds_of_second && tz_id == other.tz_id;
        }
    };

    // Tag: 0x64 ('d') - LocalDateTime
    struct BoltLocalDateTime {
        int64_t seconds_epoch_local;  // seconds since Unix epoch, interpreted as local datetime
        int32_t nanoseconds_of_second;

        BoltLocalDateTime(int64_t secs = 0, int32_t nanos = 0) : seconds_epoch_local(secs), nanoseconds_of_second(nanos) {
        }
        bool operator==(const BoltLocalDateTime& other) const {
            return seconds_epoch_local == other.seconds_epoch_local && nanoseconds_of_second == other.nanoseconds_of_second;
        }
    };

    // Tag: 0x45 ('E') - Duration
    struct BoltDuration {
        int64_t months;
        int64_t days;
        int64_t seconds;
        int32_t nanoseconds;  // nanoseconds adjustment for seconds component

        BoltDuration(int64_t m = 0, int64_t d = 0, int64_t s = 0, int32_t ns = 0) : months(m), days(d), seconds(s), nanoseconds(ns) {
        }
        bool operator==(const BoltDuration& other) const {
            return months == other.months && days == other.days && seconds == other.seconds && nanoseconds == other.nanoseconds;
        }
    };

    // --- Spatial Types ---

    // Tag: 0x58 ('X') - Point2D
    struct BoltPoint2D {
        uint32_t srid;  // Spatial Reference System Identifier
        double x;
        double y;

        BoltPoint2D(uint32_t id = 0, double px = 0.0, double py = 0.0) : srid(id), x(px), y(py) {
        }
        bool operator==(const BoltPoint2D& other) const {
            return srid == other.srid && x == other.x && y == other.y;
        }
    };

    // Tag: 0x59 ('Y') - Point3D
    struct BoltPoint3D {
        uint32_t srid;
        double x;
        double y;
        double z;

        BoltPoint3D(uint32_t id = 0, double px = 0.0, double py = 0.0, double pz = 0.0) : srid(id), x(px), y(py), z(pz) {
        }
        bool operator==(const BoltPoint3D& other) const {
            return srid == other.srid && x == other.x && y == other.y && z == other.z;
        }
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_STRUCTURE_TYPES_H#ifndef BOLTPROTOCOL_CHUNKING_H
#define BOLTPROTOCOL_CHUNKING_H

#include <cstdint>
#include <functional>  // For std::function
#include <iosfwd>      // For std::istream, std::ostream
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltError, MAX_CHUNK_PAYLOAD_SIZE, CHUNK_HEADER_SIZE

namespace boltprotocol {

    /**
     * @brief ChunkedWriter 用于将完整的 Bolt 消息分块写入输出流。
     */
    class ChunkedWriter {
      public:
        explicit ChunkedWriter(std::ostream& stream);

        // 禁止拷贝和移动，因为其持有流的引用
        ChunkedWriter(const ChunkedWriter&) = delete;
        ChunkedWriter& operator=(const ChunkedWriter&) = delete;
        ChunkedWriter(ChunkedWriter&&) = delete;
        ChunkedWriter& operator=(ChunkedWriter&&) = delete;

        /**
         * @brief 将提供的完整消息数据分块写入流。
         *        会自动添加块头和末尾的空块。
         * @param message_data 包含单个完整 Bolt 消息的字节向量。
         * @return BoltError::SUCCESS 如果所有块都成功写入。
         *         BoltError::NETWORK_ERROR 如果流写入失败。
         *         BoltError::SERIALIZATION_ERROR 如果内部逻辑错误（例如块大小计算）。
         */
        BoltError write_message(const std::vector<uint8_t>& message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }

        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError write_chunk(const uint8_t* data, uint16_t size);
        BoltError write_chunk_header(uint16_t chunk_payload_size);
        BoltError write_end_of_message_marker();  // Writes a zero-size chunk

        void set_error(BoltError err);

        std::ostream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
    };

    /**
     * @brief ChunkedReader 用于从输入流中读取分块的 Bolt 消息。
     */
    class ChunkedReader {
      public:
        explicit ChunkedReader(std::istream& stream);

        // 禁止拷贝和移动
        ChunkedReader(const ChunkedReader&) = delete;
        ChunkedReader& operator=(const ChunkedReader&) = delete;
        ChunkedReader(ChunkedReader&&) = delete;
        ChunkedReader& operator=(ChunkedReader&&) = delete;

        /**
         * @brief 从流中读取一个完整的 Bolt 消息。
         *        它会持续读取数据块，直到遇到表示消息结束的空块。
         * @param out_message_data 输出参数，用于存储组装好的完整消息字节。
         *                         如果发生错误，此参数的内容未定义。
         * @return BoltError::SUCCESS 如果成功读取并组装了一个完整的消息。
         *         BoltError::NETWORK_ERROR 如果流读取失败。
         *         BoltError::DESERIALIZATION_ERROR 如果块格式无效或消息过大。
         *         BoltError::CHUNK_TOO_LARGE 如果单个块的声明大小超过 MAX_CHUNK_PAYLOAD_SIZE.
         */
        BoltError read_message(std::vector<uint8_t>& out_message_data);

        /**
         * @brief 获取最后一次操作的错误状态。
         */
        BoltError get_error() const {
            return last_error_;
        }
        /**
         * @brief 检查是否发生了错误。
         */
        bool has_error() const {
            return last_error_ != BoltError::SUCCESS;
        }

      private:
        BoltError read_chunk_header(uint16_t& out_chunk_payload_size);
        BoltError read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to);

        void set_error(BoltError err);

        std::istream& stream_;
        BoltError last_error_ = BoltError::SUCCESS;
        // 可以在这里添加一个内部缓冲区来优化小块的读取，但为了简单起见，暂时直接追加到输出向量
    };

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_CHUNKING_H#ifndef BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H
#define BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H

#include <map>
#include <memory>  // For std::shared_ptr
#include <optional>
#include <string>
#include <variant>  // For std::holds_alternative, std::get
#include <vector>

#include "boltprotocol/bolt_core_types.h"       // For Value, BoltList, BoltMap, PackStreamStructure
#include "boltprotocol/bolt_errors_versions.h"  // For versions::Version, BoltError
#include "boltprotocol/bolt_structure_types.h"  // For forward declaring BoltNode etc. if needed, or full defs for recursion

// Forward declare from_packstream for recursive calls in get_typed_list_field
namespace boltprotocol {
    // We need to forward declare all from_packstream overloads that might be called recursively
    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date);
    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version);
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime);
    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point);
    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point);
}  // namespace boltprotocol

namespace boltprotocol {
    namespace detail {

        template <typename T>
        inline std::optional<T> get_typed_field(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<T>(field_value)) {
                    try {
                        return std::get<T>(field_value);
                    } catch (const std::bad_variant_access&) { /* Defensive */
                    }
                }
            }
            return std::nullopt;
        }

        // Specialization for shared_ptr<BoltMap> to return the inner map directly
        template <>
        inline std::optional<std::map<std::string, Value>> get_typed_field<std::map<std::string, Value>>(const std::vector<Value>& fields, size_t index) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltMap>>(field_value)) {
                    const auto& map_sptr = std::get<std::shared_ptr<BoltMap>>(field_value);
                    if (map_sptr) {
                        try {
                            return map_sptr->pairs;
                        } catch (...) { /* map copy failed */
                        }
                    }
                }
            }
            return std::nullopt;
        }

        template <typename T>  // T is the target strong type, e.g., BoltNode
        inline std::optional<std::vector<T>> get_typed_list_field(const std::vector<Value>& fields, size_t index, const versions::Version* bolt_version_for_nested = nullptr) {
            if (index < fields.size()) {
                const Value& field_value = fields[index];
                if (std::holds_alternative<std::shared_ptr<BoltList>>(field_value)) {
                    const auto& list_sptr = std::get<std::shared_ptr<BoltList>>(field_value);
                    if (list_sptr) {
                        std::vector<T> result;
                        result.reserve(list_sptr->elements.size());
                        bool conversion_ok = true;
                        for (const auto& list_element_value : list_sptr->elements) {
                            if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(list_element_value)) {
                                const auto& element_pss_sptr = std::get<std::shared_ptr<PackStreamStructure>>(list_element_value);
                                if (element_pss_sptr) {
                                    T typed_element;
                                    BoltError err = BoltError::UNKNOWN_ERROR;  // Initialize to an error state

                                    // Dispatch based on type T for version parameter
                                    if constexpr (std::is_same_v<T, BoltNode> || std::is_same_v<T, BoltRelationship> || std::is_same_v<T, BoltUnboundRelationship> || std::is_same_v<T, BoltPath> || std::is_same_v<T, BoltDateTime> || std::is_same_v<T, BoltDateTimeZoneId>) {
                                        if (!bolt_version_for_nested) {  // Version is required for these types
                                            conversion_ok = false;
                                            break;
                                        }
                                        err = from_packstream(*element_pss_sptr, typed_element, *bolt_version_for_nested);
                                    } else {  // For types like BoltDate, BoltTime, etc., that don't need version for from_packstream
                                        err = from_packstream(*element_pss_sptr, typed_element);
                                    }

                                    if (err == BoltError::SUCCESS) {
                                        try {
                                            result.push_back(std::move(typed_element));
                                        } catch (...) {
                                            conversion_ok = false;
                                            break;
                                        }
                                    } else {
                                        conversion_ok = false;
                                        break;
                                    }
                                } else {
                                    conversion_ok = false;
                                    break;
                                }  // Null PSS in list
                            } else {
                                conversion_ok = false;
                                break;
                            }  // Element not a PSS
                        }
                        if (conversion_ok) return result;
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_DETAIL_STRUCTURE_HELPERS_H#ifndef BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H
#define BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H

#include <algorithm>  // For std::reverse
#include <bit>        // For std::endian (C++20 and later)
#include <cstdint>
#include <type_traits>  // For std::is_integral_v, std::is_enum_v

namespace boltprotocol {
    namespace detail {

        // Helper to swap bytes of an integer type T
        template <typename T>
        inline T swap_bytes_helper(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "swap_bytes_helper requires an integral or enum type.");
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
            auto* bytes = reinterpret_cast<unsigned char*>(&value);
            std::reverse(bytes, bytes + sizeof(T));
            return value;
        }

        // --- Host to Big Endian (Network Order) ---
        inline uint16_t host_to_be(uint16_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {  // std::endian::big (or other, assuming network order is what we want if not little)
                return val;
            }
        }

        inline uint32_t host_to_be(uint32_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        inline uint64_t host_to_be(uint64_t val) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val);
            } else {
                return val;
            }
        }

        // --- Big Endian (Network Order) to Host ---
        inline uint16_t be_to_host(uint16_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint32_t be_to_host(uint32_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

        inline uint64_t be_to_host(uint64_t val_be) {
            if constexpr (std::endian::native == std::endian::little) {
                return swap_bytes_helper(val_be);
            } else {
                return val_be;
            }
        }

    }  // namespace detail
}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_DETAIL_BYTE_ORDER_UTILS_H#ifndef BOLTPROTOCOL_HANDSHAKE_H
#define BOLTPROTOCOL_HANDSHAKE_H

#include <array>
#include <boost/asio/basic_socket_iostream.hpp>  // For boost::asio::basic_socket_iostream
#include <boost/asio/ip/tcp.hpp>                 // For boost::asio::ip::tcp
#include <boost/asio/read.hpp>
#include <boost/asio/ssl/stream.hpp>  // For boost::asio::ssl::stream
#include <boost/asio/write.hpp>
#include <boost/system/error_code.hpp>
#include <cstdint>
#include <cstring>  // For std::memcpy
#include <istream>  // For std::istream characteristics if needed
#include <ostream>  // For std::ostream characteristics if needed
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"

namespace boltprotocol {

    constexpr size_t HANDSHAKE_NUM_PROPOSED_VERSIONS = 4;
    constexpr size_t HANDSHAKE_VERSION_SIZE_BYTES = 4;
    constexpr size_t HANDSHAKE_REQUEST_SIZE_BYTES = sizeof(BOLT_MAGIC_PREAMBLE) + (HANDSHAKE_NUM_PROPOSED_VERSIONS * HANDSHAKE_VERSION_SIZE_BYTES);
    constexpr size_t HANDSHAKE_RESPONSE_SIZE_BYTES = HANDSHAKE_VERSION_SIZE_BYTES;

    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes);
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response, versions::Version& out_negotiated_version);

    template <typename StreamType>
    BoltError perform_handshake(StreamType& stream, const std::vector<versions::Version>& proposed_versions, versions::Version& out_negotiated_version) {
        std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES> handshake_request_bytes;
        BoltError build_err = build_handshake_request(proposed_versions, handshake_request_bytes);
        if (build_err != BoltError::SUCCESS) {
            return build_err;
        }

        std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES> server_response_bytes;
        boost::system::error_code ec;

        // 使用 if constexpr 根据 StreamType 选择不同的 IO 操作
        if constexpr (std::is_base_of_v<std::basic_iostream<char>, StreamType> &&
                      // 进一步区分 basic_socket_iostream 和其他可能继承 std::iostream 的 Boost 类型
                      (std::is_same_v<StreamType, boost::asio::ip::tcp::iostream> || std::is_same_v<StreamType, boost::asio::basic_socket_iostream<boost::asio::ip::tcp>>)) {
            // 这是 boost::asio::ip::tcp::iostream 或其基类 basic_socket_iostream
            // 使用标准的 iostream 成员函数
            stream.write(reinterpret_cast<const char*>(handshake_request_bytes.data()), HANDSHAKE_REQUEST_SIZE_BYTES);
            if (stream.fail()) return BoltError::NETWORK_ERROR;
            stream.flush();
            if (stream.fail()) return BoltError::NETWORK_ERROR;

            stream.read(reinterpret_cast<char*>(server_response_bytes.data()), HANDSHAKE_RESPONSE_SIZE_BYTES);
            if (stream.fail() || static_cast<size_t>(stream.gcount()) != HANDSHAKE_RESPONSE_SIZE_BYTES) {
                return BoltError::NETWORK_ERROR;
            }
        } else {
            // 假设是其他 Boost.ASIO 同步流类型，如 ssl::stream 或 ip::tcp::socket
            // 使用 boost::asio::write 和 boost::asio::read 自由函数
            boost::asio::write(stream, boost::asio::buffer(handshake_request_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }

            boost::asio::read(stream, boost::asio::buffer(server_response_bytes), ec);
            if (ec) {
                return BoltError::NETWORK_ERROR;
            }
        }

        return parse_handshake_response(server_response_bytes, out_negotiated_version);
    }

}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_HANDSHAKE_H#ifndef BOLTPROTOCOL_MESSAGE_DEFS_H
#define BOLTPROTOCOL_MESSAGE_DEFS_H

#include "bolt_core_types.h"
#include "bolt_errors_versions.h"
#include "bolt_message_params.h"
#include "bolt_message_tags.h"
#include "bolt_structure_types.h"  // <--- ADDED: For BoltNode, BoltDate etc.
// bolt_structure_serialization.h is for functions, not direct types needed by message_params generally

namespace boltprotocol {
    extern const std::string DEFAULT_USER_AGENT_FORMAT_STRING;
    bool operator==(const Value& lhs, const Value& rhs);
}  // namespace boltprotocol

#endif  // BOLTPROTOCOL_MESSAGE_DEFS_H#ifndef BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H
#define BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    // --- Client Message Serialization (Client -> Server) ---
    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version);
    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_goodbye_message(PackStreamWriter& writer);
    BoltError serialize_reset_message(PackStreamWriter& writer);
    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version);
    BoltError serialize_commit_message(PackStreamWriter& writer);
    BoltError serialize_rollback_message(PackStreamWriter& writer);
    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version);
    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer);
    BoltError serialize_logoff_message(PackStreamWriter& writer);

    // --- Server Message Deserialization (Server -> Client) ---
    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params);
    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params);
    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params);
    BoltError deserialize_ignored_message(PackStreamReader& reader);

    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents);

    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count);

    // --- Server-Side Deserialization of Client Requests ---
    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version);
    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params);
    BoltError deserialize_logoff_message_request(PackStreamReader& reader);
    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version);

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version);        // <--- MODIFIED
    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- MODIFIED
    BoltError deserialize_commit_message_request(PackStreamReader& reader);
    BoltError deserialize_rollback_message_request(PackStreamReader& reader);
    BoltError deserialize_reset_message_request(PackStreamReader& reader);
    BoltError deserialize_goodbye_message_request(PackStreamReader& reader);
    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version);  // <--- ADDED
    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params);                                              // <--- ADDED

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_MESSAGE_SERIALIZATION_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H

#include <cstdint>

namespace boltprotocol {

    // PackStream Marker Bytes
    constexpr uint8_t MARKER_NULL = 0xC0;
    constexpr uint8_t MARKER_FALSE = 0xC2;
    constexpr uint8_t MARKER_TRUE = 0xC3;
    constexpr uint8_t MARKER_FLOAT64 = 0xC1;

    // Integer markers
    // Tiny Int: -16 to 127 directly encoded in the marker byte
    // INT_8:  0xC8 <int8>
    // INT_16: 0xC9 <int16>
    // INT_32: 0xCA <int32>
    // INT_64: 0xCB <int64>
    constexpr uint8_t MARKER_INT_8 = 0xC8;
    constexpr uint8_t MARKER_INT_16 = 0xC9;
    constexpr uint8_t MARKER_INT_32 = 0xCA;
    constexpr uint8_t MARKER_INT_64 = 0xCB;

    // String markers
    // TINY_STRING: 0x80..0x8F (length 0-15)
    // STRING_8:    0xD0 <len_uint8> <utf8_bytes>
    // STRING_16:   0xD1 <len_uint16> <utf8_bytes>
    // STRING_32:   0xD2 <len_uint32> <utf8_bytes>
    constexpr uint8_t MARKER_TINY_STRING_BASE = 0x80;  // Base for 0x80 | len
    constexpr uint8_t MARKER_STRING_8 = 0xD0;
    constexpr uint8_t MARKER_STRING_16 = 0xD1;
    constexpr uint8_t MARKER_STRING_32 = 0xD2;

    // List markers
    // TINY_LIST:   0x90..0x9F (size 0-15)
    // LIST_8:      0xD4 <size_uint8>
    // LIST_16:     0xD5 <size_uint16>
    // LIST_32:     0xD6 <size_uint32>
    constexpr uint8_t MARKER_TINY_LIST_BASE = 0x90;  // Base for 0x90 | size
    constexpr uint8_t MARKER_LIST_8 = 0xD4;
    constexpr uint8_t MARKER_LIST_16 = 0xD5;
    constexpr uint8_t MARKER_LIST_32 = 0xD6;

    // Map markers
    // TINY_MAP:    0xA0..0xAF (size 0-15)
    // MAP_8:       0xD8 <size_uint8>
    // MAP_16:      0xD9 <size_uint16>
    // MAP_32:      0xDA <size_uint32>
    constexpr uint8_t MARKER_TINY_MAP_BASE = 0xA0;  // Base for 0xA0 | size
    constexpr uint8_t MARKER_MAP_8 = 0xD8;
    constexpr uint8_t MARKER_MAP_16 = 0xD9;
    constexpr uint8_t MARKER_MAP_32 = 0xDA;

    // Structure markers
    // TINY_STRUCT: 0xB0..0xBF (size 0-15) <tag_uint8>
    // STRUCT_8:    0xDC <size_uint8> <tag_uint8>
    // STRUCT_16:   0xDD <size_uint16> <tag_uint8>
    constexpr uint8_t MARKER_TINY_STRUCT_BASE = 0xB0;  // Base for 0xB0 | size
    constexpr uint8_t MARKER_STRUCT_8 = 0xDC;
    constexpr uint8_t MARKER_STRUCT_16 = 0xDD;

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_CONSTANTS_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamReader {
      public:
        explicit PackStreamReader(const std::vector<uint8_t>& buffer);
        explicit PackStreamReader(std::istream& stream);

        // 禁止拷贝和移动以避免对内部状态和流/缓冲区的复杂管理
        PackStreamReader(const PackStreamReader&) = delete;
        PackStreamReader& operator=(const PackStreamReader&) = delete;
        PackStreamReader(PackStreamReader&&) = delete;
        PackStreamReader& operator=(PackStreamReader&&) = delete;

        /**
         * @brief Reads a single PackStream Value from the input.
         * @param out_value Output parameter where the read Value will be stored if successful.
         *                  Its content is undefined if an error occurs.
         * @return BoltError::SUCCESS on successful read.
         *         BoltError::DESERIALIZATION_ERROR for format errors, unexpected EOF, etc.
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if reader not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails.
         */
        BoltError read(Value& out_value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

        /**
         * @brief Checks if the end of the underlying buffer or stream has been reached.
         *        Also returns true if an error has occurred, as further reading is not possible.
         * @return True if EOF or error, false otherwise.
         */
        bool eof() const;

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError peek_byte(uint8_t& out_byte);
        BoltError consume_byte(uint8_t& out_byte);
        BoltError consume_bytes(void* dest, size_t size);

        template <typename T>
        BoltError consume_network_int(T& out_val) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "consume_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;  // 如果已处于错误状态，则不继续

            // 初始化 out_val 以防早期返回
            out_val = T{};
            BoltError err;

            if constexpr (sizeof(T) == 1) {
                uint8_t byte_val;
                err = consume_byte(byte_val);
                if (err != BoltError::SUCCESS) return err;
                out_val = static_cast<T>(byte_val);
                return BoltError::SUCCESS;
            } else {
                typename std::conditional<sizeof(T) == 2, uint16_t, typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type>::type raw_be_val = 0;

                err = consume_bytes(&raw_be_val, sizeof(raw_be_val));
                if (err != BoltError::SUCCESS) return err;

                if constexpr (sizeof(T) == 2) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint16_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 4) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint32_t>(raw_be_val)));
                } else if constexpr (sizeof(T) == 8) {
                    out_val = static_cast<T>(detail::be_to_host(static_cast<uint64_t>(raw_be_val)));
                } else {
                    static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for consume_network_int.");
                    set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                    return BoltError::INVALID_ARGUMENT;
                }
                return BoltError::SUCCESS;
            }
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的读取辅助函数 (现在返回 BoltError 并通过 out_value 输出参数返回结果)
        BoltError read_null_value(Value& out_value);
        BoltError read_boolean_value(bool bool_val_from_marker, Value& out_value);
        BoltError read_float64_value(Value& out_value);
        BoltError read_integer_value(uint8_t marker, Value& out_value);
        BoltError read_string_value(uint8_t marker, Value& out_value);
        BoltError read_string_data_into(std::string& out_string, uint32_t size);
        BoltError read_list_value(uint8_t marker, Value& out_value);
        BoltError read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size);
        BoltError read_map_value(uint8_t marker, Value& out_value);
        BoltError read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size);
        BoltError read_struct_value(uint8_t marker, Value& out_value);
        BoltError read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size);

        const std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::istream* stream_ptr_ = nullptr;
        size_t buffer_pos_ = 0;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器，用于防止解析恶意构造的数据时栈溢出
        // (在实际的 read_list/map/struct_elements_into 中使用)
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 可配置
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_READER_H#ifndef BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H
#define BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H

#include <cstdint>
#include <iosfwd>
#include <memory>  // For std::shared_ptr (used in Value)
#include <string>
#include <type_traits>
#include <vector>

#include "boltprotocol/detail/byte_order_utils.h"
#include "boltprotocol/message_defs.h"  // Includes Value, BoltError
#include "boltprotocol/packstream_constants.h"

namespace boltprotocol {

    class PackStreamWriter {
      public:
        explicit PackStreamWriter(std::vector<uint8_t>& buffer);
        explicit PackStreamWriter(std::ostream& stream);

        // 禁止拷贝和移动
        PackStreamWriter(const PackStreamWriter&) = delete;
        PackStreamWriter& operator=(const PackStreamWriter&) = delete;
        PackStreamWriter(PackStreamWriter&&) = delete;
        PackStreamWriter& operator=(PackStreamWriter&&) = delete;

        /**
         * @brief Writes a single PackStream Value to the output.
         * @param value The Value to serialize and write.
         * @return BoltError::SUCCESS on successful write.
         *         BoltError::SERIALIZATION_ERROR for logical errors (e.g., string too long).
         *         BoltError::NETWORK_ERROR for underlying stream errors.
         *         BoltError::INVALID_ARGUMENT if writer not properly initialized.
         *         BoltError::OUT_OF_MEMORY if a memory allocation fails (e.g. vector resize).
         */
        BoltError write(const Value& value);

        bool has_error() const {
            return error_state_ != BoltError::SUCCESS;
        }
        BoltError get_error() const {
            return error_state_;
        }

      private:
        // 底层IO辅助函数, 它们会设置 error_state_
        BoltError append_byte(uint8_t byte);
        BoltError append_bytes(const void* data, size_t size);

        template <typename T>
        BoltError append_network_int(T value) {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "append_network_int requires an integral or enum type.");
            if (has_error()) return error_state_;

            BoltError err;
            if constexpr (sizeof(T) == 1) {
                err = append_byte(static_cast<uint8_t>(value));
            } else if constexpr (sizeof(T) == 2) {
                uint16_t be_val = detail::host_to_be(static_cast<uint16_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 4) {
                uint32_t be_val = detail::host_to_be(static_cast<uint32_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else if constexpr (sizeof(T) == 8) {
                uint64_t be_val = detail::host_to_be(static_cast<uint64_t>(value));
                err = append_bytes(&be_val, sizeof(be_val));
            } else {
                static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, "Unsupported integer size for append_network_int.");
                set_error(BoltError::INVALID_ARGUMENT);  // 理论上会被 static_assert 捕获
                return BoltError::INVALID_ARGUMENT;
            }
            return err;  // 返回 append_byte 或 append_bytes 的结果
        }

      public:
        void set_error(BoltError error);

      private:
        // 类型特定的内部写入函数 (现在返回 BoltError)
        BoltError write_null_internal();
        BoltError write_boolean_internal(bool bool_value);
        BoltError write_integer_internal(int64_t int_value);
        BoltError write_float_internal(double float_value);
        BoltError write_string_header_internal(uint32_t size);
        BoltError write_string_data_internal(const std::string& value_str);  // 已改为 const ref
        BoltError serialize_string_internal(const std::string& str_value);
        BoltError write_list_header_internal(uint32_t size);
        BoltError serialize_list_internal(const BoltList& list_data);  // 已改为 const ref
        BoltError write_map_header_internal(uint32_t size);
        BoltError serialize_map_internal(const BoltMap& map_data);  // 已改为 const ref
        BoltError write_struct_header_internal(uint8_t tag, uint32_t size);
        BoltError serialize_structure_internal(const PackStreamStructure& struct_data);  // 已改为 const ref

        std::vector<uint8_t>* buffer_ptr_ = nullptr;
        std::ostream* stream_ptr_ = nullptr;
        BoltError error_state_ = BoltError::SUCCESS;

        // 递归深度计数器
        static constexpr uint32_t MAX_RECURSION_DEPTH = 100;  // 与 Reader 保持一致
        uint32_t current_recursion_depth_ = 0;
    };

}  // namespace boltprotocol

#endif  // BOLT_PROTOCOL_IMPL_PACKSTREAM_WRITER_H#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {  // Anonymous namespace for internal linkage helper functions

        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                return std::get<std::string>(it->second);
            }
            return std::nullopt;
        }

        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            result.push_back(std::get<std::string>(element));
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }

        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    return inner_map_sptr->pairs;
                }
            }
            return std::nullopt;
        }
        // Note: get_optional_int64_from_map was defined in the previous full listing of this file
        // but it's not actually used by HELLO, LOGON, or LOGOFF deserialization.
        // If other functions in this file needed it, it would go here too.

    }  // anonymous namespace

    BoltError deserialize_hello_message_request(PackStreamReader& reader, HelloMessageParams& out_params, const versions::Version& server_negotiated_version) {
        // ... (implementation remains the same, uses helpers from anonymous namespace) ...
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure hello_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::HELLO, 1, 1, hello_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (hello_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(hello_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(hello_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs = extra_map_sptr->pairs;
        // using namespace detail_server_request_deserialization; // No longer needed due to anonymous namespace

        auto ua_it = extra_map_pairs.find("user_agent");
        if (ua_it != extra_map_pairs.end() && std::holds_alternative<std::string>(ua_it->second)) {
            try {
                out_params.user_agent = std::get<std::string>(ua_it->second);
            } catch (...) {
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        bool expect_auth_in_hello = (server_negotiated_version < versions::V5_1);
        if (expect_auth_in_hello) {
            out_params.auth_scheme = get_optional_string_from_map(*extra_map_sptr, "scheme");
            out_params.auth_principal = get_optional_string_from_map(*extra_map_sptr, "principal");
            out_params.auth_credentials = get_optional_string_from_map(*extra_map_sptr, "credentials");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 1)) {
            out_params.routing_context = get_optional_map_from_map(*extra_map_sptr, "routing");
        }
        if (server_negotiated_version.major == 4 && (server_negotiated_version.minor == 3 || server_negotiated_version.minor == 4)) {
            out_params.patch_bolt = get_optional_list_string_from_map(*extra_map_sptr, "patch_bolt");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        bool bolt_agent_expected = (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 3));
        auto bolt_agent_map_val_it = extra_map_pairs.find("bolt_agent");
        if (bolt_agent_map_val_it != extra_map_pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second)) {
            auto agent_map_sptr = std::get<std::shared_ptr<BoltMap>>(bolt_agent_map_val_it->second);
            if (agent_map_sptr) {
                HelloMessageParams::BoltAgentInfo agent_info;
                auto product_val = get_optional_string_from_map(*agent_map_sptr, "product");
                if (!product_val.has_value() || product_val.value().empty()) {
                    if (bolt_agent_expected) {
                        reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                        return BoltError::INVALID_MESSAGE_FORMAT;
                    }
                } else {
                    agent_info.product = product_val.value();
                }
                agent_info.platform = get_optional_string_from_map(*agent_map_sptr, "platform");
                agent_info.language = get_optional_string_from_map(*agent_map_sptr, "language");
                agent_info.language_details = get_optional_string_from_map(*agent_map_sptr, "language_details");
                if (!agent_info.product.empty()) {
                    out_params.bolt_agent = agent_info;
                } else if (bolt_agent_expected) {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            } else if (bolt_agent_expected) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else if (bolt_agent_expected) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        for (const auto& pair : extra_map_pairs) {
            if (pair.first != "user_agent" && pair.first != "scheme" && pair.first != "principal" && pair.first != "credentials" && pair.first != "routing" && pair.first != "patch_bolt" && pair.first != "notifications_minimum_severity" && pair.first != "notifications_disabled_categories" &&
                pair.first != "bolt_agent") {
                try {
                    out_params.other_extra_tokens.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logon_message_request(PackStreamReader& reader, LogonMessageParams& out_params) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        out_params.auth_tokens.clear();

        PackStreamStructure logon_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGON, 1, 1, logon_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (logon_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(logon_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(logon_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!auth_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.auth_tokens = std::move(auth_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_logoff_message_request(PackStreamReader& reader) {
        // ... (implementation remains the same) ...
        if (reader.has_error()) return reader.get_error();
        PackStreamStructure logoff_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::LOGOFF, 0, 0, logoff_struct_contents);
        return err;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field etc.

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltNode& out_node, const versions::Version& bolt_version) {
        if (pss.tag != 0x4E) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto labels_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);  // Uses specialization

        if (!id_opt.has_value() || !labels_list_sptr_opt.has_value() || !props_map_opt.has_value()) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& labels_list_sptr = labels_list_sptr_opt.value();
        if (!labels_list_sptr) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_node.id = id_opt.value();

        out_node.labels.clear();
        out_node.labels.reserve(labels_list_sptr->elements.size());
        for (const auto& label_val : labels_list_sptr->elements) {
            if (std::holds_alternative<std::string>(label_val)) {
                try {
                    out_node.labels.push_back(std::get<std::string>(label_val));
                } catch (...) {
                    return BoltError::OUT_OF_MEMORY;
                }  // Or UNKNOWN_ERROR
            } else {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        try {
            out_node.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_node.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
            // If field 3 is present but not string, get_typed_field returns nullopt, element_id remains nullopt.
            // If it's present and is PackNull, it should also result in nullopt.
            // This needs to be handled carefully if PackNull should clear the optional vs. type mismatch.
            // Current get_typed_field will return nullopt if type is not string.
            if (pss.fields[3].index() != 0 && !out_node.element_id.has_value() && pss.fields[3].index() != detail::get_typed_field<std::string>(pss.fields, 3).has_value()) {
                // This condition means: field 3 is not PackNull, AND we didn't get a string, AND it wasn't because it was a string.
                // This is a bit complex, usually indicates a type mismatch that wasn't caught by holds_alternative if Value was more complex.
                // For string, if it's not string, get_typed_field returns nullopt.
            }
        } else {
            out_node.element_id = std::nullopt;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltNode& node, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x4E;  // 'N'

            out_pss_sptr->fields.emplace_back(Value(node.id));

            auto labels_list_sptr = std::make_shared<BoltList>();
            labels_list_sptr->elements.reserve(node.labels.size());
            for (const auto& label : node.labels) {
                labels_list_sptr->elements.emplace_back(Value(label));
            }
            out_pss_sptr->fields.emplace_back(Value(labels_list_sptr));

            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = node.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                if (node.element_id.has_value()) {
                    out_pss_sptr->fields.emplace_back(Value(node.element_id.value()));
                } else {
                    out_pss_sptr->fields.emplace_back(nullptr);
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPath& out_path, const versions::Version& bolt_version) {
        if (pss.tag != 0x50) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nodes_vec_opt = detail::get_typed_list_field<BoltNode>(pss.fields, 0, &bolt_version);
        if (!nodes_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.nodes = std::move(nodes_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto rels_vec_opt = detail::get_typed_list_field<BoltUnboundRelationship>(pss.fields, 1, &bolt_version);
        if (!rels_vec_opt) return BoltError::INVALID_MESSAGE_FORMAT;
        try {
            out_path.rels = std::move(rels_vec_opt.value());
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        auto indices_list_sptr_opt = detail::get_typed_field<std::shared_ptr<BoltList>>(pss.fields, 2);
        if (!indices_list_sptr_opt || !indices_list_sptr_opt.value()) return BoltError::INVALID_MESSAGE_FORMAT;

        const auto& indices_list_sptr = indices_list_sptr_opt.value();
        out_path.indices.clear();
        try {
            out_path.indices.reserve(indices_list_sptr->elements.size());
            for (const auto& idx_val : indices_list_sptr->elements) {
                if (std::holds_alternative<int64_t>(idx_val)) {
                    out_path.indices.push_back(std::get<int64_t>(idx_val));
                } else {
                    return BoltError::INVALID_MESSAGE_FORMAT;
                }
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::UNKNOWN_ERROR;
        }

        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPath& path, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x50;

            auto nodes_list_sptr = std::make_shared<BoltList>();
            nodes_list_sptr->elements.reserve(path.nodes.size());
            for (const auto& node : path.nodes) {
                std::shared_ptr<PackStreamStructure> node_pss_sptr;
                BoltError err = to_packstream(node, bolt_version, node_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                nodes_list_sptr->elements.emplace_back(Value(node_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(nodes_list_sptr));

            auto rels_list_sptr = std::make_shared<BoltList>();
            rels_list_sptr->elements.reserve(path.rels.size());
            for (const auto& rel : path.rels) {
                std::shared_ptr<PackStreamStructure> rel_pss_sptr;
                BoltError err = to_packstream(rel, bolt_version, rel_pss_sptr);
                if (err != BoltError::SUCCESS) return err;
                rels_list_sptr->elements.emplace_back(Value(rel_pss_sptr));
            }
            out_pss_sptr->fields.emplace_back(Value(rels_list_sptr));

            auto indices_list_sptr = std::make_shared<BoltList>();
            indices_list_sptr->elements.reserve(path.indices.size());
            for (const auto& idx : path.indices) {
                indices_list_sptr->elements.emplace_back(Value(idx));
            }
            out_pss_sptr->fields.emplace_back(Value(indices_list_sptr));

        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltRelationship& out_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x52) return BoltError::INVALID_MESSAGE_FORMAT;

        size_t expected_fields_min = 5;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 8 : 5;

        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto start_id_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto end_id_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 3);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 4);

        if (!id_opt || !start_id_opt || !end_id_opt || !type_opt || !props_map_opt) {
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        out_rel.id = id_opt.value();
        out_rel.start_node_id = start_id_opt.value();
        out_rel.end_node_id = end_id_opt.value();
        out_rel.type = type_opt.value();
        try {
            out_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 8) {
            out_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 5);
            out_rel.start_node_element_id = detail::get_typed_field<std::string>(pss.fields, 6);
            out_rel.end_node_element_id = detail::get_typed_field<std::string>(pss.fields, 7);
        } else {
            out_rel.element_id = std::nullopt;
            out_rel.start_node_element_id = std::nullopt;
            out_rel.end_node_element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltRelationship& rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x52;
            out_pss_sptr->fields.emplace_back(Value(rel.id));
            out_pss_sptr->fields.emplace_back(Value(rel.start_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.end_node_id));
            out_pss_sptr->fields.emplace_back(Value(rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));

            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(rel.element_id.has_value() ? Value(rel.element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.start_node_element_id.has_value() ? Value(rel.start_node_element_id.value()) : nullptr);
                out_pss_sptr->fields.emplace_back(rel.end_node_element_id.has_value() ? Value(rel.end_node_element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltUnboundRelationship& out_unbound_rel, const versions::Version& bolt_version) {
        if (pss.tag != 0x72) return BoltError::INVALID_MESSAGE_FORMAT;
        size_t expected_fields_min = 3;
        size_t expected_fields_max = (bolt_version.major >= 5) ? 4 : 3;
        if (pss.fields.size() < expected_fields_min || pss.fields.size() > expected_fields_max) return BoltError::INVALID_MESSAGE_FORMAT;

        auto id_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto type_opt = detail::get_typed_field<std::string>(pss.fields, 1);
        auto props_map_opt = detail::get_typed_field<std::map<std::string, Value>>(pss.fields, 2);

        if (!id_opt || !type_opt || !props_map_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_unbound_rel.id = id_opt.value();
        out_unbound_rel.type = type_opt.value();
        try {
            out_unbound_rel.properties = props_map_opt.value();
        } catch (...) {
            return BoltError::OUT_OF_MEMORY;
        }

        if (bolt_version.major >= 5 && pss.fields.size() == 4) {
            out_unbound_rel.element_id = detail::get_typed_field<std::string>(pss.fields, 3);
        } else {
            out_unbound_rel.element_id = std::nullopt;
        }
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltUnboundRelationship& unbound_rel, const versions::Version& bolt_version, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x72;
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.id));
            out_pss_sptr->fields.emplace_back(Value(unbound_rel.type));
            auto props_map_sptr = std::make_shared<BoltMap>();
            props_map_sptr->pairs = unbound_rel.properties;
            out_pss_sptr->fields.emplace_back(Value(props_map_sptr));
            if (bolt_version.major >= 5) {
                out_pss_sptr->fields.emplace_back(unbound_rel.element_id.has_value() ? Value(unbound_rel.element_id.value()) : nullptr);
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint2D& out_point) {
        if (pss.tag != 0x58) return BoltError::INVALID_MESSAGE_FORMAT;  // 'X'
        if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);

        if (!srid_opt || !x_opt || !y_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint2D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x58;  // 'X'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltPoint3D& out_point) {
        if (pss.tag != 0x59) return BoltError::INVALID_MESSAGE_FORMAT;  // 'Y'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto srid_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto x_opt = detail::get_typed_field<double>(pss.fields, 1);
        auto y_opt = detail::get_typed_field<double>(pss.fields, 2);
        auto z_opt = detail::get_typed_field<double>(pss.fields, 3);

        if (!srid_opt || !x_opt || !y_opt || !z_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_point.srid = static_cast<uint32_t>(srid_opt.value());
        out_point.x = x_opt.value();
        out_point.y = y_opt.value();
        out_point.z = z_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltPoint3D& point, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x59;  // 'Y'
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(point.srid)));
            out_pss_sptr->fields.emplace_back(Value(point.x));
            out_pss_sptr->fields.emplace_back(Value(point.y));
            out_pss_sptr->fields.emplace_back(Value(point.z));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_typed_field

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDate& out_date) {
        if (pss.tag != 0x44) return BoltError::INVALID_MESSAGE_FORMAT;  // 'D'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!days_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_date.days_since_epoch = days_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDate& date, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x44;  // 'D'
            out_pss_sptr->fields.emplace_back(Value(date.days_since_epoch));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <iostream>
#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    // DateTime (Modern 'I' - 0x49 and Legacy 'F' - 0x46)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTime& out_datetime, const versions::Version& bolt_version) {
        // bolt_version is available if subtle distinctions are needed, but tag is primary.
        if (pss.tag == 0x49) {  // Modern DateTime 'I'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.seconds_epoch_utc = secs_opt.value();
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x46) {  // Legacy DateTime 'F'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;

            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !offset_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
            out_datetime.seconds_epoch_utc = secs_adjusted_by_offset_opt.value() - out_datetime.tz_offset_seconds;
            out_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            return BoltError::SUCCESS;
        }

        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTime& datetime, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);

        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x49;  // 'I'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            } else {                       // Use Legacy DateTime 'F'
                out_pss_sptr->tag = 0x46;  // 'F'
                out_pss_sptr->fields.emplace_back(Value(datetime.seconds_epoch_utc + datetime.tz_offset_seconds));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime.tz_offset_seconds)));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // DateTimeZoneId (Modern 'i' - 0x69 and Legacy 'f' - 0x66)
    BoltError from_packstream(const PackStreamStructure& pss, BoltDateTimeZoneId& out_datetime_zoneid, const versions::Version& bolt_version) {
        // bolt_version might be used for subtle interpretation differences if any beyond tag.
        if (pss.tag == 0x69) {  // Modern 'i'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            return BoltError::SUCCESS;

        } else if (pss.tag == 0x66) {  // Legacy 'f'
            if (pss.fields.size() != 3) return BoltError::INVALID_MESSAGE_FORMAT;
            auto secs_adjusted_by_offset_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
            auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
            auto tzid_opt = detail::get_typed_field<std::string>(pss.fields, 2);

            if (!secs_adjusted_by_offset_opt.has_value() || !nanos_opt.has_value() || !tzid_opt.has_value()) {
                return BoltError::INVALID_MESSAGE_FORMAT;
            }

            out_datetime_zoneid.seconds_epoch_utc = secs_adjusted_by_offset_opt.value();
            out_datetime_zoneid.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
            try {
                out_datetime_zoneid.tz_id = tzid_opt.value();
            } catch (...) {
                return BoltError::OUT_OF_MEMORY;
            }
            // Caller should be aware that for legacy 'f', seconds_epoch_utc is not pure UTC.
            return BoltError::SUCCESS;
        }
        return BoltError::INVALID_MESSAGE_FORMAT;
    }

    BoltError to_packstream(const BoltDateTimeZoneId& datetime_zoneid, const versions::Version& bolt_version, bool utc_patch_active_for_4_4, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        bool use_modern_format = (bolt_version.major >= 5) || (bolt_version.major == 4 && bolt_version.minor == 4 && utc_patch_active_for_4_4);
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            if (use_modern_format) {
                out_pss_sptr->tag = 0x69;  // 'i'
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            } else {                       // Use Legacy DateTimeZoneId 'f'
                out_pss_sptr->tag = 0x66;  // 'f'
                // As discussed, serializing to legacy 'f' from UTC seconds + tz_id without a TZDB is problematic.
                // The stored datetime_zoneid.seconds_epoch_utc is assumed to be pure UTC.
                // To produce the correct legacy 'seconds' field, we'd need to add the offset for tz_id at that instant.
                // Lacking TZDB, we will return an error or serialize potentially incorrect data.
                // For now, return error to highlight the issue.
                // A user wanting to serialize to legacy 'f' must provide a `seconds_epoch_utc` value
                // that is ALREADY `actual_utc_seconds + offset_for_tz_id_at_that_instant`.
                // std::cerr << "Error: Cannot accurately serialize BoltDateTimeZoneId to legacy format (0x66) "
                //           << "without timezone database information or pre-adjusted seconds value." << std::endl;
                // return BoltError::SERIALIZATION_ERROR;
                // OR, proceed with caution:
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.seconds_epoch_utc));  // This is UTC, not adjusted!
                out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(datetime_zoneid.nanoseconds_of_second)));
                out_pss_sptr->fields.emplace_back(Value(datetime_zoneid.tz_id));
            }
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // LocalDateTime ('d' - 0x64)
    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalDateTime& out_local_datetime) {
        if (pss.tag != 0x64) return BoltError::INVALID_MESSAGE_FORMAT;
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;
        auto secs_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        if (!secs_opt.has_value() || !nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;
        out_local_datetime.seconds_epoch_local = secs_opt.value();
        out_local_datetime.nanoseconds_of_second = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalDateTime& local_datetime, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x64;
            out_pss_sptr->fields.emplace_back(Value(local_datetime.seconds_epoch_local));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(local_datetime.nanoseconds_of_second)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltDuration& out_duration) {
        if (pss.tag != 0x45) return BoltError::INVALID_MESSAGE_FORMAT;  // 'E'
        if (pss.fields.size() != 4) return BoltError::INVALID_MESSAGE_FORMAT;

        auto months_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto days_opt = detail::get_typed_field<int64_t>(pss.fields, 1);
        auto seconds_opt = detail::get_typed_field<int64_t>(pss.fields, 2);
        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 3);

        if (!months_opt || !days_opt || !seconds_opt || !nanos_opt) return BoltError::INVALID_MESSAGE_FORMAT;

        out_duration.months = months_opt.value();
        out_duration.days = days_opt.value();
        out_duration.seconds = seconds_opt.value();
        out_duration.nanoseconds = static_cast<int32_t>(nanos_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltDuration& duration, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x45;  // 'E'
            out_pss_sptr->fields.emplace_back(Value(duration.months));
            out_pss_sptr->fields.emplace_back(Value(duration.days));
            out_pss_sptr->fields.emplace_back(Value(duration.seconds));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(duration.nanoseconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <variant>

#include "boltprotocol/bolt_structure_serialization.h"
#include "boltprotocol/detail/bolt_structure_helpers.h"

namespace boltprotocol {

    BoltError from_packstream(const PackStreamStructure& pss, BoltTime& out_time) {
        if (pss.tag != 0x54) return BoltError::INVALID_MESSAGE_FORMAT;  // 'T'
        if (pss.fields.size() != 2) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        auto offset_opt = detail::get_typed_field<int64_t>(pss.fields, 1);  // Spec: Integer

        if (!nanos_opt.has_value() || !offset_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_time.nanoseconds_since_midnight = nanos_opt.value();
        // tz_offset_seconds is int32_t in BoltTime struct. Check for overflow if necessary,
        // though unlikely for timezone offsets.
        out_time.tz_offset_seconds = static_cast<int32_t>(offset_opt.value());
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltTime& time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x54;  // 'T'
            out_pss_sptr->fields.emplace_back(Value(time.nanoseconds_since_midnight));
            out_pss_sptr->fields.emplace_back(Value(static_cast<int64_t>(time.tz_offset_seconds)));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError from_packstream(const PackStreamStructure& pss, BoltLocalTime& out_local_time) {
        if (pss.tag != 0x74) return BoltError::INVALID_MESSAGE_FORMAT;  // 't'
        if (pss.fields.size() != 1) return BoltError::INVALID_MESSAGE_FORMAT;

        auto nanos_opt = detail::get_typed_field<int64_t>(pss.fields, 0);
        if (!nanos_opt.has_value()) return BoltError::INVALID_MESSAGE_FORMAT;

        out_local_time.nanoseconds_since_midnight = nanos_opt.value();
        return BoltError::SUCCESS;
    }

    BoltError to_packstream(const BoltLocalTime& local_time, std::shared_ptr<PackStreamStructure>& out_pss_sptr) {
        try {
            out_pss_sptr = std::make_shared<PackStreamStructure>();
            out_pss_sptr->tag = 0x74;  // 't'
            out_pss_sptr->fields.emplace_back(Value(local_time.nanoseconds_since_midnight));
        } catch (const std::bad_alloc&) {
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            return BoltError::SERIALIZATION_ERROR;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/chunking.h"

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy (though not strictly needed if only writing from vector)
#include <exception>  // For std::bad_alloc
#include <iostream>   // For stream operations (std::ostream, std::istream)
#include <vector>     // For std::vector manipulations

#include "boltprotocol/detail/byte_order_utils.h"  // For host_to_be, be_to_host

namespace boltprotocol {

    // --- ChunkedWriter Implementation ---

    ChunkedWriter::ChunkedWriter(std::ostream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {                        // Initial check of stream state
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if stream is already bad
        }
    }

    void ChunkedWriter::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to write the 2-byte chunk header
    BoltError ChunkedWriter::write_chunk_header(uint16_t chunk_payload_size) {
        if (has_error()) return last_error_;  // Don't proceed if already in error state

        uint16_t size_be = detail::host_to_be(chunk_payload_size);
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.write(reinterpret_cast<const char*>(&size_be), sizeof(size_be));
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return BoltError::NETWORK_ERROR;
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write a data chunk (header + payload)
    BoltError ChunkedWriter::write_chunk(const uint8_t* data, uint16_t size) {
        // This function is internal. `write_message` ensures size <= MAX_CHUNK_PAYLOAD_SIZE.
        // `has_error()` check is done by caller or at the start of `write_message`.

        BoltError err = write_chunk_header(size);
        if (err != BoltError::SUCCESS) {
            // error already set by write_chunk_header
            return err;
        }

        if (size > 0) {             // Only write payload if size is non-zero
            if (data == nullptr) {  // Should not happen if size > 0
                set_error(BoltError::INVALID_ARGUMENT);
                return last_error_;
            }
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return last_error_;
            }
            stream_.write(reinterpret_cast<const char*>(data), size);
            if (stream_.fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return BoltError::NETWORK_ERROR;
            }
        }
        return BoltError::SUCCESS;
    }

    // Private helper to write the end-of-message marker (a chunk with size 0)
    BoltError ChunkedWriter::write_end_of_message_marker() {
        return write_chunk_header(0);  // This writes a 2-byte header with 0x0000
    }

    // Public method to write a full message, chunked.
    BoltError ChunkedWriter::write_message(const std::vector<uint8_t>& message_data) {
        if (has_error()) return last_error_;  // Check if writer is already in an error state
        last_error_ = BoltError::SUCCESS;     // Reset error for this new operation

        const uint8_t* data_ptr = message_data.data();
        size_t total_message_size = message_data.size();
        size_t remaining_size = total_message_size;

        if (stream_.fail()) {  // Check stream before starting writes for this message
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        // Handle empty message payload: send a single EOM marker if message_data is empty.
        // Bolt messages are typically not empty (even GOODBYE has a PSS structure).
        // If message_data is empty, it means the PSS serialization resulted in zero bytes.
        // This case is unusual. A common interpretation would be to send *no* data chunks,
        // followed by the EOM marker.
        if (total_message_size == 0) {
            BoltError eom_err = write_end_of_message_marker();
            if (eom_err == BoltError::SUCCESS) {
                stream_.flush();  // Attempt to flush
                if (stream_.fail()) {
                    set_error(BoltError::NETWORK_ERROR);
                    return last_error_;
                }
            }
            return eom_err;  // Return error from writing EOM or SUCCESS
        }

        // Write data chunks
        while (remaining_size > 0) {
            uint16_t current_chunk_payload_size = static_cast<uint16_t>(std::min(remaining_size, static_cast<size_t>(MAX_CHUNK_PAYLOAD_SIZE)));

            BoltError chunk_write_err = write_chunk(data_ptr, current_chunk_payload_size);
            if (chunk_write_err != BoltError::SUCCESS) {
                // Error (and last_error_) already set by write_chunk or write_chunk_header
                return last_error_;
            }

            data_ptr += current_chunk_payload_size;
            remaining_size -= current_chunk_payload_size;
        }

        // After all data chunks are written, write the end-of-message marker
        BoltError eom_err = write_end_of_message_marker();
        if (eom_err != BoltError::SUCCESS) {
            return last_error_;  // Error already set
        }

        // Attempt to flush the stream to ensure all data is sent
        stream_.flush();
        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }

        return BoltError::SUCCESS;
    }

    // --- ChunkedReader Implementation ---

    ChunkedReader::ChunkedReader(std::istream& stream) : stream_(stream), last_error_(BoltError::SUCCESS) {
        if (stream_.fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void ChunkedReader::set_error(BoltError err) {
        if (last_error_ == BoltError::SUCCESS && err != BoltError::SUCCESS) {
            last_error_ = err;
        }
    }

    // Private helper to read the 2-byte chunk header
    BoltError ChunkedReader::read_chunk_header(uint16_t& out_chunk_payload_size) {
        out_chunk_payload_size = 0;  // Initialize output
        if (has_error()) return last_error_;

        uint16_t size_be;  // To store big-endian size from stream

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(&size_be), sizeof(size_be));

        if (stream_.fail()) {                     // Check failbit (which is set on EOF by read if not enough bytes)
            set_error(BoltError::NETWORK_ERROR);  // Could be EOF if connection closed cleanly mid-message
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != sizeof(size_be)) {
            // This case should ideally be caught by stream.fail() if not enough bytes were read.
            // But as a safeguard:
            set_error(BoltError::NETWORK_ERROR);  // Incomplete read for header
            return last_error_;
        }

        out_chunk_payload_size = detail::be_to_host(size_be);

        // As per spec, MAX_CHUNK_PAYLOAD_SIZE is 65535 (0xFFFF).
        // The chunk_payload_size read from header can be this max value.
        // There's no separate check for > MAX_CHUNK_PAYLOAD_SIZE here, as uint16_t naturally holds up to this.
        // A CHUNK_TOO_LARGE error would be if a spec defined a lower practical limit, but Bolt uses full uint16_t range.

        return BoltError::SUCCESS;
    }

    // Private helper to read the payload of a chunk
    BoltError ChunkedReader::read_chunk_payload(uint16_t payload_size, std::vector<uint8_t>& buffer_to_append_to) {
        if (has_error()) return last_error_;
        if (payload_size == 0) return BoltError::SUCCESS;  // Nothing to read

        size_t current_buffer_capacity = buffer_to_append_to.capacity();
        size_t current_buffer_size = buffer_to_append_to.size();
        size_t required_capacity = current_buffer_size + payload_size;

        // Grow buffer if needed. This is where std::bad_alloc can occur.
        if (required_capacity > current_buffer_capacity) {
            try {
                // Reserve to avoid multiple small reallocations if reading many small chunks.
                // A growth factor could be used (e.g., 1.5x or 2x) for efficiency.
                // For simplicity here, just reserve what's immediately needed for this chunk.
                buffer_to_append_to.reserve(required_capacity);
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return last_error_;
            } catch (const std::length_error&) {          // If required_capacity is too large for vector
                set_error(BoltError::MESSAGE_TOO_LARGE);  // Or OUT_OF_MEMORY if more appropriate
                return last_error_;
            } catch (const std::exception&) {
                set_error(BoltError::UNKNOWN_ERROR);
                return last_error_;
            }
        }

        // Resize to exact size needed for appending, then read directly into new space.
        // This is less efficient than reading into a temporary buffer and then appending,
        // but simpler for now. A more optimized version might use a fixed-size read buffer.
        // We need to append, so we must first store current_buffer_size, then resize, then read.
        try {
            buffer_to_append_to.resize(required_capacity);  // Resize to make space
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return last_error_;
        } catch (const std::length_error&) {
            set_error(BoltError::MESSAGE_TOO_LARGE);
            return last_error_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return last_error_;
        }

        if (stream_.fail()) {
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        stream_.read(reinterpret_cast<char*>(buffer_to_append_to.data() + current_buffer_size), payload_size);

        if (stream_.fail()) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize on partial read/failure
            set_error(BoltError::NETWORK_ERROR);
            return last_error_;
        }
        if (static_cast<size_t>(stream_.gcount()) != payload_size) {
            buffer_to_append_to.resize(current_buffer_size);  // Revert resize
            set_error(BoltError::NETWORK_ERROR);              // Incomplete read for payload
            return last_error_;
        }
        return BoltError::SUCCESS;
    }

    // Public method to read a full message, de-chunked.
    BoltError ChunkedReader::read_message(std::vector<uint8_t>& out_message_data) {
        if (has_error()) return last_error_;
        last_error_ = BoltError::SUCCESS;  // Reset error for this new operation

        out_message_data.clear();  // Ensure output vector starts empty for this message
        // Optionally, reserve a typical message size if known, e.g., out_message_data.reserve(4096);
        // This needs a try-catch for bad_alloc if done.

        uint16_t current_chunk_payload_size;
        BoltError err;

        while (true) {  // Loop to read chunks until EOM
            err = read_chunk_header(current_chunk_payload_size);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_header
                return last_error_;
            }

            if (current_chunk_payload_size == 0) {  // End-of-message marker (0x0000 chunk size)
                break;                              // Successfully read all chunks for this message
            }

            // Optional: Check against a max total message size to prevent OOM from malicious server
            // Example: constexpr size_t MAX_ALLOWED_TOTAL_MESSAGE_SIZE = 16 * 1024 * 1024; // 16MB
            // if (out_message_data.size() + current_chunk_payload_size > MAX_ALLOWED_TOTAL_MESSAGE_SIZE) {
            //    set_error(BoltError::MESSAGE_TOO_LARGE);
            //    out_message_data.clear();
            //    return last_error_;
            // }

            err = read_chunk_payload(current_chunk_payload_size, out_message_data);
            if (err != BoltError::SUCCESS) {
                out_message_data.clear();  // Clear potentially partial data on error
                // last_error_ already set by read_chunk_payload
                return last_error_;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/handshake.h"  // 包含声明

#include <algorithm>  // For std::min
#include <cstring>    // For std::memcpy
// <iostream> is not directly needed here anymore for perform_handshake

#include "boltprotocol/detail/byte_order_utils.h"  // For detail::host_to_be

namespace boltprotocol {

    // build_handshake_request: Constructs the 20-byte handshake request.
    BoltError build_handshake_request(const std::vector<versions::Version>& proposed_versions, std::array<uint8_t, HANDSHAKE_REQUEST_SIZE_BYTES>& out_handshake_bytes) {
        if (proposed_versions.empty()) {
            return BoltError::INVALID_ARGUMENT;
        }

        // 1. Magic Preamble (4 bytes, Big Endian)
        uint32_t preamble_be = detail::host_to_be(BOLT_MAGIC_PREAMBLE);  // BOLT_MAGIC_PREAMBLE from message_defs.h
        std::memcpy(out_handshake_bytes.data(), &preamble_be, sizeof(preamble_be));
        size_t current_offset = sizeof(preamble_be);

        // 2. Proposed Versions (4 versions, each 4 bytes, Big Endian)
        size_t num_versions_to_write = std::min(proposed_versions.size(), HANDSHAKE_NUM_PROPOSED_VERSIONS);

        for (size_t i = 0; i < num_versions_to_write; ++i) {
            // Version::to_handshake_bytes() already returns the 4 bytes in the correct format (00 00 Maj Min)
            // and handles endianness *if* it were encoding a multi-byte representation of major/minor itself.
            // However, the Bolt spec for handshake versions is simpler: the 4-byte int is 0.0.Major.Minor.
            // So we construct this 32-bit int and then convert to big endian.
            uint32_t version_int32_for_handshake = 0;  // Example: For 5.4, this would be 0x00000504
            version_int32_for_handshake = (static_cast<uint32_t>(proposed_versions[i].major) << 8) | (static_cast<uint32_t>(proposed_versions[i].minor));

            uint32_t version_be = detail::host_to_be(version_int32_for_handshake);
            std::memcpy(out_handshake_bytes.data() + current_offset, &version_be, HANDSHAKE_VERSION_SIZE_BYTES);
            current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
        }

        // Fill remaining version slots with "No Version" (all zeros)
        if (num_versions_to_write < HANDSHAKE_NUM_PROPOSED_VERSIONS) {
            uint32_t no_version_int_be = detail::host_to_be(static_cast<uint32_t>(0));  // 0x00000000
            for (size_t i = num_versions_to_write; i < HANDSHAKE_NUM_PROPOSED_VERSIONS; ++i) {
                std::memcpy(out_handshake_bytes.data() + current_offset, &no_version_int_be, HANDSHAKE_VERSION_SIZE_BYTES);
                current_offset += HANDSHAKE_VERSION_SIZE_BYTES;
            }
        }
        return BoltError::SUCCESS;
    }

    // parse_handshake_response: Parses the 4-byte server response.
    BoltError parse_handshake_response(const std::array<uint8_t, HANDSHAKE_RESPONSE_SIZE_BYTES>& server_response_bytes, versions::Version& out_negotiated_version) {
        // Version::from_handshake_bytes directly uses the byte array.
        BoltError err = versions::Version::from_handshake_bytes(server_response_bytes, out_negotiated_version);

        if (err != BoltError::SUCCESS) {
            return err;  // Could be UNSUPPORTED_PROTOCOL_VERSION if format is unexpected by from_handshake_bytes
        }

        // Specific check for "No common version" which is represented by all zeros.
        // Version::from_handshake_bytes might return 0.0 as a valid version for all zeros.
        if (out_negotiated_version.major == 0 && out_negotiated_version.minor == 0) {
            // Check if all bytes in server_response_bytes are actually zero
            bool all_zero = true;
            for (uint8_t byte : server_response_bytes) {
                if (byte != 0) {
                    all_zero = false;
                    break;
                }
            }
            if (all_zero) {
                return BoltError::HANDSHAKE_NO_COMMON_VERSION;
            }
            // If it parsed as 0.0 but bytes weren't all zero, it's an odd case,
            // but Version::from_handshake_bytes should ideally handle invalid formats.
            // For now, if it parses to 0.0 and wasn't all zeros, treat as success with 0.0 (unlikely scenario).
        }
        return BoltError::SUCCESS;
    }

    // The definition of perform_handshake (template function) is now in handshake_impl.hpp

}  // namespace boltprotocol#include <cstring>    // For std::memcpy if used here
#include <stdexcept>  // For Version::to_string (though not strictly needed for string conversion)

#include "boltprotocol/bolt_errors_versions.h"
#include "boltprotocol/detail/byte_order_utils.h"  // 如果 to_handshake_bytes 等在这里实现

namespace boltprotocol {
    namespace versions {

        // --- Definitions for Version struct methods (declared in bolt_errors_versions.h) ---
        bool Version::operator<(const Version& other) const {
            if (major != other.major) {
                return major < other.major;
            }
            return minor < other.minor;
        }

        bool Version::operator==(const Version& other) const {
            return major == other.major && minor == other.minor;
        }

        bool Version::operator!=(const Version& other) const {
            return !(*this == other);
        }

        bool Version::operator>(const Version& other) const {
            // a > b is equivalent to b < a
            return other < *this;
        }

        bool Version::operator<=(const Version& other) const {
            // a <= b is equivalent to !(a > b)
            return !(*this > other);
        }

        bool Version::operator>=(const Version& other) const {
            // a >= b is equivalent to !(a < b)
            return !(*this < other);
        }

        std::string Version::to_string() const {
            return std::to_string(static_cast<int>(major)) + "." + std::to_string(static_cast<int>(minor));
        }

        std::array<uint8_t, 4> Version::to_handshake_bytes() const {
            // Bolt版本字节顺序: [0, 0, minor, major] (小端在前，但通常视为一个整体)
            // 服务器期望的是大端整数，但每个字节是独立的。
            // 例如 版本 3.0 (0x03) 在网络上可能是 0x00000003
            // Neo4j驱动通常发送 [0,0,minor,major]
            // **更正**: Bolt协议规范中版本握手字节的顺序是 [major, minor, 0, 0] for highest,
            // [major, minor, 0, 0] for second highest, etc. for Bolt v1.
            // For Bolt v3+ (which uses 4-byte version numbers per proposal slot):
            // The versions are sent as 32-bit unsigned integers in big-endian byte order.
            // Example: version 4.1 (0x0104 internally for some drivers, or 0x0401 for others)
            // is encoded as [0, 0, 4, 1] or [0, 0, 1, 4] depending on interpretation.
            // The Java driver sends it as four bytes: [0, 0, minor, major]. Let's stick to that.
            return {0, 0, minor, major};
        }

        BoltError Version::from_handshake_bytes(const std::array<uint8_t, 4>& bytes, Version& out_version) {
            // 服务器返回一个它选择的版本，格式与客户端发送的相同
            // 即 bytes[3] 是主版本，bytes[2] 是次版本
            // 检查前两个字节是否为0，这是现代Bolt版本号的常见模式
            if (bytes[0] == 0 && bytes[1] == 0) {
                out_version.minor = bytes[2];
                out_version.major = bytes[3];
                // 对于全零的情况 (0.0)，可以表示“无版本”或握手失败但协议上需要返回一些东西
                // 如果major和minor都是0，这在实际Bolt版本中通常无效，除非它代表一种特殊情况。
                // Neo4j服务器在不接受任何提议版本时会关闭连接，而不是返回0.0。
                // 这里假设如果成功解析，即使是0.0，也返回SUCCESS，由调用者决定其含义。
                return BoltError::SUCCESS;
            }
            // 对于旧版Bolt或范围版本，字节格式可能不同。
            // 例如，Bolt v1 返回单个字节。Bolt v4.3+ 的范围表示法使用第一个字节。
            // 此处简化，只处理现代驱动常见的 [0,0,minor,major] 格式。
            // 如果需要支持其他格式，需要更复杂的解析逻辑。
            // 例如，如果 bytes[0] != 0，则可能是范围提议。
            // uint32_t version_val_be;
            // std::memcpy(&version_val_be, bytes.data(), 4);
            // uint32_t version_val_host = detail::be_to_host(version_val_be);
            // if ( (version_val_host >> 16) == 0 ) { // 假设是 0x0000MMNN (小端) 或 0x0000NNMM (大端)
            //     out_version.major = static_cast<uint8_t>(version_val_host & 0xFF);
            //     out_version.minor = static_cast<uint8_t>((version_val_host >> 8) & 0xFF);
            //     return BoltError::SUCCESS;
            // }
            return BoltError::UNSUPPORTED_PROTOCOL_VERSION;  // 或 INVALID_MESSAGE_FORMAT
        }

        // --- Definitions for extern version constants (declared in bolt_errors_versions.h) ---
        const Version V5_4(5, 4);
        const Version V5_3(5, 3);
        const Version V5_2(5, 2);
        const Version V5_1(5, 1);
        const Version V5_0(5, 0);
        const Version V4_4(4, 4);
        const Version V4_3(4, 3);  // 确保 V4_3 被定义
        // const Version V4_2(4,2);
        // const Version V4_1(4,1);
        // const Version V4_0(4,0);
        // const Version V3_0(3,0);

        // --- Definition for get_default_proposed_versions (declared in bolt_errors_versions.h) ---
        const std::vector<Version>& get_default_proposed_versions() {
            // 驱动应按优先顺序列出它支持的版本，从高到低
            static const std::vector<Version> DEFAULT_PROPOSED_VERSIONS_LIST = {
                V5_4, V5_3, V5_2, V5_1, V5_0, V4_4, V4_3  // 确保 V4_3 在这里
                // Add V4_2, V4_1 etc. if they are defined constants and desired in default list
            };
            return DEFAULT_PROPOSED_VERSIONS_LIST;
        }

    }  // namespace versions

    // --- 修正：将 DEFAULT_USER_AGENT_FORMAT_STRING 和 Value::operator== 的定义移到 bolt_core_types.cpp 或一个新的 bolt_message_defs.cpp (如果它们在 message_defs.h 中声明为 extern) ---
    // 为了保持 bolt_errors_versions.cpp 的纯粹性，这些定义不应在此处。
    // 假设它们在别处定义。

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_run_message(const RunMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure run_struct_obj;
        run_struct_obj.tag = static_cast<uint8_t>(MessageTag::RUN);

        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            // Field 1: Cypher query (string)
            run_struct_obj.fields.emplace_back(Value(params.cypher_query));

            // Field 2: Parameters map (cypher parameters)
            // It's okay if params.parameters is empty, it will serialize as an empty map.
            auto cypher_params_map_sptr = std::make_shared<BoltMap>();
            cypher_params_map_sptr->pairs = params.parameters;
            run_struct_obj.fields.emplace_back(Value(cypher_params_map_sptr));

            // Field 3: Extra metadata map
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
            }

            if (target_bolt_version.major > 4 || (target_bolt_version.major == 4 && target_bolt_version.minor >= 4)) {  // imp_user for RUN introduced in Bolt 4.4
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            run_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(run_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_pull_message and serialize_discard_message remain unchanged
    // ... (serialize_pull_message implementation) ...
    BoltError serialize_pull_message(const PullMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure pull_struct_obj;
        pull_struct_obj.tag = static_cast<uint8_t>(MessageTag::PULL);
        std::shared_ptr<BoltMap> extra_map_sptr;

        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            pull_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pull_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_discard_message implementation) ...
    BoltError serialize_discard_message(const DiscardMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure discard_struct_obj;
        discard_struct_obj.tag = static_cast<uint8_t>(MessageTag::DISCARD);
        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            if (params.n.has_value()) {
                extra_map_sptr->pairs.emplace("n", Value(params.n.value()));
            }
            if (params.qid.has_value()) {
                extra_map_sptr->pairs.emplace("qid", Value(params.qid.value()));
            }
            discard_struct_obj.fields.emplace_back(Value(extra_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(discard_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_route_message(const RouteMessageParams& params, PackStreamWriter& writer, const versions::Version& negotiated_bolt_version) {
        if (writer.has_error()) return writer.get_error();

        if (negotiated_bolt_version < versions::Version(4, 3)) {
            writer.set_error(BoltError::SERIALIZATION_ERROR);
            return writer.get_error();
        }

        PackStreamStructure route_struct_obj;
        route_struct_obj.tag = static_cast<uint8_t>(MessageTag::ROUTE);

        std::shared_ptr<BoltMap> routing_table_context_map_sptr;
        std::shared_ptr<BoltList> bookmarks_list_sptr;

        try {
            routing_table_context_map_sptr = std::make_shared<BoltMap>();
            routing_table_context_map_sptr->pairs = params.routing_table_context;
            route_struct_obj.fields.emplace_back(Value(routing_table_context_map_sptr));

            bookmarks_list_sptr = std::make_shared<BoltList>();
            for (const auto& bookmark_str : params.bookmarks) {
                bookmarks_list_sptr->elements.emplace_back(Value(bookmark_str));
            }
            route_struct_obj.fields.emplace_back(Value(bookmarks_list_sptr));

            if (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor == 3) {  // Bolt 4.3
                if (params.db_name_for_v43.has_value()) {
                    route_struct_obj.fields.emplace_back(Value(params.db_name_for_v43.value()));
                } else {
                    route_struct_obj.fields.emplace_back(nullptr);
                }
            } else if (negotiated_bolt_version.major > 4 || (negotiated_bolt_version.major == 4 && negotiated_bolt_version.minor >= 4)) {  // Bolt 4.4+
                std::shared_ptr<BoltMap> extra_map_sptr = std::make_shared<BoltMap>();                                                     // Always create the map
                if (params.extra_for_v44_plus.has_value()) {
                    extra_map_sptr->pairs = params.extra_for_v44_plus.value();
                }
                // The 'extra' dictionary field is always present for Bolt 4.4+, even if empty.
                route_struct_obj.fields.emplace_back(Value(extra_map_sptr));
            }
            // No other cases, as we checked for version < 4.3 at the beginning.

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(route_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            metadata_map_sptr->pairs = params.metadata;
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_hello_message(const HelloMessageParams& params, PackStreamWriter& writer, const versions::Version& client_target_version) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_hello_obj;
        pss_hello_obj.tag = static_cast<uint8_t>(MessageTag::HELLO);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& pairs = extra_map_sptr->pairs;

            pairs.emplace("user_agent", Value(params.user_agent));

            bool use_auth_in_hello = (client_target_version < versions::V5_1);  // Qualified comparison

            if (use_auth_in_hello) {
                if (params.auth_scheme.has_value()) pairs.emplace("scheme", Value(params.auth_scheme.value()));
                if (params.auth_principal.has_value()) pairs.emplace("principal", Value(params.auth_principal.value()));
                if (params.auth_credentials.has_value()) pairs.emplace("credentials", Value(params.auth_credentials.value()));
                if (params.auth_scheme_specific_tokens.has_value()) {
                    for (const auto& token_pair : params.auth_scheme_specific_tokens.value()) {
                        pairs.emplace(token_pair.first, token_pair.second);
                    }
                }
            }

            if (client_target_version.major > 4 || (client_target_version.major == 4 && client_target_version.minor >= 1)) {
                if (params.routing_context.has_value()) {
                    auto routing_map_val_sptr = std::make_shared<BoltMap>();
                    routing_map_val_sptr->pairs = params.routing_context.value();
                    pairs.emplace("routing", Value(routing_map_val_sptr));
                }
            }

            if (client_target_version.major == 4 && (client_target_version.minor == 3 || client_target_version.minor == 4)) {
                if (params.patch_bolt.has_value() && !params.patch_bolt.value().empty()) {
                    auto patch_list_sptr = std::make_shared<BoltList>();
                    for (const auto& patch_str : params.patch_bolt.value()) {
                        patch_list_sptr->elements.emplace_back(Value(patch_str));
                    }
                    pairs.emplace("patch_bolt", Value(patch_list_sptr));
                }
            }

            if (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 2)) {
                if (params.notifications_min_severity.has_value()) {
                    pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat_str : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat_str));
                    }
                    pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            bool bolt_agent_mandatory = (client_target_version.major > 5 || (client_target_version.major == 5 && client_target_version.minor >= 3));
            if (bolt_agent_mandatory) {
                if (!params.bolt_agent.has_value() || params.bolt_agent.value().product.empty()) {
                    writer.set_error(BoltError::SERIALIZATION_ERROR);
                    return BoltError::SERIALIZATION_ERROR;
                }
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            } else if (params.bolt_agent.has_value()) {
                auto bolt_agent_map_sptr = std::make_shared<BoltMap>();
                const auto& agent_info = params.bolt_agent.value();
                bolt_agent_map_sptr->pairs.emplace("product", Value(agent_info.product));  // Product is mandatory in BoltAgentInfo itself
                if (agent_info.platform.has_value()) bolt_agent_map_sptr->pairs.emplace("platform", Value(agent_info.platform.value()));
                if (agent_info.language.has_value()) bolt_agent_map_sptr->pairs.emplace("language", Value(agent_info.language.value()));
                if (agent_info.language_details.has_value()) bolt_agent_map_sptr->pairs.emplace("language_details", Value(agent_info.language_details.value()));
                pairs.emplace("bolt_agent", Value(bolt_agent_map_sptr));
            }

            for (const auto& token_pair : params.other_extra_tokens) {
                pairs.emplace(token_pair.first, token_pair.second);
            }
            pss_hello_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_hello_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_goodbye_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::GOODBYE);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_reset_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::RESET);
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logon_message(const LogonMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure pss_logon_obj;
        pss_logon_obj.tag = static_cast<uint8_t>(MessageTag::LOGON);

        std::shared_ptr<BoltMap> auth_map_sptr;
        try {
            auth_map_sptr = std::make_shared<BoltMap>();
            // The auth_tokens map in LogonMessageParams directly becomes the PSS field.
            auth_map_sptr->pairs = params.auth_tokens;

            pss_logon_obj.fields.emplace_back(Value(auth_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(pss_logon_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    BoltError serialize_logoff_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::LOGOFF);
            // LOGOFF PSS has no fields.
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <map>
#include <memory>  // For std::make_shared, std::shared_ptr
#include <vector>  // For PackStreamStructure fields

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For the function declaration
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_telemetry_message(const TelemetryMessageParams& params, PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();

        PackStreamStructure telemetry_struct_obj;                                // Create on stack
        telemetry_struct_obj.tag = static_cast<uint8_t>(MessageTag::TELEMETRY);  // Tag 0x54

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::make_shared<BoltMap>();
            // Copy the metadata from params. Telemetry typically has specific keys like "api".
            // The caller is responsible for ensuring params.metadata is correctly populated.
            metadata_map_sptr->pairs = params.metadata;

            // The TELEMETRY message PackStreamStructure has one field: the metadata map.
            telemetry_struct_obj.fields.emplace_back(Value(metadata_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Catch other potential exceptions from map copy or emplace_back
            writer.set_error(BoltError::UNKNOWN_ERROR);
            // Consider logging e_std.what() for debugging if needed
            return BoltError::UNKNOWN_ERROR;
        }

        // Now, convert the stack-based PSS object to a shared_ptr to pass to writer.write()
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(telemetry_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {  // Other exceptions from make_shared or PSS move ctor
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {                                 // Should typically be caught by bad_alloc if make_shared fails
            writer.set_error(BoltError::OUT_OF_MEMORY);  // Or UNKNOWN_ERROR if make_shared could return null without exception
            return BoltError::OUT_OF_MEMORY;
        }

        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <vector>

#include "boltprotocol/message_defs.h"  // Includes bolt_errors_versions.h for versions::Version
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError serialize_begin_message(const BeginMessageParams& params, PackStreamWriter& writer, const versions::Version& target_bolt_version) {
        if (writer.has_error()) return writer.get_error();
        PackStreamStructure begin_struct_obj;
        begin_struct_obj.tag = static_cast<uint8_t>(MessageTag::BEGIN);

        std::shared_ptr<BoltMap> extra_map_sptr;
        try {
            extra_map_sptr = std::make_shared<BoltMap>();
            auto& extra_pairs = extra_map_sptr->pairs;

            // Populate extra_pairs from params based on target_bolt_version
            // BEGIN shares many 'extra' fields with RUN's auto-commit extras
            if (target_bolt_version.major >= 3) {  // Bookmarks, tx_timeout, tx_metadata, mode introduced in Bolt 3
                if (params.bookmarks.has_value() && !params.bookmarks.value().empty()) {
                    auto bookmarks_list_sptr = std::make_shared<BoltList>();
                    for (const auto& bm : params.bookmarks.value()) {
                        bookmarks_list_sptr->elements.emplace_back(Value(bm));
                    }
                    extra_pairs.emplace("bookmarks", Value(bookmarks_list_sptr));
                }
                if (params.tx_timeout.has_value()) {
                    extra_pairs.emplace("tx_timeout", Value(params.tx_timeout.value()));
                }
                if (params.tx_metadata.has_value() && !params.tx_metadata.value().empty()) {
                    auto tx_meta_map_sptr = std::make_shared<BoltMap>();
                    tx_meta_map_sptr->pairs = params.tx_metadata.value();
                    extra_pairs.emplace("tx_metadata", Value(tx_meta_map_sptr));
                }
                if (params.mode.has_value()) {  // Defaults to "w" if not sent, but can be explicit
                    extra_pairs.emplace("mode", Value(params.mode.value()));
                }
            }

            if (target_bolt_version.major >= 4) {  // db and imp_user for BEGIN introduced in Bolt 4.0
                if (params.db.has_value()) {
                    extra_pairs.emplace("db", Value(params.db.value()));
                }
                if (params.imp_user.has_value()) {
                    extra_pairs.emplace("imp_user", Value(params.imp_user.value()));
                }
            }

            if (target_bolt_version.major > 5 || (target_bolt_version.major == 5 && target_bolt_version.minor >= 2)) {  // notifications introduced in Bolt 5.2
                if (params.notifications_min_severity.has_value()) {
                    extra_pairs.emplace("notifications_minimum_severity", Value(params.notifications_min_severity.value()));
                }
                if (params.notifications_disabled_categories.has_value() && !params.notifications_disabled_categories.value().empty()) {
                    auto disabled_cat_list_sptr = std::make_shared<BoltList>();
                    for (const auto& cat : params.notifications_disabled_categories.value()) {
                        disabled_cat_list_sptr->elements.emplace_back(Value(cat));
                    }
                    extra_pairs.emplace("notifications_disabled_categories", Value(disabled_cat_list_sptr));
                }
            }

            // Add other custom fields
            for (const auto& field_pair : params.other_extra_fields) {
                extra_pairs.emplace(field_pair.first, field_pair.second);
            }

            begin_struct_obj.fields.emplace_back(Value(extra_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>(std::move(begin_struct_obj));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception& e_std) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // serialize_commit_message and serialize_rollback_message remain unchanged
    // ... (serialize_commit_message implementation) ...
    BoltError serialize_commit_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::COMMIT);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));

        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

    // ... (serialize_rollback_message implementation) ...
    BoltError serialize_rollback_message(PackStreamWriter& writer) {
        if (writer.has_error()) return writer.get_error();
        std::shared_ptr<PackStreamStructure> pss_sptr;
        try {
            pss_sptr = std::make_shared<PackStreamStructure>();
            pss_sptr->tag = static_cast<uint8_t>(MessageTag::ROLLBACK);
            auto empty_map_sptr = std::make_shared<BoltMap>();
            pss_sptr->fields.emplace_back(Value(empty_map_sptr));
        } catch (const std::bad_alloc&) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            writer.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        if (!pss_sptr) {
            writer.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        }
        return writer.write(Value(std::move(pss_sptr)));
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::exception
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get
#include <vector>     // For PackStreamStructure::fields

#include "boltprotocol/message_defs.h"           // For message structs, Value, MessageTag, BoltError
#include "boltprotocol/message_serialization.h"  // 主头文件，声明这些函数
#include "boltprotocol/packstream_reader.h"      // For PackStreamReader

namespace boltprotocol {

    // Helper to deserialize a structure from a reader and validate its basic properties
    // This function was originally in message_serialization_server.cpp
    BoltError deserialize_message_structure_prelude(PackStreamReader& reader, MessageTag expected_tag, size_t expected_fields_min, size_t expected_fields_max, PackStreamStructure& out_structure_contents) {
        if (reader.has_error()) return reader.get_error();

        Value raw_value;
        BoltError err = reader.read(raw_value);
        if (err != BoltError::SUCCESS) {
            // reader.read() should have set its internal error state.
            return err;
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        if (std::holds_alternative<std::shared_ptr<PackStreamStructure>>(raw_value)) {
            try {
                struct_sptr = std::get<std::shared_ptr<PackStreamStructure>>(std::move(raw_value));
            } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            } catch (const std::exception&) {  // Other potential issues with std::get or Value move
                reader.set_error(BoltError::UNKNOWN_ERROR);
                return BoltError::UNKNOWN_ERROR;
            }
        } else {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (!struct_sptr) {  // Null shared_ptr received in Value
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Move the contents from the object pointed to by shared_ptr into out_structure_contents.
        try {
            out_structure_contents = std::move(*struct_sptr);  // PackStreamStructure move assignment
        } catch (const std::bad_alloc&) {                      // If vector/map move assignment allocates and fails
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (static_cast<MessageTag>(out_structure_contents.tag) != expected_tag) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Tag mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        if (out_structure_contents.fields.size() < expected_fields_min || out_structure_contents.fields.size() > expected_fields_max) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Field count mismatch
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        return BoltError::SUCCESS;
    }

    // peek_message_structure_header remains problematic and likely unused as discussed.
    // If it were to be implemented and was general, it could go here.
    // For now, it's commented out or returns an error in message_serialization.h
    /*
    BoltError peek_message_structure_header(PackStreamReader& reader, uint8_t& out_tag, uint32_t& out_fields_count) {
        // ... implementation ...
        return BoltError::UNKNOWN_ERROR; // Placeholder
    }
    */

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::bad_variant_access
#include <memory>     // For std::shared_ptr
#include <variant>    // For std::holds_alternative, std::get (though not strictly used for get if field is optional)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        // IGNORED message PSS has 0 or 1 field. If 1, it's a map (usually for future use or diagnostics).
        // The spec typically shows IGNORED {}, meaning 0 fields in its PSS, or IGNORED {<metadata_map>}.
        // A PSS with 0 fields is valid. A PSS with 1 field (the map) is also valid.
        // So, expected_fields_min = 0, expected_fields_max = 1.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // If there is a field, it must be a map.
        // Client usually doesn't need to parse this map, so we just validate its presence and type if it exists.
        if (!ignored_struct_contents.fields.empty()) {  // Field is present
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            // We don't need to extract the map's content for IGNORED typically.
            // std::shared_ptr<BoltMap> metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0]);
            // if (!metadata_map_sptr) { /* This would be an error if the field is present but map pointer is null */ }
        }
        // If fields is empty, it's a valid IGNORED {} message, nothing more to do.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_reset_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RESET message PSS (Bolt 1+) has 0 fields.
        PackStreamStructure reset_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RESET, 0, 0, reset_struct_contents);
        // No fields to parse further from reset_struct_contents.fields.
        return err;
    }

    BoltError deserialize_goodbye_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // GOODBYE message PSS (Bolt 3+) has 0 fields.
        PackStreamStructure goodbye_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::GOODBYE, 0, 0, goodbye_struct_contents);
        // No fields to parse further.
        return err;
    }

    BoltError deserialize_telemetry_message_request(PackStreamReader& reader, TelemetryMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure telemetry_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::TELEMETRY, 1, 1, telemetry_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (telemetry_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(telemetry_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        auto metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(telemetry_struct_contents.fields[0]));
        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        auto api_val_it = out_params.metadata.find("api");
        if (api_val_it == out_params.metadata.end() || !std::holds_alternative<int64_t>(api_val_it->second)) {
            // Specification: "unless it sends an invalid value for the api field, which results in a FAILURE response."
            // This deserializer can flag it, actual FAILURE is up to server logic.
            // For now, successful deserialization of the structure, content validation is next step.
            // reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Or a specific "TELEMETRY_INVALID_API_FIELD"
            // return reader.get_error();
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_run_message_request(PackStreamReader& reader, RunMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure run_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RUN, 3, 3, run_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (run_struct_contents.fields.size() < 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        if (!std::holds_alternative<std::string>(run_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.cypher_query = std::get<std::string>(std::move(run_struct_contents.fields[0]));
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto params_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[1]));
        if (!params_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.parameters = std::move(params_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(run_struct_contents.fields[2])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(run_struct_contents.fields[2]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;

        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
        }
        if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && pair.first == "db") ||
                                   ((server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) && pair.first == "imp_user") ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log out_of_memory for map */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_pull_message_request(PackStreamReader& reader, PullMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure pull_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ PULL has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 1, 1, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (pull_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(pull_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(pull_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ PULL
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT; // Be strict or allow for now?
            }
        } else {  // Bolt < 4.0 (PULL_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::PULL, 0, 0, pull_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            // For PULL_ALL, n is implicitly -1 (all), qid is implicitly -1 (last query)
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_discard_message_request(PackStreamReader& reader, DiscardMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params.n = std::nullopt;
        out_params.qid = std::nullopt;

        PackStreamStructure discard_struct_contents;
        BoltError err;

        if (server_negotiated_version.major >= 4) {  // Bolt 4.0+ DISCARD has 1 field (extra map)
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 1, 1, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;

            if (discard_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(discard_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(discard_struct_contents.fields[0]));
            if (!extra_map_sptr) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            out_params.n = get_optional_int64_from_map(*extra_map_sptr, "n");
            out_params.qid = get_optional_int64_from_map(*extra_map_sptr, "qid");
            if (!out_params.n.has_value()) {  // 'n' is mandatory in Bolt 4.0+ DISCARD
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                // return BoltError::INVALID_MESSAGE_FORMAT;
            }
        } else {  // Bolt < 4.0 (DISCARD_ALL) has 0 fields
            err = deserialize_message_structure_prelude(reader, MessageTag::DISCARD, 0, 0, discard_struct_contents);
            if (err != BoltError::SUCCESS) return err;
            out_params.n = -1;
            out_params.qid = -1;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_route_message_request(PackStreamReader& reader, RouteMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};  // Clear params

        // ROUTE message introduced in 4.3. PSS has 3 fields.
        if (server_negotiated_version < versions::Version(4, 3)) {
            reader.set_error(BoltError::UNSUPPORTED_PROTOCOL_VERSION);  // Or INVALID_MESSAGE_FORMAT
            return reader.get_error();
        }

        PackStreamStructure route_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROUTE, 3, 3, route_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (route_struct_contents.fields.size() != 3) {  // Defensive, prelude should catch this
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        // Field 0: routing_context (Map)
        if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto route_context_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[0]));
        if (!route_context_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        try {
            out_params.routing_table_context = std::move(route_context_map_sptr->pairs);
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 1: bookmarks (List<String>)
        if (!std::holds_alternative<std::shared_ptr<BoltList>>(route_struct_contents.fields[1])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto bookmarks_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(route_struct_contents.fields[1]));
        if (!bookmarks_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        out_params.bookmarks.clear();
        try {
            out_params.bookmarks.reserve(bookmarks_list_sptr->elements.size());
            for (const auto& bm_val : bookmarks_list_sptr->elements) {
                if (std::holds_alternative<std::string>(bm_val)) {
                    out_params.bookmarks.push_back(std::get<std::string>(bm_val));
                } else {
                    reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return BoltError::INVALID_MESSAGE_FORMAT;  // Bookmark not a string
                }
            }
        } catch (...) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Field 2: Varies by version (db string for 4.3, extra map for 4.4+)
        if (server_negotiated_version.major == 4 && server_negotiated_version.minor == 3) {  // Bolt 4.3
            if (std::holds_alternative<std::string>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::get<std::string>(std::move(route_struct_contents.fields[2]));
            } else if (std::holds_alternative<std::nullptr_t>(route_struct_contents.fields[2])) {
                out_params.db_name_for_v43 = std::nullopt;
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Expected string or null
            }
        } else if (server_negotiated_version.major > 4 || (server_negotiated_version.major == 4 && server_negotiated_version.minor >= 4)) {  // Bolt 4.4+
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(route_struct_contents.fields[2])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
            auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(route_struct_contents.fields[2]));
            if (extra_map_sptr) {  // Map can be empty, but shared_ptr should be non-null
                out_params.extra_for_v44_plus = std::move(extra_map_sptr->pairs);
            } else {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;  // Extra map field was null
            }
        }
        // For Bolt 5.0+, the PSS structure is like 4.4 (3 fields, 3rd is extra map).
        // The semantic meaning of routing_table_context and extra_for_v44_plus for ROUTE V2 is handled
        // by how the client populates RouteMessageParams and how server interprets them.

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"  // For deserialize_message_structure_prelude
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    namespace {
        std::optional<std::string> get_optional_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::string>(it->second)) {
                try {
                    return std::get<std::string>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
        std::optional<std::vector<std::string>> get_optional_list_string_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltList>>(it->second)) {
                auto list_sptr = std::get<std::shared_ptr<BoltList>>(it->second);
                if (list_sptr) {
                    std::vector<std::string> result;
                    result.reserve(list_sptr->elements.size());
                    bool all_strings = true;
                    for (const auto& element : list_sptr->elements) {
                        if (std::holds_alternative<std::string>(element)) {
                            try {
                                result.push_back(std::get<std::string>(element));
                            } catch (...) {
                                all_strings = false;
                                break;
                            }
                        } else {
                            all_strings = false;
                            break;
                        }
                    }
                    if (all_strings) return result;
                }
            }
            return std::nullopt;
        }
        std::optional<std::map<std::string, Value>> get_optional_map_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<std::shared_ptr<BoltMap>>(it->second)) {
                auto inner_map_sptr = std::get<std::shared_ptr<BoltMap>>(it->second);
                if (inner_map_sptr) {
                    try {
                        return inner_map_sptr->pairs;
                    } catch (...) {
                    }
                }
            }
            return std::nullopt;
        }
        std::optional<int64_t> get_optional_int64_from_map(const BoltMap& map, const std::string& key) {
            auto it = map.pairs.find(key);
            if (it != map.pairs.end() && std::holds_alternative<int64_t>(it->second)) {
                try {
                    return std::get<int64_t>(it->second);
                } catch (...) {
                }
            }
            return std::nullopt;
        }
    }  // namespace

    BoltError deserialize_begin_message_request(PackStreamReader& reader, BeginMessageParams& out_params, const versions::Version& server_negotiated_version) {
        if (reader.has_error()) return reader.get_error();
        out_params = {};

        PackStreamStructure begin_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::BEGIN, 1, 1, begin_struct_contents);
        if (err != BoltError::SUCCESS) return err;

        if (begin_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(begin_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto extra_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(begin_struct_contents.fields[0]));
        if (!extra_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        const auto& extra_map_pairs_ref = extra_map_sptr->pairs;
        if (server_negotiated_version.major >= 3) {
            out_params.bookmarks = get_optional_list_string_from_map(*extra_map_sptr, "bookmarks");
            out_params.tx_timeout = get_optional_int64_from_map(*extra_map_sptr, "tx_timeout");
            out_params.tx_metadata = get_optional_map_from_map(*extra_map_sptr, "tx_metadata");
            out_params.mode = get_optional_string_from_map(*extra_map_sptr, "mode");
        }
        if (server_negotiated_version.major >= 4) {
            out_params.db = get_optional_string_from_map(*extra_map_sptr, "db");
            out_params.imp_user = get_optional_string_from_map(*extra_map_sptr, "imp_user");
        }
        if (server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) {
            out_params.notifications_min_severity = get_optional_string_from_map(*extra_map_sptr, "notifications_minimum_severity");
            out_params.notifications_disabled_categories = get_optional_list_string_from_map(*extra_map_sptr, "notifications_disabled_categories");
        }
        for (const auto& pair : extra_map_pairs_ref) {
            bool is_typed_field = ((server_negotiated_version.major >= 3 && (pair.first == "bookmarks" || pair.first == "tx_timeout" || pair.first == "tx_metadata" || pair.first == "mode")) || (server_negotiated_version.major >= 4 && (pair.first == "db" || pair.first == "imp_user")) ||
                                   ((server_negotiated_version.major > 5 || (server_negotiated_version.major == 5 && server_negotiated_version.minor >= 2)) && (pair.first == "notifications_minimum_severity" || pair.first == "notifications_disabled_categories")));
            if (!is_typed_field) {
                try {
                    out_params.other_extra_fields.emplace(pair.first, pair.second);
                } catch (...) { /* ignore or log */
                }
            }
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_commit_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // CommitMessageParams is empty struct, no out_params needed.

        PackStreamStructure commit_struct_contents;
        // COMMIT PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::COMMIT, 1, 1, commit_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        // Validate the field is indeed a map (preferably empty).
        if (commit_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(commit_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map field was a null shared_ptr
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // Specification: "Fields: No fields." but the PackStream structure for COMMIT is `COMMIT {}`
        // This means the PSS has one field, which is an empty map.
        // We can optionally check if map_sptr->pairs is empty for stricter validation.
        // if (!map_sptr->pairs.empty()) {
        //     reader.set_error(BoltError::INVALID_MESSAGE_FORMAT); // Expected empty map
        //     return BoltError::INVALID_MESSAGE_FORMAT;
        // }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_rollback_message_request(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();
        // RollbackMessageParams is empty.

        PackStreamStructure rollback_struct_contents;
        // ROLLBACK PSS (Bolt 3+) has 1 field: an empty map {}.
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::ROLLBACK, 1, 1, rollback_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }
        // Validate the field.
        if (rollback_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        auto map_sptr = std::get<std::shared_ptr<BoltMap>>(rollback_struct_contents.fields[0]);
        if (!map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }
        // The map should be empty.
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>
#include <map>
#include <memory>
#include <variant>
#include <vector>

#include "boltprotocol/detail/bolt_structure_helpers.h"  // For get_optional_list_string_from_map if used
#include "boltprotocol/message_defs.h"
#include "boltprotocol/message_serialization.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    BoltError deserialize_success_message(PackStreamReader& reader, SuccessMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure success_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::SUCCESS, 1, 1, success_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (success_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(success_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(success_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        // Example of how an upper layer (e.g., ClientSession) might use this:
        // After calling deserialize_success_message for a HELLO response:
        // if (auto patch_list_val = boltprotocol::detail::get_optional_list_string_from_map(boltprotocol::BoltMap{out_params.metadata}, "patch_bolt")) {
        //    session.agreed_patches = patch_list_val.value();
        //    for(const auto& patch : session.agreed_patches) {
        //        if (patch == "utc") session.utc_patch_active_for_4_4 = true;
        //    }
        // }
        // This logic belongs in the consuming code, not the generic deserializer.

        return BoltError::SUCCESS;
    }

    BoltError deserialize_failure_message(PackStreamReader& reader, FailureMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.metadata.clear();

        PackStreamStructure failure_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::FAILURE, 1, 1, failure_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (failure_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltMap>>(failure_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltMap> metadata_map_sptr;
        try {
            metadata_map_sptr = std::get<std::shared_ptr<BoltMap>>(std::move(failure_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!metadata_map_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.metadata = std::move(metadata_map_sptr->pairs);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_record_message(PackStreamReader& reader, RecordMessageParams& out_params) {
        if (reader.has_error()) return reader.get_error();
        out_params.fields.clear();

        PackStreamStructure record_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::RECORD, 1, 1, record_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (record_struct_contents.fields.empty() || !std::holds_alternative<std::shared_ptr<BoltList>>(record_struct_contents.fields[0])) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        std::shared_ptr<BoltList> fields_list_sptr;
        try {
            fields_list_sptr = std::get<std::shared_ptr<BoltList>>(std::move(record_struct_contents.fields[0]));
        } catch (const std::bad_variant_access&) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }

        if (!fields_list_sptr) {
            reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
            return BoltError::INVALID_MESSAGE_FORMAT;
        }

        try {
            out_params.fields = std::move(fields_list_sptr->elements);
        } catch (const std::bad_alloc&) {
            reader.set_error(BoltError::OUT_OF_MEMORY);
            return BoltError::OUT_OF_MEMORY;
        } catch (const std::exception&) {
            reader.set_error(BoltError::UNKNOWN_ERROR);
            return BoltError::UNKNOWN_ERROR;
        }
        return BoltError::SUCCESS;
    }

    BoltError deserialize_ignored_message(PackStreamReader& reader) {
        if (reader.has_error()) return reader.get_error();

        PackStreamStructure ignored_struct_contents;
        BoltError err = deserialize_message_structure_prelude(reader, MessageTag::IGNORED, 0, 1, ignored_struct_contents);
        if (err != BoltError::SUCCESS) {
            return err;
        }

        if (!ignored_struct_contents.fields.empty()) {
            if (!std::holds_alternative<std::shared_ptr<BoltMap>>(ignored_struct_contents.fields[0])) {
                reader.set_error(BoltError::INVALID_MESSAGE_FORMAT);
                return BoltError::INVALID_MESSAGE_FORMAT;
            }
        }

        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_reader.h"  // 主声明

#include <cstring>    // For memcpy in consume_bytes (if used for non-trivial types, though here it's for raw bytes)
#include <exception>  // For std::bad_alloc (relevant for Value assignment in read() if target type allocates)
#include <iostream>   // For std::istream operations
// byte_order_utils.h is included via packstream_reader.h

namespace boltprotocol {

    // --- PackStreamReader Constructor and Basic IO ---

    PackStreamReader::PackStreamReader(const std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // No body needed if all initialization is in member initializer list
    }

    PackStreamReader::PackStreamReader(std::istream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), buffer_pos_(0), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {   // Basic stream validity check
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR if appropriate
        }
    }

    void PackStreamReader::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    bool PackStreamReader::eof() const {
        if (has_error()) return true;  // If already in error, considered EOF for reading purposes
        if (buffer_ptr_) {
            return buffer_pos_ >= buffer_ptr_->size();
        }
        if (stream_ptr_) {
            // stream.eof() is only true after an attempt to read past EOF.
            // stream.peek() == EOF is a more reliable way to check without consuming.
            return stream_ptr_->peek() == EOF;
        }
        return true;  // No valid source
    }

    BoltError PackStreamReader::peek_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check stream state before peeking
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->peek();  // peek() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {  // badbit indicates a serious I/O error
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // eofbit, or (eofbit and failbit if formatting error also occurred)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_byte(uint8_t& out_byte) {
        if (has_error()) return error_state_;
        out_byte = 0;  // Initialize

        if (buffer_ptr_) {
            if (buffer_pos_ < buffer_ptr_->size()) {
                out_byte = (*buffer_ptr_)[buffer_pos_++];
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // EOF on buffer
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            int byte_read = stream_ptr_->get();  // get() returns int
            if (byte_read == EOF) {
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {
                    set_error(BoltError::DESERIALIZATION_ERROR);  // EOF encountered
                }
                return error_state_;
            }
            out_byte = static_cast<uint8_t>(byte_read);
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    BoltError PackStreamReader::consume_bytes(void* dest, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to read
        if (dest == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            if (buffer_pos_ + size <= buffer_ptr_->size()) {
                // Using reinterpret_cast for buffer_ptr_->data() is okay as it's uint8_t
                std::memcpy(dest, buffer_ptr_->data() + buffer_pos_, size);
                buffer_pos_ += size;
                return BoltError::SUCCESS;
            }
            set_error(BoltError::DESERIALIZATION_ERROR);  // Buffer read out of bounds
            return error_state_;
        }
        if (stream_ptr_) {
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->read(static_cast<char*>(dest), static_cast<std::streamsize>(size));

            // Check if the read was successful and complete
            if (static_cast<size_t>(stream_ptr_->gcount()) != size) {
                // failbit will be set if gcount() < size and not EOF, or badbit is set.
                // eofbit will be set if EOF was reached during the read.
                if (stream_ptr_->bad()) {
                    set_error(BoltError::NETWORK_ERROR);
                } else {                                          // Could be failbit (less data than requested) or eofbit (hit EOF)
                    set_error(BoltError::DESERIALIZATION_ERROR);  // Not enough data or other stream error
                }
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        set_error(BoltError::INVALID_ARGUMENT);  // No input source
        return error_state_;
    }

    // --- PackStreamReader Main Read Logic ---

    BoltError PackStreamReader::read(Value& out_value) {
        // Reset output value to a known state (nullptr for variant is a good default)
        try {
            out_value = nullptr;
        } catch (const std::bad_alloc&) {  // Should not happen for nullptr_t assignment
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }

        if (has_error()) return error_state_;
        if (eof()) {                                      // Check before attempting to consume any byte
            set_error(BoltError::DESERIALIZATION_ERROR);  // Attempt to read past EOF
            return error_state_;
        }

        uint8_t marker;
        BoltError err = consume_byte(marker);
        if (err != BoltError::SUCCESS) return err;  // error_state_ already set by consume_byte

        // Handle Tiny Positive Int (0 to 127) and Tiny Negative Int (-16 to -1) directly
        // These are outside the typical marker switch for performance and clarity.
        if (marker <= 0x7F) {  // Tiny Positive Int (0 to 127)
            try {
                out_value = static_cast<int64_t>(marker);
            } catch (const std::bad_alloc&) {  // Value variant assignment might allocate.
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }
        if (marker >= 0xF0) {  // Tiny Negative Int (-16 to -1)
            try {
                out_value = static_cast<int64_t>(static_cast<int8_t>(marker));
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            }
            return BoltError::SUCCESS;
        }

        // Dispatch to type-specific handlers based on marker
        // These handlers are now in separate .cpp files but are still part of PackStreamReader class.
        switch (marker) {
            case MARKER_NULL:
                return read_null_value(out_value);
            case MARKER_FALSE:
                return read_boolean_value(false, out_value);
            case MARKER_TRUE:
                return read_boolean_value(true, out_value);
            case MARKER_FLOAT64:
                return read_float64_value(out_value);

            case MARKER_INT_8:
            case MARKER_INT_16:
            case MARKER_INT_32:
            case MARKER_INT_64:
                return read_integer_value(marker, out_value);

            // Ranged cases for C++20 and later (as per project requirement)
            case MARKER_TINY_STRING_BASE ...(MARKER_TINY_STRING_BASE + 0x0F):  // 0x80 to 0x8F
            case MARKER_STRING_8:
            case MARKER_STRING_16:
            case MARKER_STRING_32:
                return read_string_value(marker, out_value);

            case MARKER_TINY_LIST_BASE ...(MARKER_TINY_LIST_BASE + 0x0F):  // 0x90 to 0x9F
            case MARKER_LIST_8:
            case MARKER_LIST_16:
            case MARKER_LIST_32:
                return read_list_value(marker, out_value);

            case MARKER_TINY_MAP_BASE ...(MARKER_TINY_MAP_BASE + 0x0F):  // 0xA0 to 0xAF
            case MARKER_MAP_8:
            case MARKER_MAP_16:
            case MARKER_MAP_32:
                return read_map_value(marker, out_value);

            case MARKER_TINY_STRUCT_BASE ...(MARKER_TINY_STRUCT_BASE + 0x0F):  // 0xB0 to 0xBF
            case MARKER_STRUCT_8:
            case MARKER_STRUCT_16:
                return read_struct_value(marker, out_value);

            default:
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Unknown marker
                return error_state_;
        }
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error, std::bad_variant_access
#include <map>
#include <memory>  // For std::shared_ptr, std::make_shared
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read List elements into a pre-allocated BoltList shared_ptr
    BoltError PackStreamReader::read_list_elements_into(std::shared_ptr<BoltList>& list_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!list_sptr) {  // Should be allocated by caller (read_list_value)
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = BoltError::SUCCESS;
        try {
            list_sptr->elements.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large for vector
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value element;
            err = this->read(element);  // Recursive call to PackStreamReader::read for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call
                return error_state_;
            }
            try {
                list_sptr->elements.push_back(std::move(element));  // Value move ctor/vector push_back
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other potential exceptions from push_back or Value move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_list_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_LIST_BASE) {  // Tiny List (0x90 to 0x9F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_LIST_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_LIST_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltList> list_sptr;
        try {
            list_sptr = std::make_shared<BoltList>();  // Potential std::bad_alloc
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other errors from make_shared construction
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        // No need to check if (!list_sptr) because make_shared throws on failure.

        err = read_list_elements_into(list_sptr, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set
            return error_state_;
        }

        try {
            out_value = std::move(list_sptr);  // Move shared_ptr into variant
        } catch (const std::bad_alloc&) {      // Variant assignment can allocate.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // Helper to read Map key-value pairs into a pre-allocated BoltMap shared_ptr
    BoltError PackStreamReader::read_map_pairs_into(std::shared_ptr<BoltMap>& map_sptr, uint32_t size) {
        if (has_error()) return error_state_;
        if (!map_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        for (uint32_t i = 0; i < size; ++i) {
            Value key_as_value;
            err = this->read(key_as_value);  // Read map key
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            std::string key_str;
            if (std::holds_alternative<std::string>(key_as_value)) {
                try {
                    // std::get for rvalue variant returns rvalue ref or throws if type mismatch / bad state
                    key_str = std::get<std::string>(std::move(key_as_value));
                } catch (const std::bad_variant_access&) {  // Should not happen due to holds_alternative
                    current_recursion_depth_--;
                    set_error(BoltError::INVALID_MESSAGE_FORMAT);
                    return error_state_;
                } catch (const std::bad_alloc&) {  // string move assignment/ctor
                    current_recursion_depth_--;
                    set_error(BoltError::OUT_OF_MEMORY);
                    return error_state_;
                } catch (const std::exception&) {
                    current_recursion_depth_--;
                    set_error(BoltError::UNKNOWN_ERROR);
                    return error_state_;
                }
            } else {
                current_recursion_depth_--;
                set_error(BoltError::INVALID_MESSAGE_FORMAT);  // Map key must be a string
                return error_state_;
            }

            Value map_value_element;
            err = this->read(map_value_element);  // Read map value
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }

            try {
                // map::emplace can throw (e.g. bad_alloc for node, or if Value copy/move throws)
                map_sptr->pairs.emplace(std::move(key_str), std::move(map_value_element));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other exceptions from emplace or Value's move
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_map_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_MAP_BASE) {  // Tiny Map (0xA0 to 0xAF)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_MAP_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_MAP_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<BoltMap> map_sptr;
        try {
            map_sptr = std::make_shared<BoltMap>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_map_pairs_into(map_sptr, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(map_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less likely here, more in complex types)
#include <limits>     // For std::numeric_limits (though not strictly needed for existing integer logic)

#include "boltprotocol/message_defs.h"       // For Value, BoltError
#include "boltprotocol/packstream_reader.h"  // For PackStreamReader class declaration and constants
// byte_order_utils.h is included via packstream_reader.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamReader::read_null_value(Value& out_value) {
        if (has_error()) return error_state_;
        out_value = nullptr;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_boolean_value(bool bool_val_from_marker, Value& out_value) {
        if (has_error()) return error_state_;
        out_value = bool_val_from_marker;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_float64_value(Value& out_value) {
        if (has_error()) return error_state_;
        uint64_t temp_int;
        BoltError err = consume_network_int(temp_int);  // consume_network_int handles byte swapping
        if (err != BoltError::SUCCESS) return err;

        double val;
        // Ensure that double is 64-bit and has the same endianness concerns as uint64_t
        // The value read into temp_int is already in host byte order.
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&val, &temp_int, sizeof(double));

        try {
            out_value = val;
        } catch (const std::bad_alloc&) {  // Value variant assignment might allocate if it's a complex type, though not for double. Defensive.
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_integer_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        BoltError err;
        int64_t final_val = 0;

        switch (marker) {
            case MARKER_INT_8:
                {
                    int8_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_16:
                {
                    int16_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_32:
                {
                    int32_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = static_cast<int64_t>(val);
                    break;
                }
            case MARKER_INT_64:
                {
                    int64_t val;
                    err = consume_network_int(val);
                    if (err != BoltError::SUCCESS) return err;
                    final_val = val;
                    break;
                }
            default:
                // This case should ideally not be reached if dispatch in `read()` is correct
                set_error(BoltError::INVALID_ARGUMENT);
                return error_state_;
        }

        try {
            out_value = final_val;
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <string>
#include <vector>  // Though not directly used, good for context

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read string data of a given size into an std::string
    // This was originally in packstream_reader_types.cpp
    BoltError PackStreamReader::read_string_data_into(std::string& out_string, uint32_t size) {
        if (has_error()) return error_state_;
        out_string.clear();

        if (size == 0) {
            return BoltError::SUCCESS;
        }
        try {
            out_string.resize(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {              // String too long for std::string to handle
            set_error(BoltError::DESERIALIZATION_ERROR);  // Or MESSAGE_TOO_LARGE
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        // consume_bytes will set error_state_ on failure (e.g., not enough bytes)
        return consume_bytes(out_string.data(), size);
    }

    BoltError PackStreamReader::read_string_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRING_BASE) {  // Tiny String (0x80 to 0x8F)
            size = marker & 0x0F;
        } else {
            switch (marker) {
                case MARKER_STRING_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;
                        break;
                    }
                case MARKER_STRING_32:
                    {
                        uint32_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;  // Already uint32_t
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);  // Marker not a string marker
                    return error_state_;
            }
        }

        std::string s_val;
        err = read_string_data_into(s_val, size);
        if (err != BoltError::SUCCESS) {
            // error_state_ is already set by read_string_data_into or consume_bytes
            return error_state_;
        }

        try {
            out_value = std::move(s_val);  // std::string move constructor into variant
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {  // Other potential exceptions from variant assignment
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc, std::length_error
#include <memory>     // For std::shared_ptr, std::make_shared
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_reader.h"

namespace boltprotocol {

    // Helper to read Structure fields into a pre-allocated PackStreamStructure shared_ptr
    BoltError PackStreamReader::read_struct_fields_into(std::shared_ptr<PackStreamStructure>& struct_sptr, uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        if (!struct_sptr) {
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        struct_sptr->tag = tag;  // Set the tag

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err;
        try {
            struct_sptr->fields.reserve(size);  // Potential std::bad_alloc or std::length_error
        } catch (const std::bad_alloc&) {
            current_recursion_depth_--;
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::length_error&) {
            current_recursion_depth_--;
            set_error(BoltError::DESERIALIZATION_ERROR);  // Size too large
            return error_state_;
        } catch (const std::exception&) {
            current_recursion_depth_--;
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        for (uint32_t i = 0; i < size; ++i) {
            Value field_val;
            err = this->read(field_val);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;
            }
            try {
                struct_sptr->fields.push_back(std::move(field_val));
            } catch (const std::bad_alloc&) {
                current_recursion_depth_--;
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {
                current_recursion_depth_--;
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamReader::read_struct_value(uint8_t marker, Value& out_value) {
        if (has_error()) return error_state_;
        uint32_t size = 0;
        uint8_t tag = 0;
        BoltError err;

        if ((marker & 0xF0) == MARKER_TINY_STRUCT_BASE) {  // Tiny Struct (0xB0 to 0xBF)
            size = marker & 0x0F;
            err = consume_byte(tag);  // Read the tag byte following the marker
            if (err != BoltError::SUCCESS) return err;
        } else {
            switch (marker) {
                case MARKER_STRUCT_8:
                    {
                        uint8_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                case MARKER_STRUCT_16:
                    {
                        uint16_t s_len;
                        err = consume_network_int(s_len);
                        if (err != BoltError::SUCCESS) return err;
                        size = s_len;

                        err = consume_byte(tag);  // Read the tag byte
                        if (err != BoltError::SUCCESS) return err;
                        break;
                    }
                default:
                    set_error(BoltError::INVALID_ARGUMENT);
                    return error_state_;
            }
        }

        std::shared_ptr<PackStreamStructure> struct_sptr;
        try {
            struct_sptr = std::make_shared<PackStreamStructure>();
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }

        err = read_struct_fields_into(struct_sptr, tag, size);
        if (err != BoltError::SUCCESS) return err;

        try {
            out_value = std::move(struct_sptr);
        } catch (const std::bad_alloc&) {
            set_error(BoltError::OUT_OF_MEMORY);
            return error_state_;
        } catch (const std::exception&) {
            set_error(BoltError::UNKNOWN_ERROR);
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include "boltprotocol/packstream_writer.h"  // 主声明

#include <cstring>    // For memcpy (used in append_network_int indirectly via detail::host_to_be)
#include <exception>  // For std::bad_alloc (relevant for vector buffer operations)
#include <iostream>   // For std::ostream operations
#include <variant>    // For std::visit
// byte_order_utils.h is included via packstream_writer.h

namespace boltprotocol {

    // --- PackStreamWriter Constructor and Low-Level IO ---

    PackStreamWriter::PackStreamWriter(std::vector<uint8_t>& buffer) : buffer_ptr_(&buffer), stream_ptr_(nullptr), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        // Initialization in member initializer list
    }

    PackStreamWriter::PackStreamWriter(std::ostream& stream) : buffer_ptr_(nullptr), stream_ptr_(&stream), error_state_(BoltError::SUCCESS), current_recursion_depth_(0) {
        if (!stream_ptr_ || stream_ptr_->fail()) {
            set_error(BoltError::INVALID_ARGUMENT);  // Or NETWORK_ERROR
        }
    }

    void PackStreamWriter::set_error(BoltError error) {
        if (error_state_ == BoltError::SUCCESS && error != BoltError::SUCCESS) {
            error_state_ = error;
        }
    }

    BoltError PackStreamWriter::append_byte(uint8_t byte) {
        if (has_error()) return error_state_;

        if (buffer_ptr_) {
            try {
                buffer_ptr_->push_back(byte);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other possible exceptions from vector
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->put(static_cast<char>(byte));
            if (stream_ptr_->fail()) {
                set_error(BoltError::NETWORK_ERROR);  // Error after writing
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::append_bytes(const void* data, size_t size) {
        if (has_error()) return error_state_;
        if (size == 0) return BoltError::SUCCESS;  // Nothing to append
        if (data == nullptr && size > 0) {         // Should not happen with internal calls typically
            set_error(BoltError::INVALID_ARGUMENT);
            return error_state_;
        }

        if (buffer_ptr_) {
            const auto* byte_data = static_cast<const uint8_t*>(data);
            try {
                // Insert range [first, last)
                buffer_ptr_->insert(buffer_ptr_->end(), byte_data, byte_data + size);  // Potential std::bad_alloc
            } catch (const std::bad_alloc&) {
                set_error(BoltError::OUT_OF_MEMORY);
                return error_state_;
            } catch (const std::exception&) {  // Other vector exceptions
                set_error(BoltError::UNKNOWN_ERROR);
                return error_state_;
            }
        } else if (stream_ptr_) {
            if (stream_ptr_->fail()) {  // Check before writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
            stream_ptr_->write(static_cast<const char*>(data), static_cast<std::streamsize>(size));
            if (stream_ptr_->fail()) {  // Error after writing
                set_error(BoltError::NETWORK_ERROR);
                return error_state_;
            }
        } else {
            set_error(BoltError::INVALID_ARGUMENT);  // No output target
            return error_state_;
        }
        return BoltError::SUCCESS;
    }

    // --- PackStreamWriter Main Dispatch Logic ---

    BoltError PackStreamWriter::write(const Value& value) {
        if (has_error()) return error_state_;  // Already in error

        // Visitor lambda to dispatch to internal type-specific writers
        auto visitor = [&](const auto& arg) -> BoltError {
            // std::decay_t to handle const& from variant's get/visit
            using T = std::decay_t<decltype(arg)>;

            if constexpr (std::is_same_v<T, std::nullptr_t>) {
                return write_null_internal();
            } else if constexpr (std::is_same_v<T, bool>) {
                return write_boolean_internal(arg);
            } else if constexpr (std::is_same_v<T, int64_t>) {
                return write_integer_internal(arg);
            } else if constexpr (std::is_same_v<T, double>) {
                return write_float_internal(arg);
            } else if constexpr (std::is_same_v<T, std::string>) {
                return serialize_string_internal(arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltList>>) {
                if (!arg) {  // Handle null shared_ptr as PackStream NULL
                    return write_null_internal();
                }
                return serialize_list_internal(*arg);  // Dereference shared_ptr
            } else if constexpr (std::is_same_v<T, std::shared_ptr<BoltMap>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_map_internal(*arg);
            } else if constexpr (std::is_same_v<T, std::shared_ptr<PackStreamStructure>>) {
                if (!arg) {
                    return write_null_internal();
                }
                return serialize_structure_internal(*arg);
            } else {
                // This static_assert will fail at compile time if Value has an unhandled type.
                // static_assert(false, "Unhandled type in PackStreamWriter::write visitor");
                // For runtime, in case a type slips through somehow (shouldn't with variant):
                set_error(BoltError::SERIALIZATION_ERROR);  // Unknown type to serialize
                return error_state_;
            }
        };

        return std::visit(visitor, value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits
#include <map>
#include <memory>  // For std::shared_ptr (used in Value variant)
#include <string>  // For map keys
#include <vector>

#include "boltprotocol/message_defs.h"  // For BoltList, BoltMap, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_list_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny List
            err = append_byte(MARKER_TINY_LIST_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_LIST_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_LIST_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // LIST_32
            err = append_byte(MARKER_LIST_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_list_internal(const BoltList& list_data) {
        if (has_error()) return error_state_;
        const auto& list_elements = list_data.elements;

        if (list_elements.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // List too large for PackStream size encoding
            return error_state_;
        }
        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_list_header_internal(static_cast<uint32_t>(list_elements.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;  // Error already set
        }

        for (const auto& item : list_elements) {
            err = this->write(item);  // Recursive call to PackStreamWriter::write for each element
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                // error_state_ is already set by the recursive call to write()
                return error_state_;
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

    BoltError PackStreamWriter::write_map_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Map
            err = append_byte(MARKER_TINY_MAP_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_MAP_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_MAP_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // MAP_32
            err = append_byte(MARKER_MAP_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_map_internal(const BoltMap& map_data) {
        if (has_error()) return error_state_;
        const auto& map_pairs = map_data.pairs;

        if (map_pairs.size() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // Map too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_map_header_internal(static_cast<uint32_t>(map_pairs.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& pair : map_pairs) {
            // Write key (must be string for PackStream maps)
            err = serialize_string_internal(pair.first);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by serialize_string_internal
            }
            // Write value (recursive call)
            err = this->write(pair.second);
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set by recursive write()
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocol#include <cstring>    // For memcpy (for float64)
#include <exception>  // For std::bad_alloc (though less direct here)
#include <limits>     // For std::numeric_limits

#include "boltprotocol/message_defs.h"       // For BoltError (though packstream_writer.h includes it)
#include "boltprotocol/packstream_writer.h"  // For PackStreamWriter class declaration and constants
// byte_order_utils.h is included via packstream_writer.h -> detail/byte_order_utils.h

namespace boltprotocol {

    BoltError PackStreamWriter::write_null_internal() {
        if (has_error()) return error_state_;
        return append_byte(MARKER_NULL);
    }

    BoltError PackStreamWriter::write_boolean_internal(bool bool_value) {
        if (has_error()) return error_state_;
        return append_byte(bool_value ? MARKER_TRUE : MARKER_FALSE);
    }

    BoltError PackStreamWriter::write_integer_internal(int64_t int_value) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;  // Initialize err

        if (int_value >= -16 && int_value <= 127) {  // Tiny Int
            err = append_byte(static_cast<uint8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int8_t>::min() && int_value <= std::numeric_limits<int8_t>::max()) {
            err = append_byte(MARKER_INT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int8_t>(int_value));
        } else if (int_value >= std::numeric_limits<int16_t>::min() && int_value <= std::numeric_limits<int16_t>::max()) {
            err = append_byte(MARKER_INT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int16_t>(int_value));
        } else if (int_value >= std::numeric_limits<int32_t>::min() && int_value <= std::numeric_limits<int32_t>::max()) {
            err = append_byte(MARKER_INT_32);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<int32_t>(int_value));
        } else {  // INT_64
            err = append_byte(MARKER_INT_64);
            if (err == BoltError::SUCCESS) err = append_network_int(int_value);
        }
        return err;  // Return the result of the last append operation
    }

    BoltError PackStreamWriter::write_float_internal(double float_value) {
        if (has_error()) return error_state_;
        BoltError err = append_byte(MARKER_FLOAT64);
        if (err != BoltError::SUCCESS) return err;  // If appending marker failed

        uint64_t temp_int;  // To hold byte representation of double
        static_assert(sizeof(double) == sizeof(uint64_t), "Double is not 64-bit.");
        std::memcpy(&temp_int, &float_value, sizeof(double));

        // append_network_int will handle host-to-be conversion for temp_int
        return append_network_int(temp_int);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc (from vector operations if buffer_ptr_)
#include <limits>     // For std::numeric_limits
#include <string>
#include <vector>  // For buffer_ptr_ if used (though append_bytes handles it)

#include "boltprotocol/message_defs.h"
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_string_header_internal(uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny String (0x80 to 0x8F)
            err = append_byte(MARKER_TINY_STRING_BASE | static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint8_t>::max()) {
            err = append_byte(MARKER_STRING_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
        } else if (size <= std::numeric_limits<uint16_t>::max()) {
            err = append_byte(MARKER_STRING_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
        } else {  // STRING_32 (uint32_t max is handled by PackStream spec)
            err = append_byte(MARKER_STRING_32);
            if (err == BoltError::SUCCESS) err = append_network_int(size);  // size is already uint32_t
        }
        return err;
    }

    BoltError PackStreamWriter::write_string_data_internal(const std::string& value_str) {
        if (has_error()) return error_state_;
        if (value_str.empty()) {
            return BoltError::SUCCESS;  // Nothing to append for an empty string's data
        }
        // append_bytes handles potential errors (like OUT_OF_MEMORY if writing to vector buffer)
        return append_bytes(value_str.data(), value_str.length());
    }

    BoltError PackStreamWriter::serialize_string_internal(const std::string& str_value) {
        if (has_error()) return error_state_;

        // PackStream strings are limited to 2^32 - 1 bytes (UINT32_MAX).
        // std::string::length() returns size_t.
        if (str_value.length() > std::numeric_limits<uint32_t>::max()) {
            set_error(BoltError::SERIALIZATION_ERROR);  // String too long for PackStream
            return error_state_;
        }
        uint32_t len = static_cast<uint32_t>(str_value.length());

        BoltError err = write_string_header_internal(len);
        if (err != BoltError::SUCCESS) {
            // error_state_ already set by write_string_header_internal or its callees
            return error_state_;
        }
        // Only write data if length > 0 (handled by write_string_data_internal)
        return write_string_data_internal(str_value);
    }

}  // namespace boltprotocol#include <exception>  // For std::bad_alloc
#include <limits>     // For std::numeric_limits (for STRUCT_16 max size)
#include <memory>     // For std::shared_ptr (used in Value variant)
#include <vector>

#include "boltprotocol/message_defs.h"  // For PackStreamStructure, Value
#include "boltprotocol/packstream_writer.h"

namespace boltprotocol {

    BoltError PackStreamWriter::write_struct_header_internal(uint8_t tag, uint32_t size) {
        if (has_error()) return error_state_;
        BoltError err = BoltError::SUCCESS;

        if (size <= 0x0F) {  // Tiny Struct (0xB0 to 0xBF)
            err = append_byte(MARKER_TINY_STRUCT_BASE | static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint8_t>::max()) {  // Struct 8
            err = append_byte(MARKER_STRUCT_8);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint8_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else if (size <= std::numeric_limits<uint16_t>::max()) {  // Struct 16
            err = append_byte(MARKER_STRUCT_16);
            if (err == BoltError::SUCCESS) err = append_network_int(static_cast<uint16_t>(size));
            if (err == BoltError::SUCCESS) err = append_byte(tag);
        } else {
            // PackStream v1 (which Bolt uses) does not define STRUCT_32.
            // Maximum number of fields for a structure is 65535 (0xFFFF).
            set_error(BoltError::SERIALIZATION_ERROR);  // Structure too large for PackStream v1 encoding
            return error_state_;
        }
        return err;
    }

    BoltError PackStreamWriter::serialize_structure_internal(const PackStreamStructure& struct_data) {
        if (has_error()) return error_state_;

        // Max fields for a PackStream structure (STRUCT_16 limit)
        if (struct_data.fields.size() > std::numeric_limits<uint16_t>::max()) {  // 65535
            set_error(BoltError::SERIALIZATION_ERROR);                           // Structure too large
            return error_state_;
        }

        if (current_recursion_depth_ >= MAX_RECURSION_DEPTH) {
            set_error(BoltError::RECURSION_DEPTH_EXCEEDED);
            return error_state_;
        }
        current_recursion_depth_++;

        BoltError err = write_struct_header_internal(struct_data.tag, static_cast<uint32_t>(struct_data.fields.size()));
        if (err != BoltError::SUCCESS) {
            current_recursion_depth_--;
            return error_state_;
        }

        for (const auto& field : struct_data.fields) {
            err = this->write(field);  // Recursive call
            if (err != BoltError::SUCCESS) {
                current_recursion_depth_--;
                return error_state_;  // Error already set
            }
        }
        current_recursion_depth_--;
        return BoltError::SUCCESS;
    }

}  // namespace boltprotocolBolt Protocol handshake specification

All Bolt connections begin with a handshake to negotiate which version of the messaging protocol to use. Following a successful negotiation, the agreed messaging protocol then takes ownership of the connection for the remainder of its lifetime. The handshake itself is not versioned.

Bolt is a client-server protocol designed primarily for executing queries against a database server. Communication occurs through request-response exchanges, in much the same way as HTTP. Unlike HTTP, however, Bolt connections are stateful.

Bolt Protocol message specification

The message specification describes the message exchanges that take place on a connection following a successful Bolt handshake. For details of establishing a connection and performing a handshake, see Bolt Protocol handshake specification.

The Bolt protocol communicates with specific versioned messages.
Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.

For more information, see the corresponding version of the Bolt Protocol server state specification.
Server signals

Jump ahead means that the signal is immediately available before any messages are processed in the message queue.
Server signal 	Jump ahead 	Description

<INTERRUPT>


X

an interrupt signal

<DISCONNECT>


a disconnect signal
Protocol errors

If a server or client receives a message type that is unexpected, according to the transitions described in this document, it must treat that as a protocol error. Protocol errors are fatal and should immediately transition the server state to DEFUNCT, closing any open connections.
Session

Each connection to the server creates a new session that lives until that connection is closed. Each session is isolated and the server keeps track of the current state, based on the requests and responses exchanged within that session. A session ends when the socket for that connection is closed. Typically, this will be closed by the client.
Message exchange

Messages are exchanged in a request-response pattern between client and server. Each request consists of exactly one message and each response consists of zero or more detail messages followed by exactly one summary message. The presence or absence of detail messages in a response is directly related to the type of request message that has been sent. In other words, some request message types elicit a response that may contain detail messages, others do not.

Messages may also be pipelined. In other words, clients may send multiple requests eagerly without first waiting for responses. When a failure occurs in this scenario, servers must ignore all subsequent requests until the client has explicitly acknowledged receipt of the failure. This prevents inadvertent execution of queries that may not be valid. More details of this process can be found in the sections below.
Serialization

Messages and their contents are serialized into network streams using PackStream Specification Version 1. Each message is represented as a PackStream structure that contains a fixed number of fields. The message type is denoted by the PackStream structure tag byte and each message is defined in the Bolt protocol. Serialization is specified with PackStream Version 1.
Chunking

A layer of chunking is also applied to message transmissions as a way to more predictably manage packets of data. The chunking process allows the message to be broken into one or more pieces, each of an arbitrary size, and for those pieces to be transmitted within separate chunks. Each chunk consists of a two-byte header, detailing the chunk size in bytes followed by the chunk data itself. Chunk headers are 16-bit unsigned integers, meaning that the maximum theoretical chunk size permitted is 65,535 bytes.

Each encoded message must be terminated with a chunk of zero size, i.e.

00 00

This is used to signal message boundaries to a receiving parties, allowing blocks of data to be fully received without requiring that the message is parsed immediately. This also allows for unknown message types to be received and handled without breaking the messaging chain.

The Bolt protocol encodes each message using a chunked transfer encoding.

Each message is transferred as one or more chunks of data.

Each chunk starts with a two-byte header, an unsigned big-endian 16-bit integer, representing the size of the chunk not including the header.

A message can be divided across multiple chunks, allowing client and server alike to transfer large messages without having to determine the length of the entire message in advance.

Chunking applies on each message individually.

One chunk cannot contain more than one message.

Each message ends with two bytes with the value 00 00, these are not counted towards the chunk size (you may consider them as individual chunks of size 0).

With version 4.1+, the NOOP chunk (empty chunk) is used to send an empty chunk and the purpose is to be able to support a keep alive behaviour on the connection.


Examples of how Bolt chunks messages
Example of a message in one chunk

Message data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

results in the following chunk:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00

with the chunk header 00 10 and the end marker 00 00.
Example of a message split in two chunks

Message data containing 20 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 02 03 04

results in chunk 1 and chunk 2:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00 04 01 02 03 04 00 00

with the chunk 1 header 00 01 and no end marker for chunk 1, still message data. Chunk 2 has a header 00 04 and an end marker 00 00.
Example with two messages

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

are both encoded with chunking:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Example with two messages with a NOOP in between

Message 1 data containing 16 bytes:

00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

Message 2 data containing 8 bytes:

0F 0E 0D 0C 0B 0A 09 08

The two messages encoded with chunking and a NOOP(empty chunk) in between:

00 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00 00
00 00
00 08 0F 0E 0D 0C 0B 0A 09 08 00 00

Pipelining

The client may send multiple requests eagerly without first waiting for responses.
Transaction

A transaction is the concept of atomic units of work.

The concept of Transaction is when the server is in the READY state and the transaction is opened with the request message RUN and the response of a summary message SUCCESS. The Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL.

Version 3 of the Bolt Protocol introduces the concept of Auto-commit Transaction and Explicit Transaction. Auto-commit Transaction is the server in the READY state and the transition to the STREAMING state. The transaction is opened with the request message RUN and the response of a summary message SUCCESS.

The Auto-commit Transaction is successfully closed with the summary message SUCCESS for the request message PULL_ALL or the request message DISCARD_ALL. Thus, the Auto-commit Transaction can only contain one RUN request message.

In version 4 of the Bolt Protocol, the DISCARD_ALL and PULL_ALL messages are renamed to DISCARD and PULL and new fields are introduced.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: RUN ...      // Open a new Auto-commit Transaction
S: SUCCESS ...  // Server is in STREAMING state

C: PULL ...
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in STREAMING state

C: PULL
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in READY state and this implies that the Auto-commit Transaction is closed.

In version 1, HELLO is called INIT and Auto-commit Transaction is just Transaction. The field has_more=true/false is introduced in version 4. See also the corresponding version of the Bolt Protocol server state specification.

The Explicit Transaction is introduced in version 3 of Bolt and is a more generic transaction that can contain several RUN request messages. The concept of Explicit Transaction is when the server is in the READY state and the transaction is opened with the request message BEGIN and the response of a summary message SUCCESS (thus transition into the TX_READY server state).

The Explicit Transaction is successfully closed with the request message COMMIT and the response of a summary message SUCCESS. The result stream (detail messages) must be fully consumed or discarded by a client before the server can transition to the TX_READY state and thus be able to close the transaction with a COMMIT request message. It can be gracefully discarded and set to the initial server state of READY with the request message ROLLBACK.
Example with Bolt v4

...
C: HELLO ...
S: SUCCESS ...  // Server is in READY state

C: BEGIN ...    // Open a new Explicit Transaction
S: SUCCESS ...  // Server is in TX_READY state

C: RUN ...
S: SUCCESS {"qid": 123, ...} // Server is in TX_STREAMING state, one stream is open

C: RUN ...
S: SUCCESS {"qid": 456, ...} // Server is in TX_STREAMING state, two streams are open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": true, ...}  // Server is still in TX_STREAMING state, two streams are still open

C: PULL {"qid": 123, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS ... has_more=false  // Server is still in TX_STREAMING state, one stream is still open

C: PULL {"qid": 456, ...}
S: RECORD ...
...
S: RECORD ...
S: SUCCESS {"has_more": false, ...}  // Server is in TX_READY state, all streams have been fully consumed

C: COMMIT   // Close the Explicit Transaction
S: SUCCESS  // Server is in READY state

In version 3, PULL is called PULL_ALL. Additionally, there are no fields, e.g qid=123 and has_more=true/false available in version 3 of the Bolt Protocol.

More examples of message exchanges can be found in Appendix — Message exchange examples.
Messages

There are three different kinds of messages:

Request message - the client sends a message.

Summary message - the server always responds with one summary message if the connection is still open.

Detail message - the server always responds with zero or more detail messages before sending a summary message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Message 	Signature 	Type of message 	Fields 	Description

HELLO

01

Request

extra::Dictionary(user_agent::String, routing::Dictionary(address::String), notifications_minimum_severity::String, notifications_disabled_categories::List<String>, bolt_agent::Dictionary(product::String, platform::String, language::String, language_details::String))

initialize connection (replaces INIT of v1 & v2)(routing::Dictionary(address::String) added in v4.1) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)(bolt_agent::Dictionary added in v5.3)

LOGON

6A

Request

scheme::String, …​

authenticates the user you send with the message

LOGOFF

6B

Request

logs off current user, becomes ready for another LOGON message

TELEMETRY

54

Request

api::Integer

transmit usage telemetry (added in v5.4)

GOODBYE

02

Request

close the connection, triggers a <DISCONNECT> signal

ACK_FAILURE (only v1 and v2)

0E

Request

acknowledge a failure response (deprecated, use RESET instead with v3+)

RESET

0F

Request

reset the connection, triggers an <INTERRUPT> signal

RUN

10

Request

query::String, parameters::Dictionary, extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db:String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

execute a query (extra::Dictionary added in v3)(db:String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

DISCARD

2F

Request

extra::Dictionary(n::Integer, qid::Integer)

discard records (replaces DISCARD_ALL of v1, v2 & v3)(fields added in v4.0)

PULL

3F

Request

extra::Dictionary(n::Integer, qid::Integer)

fetch records (replaces PULL_ALL of v1, v2 & v3)(fields added in v4.0)

BEGIN

11

Request

extra::Dictionary(bookmarks::List<String>, tx_timeout::Integer, tx_metadata::Dictionary, mode::String, db::String, imp_user::String, notifications_minimum_severity::String, notifications_disabled_categories::List<String>)

begin a new transaction (added in v3)(db::String, imp_user::String added in v4.0) (notifications_minimum_severity::String, notifications_disabled_categories::List<String> added in v5.2)

COMMIT

12

Request

commit a transaction (added in v3)

ROLLBACK

13

Request

rollback a transaction (added in v3)

ROUTE

66

Request

routing::Dictionary(address::String), bookmarks::List<String>, extra::Dictionary(db::String, imp_user::String)

fetch the current routing table (added in v4.3)

SUCCESS

70

Summary

metadata::Dictionary

request succeeded

IGNORED

7E

Summary

request was ignored

FAILURE

7F

Summary

metadata::Dictionary

request failed

RECORD

71

Detail

data::List

data values
Request message HELLO

Introduced in bolt 3

The HELLO message request the connection to be authorized for use with the remote database and replaces the INIT request message of version 1 and 2. See below for more information on INIT.

The server must be in the CONNECTED state to be able to process a HELLO message. For any other states, receipt of an HELLO request must be considered a protocol violation and lead to connection closure.

Clients should send HELLO message to the server immediately after connection and process the corresponding response before using that connection in any other way.

Clients wishing to retry initialization should establish a new connection.

In version 4.1, routing::Dictionary(address::String) was added to indicate an indicator if the server should carry out routing, according to the given routing context.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

In version 5.3, bolt_agent::Dictionary was added to indicate the underlying driver and its version as opposed to the application using the driver in `user_agent.

On versions earlier than 5.1, the authentication token described on the LOGON message should be sent as part of the HELLO message instead.
routing values 	Description

{"routing": null} or {}

the server should not carry out routing

{"routing": {}}

the server should carry out routing

{"routing": {"address": "x.example.com:9001", "region": "example", …​}}

the server should carry out routing according to the given routing context

Signature: 01
Fields:

extra::Dictionary(
scheme::String,
...
user_agent::String,
patch_bolt::List<String>,
routing::Dictionary(address::String),
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>,
bolt_agent::Dictionary(
product::String,
platform::String,
language::String,
language_details::String
)
)

scheme is the authentication scheme, alongside any additional entries (...) specific to the chosen scheme. Predefined schemes are: "none", "basic", "bearer", "kerberos" (depending on the server’s capabilities). See LOGON message for more information. Removed after bolt 5.0

The user_agent should conform to "Name/Version" for example "Example/4.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information). Drivers should allow application code to set this value as it is meant to identify the application using the driver.

patch_bolt lets the driver request a patch to the protocol from the server. The patch must not be applied until the server acknowledges it in the SUCCESS response. Default: []. Introduced in bolt 4.3 Removed after bolt 4.4

    "utc" is currently the only supported patch. If successfully negotiated, server and driver will use DateTime and DateTimeZoneId as defined in Bolt version 5.0.

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string. Setting routing to null indicates that the server should not carry out any routing. Default: null. Introduced in bolt 4.1

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use its configured default. Default: null. Introduced in bolt 5.2

bolt_agent::Dictionary, as opposed to user_agent, is meant to identify the driver rather than the application using it. Drivers should not allow applications to change this value. When populating the fields, drivers should be careful not to include anything that could be used to identify a single machine or user. This field is mandatory. Introduced in bolt 5.3

    product::String should conform to "Name/Version" and identify the driver for example "neo4j-fortran-alice-doe/42.69.0". This field is mandatory.

    platform::String should describe the platform the driver is running on for example "Linux 5.15.0-58-generic; x86_64". Send null (or omit) if no platform information is available. Default: null.

    language::String should conform to "Name/Version" and describe the language the driver/application is written in for example "Fortran/77". Send null (or omit) if no language information is available. Default: null.

    language_details::String can contain further information about the language the driver/application is written in for example compiler, runtime, or interpreter and respective versions. Send null (or omit) if no language details are available. Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

HELLO {extra}

Example 1

HELLO {"user_agent": "Example/4.1.0", "routing": {"address": "x.example.com:9001"}, "bolt_agent": {"product": "neo4j-fortran-alice-doe/42.69.0", "platform": "Linux 5.15.0-58-generic; x86_64", "language": "Fortran/77", "language_details": "gfortran 9.3.0"}}

Example 2

HELLO {"user_agent": "Example/4.2.0", "patch_bolt": ["utc"], "routing": {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"}, "notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata:

server::String (server agent string, example "Neo4j/4.1.0")

connection_id::String (unique identifier of the bolt connection used on the server side, example: "bolt-61")

patch_bolt::List<String> only if the client requested patches in the patch_bolt field of the request. The server will include the subset of requested patches (with the exact same string the client requests) if it supports it. From that point onward, the server-client communication must only use the patched protocol. Introduced in bolt 4.3 Removed after bolt 4.4

hints::Dictionary (set of optional configuration hints to be considered by the driver) Introduced in bolt 4.3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The hints dictionary may contain a set of optional configuration hints which may be interpreted or ignored by drivers at their own discretion in order to augment operations where applicable. A full listing of the available hints may be found in Appendix — Connection hints. Hints remain valid throughout the lifetime of a given connection and cannot be changed. As such, newly established connections may observe different hints and/or hint values as the server configuration is adjusted.
Example

SUCCESS {"server": "Neo4j/4.0.0", "hints": {"connection.recv_timeout_seconds": 120}}

Example 2

SUCCESS {"server": "Neo4j/4.4.0", "patch_bolt": ["utc"], "hints": {"connection.recv_timeout_seconds": 120}}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages. Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1+

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message INIT

Introduced in bolt 1 Removed after bolt 2

The INIT message is a request for the connection to be authorized for use with the remote database.

The request message INIT is only valid in version 1 and 2 and is replaced by the request message HELLO in version 3+.

The INIT message uses the structure signature 01 and passes two fields: user agent (String) and auth_token (Dictionary).

The server must be in the CONNECTED state to be able to process an INIT request. For any other states, receipt of an INIT request must be considered a protocol violation and lead to connection closure.

Clients should send INIT requests to the network immediately after connection and process the corresponding response before using that connection in any other way.

A receiving server may choose to register or otherwise log the user agent but may also ignore it if preferred.

The auth token should be used by the server to determine whether the client is permitted to exchange further messages. If this authentication fails, the server must respond with a FAILURE message and immediately close the connection. Clients wishing to retry initialization should establish a new connection.

Signature: 01
Fields:

user_agent::String,
auth_token::Dictionary(
scheme::String,
principal::String,
credentials::String,
)

The user_agent should conform to "Name/Version" for example "Example/1.1.0" (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent for more information).

The scheme is the authentication scheme. Predefined schemes are "none" and "basic". If no scheme is provided, it defaults to "none".

The auth_token must contain either just the entry {"scheme" : "none"} or the keys scheme, principal and credentials.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid Summary Messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

INIT "user_agent" {auth_token}

Example 1

INIT "Example/1.0.0" {"scheme": "none"}

Example 2

INIT "Example/1.0.0" {"scheme": "basic", "principal": "neo4j", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. Servers can include metadata that describes details of the server environment and/or the connection.

The following fields are defined for inclusion in the SUCCESS metadata.

server::String (server agent string, example "Neo4j/3.4.0")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"server": "Neo4j/3.4.0"}

Server response FAILURE

A FAILURE message response indicates that the client is not permitted to exchange further messages.

Servers may choose to include metadata describing the nature of the failure but must immediately close the connection after the failure has been sent.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message LOGON

Introduced in bolt 5.1

A LOGON message carries an authentication request.

This message is new in version 5.1. In previous versions, authentication was part of the HELLO message.

Signature: 6A
Fields:

auth::Dictionary(
scheme::String,
...
)

The scheme is the authentication scheme. Predefined schemes are none, basic, bearer and kerberos (depending on the server’s capabilities).

Further entries in the message are passed to the implementation of the chosen authentication scheme. Their names, types, and defaults depend on that choice.

    The scheme basic requires a username principal::String and a password credentials::String.

    The scheme bearer merely requires a token credentials::String.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

If authentication fails, the server responds with a FAILURE message and immediately closes the connection.
Examples
Synopsis

LOGON {auth}

Example 1

LOGON {"scheme": "basic", "principal": "user", "credentials": "password"}

Server response SUCCESS

A SUCCESS message response indicates that the client has been successfully authenticated.

The following fields are defined for inclusion in the SUCCESS metadata.

advertised_address::String? - the configured advertised address of the database server. Introduced in bolt 5.8

credentials_expired::Boolean - the sent credentials are expired, the user must update them. If this field is not present, it should be considered to be false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v5.8+

SUCCESS {"advertised_address": "graphz.example.com:7687"}

Example v5.1+

SUCCESS {}

Request message LOGOFF

Introduced in bolt 5.1

A LOGOFF message logs off the currently authenticated user. The connection is then ready for another LOGON message.

This message is new in version 5.1. No equivalent exists in previous versions.

Signature: 6B

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

LOGOFF

Example

LOGOFF

Server response SUCCESS

If a LOGOFF message request has been successfully received, the server should respond with a SUCCESS message and enter the AUTHENTICATION state.
Example

SUCCESS {}

Server response FAILURE

If LOGOFF message is received while the server is not in the READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to LOGOFF should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by a session in the FAILED state."}

Example v5.1+

FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message 'LogoffMessage{}' cannot be handled by session in the READY state", "gql_status": "08N06", "description": "error: connection exception - protocol error. General network protocol error.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}, "cause": {"message": "08N10: Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "gql_status": "08N10", "description": "error: connection exception - invalid server state. Message LogoffMessage{} cannot be handled by session in the 'READY' state.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Request message TELEMETRY

Introduced in bolt 5.4

The TELEMETRY message contains an integer representing which driver API was used.

The telemetry information is stored on the server’s metrics system. The client receives a SUCCESS response, unless it sends an invalid value for the api field, which results in a FAILURE response.

Clients should offer the user the option to disable sending telemetry. Further, the server might opt out of receiving telemetry from the client by sending the corresponding configuration hint in the SUCCESS message of the HELLO message. See Appendix — Connection hints for more information. If the client ignores the hint, the server must still accept the TELEMETRY message.

The message may only be sent in the READY state.

Signature: 54
Fields:

api::Integer

Valid values for api and the corresponding API associations are:

0 — Managed transaction

1 — Explicit transaction

2 — Implicit transaction

3 — Driver-level execute_query()
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

TELEMETRY api

Example 1

TELEMETRY 0

Server response SUCCESS

If a TELEMETRY message request is successfully received, the server responds with a SUCCESS and remains in its current state.
Example

SUCCESS {}

Server response FAILURE

If a TELEMETRY message contains a value that is not a valid api value or is sent in the wrong state, the server responds with a FAILURE message and enters the FAILED state.
Example 1 v5.7+

C: TELEMETRY 2
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state.", "gql_status": "50N42", "description": "error: general processing exception - unexpected error. Unexpected error has occurred. See debug log for details."}

Example 1 v5.4+

C: TELEMETRY 2
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Message of type TelemetryMessage cannot be handled by a session in the NEGOTIATION state."}

Example 2 v5.7+

C: TELEMETRY "oh no!"
S: FAILURE {"neo4j_code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING", "gql_status": "22G03", "description": "error: data exception - invalid value type", "cause": {"message": "22N01: Expected the value 128 to be of type INT, but was of type STRING.", "gql_status": "22N01", "description": "error: data exception - invalid type. Expected the value 128 to be of type INT, but was of type STRING.", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}}

Example 2 v5.4+

C: TELEMETRY "oh no!"
S: FAILURE {"code": "Neo.ClientError.Request.Invalid", "message": "Unexpected type: Expected INT but got STRING"}

Example 3 v5.7+

C: TELEMETRY 9001
S: FAILURE {"neo4j_code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "gql_status": "50N00", "description": "error: general processing exception - internal error. Internal exception raised DecoderException: org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001", "cause": {"message": "50N09: The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "gql_status": "50N09", "description": "error: general processing exception - invalid server state transition. The server transitioned into a server state that is not valid in the current context: 'uncaught error'.", "diagnostic_record": {"_classification": "DATABASE_ERROR"}}}

Example 3 v5.4+

C: TELEMETRY 9001
S: FAILURE {"code": "Neo.DatabaseError.General.UnknownError", "message": "org.neo4j.packstream.error.reader.PackstreamReaderException: Unknown driver interface type 9001"}

Request message GOODBYE

Introduced in bolt 3

The GOODBYE message notifies the server that the connection is terminating gracefully. On receipt of this message, the server should immediately shut down the socket on its side without sending a response.

A client may shut down the socket at any time after sending the GOODBYE message. This message interrupts the server current work if there is any.

Signature: 02

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

No summary messages should be returned.
Examples
Synopsis

GOODBYE

Example

GOODBYE

Request message ACK_FAILURE

Introduced in bolt 1 Removed after bolt 2

The request message ACK_FAILURE signals to the server that the client has acknowledged a previous failure and should return to a READY state.

The request message ACK_FAILURE is only valid in version 1 and 2 and the request message RESET should be used in its place in version 3+.

Signature: 0E

Fields: No fields.

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a FAILED state to be able to successfully process an ACK_FAILURE request. For any other states, receipt of an ACK_FAILURE request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

ACK_FAILURE

Example

ACK_FAILURE

Server response SUCCESS

If an ACK_FAILURE request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.

The server may attach metadata to the SUCCESS message.
Example

SUCCESS {}

Server response message FAILURE

If an ACK_FAILURE request is received while not in the FAILED state, the server should respond with a FAILURE message and immediately close the connection.

The server may attach metadata to the message to provide more detail on the nature of the failure.
Example

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RESET

Introduced in bolt 1

The RESET message requests that the connection should be set back to its initial RESET state, as if a HELLO (INIT in v1 and v2) (and a LOGON in v5.1+) had just successfully completed. The RESET message is unique in that, on arrival at the server, it jumps ahead in the message queue, stopping any unit of work that happens to be executing. All the queued messages originally in front of the RESET message will then be IGNORED until the RESET position is reached. Then from this point, the server state is reset to a state that is ready for a new session.

In version 1 and 2, the RESET message splits into two separate signals. First, an <INTERRUPT> signal jumps ahead in the message queue, stopping any unit of work that happens to be executing, and putting the state machine into an INTERRUPTED state. Second, the RESET queues along with all other incoming messages and is used to put the state machine back to READY when its turn for processing arrives. This essentially means that the INTERRUPTED state exists only transitionally between the arrival of a RESET in the message queue and the later processing of that RESET in its proper position. The INTERRUPTED state is therefore the only state to automatically resolve without any further input from the client and whose entry does not generate a response message.

Signature: 0F

Fields: No fields

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

RESET

Example

RESET

Server response SUCCESS

If a RESET message request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example

SUCCESS {}

Server response FAILURE

If RESET message is received before the server enters a READY state, it should trigger a FAILURE followed by immediate closure of the connection. The server may attach metadata to the message to provide more detail on the nature of the failure. Clients receiving a FAILURE in response to RESET should treat that connection as DEFUNCT and dispose of it.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1-v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message RUN

Introduced in bolt 1

The RUN message requests that a Cypher query is executed with a set of parameters and additional extra data.

In version 3+, this message can both be used in an Explicit Transaction or an Auto-commit Transaction. The transaction type is implied by the message sequence:

Explicit Transaction: RUN while inside a transaction context started with BEGIN first.

Auto-commit Transaction: RUN without having started an explicit transaction with BEGIN first.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 10
Fields:

query::String,
parameters::Dictionary,
extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The query can be any Cypher query (including a procedure call).

The parameters is a dictionary of parameters to be used in the query string.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

An Explicit Transaction (BEGIN+RUN) does not carry any data in the extra field.

For Auto-commit Transaction (RUN) the extra field carries:

extra contains additional options. Introduced in bolt 3

    The bookmarks is a list of strings containing some kind of bookmark identification, e.g., ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

    The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

    The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

    The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Default: "w".

    The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

    The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

    The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

    The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The server must be in a READY or READY_TX (v3+) state to be able to successfully process a RUN request. If the server is in a FAILED or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a RUN request will be considered a protocol violation and will lead to connection closure.
Examples
Synopsis

RUN "query" {parameters} {extra}

Example 1

RUN "RETURN $x AS x" {"x": 1} {"bookmarks": [], "tx_timeout": 123, "tx_metadata": {"log": "example_message"}, "mode": "r"}

Example 2

RUN "RETURN $x AS x" {"x": 1} {}

Example 3

RUN "CALL dbms.procedures()" {} {}

Example 3

RUN "RETURN 42" {} {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages.

The following fields are defined for inclusion in the SUCCESS metadata.

fields::List<String>, the fields of the return result. e.g. [“name”, “age”, …]

t_first::Integer, the time, specified in ms, which the first record in the result stream is available after.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Implicit Transaction (RUN):

db::String? - resolved user’s home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For Explicit Transaction (BEGIN+RUN):

qid::Integer specifies the server assigned statement ID to reference the server side result-set with commencing BEGIN`RUN`PULL and BEGIN`RUN`DISCARD messages. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.0+

SUCCESS {"fields": ["x"], "t_first": 123, "qid": 7000}

Example v3+

SUCCESS {"fields": ["x"], "t_first": 123}

For v1 and v2, if a RUN request has been successfully received and is considered valid by the server, the server should respond with a SUCCESS message and enter the STREAMING state. The server may attach metadata to the message to provide header detail for the results that follow. Clients should not consider a SUCCESS response to indicate completion of the execution of that query, merely acceptance of it. The following fields are defined for inclusion in the metadata:

`fields` (e.g. ["name", "age"])

`result_available_after` (e.g. 123)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v1 and v2

SUCCESS {"fields": ["x"], "result_available_after": 123}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message DISCARD

Introduced in bolt 1

The DISCARD message requests that the remainder of the result stream should be thrown away.

In v1, v2 and v3, this message is called DISCARD_ALL, has no fields and issues a request to discard the outstanding result and return to a READY state. A receiving server should not abort the request but continue to process it without streaming any detail messages back to the client.

Signature: 2F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to throw away. n=-1 will throw away all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

DISCARD {extra}

Example 1

DISCARD {"n": -1, "qid": -1}

Example 2

DISCARD {"n": 1000}

Example 3 v1, v2 or v3

DISCARD_ALL

In version 1 and 2, the server must be in a STREAMING or STREAMING_TX (v3+) state to be able to successfully process a DISCARD request. If the server is in a FAILED state or INTERRUPTED state, the request will be IGNORED. For any other states, receipt of a DISCARD request will be considered a protocol violation and will lead to connection closure.
Server response SUCCESS

has_more::Boolean, true if there are no more records to stream. If this field is not present, it should be considered to default to false. Introduced in bolt 4.0
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::String — the bookmark after committing this transaction (Autocommit Transaction only).

db::String — the database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary> — a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Introduced in bolt 3 Removed after bolt 5.4

statuses::List<Dictionary> — a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionary — plan result. Introduced in bolt 3

profile::Dictionary — profile result. Introduced in bolt 3

result_consumed_after::Integer — same as t_last. Removed after bolt 2

result_available_after::Integer — same as t_first. Removed after bolt 2

stats::Dictionary — counter information, such as db-hits etc. Introduced in bolt 3

t_last::Integer — the time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integer — the time (in ms) after which the DBMS was ready to stream the first record in the result. Introduced in bolt 3

type::String — the type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example 1 v4+

SUCCESS {"has_more": true}

Example 2 v4+

SUCCESS {"bookmark": "example-bookmark:1", "db": "example_database"}

Example v3

SUCCESS {"bookmark": "example-bookmark:1"}

In version 1 and 2, if a DISCARD_ALL request has been successfully received, the server should respond with a SUCCESS message and enter the READY state.
Example v1 and v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Request message PULL

The PULL message requests data from the remainder of the result stream.

In v1, v2, and v3, this message is called PULL_ALL and has no fields. In v1 and v2, this message issues a request to stream the outstanding result back to the client, before returning to a READY state. Result detail consists of zero or more detail messages being sent before the summary message. This version of the protocol defines one such detail message, namely RECORD (described below).

Signature: 3F
Fields:

extra::Dictionary(
n::Integer,
qid::Integer
)

extra contains additional options. Introduced in bolt 4.0

    The n specifies how many records to fetch. n=-1 will fetch all records. n has no default and must be present.

    The qid (query identification) specifies for which statement the operation should be carried out (Explicit Transaction only). qid=-1 can be used to denote the last executed statement. Default: -1.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

Zero or more RECORD.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

PULL {extra}

Synopsis v1 - v3

PULL_ALL

Example 1

PULL {"n": -1, "qid": -1}

Example 2

PULL {"n": 1000}

Example v1 - v3

PULL_ALL

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

has_more::Boolean, true if there are more records to stream. If this field is not present it should be considered to default to false.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Or in the case that has_more is false:

bookmark::String — the bookmark after committing this transaction (Autocommit Transaction only).

db::String — the database name where the query was executed. Introduced in bolt 4.0

notifications::List<Dictionary> — a list of all notifications generated during execution of this statement. May be omitted if no notifications exist. In v3, this field is notifications::Dictionary. Removed after bolt 5.4

statuses::List<Dictionary> — a list of all gqlStatusObjects generated during execution of this statement. Introduced in bolt 5.6

plan::Dictionary — plan result. Introduced in bolt 3

profile::Dictionary — profile result. Introduced in bolt 3

result_consumed_after::Integer — same as t_last. Removed after bolt 2

result_available_after::Integer — same as t_first. Removed after bolt 2

stats::Dictionary — counter information, such as db-hits etc. Introduced in bolt 3

t_last::Integer — the time (in ms) after which the last record in the result stream is consumed. Introduced in bolt 3

t_first::Integer — the time (in ms) after which the first record in the result stream is available. Introduced in bolt 3

type::String — the type of the statement, e.g. "r" for read-only statement, "w" for write-only statement, "rw" for read-and-write, and "s" for schema only. Introduced in bolt 3
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v3+

SUCCESS {"bookmark": "example-bookmark:1", "t_last": 123}

Example v1 - v2

SUCCESS {"bookmark": "example_bookmark_identifier", "result_consumed_after": 123}

Server response IGNORED

For v1 and v2, a server that receives a PULL_ALL request while in FAILED state or INTERRUPTED state, should respond with an IGNORED message and discard the request without processing it. No state change should occur.
Example

IGNORED

Server response FAILURE

For v1 and v2, a PULL_ALL message request cannot be processed successfully, the server should respond with a FAILURE message and enter the FAILED state. The server may attach metadata to the message to provide more detail on the nature of the failure.
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Server response RECORD (in v1 and v2)

Zero or more RECORD messages may be returned in response to a PULL_ALL prior to the trailing summary message. Each record carries with it a list of values which form the data content of the record. The order of the values within the list should be meaningful to the client, perhaps based on a requested ordering for that result, but no guarantees should be made around the order of records within the result. A record should only be considered valid if followed by a SUCCESS summary message. Until this summary has been received, the record’s validity should be considered tentative.
Example

RECORD [1, 2, 3]

Request massage BEGIN

Introduced in bolt 1

The BEGIN message request the creation of a new Explicit Transaction. This message should then be followed by a RUN message. The Explicit Transaction is closed with either the COMMIT message or ROLLBACK message.

In version 5.2, notifications_minimum_severity::String and notifications_disabled_categories::List<String> were added to be able to control the notification config. Disabling categories or severities allows the server to skip analysis for those, which can speed up query execution.

Signature: 11
Fields:

extra::Dictionary(
bookmarks::List<String>,
tx_timeout::Integer,
tx_metadata::Dictionary,
mode::String,
db::String,
imp_user::String,
notifications_minimum_severity::String,
notifications_disabled_categories::List<String>
)

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"]. Default: [].

The tx_timeout is an integer in that specifies a transaction timeout in ms. Default: server-side configured timeout.

The tx_metadata is a dictionary that can contain some metadata information, mainly used for logging. Default: null.

The mode specifies what kind of server the RUN message is targeting. For write access use "w" and for read access use "r". Defaults to write access if no mode is sent. Default: "w".

The db specifies the database name for multi-database to select where the transaction takes place. null and "" denote the server-side configured default database. Default: null. Introduced in bolt 4.0

The imp_user key specifies the impersonated user which executes this transaction. null denotes no impersonation (execution takes place as the current user). Default: null. Introduced in bolt 4.4

The notifications_minimum_severity specifies the minimum severity a notification needs to have to be returned. Please see the Status Codes → Server notification grouping and filtering for acceptable entries, with the special value "OFF" added to the protocol, which disables all notifications. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2

The notifications_disabled_categories is a list of notification categories that will not be returned. Please see Status Codes → Server notification grouping and filtering for available categories. Sending null will make the server use whatever was specified in the HELLO message of the current connection. Default: null. Introduced in bolt 5.2
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

BEGIN {extra}

Example 1

BEGIN {"tx_timeout": 123, "mode": "r", "db": "example_database", "tx_metadata": {"log": "example_log_data"}, "imp_user" : "bob"}

Example 2

BEGIN {"db": "example_database", "tx_metadata": {"log": "example_log_data"}, "bookmarks": ["example-bookmark:1", "example-bookmark2"]}

Example 3

BEGIN {"notifications_minimum_severity": "WARNING", "notifications_disabled_categories": ["HINT", "GENERIC"]}

Server response SUCCESS

The following fields are defined for inclusion in the SUCCESS metadata:

db::String? - resolved user’s home database that the transaction will run into. The field is only present if the client did not explicitly provide a database to start the transaction for. Introduced in bolt 5.8
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {}

Example with Home Database Resolution

SUCCESS {"db": "my_home_db"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message COMMIT

The COMMIT message request that the Explicit Transaction is done.

The COMMIT message does not exist in v1 and v2.

Signature: 12

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

COMMIT

Example

COMMIT

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was completed:

bookmark::String, the bookmark after committing this transaction.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example

SUCCESS {"bookmark": "example-bookmark:1"}

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROLLBACK

The ROLLBACK message requests that the Explicit Transaction rolls back.

The ROLLBACK message does not exist in v1 and v2.

Signature: 13

Fields: No fields.

Detail messages:

No detail messages.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROLLBACK

Example

ROLLBACK

Server response SUCCESS

A SUCCESS message response indicates that the Explicit Transaction was rolled back.
Example

SUCCESS

Server response IGNORED
Example

IGNORED

Server response FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Request message ROUTE

Introduced in bolt 4.3

The ROUTE instructs the server to return the current routing table. In previous versions there was no explicit message for this and a procedure had to be invoked using Cypher through the RUN and PULL messages.

This message can only be sent after successful authentication and outside of transactions.

Signature: 66
Fields:

routing::Dictionary,
bookmarks::List<String>,
db::String,
extra::Dictionary(
db::String,
imp_user::String,
)

Note that in v4.4, the db parameter is migrated into a dedicated dictionary named extra that also includes the imp_user and thus, in v4.3 the fields are:

routing::Dictionary,
bookmarks::List<String>,
db::String

The routing field should contain routing context information and the address field that should contain the address that the client initially tries to connect with e.g. "x.example.com:9001". Key-value entries in the routing context should correspond exactly to those in the original URI query string.

The bookmarks is a list of strings containing some kind of bookmark identification e.g ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"].

The db specifies the database name for multi-database to select where the transaction takes place. null denotes the server-side configured default database. Removed after bolt 4.3

extra contains additional options. Introduced in bolt 4.4

    db as above. Default: null.

    The imp_user specifies the impersonated user for the purposes of resolving their home database. null denotes no impersonation (execution takes place as the current user). Default: null.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Detail messages:

No detail messages should be returned.

Valid summary messages:

SUCCESS

IGNORED

FAILURE
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

ROUTE {routing} [bookmarks] {extra}

Example v4.4+

ROUTE {"address": "x.example.com:9001", "policy": "example_policy_routing_context", "region": "example_region_routing_context"} ["neo4j-bookmark-transaction:1", "neo4j-bookmark-transaction:2"] {"db": "example_database", "imp_user": "bob"}

Example v4.3

ROUTE {"address": "x.example.com:7687"} [] null

Server response SUCCESS

A SUCCESS message response indicates that the client is permitted to exchange further messages. The following fields are defined for inclusion in the SUCCESS metadata:

rt::Dictionary(ttl::Integer, db::String, servers::List<Dictionary(addresses::List<String>, role::String)>), the current routing table.

    ttl::Integer specifies for how many seconds this routing table should be considered valid.

    db::String identifies the database for which this routing table applies. Introduced in bolt 4.4

    servers have three elements of the type Dictionary(addresses::List<String>, role::String), where role is one of "ROUTE", "READ", "WRITE" for exactly one entry each.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Example v4.4+

SUCCESS {
"rt": {"ttl": 1000,
"db": "foo",
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Example v4.3

SUCCESS {
"rt": {"ttl": 1000,
"servers": [{"addresses": ["localhost:9001"], "role": "ROUTE"},
{"addresses": ["localhost:9010", "localhost:9012"], "role": "READ"},
{"addresses": ["localhost:9020", "localhost:9022"], "role": "WRITE"}]}
}

Server message IGNORED
Example

IGNORED

Server message FAILURE
Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v4.3 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Summary message SUCCESS

The SUCCESS message indicates that the corresponding request has succeeded as intended. It may contain metadata relating to the outcome. Metadata keys are described in the section of this document relating to the message that began the exchange.

Signature: 70
Fields:

metadata::Dictionary

Examples
Synopsis

SUCCESS {metadata}

Example

SUCCESS {"example": "see specific message for server response metadata"}

Summary message IGNORED

The IGNORED message indicates that the corresponding request has not been carried out.

Signature: 7E

Fields: No fields.
Examples
Synopsis

IGNORED

Example

IGNORED

Summary message FAILURE

Signature: 7F
Fields:

metadata::Dictionary

The following fields are defined in the metadata:

message::String - the human readable description of the failure.

code::String - the neo4j code identifying the failure. Removed after bolt 5.6

neo4j_code::String - the neo4j code identifying the failure. Introduced in bolt 5.7

gql_status::String - the GQL status which identifies the error. This should be used in favor of neo4j_code. See more about GQL-status notification object. Introduced in bolt 5.7

description::String - describes the failure represented by gql_status. Introduced in bolt 5.7

diagnostic_record::Dictionary - contains fields for helping diagnosing the status. Omitted when content is default. Introduced in bolt 5.7

    OPERATION::String - GQL standard field. Default: ""

    OPERATION_CODE::String - GQL standard field. Default: "0"

    CURRENT_SCHEMA::String - GQL standard field. Default: "/"

    _classification::String? - classifies the failure.

cause:Dictionary(message::String, gql_status::String, description::String, diagnostic_record::Dictionary, cause::Dictionary?)? - the inner cause of the error. This fields provides more specific details and context about the failure. Introduced in bolt 5.7

The diagnostic_record field can contain extra and undocumented entries. This information can be important for diagnosing failures.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Examples
Synopsis

FAILURE {metadata}

Example v5.7+

FAILURE {"gql_status": "01N00", "message": "old message you have failed something", "description": "default condition - default subcondition. Message", "neo4j_code": "Example.Failure.Code", "diagnostic_record": {"_classification": "CLIENT_ERROR"}}

Example v1 - v5.6

FAILURE {"code": "Example.Failure.Code", "message": "example failure"}

Detail message RECORD

A RECORD message carries a sequence of values corresponding to a single entry in a result.

Signature: 71

These messages are currently only ever received in response to a PULL (PULL_ALL in v1, v2, and v3) message and will always be followed by a summary message.
Examples
Synopsis

RECORD [data]

Example 1

RECORD ["1", "2", "3"]

Example 2

RECORD [{"point": [1, 2]}, "example_data", 123]

Summary of changes per version

The sections below list the changes of messages compared to the previous version. Please also check for changes in Structure Semantics.
Version 5.8

Introduce connection hint ssr.enabled

Introduce advertised_address as response metadata of LOGON

SUCCESS message of begin transaction messages (BEGIN or RUN) contains resolved home database as db.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.7

FAILURE message was changed to have gql_status, description, diagnostic_record and cause. code was renamed to neo4j_code.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.6

SUCCESS messages that contain a notifications field were changed to have a field statuses instead.

    SUCCESS on PULL

    SUCCESS on DISCARD
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.5

Unsupported (and undocumented 😏) protocol version

Version 5.5 was only ever released in some drivers, but has a flawed design. No Neo4j server will negotiate this protocol version.
Version 5.4

A new message TELEMETRY is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.3

A new field bolt_agent is added to the HELLO message’s extra dictionary.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.2

HELLO, BEGIN and RUN messages now accept notifications options notifications_minimum_severity and notifications_disabled_categories.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.1

HELLO message no longer accepts authentication.

LOGON message has been added and accepts authentication.

LOGOFF message has been added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5

No changes from version 4.4
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.4

The db parameter within the ROUTE message is migrated into a dedicated dictionary named extra.

An imp_user parameter is added to the meta fields within ROUTE, RUN and BEGIN messages respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.3

NOOP chunks may now be transmitted in all connection states when a connection remains in idle for extended periods of time while the server is busy processing a request.

An additional hints dictionary is added to the metadata property of the SUCCESS structure transmitted in response to the HELLO command in order to provide optional configuration hints to drivers.

A new message ROUTE to query the routing table is added.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

The HELLO message, defines the sub-field routing::Dictionary(address::String) to indicate if server side routing should be performed and can include routing context data.

Support for NOOP chunk (empty chunk). Both server and client should support this.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.0

DISCARD_ALL message renamed to DISCARD and introduced new fields.

PULL_ALL message renamed to PULL and introduced new fields.

The BEGIN message now have a field db::String to specify a database name.

The RUN message now have a field db::String to specify a database name.

Explicit Transaction (BEGIN+RUN) can now get a server response with a SUCCESS and metadata key qid (query identification).

The DISCARD message can now discard an arbitrary number of records. New fields n and qid.

The DISCARD message can now get a server response with a SUCCESS and metadata key has_more.

The PULL message can now fetch an arbitrary number of records. New fields n and qid.

The PULL message can now get a server response with a SUCCESS and metadata key has_more.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 3

The INIT request message is replaced with HELLO message.

The ACK_FAILURE request message is removed. Use RESET message instead.

Added extra::Dictionary field to RUN message.

Added extra::Dictionary field to BEGIN message.

New HELLO request message.

New GOODBYE request message.

New BEGIN request message.

New COMMIT request message.

New ROLLBACK request message.

New RESET request message.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

Byte values are represented using hexadecimal notation unless otherwise specified.
Endianness

Bolt requires that all values that can vary by endianness should be transmitted using network byte order, also known as big-endian byte order. This means that the most significant part of the value is written to the network or memory space first and the least significant part is written last.
Connection and disconnection

Bolt communication is intended to take place over a TCP connection. The default port is TCP 7687 but any port can be used.

There is no formal shutdown procedure for a Bolt connection. Either peer may close the connection at TCP level at any time. Both client and server should be prepared for that to occur and should handle it appropriately.
Handshake

Immediately following a successful connection, the client MUST initiate a handshake. This handshake is a fixed exchange used to determine the version of messaging protocol that follows.
Bolt identification

The first part of the handshake is used to identify to the server that this is a Bolt connection. It should be sent by a client immediately following the establishment of a successful connection and does not require a server response.

The identification consists of the following four bytes:

C: 60 60 B0 17

Version negotiation

After identification, a small client-server exchange occurs to determine which version of the messaging protocol to use. In this, the client submits exactly four protocol versions, each encoded as a big-endian 32-bit unsigned integer for a total of 128 bits. Protocol version zero can be used as a placeholder if fewer than four versions are required in the exchange. Should a match be found for a version supported by the server, the response will contain that version encoded as a single 32-bit integer. If no match is found, a zero value is returned followed by immediate closure of the connection by the server.

Within this exchange, a zero value (four zero bytes) always represents “no protocol version”. For the client, this can be used as a filler if fewer than four protocol versions are known. For the server, this indicates no version match has been found.

A server should assume that the versions contained within a client’s request have been sent in order of preference. Therefore, if a match occurs for more than one version, the first match should be selected.
Example where the client is aware of the Bolt protocol version 1 and the server responds with version 1.

C: 60 60 B0 17
C: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 01

Example where the client is aware of the Bolt protocol versions 1 and 2, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol versions 1, 2 and 3, and the server responds with version 2.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 02 00 00 00 01 00 00 00 00
S: 00 00 00 02

Example where the client is aware of the Bolt protocol version 3 but the server responds with no version, the server do not support communication with the client.

C: 60 60 B0 17
C: 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00 00
S: 00 00 00 00

Bolt version 4.3

With Bolt version 4.3, the version scheme supports ranges of minor versions. The first 8 bits are reserved. The next 8 bits represent the number of consecutive minor versions below the specified minor (next 8 bits) and major (next 8 bits) version that are supported.

The range cannot span multiple major versions.
Example with versions 4.3 plus two previous minor versions, 4.2 and 4.1

00 02 03 04

Example where the client is aware of five Bolt versions; 3, 4.0, 4.1, 4.2 and 4.3, and the server responds with 4.1

C: 60 60 B0 17
C: 00 03 03 04 00 00 01 04 00 00 00 04 00 00 00 03
S: 00 00 01 04

The client has to specify all versions prior to 4.3 explicitly since servers that only support those protocol versions might not support ranges. The example makes use of the fact that Bolt 4.1 and 4.2 are equivalent and only offer 4.3, 4.2, 4.0, and 3, but specify a range (4.3-4.0), in case the server supports ranges.
Bolt version 4.0

With Bolt version 4.0 the version scheme supports major and minor versioning number. The first 16 bits are reserved. 8 bits represents the minor version. 8 bits represents the major version.
Example with version 4.1

00 00 01 04

Example where the client is aware of three Bolt versions; 3, 4.0 and 4.1, and the server responds with 4.1.

C: 60 60 B0 17
C: 00 00 01 04 00 00 00 04 00 00 00 03 00 00 00 00
S: 00 00 01 04

Structure Semantics

While PackStream defines what a Structure looks like, it does not define what it means. The semantics of Structures are bound to the Bolt Protocol version.

The table below lists the PackStream specified structures and their code and tag byte across all currently existing Bolt Protocol versions.
Structures
Structure name 	Code 	tag byte

Node

N

4E

Relationship

R

52

UnboundRelationship

r

72

Path

P

50

Date

D

44

Time

T

54

LocalTime

t

74

DateTime

I

49

DateTimeZoneId

i

69

LocalDateTime

d

64

Duration

E

45

Point2D

X

58

Point3D

Y

59

Legacy Structures

Legacy DateTime

F

46

Legacy DateTimeZoneId

f

66
Node

A snapshot of a node within a graph database.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 4E

Number of fields: 4 (3 before version 5.0)

Node::Structure(
id::Integer,
labels::List<String>,
properties::Dictionary,
element_id::String,
)

Example of a node structure

Node(
id = 3,
labels = ["Example", "Node"],
properties = {"name": "example"},
element_id = "abc123",
)

B4 4E
...

Relationship

A snapshot of a relationship within a graph database.

The fields element_id, start_node_element_id, and end_node_element_id were added with version 5.0 and do not exist in earlier versions.

tag byte: 52

Number of fields: 8 (5 before version 5.0)

Relationship::Structure(
id::Integer,
startNodeId::Integer,
endNodeId::Integer,
type::String,
properties::Dictionary,
element_id::String,
start_node_element_id::String,
end_node_element_id::String,
)

Example of a relationship structure

Relationship(
id = 11,
startNodeId = 2,
endNodeId = 3,
type = "KNOWS",
properties = {"name": "example"},
element_id = "abc123",
start_node_element_id = "def456",
end_node_element_id = "ghi789",
)

B8 52
...

UnboundRelationship

A relationship without start or end node ID. It is used internally for Path serialization.

The element_id field was added with version 5.0 and does not exist in earlier versions.

tag byte: 72

Number of fields: 4 (3 before version 5.0)

UnboundRelationship::Structure(
id::Integer,
type::String,
properties::Dictionary,
element_id::String,
)

Example of unbound relationship structure

UnboundRelationship(
id = 17,
type = "KNOWS",
properties = {"name": "example"},
element_id = "foo"
)

B4 72
...

Path

An alternating sequence of nodes and relationships.

tag byte: 50

Number of fields: 3

Path::Structure(
nodes::List<Node>,
rels::List<UnboundRelationship>,
indices::List<Integer>,
)

Where the nodes field contains a list of nodes and the rels field is a list of unbound relationships. The indices are a list of integers describing how to construct the path from nodes and rels. The first node in nodes is always the first node in the path and is not referenced in indices. indices always has an even number of entries. The 1st, 3rd, …​ entry in indices refers to an entry in rels (1-indexed), for example, a 3 would refer to the 3rd element of rels. The number can also be negative which should be treated like the positive equivalent, except for denoting the relationship in the inverse direction. The number is never 0. The 2nd, 4th, …​ entry in indices refers to an entry in nodes (0-indexed), for example, a 3 would refer to the 4th element of nodes. The number is always ≥ 0.
Example (simplified notation for <Node> and <UnboundRelationship>)

Path::Structure(
nodes: [Node::Structure(42, ...), Node::Structure(69, ...), Node::Structure(1, ...)],
rels: [UnboundRelationship::Structure(1000, ...), UnboundRelationship::Structure(1001, ...)],
indices: [1, 1, 1, 0, -2, 2],

This represents the path (42)-[1000]→(69)-[1000]→(42)←[1001]-(1), where (n) denotes a node with id n and [n] a relationship with id n (→ or ← denotes the direction of each relationship).
Date

A date without a time-zone in the ISO-8601 calendar system, e.g. 2007-12-03.

tag byte: 44

Number of fields: 1

Date::Structure(
days::Integer,
)

Where the days are days since Unix epoch. 0 for example represents 1970-01-01 while 1 represents 1970-01-02.
Time

An instant capturing the time of day, and the timezone, but not the date.

tag byte: 54

Number of fields: 2

Time::Structure(
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight (this time is not UTC) and the tz_offset_seconds are an offset in seconds from UTC.
LocalTime

An instant capturing the time of day, but neither the date nor the time zone.

tag byte: 74

Number of fields: 1

LocalTime::Structure(
nanoseconds::Integer,
)

Where the nanoseconds are nanoseconds since midnight.
DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure is new in version 5.0. It replaces Legacy DateTime and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 49

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_offset_seconds specifies the offset in seconds from UTC.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+01:00 can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00.000000042+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure is new in version 5.0. It replaces Legacy DateTimeZoneId and fixes a bug in certain edge-cases. Version 4.4 also allows for usage of the fixed structure, if server and client negotiate its usage (see HELLO message).

tag byte: 69

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The seconds and nanoseconds are the time since Unix epoch, often referred as a Unix timestamp.

The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).

The tz_id specifies the timezone name as understood by the timezone database.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00.000000042+0100[Europe/Paris] can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3_600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00.000000042Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4_500 seconds.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 4500
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens in reverse:

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp (4500 seconds and 42 nanoseconds), giving 1970-01-01T01:15:00.000000042Z

localize the resulting UTC DateTime to the timezone specified by tz_id, giving 1970-01-01T02:15:00.000000042+0100[Europe/Paris]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

LocalDateTime

An instant capturing the date and the time but not the time zone.

tag byte: 64

Number of fields: 2

LocalDateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
)

Where the seconds are seconds since the Unix epoch.
Duration

A temporal amount. This captures the difference in time between two instants. It only captures the amount of time between two instants, it does not capture a start time and end time. A unit capturing the start time and end time would be a Time Interval and is out of scope for this proposal.

A duration can be negative.

tag byte: 45

Number of fields: 4

Duration::Structure(
months::Integer,
days::Integer,
seconds::Integer,
nanoseconds::Integer,
)

Point2D

A representation of a single location in 2-dimensional space.

tag byte: 58

Number of fields: 3

Point2D::Structure(
srid::Integer,
x::Float,
y::Float,
)

Where the srid is a Spatial Reference System Identifier.
Point3D

A representation of a single location in 3-dimensional space.

tag byte: 59

Number of fields: 4

Point3D::Structure(
srid::Integer,
x::Float,
y::Float,
z::Float,
)

Where the srid is a Spatial Reference System Identifier.
Legacy Structures
Legacy DateTime

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone offset.

This structure got removed in version 5.0 in favor of DateTime.

tag byte: 46

Number of fields: 3

DateTime::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_offset_seconds::Integer,
)

The tz_offset_seconds specifies the offset in seconds from UTC.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the above offset.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+01:00 (and 42 nanoseconds) can be implemented as follows:

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_offset_seconds: 3600
}

The deserialization of such a DateTime structure expectedly happens in reverse:

remove the offset from the seconds field, which gives here 8100

instantiate the idiomatic equivalent of DateTime based on that Unix timestamp, giving 1970-01-01T01:15:00Z

localize the resulting UTC DateTime to the timezone of the specified offset, giving 1970-01-01T02:15:00+0100
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Legacy DateTimeZoneId

An instant capturing the date, the time, and the time zone. The time zone information is specified with a zone identifier.

This structure got removed in version 5.0 in favor of DateTimeZoneId.

tag byte: 66

Number of fields: 3

DateTimeZoneId::Structure(
seconds::Integer,
nanoseconds::Integer,
tz_id::String,
)

The tz_id specifies the timezone name as understood by the timezone database.

The seconds elapsed since the Unix epoch, often referred as a Unix timestamp, added to the offset derived from the named timezone and specified the point in time.

The nanoseconds are what remains after the last second of the DateTime. The amount of nanoseconds ranges from 0 to 999_999_999 (_ separator added here and later for clarity).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

For instance, the serialization of the point in time denoted as 1970-01-01T02:15:00+0100[Europe/Paris] (and 42 nanoseconds) can be implemented as follows:

retrieve the offset of the named timezone for that point in time, here +1 hour, i.e. 3600 seconds.

compute the UTC time, i.e. 1970-01-01T01:15:00Z (Z denotes UTC).

compute the difference between that UTC time and the Unix epoch, which is 1h15, i.e. 4500 seconds.

add the resolved offset of +1 hour, i.e. 3600 seconds, to the above difference, which yields 8100 (4500 + 3600).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The resulting DateTime instance is therefore as follows:

{
seconds: 8100
nanoseconds: 42,
tz_id: "Europe/Paris"
}

The deserialization of such a DateTime structure happens as follows:

instantiate the idiomatic equivalent of DateTime assuming the seconds denote a Unix timestamp, giving 1970-01-01T02:15:00Z.

set the timezone of the resulting instance, without changing the date/time components, giving 1970-01-01T02:15:00+0100[Europe/Paris] (this may lead to ambiguities, refer to the Known Limitations section below for more information).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Known Limitations
Accuracy

The resolution of offsets for a given time zone name and point in time is bound to the accuracy of the underlying timezone database. In particular, time zones before 1970 are not as well specified. Moreover, the offset resolution likely occurs both on the Bolt client side and Bolt server side. They each rely on a different timezone database. If these copies are not in sync, it could lead to unwanted discrepancies. In such a situation, either server or client could:

reject a timezone name deemed valid by the other party.

resolve different offsets for the same time zone and DateTimeZoneId.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Time Shifts

Note: these issues have been resolved with the introduction of DateTimeZoneId in version 5.0.

Not all instances of DateTimeZoneId map to a single valid point in time.

During time shifts like going from 2AM to 3AM in a given day and timezone, 2:30AM e.g. does not happen.

Similarly, when going from 3AM to 2AM in a given day and timezone, 2:30AM happens twice.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In the first case, a DateTimeZoneId specifying a time between 2AM and 3AM does not correspond to any actual points in time for that timezone and is invalid.

In the second case, all points in the time between 2AM and 3AM exist twice, but with a different offset. Therefore, the timezone name is not sufficient to resolve the ambiguity, the timezone offset is also needed. Since DateTimeZoneId does not include the timezone offset, the resolution of these particular datetimes is undefined behavior.
Summary of changes per version

The sections below list the changes of structure semantics in versions where they changed. Please also check for changes in Bolt Messages.
Version 5.0

The element_id field was added to Node.

The fields element_id, start_node_element_id, and end_node_element_id were added to Relationship.

The element_id field was added to UnboundRelationship.

Replaced Legacy DateTime and Legacy DateTimeZoneId with DateTime and DateTimeZoneId respectively.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Bolt Protocol server state specification

For the server, each connection using the Bolt Protocol will occupy one of several states throughout its lifetime.

This state is used to determine what actions may be undertaken by the client. Each server state specification corresponds to a message specification with the same version.

For a summary of all available server state transitions in each version of the Bolt Protocol, see the Appendix pages.
Server states

Each connection maintained by a Bolt server will occupy one of several states throughout its lifetime. This state is used to determine what actions may be undertaken by the client.
State 	Logic state 	Description

DISCONNECTED

X

no socket connection

DEFUNCT

X

the socket connection is permanently closed

NEGOTIATION

protocol handshake is completed successfully; ready to accept a HELLO message

AUTHENTICATION

HELLO or LOGOFF message accepted; ready to accept a LOGON message

READY

ready to accept a RUN message

STREAMING

Auto-commit Transaction, a result is available for streaming from the server

TX_READY

Explicit Transaction, ready to accept a RUN message

TX_STREAMING

Explicit Transaction, a result is available for streaming from the server

FAILED

a connection is in a temporarily unusable state

INTERRUPTED

the server got an <INTERRUPT> signal
Server state DISCONNECTED

No socket connection has yet been established. This is the initial state and exists only in a logical sense prior to the socket being opened.
Transitions from DISCONNECTED

Bolt handshake completed successfully to NEGOTIATION

Bolt handshake did not complete successfully to DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state NEGOTIATION

After a new protocol connection has been established and handshake has been completed successfully, the server enters the NEGOTIATION state. The connection has not yet been authenticated and permits only one transition, through successful initialization using the HELLO message, into the AUTHENTICATION state.
Transitions from NEGOTIATION

<DISCONNECT> to DEFUNCT

HELLO to AUTHENTICATION or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state AUTHENTICATION

Connection has been established and metadata has been sent back from the HELLO message or a LOGOFF message was received whilst in ready state. Ready to accept a LOGON message with authentication information.
Transitions from NEGOTIATION

LOGON to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Transitions from READY

LOGOFF to AUTHENTICATION
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state DEFUNCT

This is not strictly a connection state, but is instead a logical state that exists after a connection has been closed. When DEFUNCT, a connection is permanently not usable. This may arise due to a graceful shutdown or can occur after an unrecoverable error or protocol violation. Clients and servers should clear up any resources associated with a connection on entering this state, including closing any open sockets. This is a terminal state on which no further transitions may be carried out. The <DISCONNECT> signal will set the connection in the DEFUNCT server state.
Server state READY

The READY state can handle the request messages RUN and BEGIN and receive a query.
Transitions from READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to STREAMING or FAILED

BEGIN to TX_READY or FAILED (v3+)

LOGOFF to AUTHENTICATION (v5.1+)

TELEMETRY to READY (v5.4+)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state STREAMING

When STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can re-enter the READY state and allow any further queries to be executed.
Transitions from STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL to READY, FAILED, or STREAMING

DISCARD to READY, FAILED, or STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1, v2 and v3, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

PULL_ALL to READY or FAILED

DISCARD_ALL to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 1. Request message DISCARD state transitions State 	New state 	Response

STREAMING

READY

SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

FAILURE {}

STREAMING

STREAMING

SUCCESS {"has_more": true}
Table 2. Request message PULL state transitions State 	New state 	Response

STREAMING

READY

[RECORD …] SUCCESS {"has_more": false} or SUCCESS {}

STREAMING

FAILED

[RECORD …] FAILURE {}

STREAMING

STREAMING

[RECORD …] SUCCESS {"has_more": true}
Table 3. Request message DISCARD_ALL state transitions in v1, v2, and v3 only State 	New state 	Response

STREAMING

READY

`SUCCESS {}

STREAMING

FAILED

FAILURE {}
Table 4. Request message PULL_ALL state transitions in v1. v2 and v3 only State 	New state 	Response

STREAMING

READY

[RECORD …] SUCCESS {}

STREAMING

FAILED

[RECORD …] FAILURE {}
Server state TX_READY
Transitions from TX_READY

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

COMMIT to READY or FAILED

ROLLBACK to READY or FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 5. Request message RUN state transitions State 	New state 	Response

TX_READY

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_READY

FAILED

FAILURE{}

The TX_READY server state does not exist in v1 or v2.
Server state TX_STREAMING

When TX_STREAMING, a result is available for streaming from server to client. This result must be fully consumed or discarded by a client before the server can transition to the TX_READY state.
Transitions from TX_STREAMING

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to TX_STREAMING or FAILED

PULL to TX_READY, FAILED or TX_STREAMING

DISCARD to TX_READY, FAILED or TX_STREAMING
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Table 6. Request message RUN state transitions State 	New state 	Response

TX_STREAMING

TX_STREAMING

SUCCESS {"qid": id::Integer}

TX_STREAMING

FAILED

FAILURE{}
Table 7. Request message DISCARD state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

FAILURE {}

TX_STREAMING

TX_STREAMING

SUCCESS {"has_more": true}
Table 8. Request messages PULL state transitions State 	New state 	Response

TX_STREAMING

TX_READY or TX_STREAMING if there are other streams open

[RECORD …] SUCCESS {"has_more": false} or SUCCESS {}

TX_STREAMING

FAILED

[RECORD …] FAILURE {}

TX_STREAMING

TX_STREAMING

[RECORD …] SUCCESS {"has_more": true}

The TX_STREAMING server state does not exist in v1 or v2.
Server state FAILED

When FAILED, a connection is in a temporarily unusable state. This is generally as the result of encountering a recoverable error. This mode ensures that only one failure can exist at a time, preventing cascading issues from batches of work.
Transitions from FAILED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to FAILED

PULL to FAILED

DISCARD to FAILED
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, in a FAILED state, no more work will be processed until the failure has been acknowledged by ACK_FAILURE or until the connection has been RESET.

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

ACK_FAILURE to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Server state INTERRUPTED

This state occurs between the server receiving the jump-ahead <INTERRUPT> and the queued RESET message, (the RESET message triggers an <INTERRUPT>). Most incoming messages are ignored when the server are in an INTERRUPTED state, with the exception of the RESET that allows transition back to READY. The <INTERRUPT> signal will set the connection in the INTERRUPTED server state.
Transitions from INTERRUPTED

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD to INTERRUPTED

PULL to INTERRUPTED

BEGIN to INTERRUPTED

COMMIT to INTERRUPTED

ROLLBACK to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

In v1 and v2, the following transitions are possible:

<INTERRUPT> to INTERRUPTED

<DISCONNECT> to DEFUNCT

RUN to INTERRUPTED

DISCARD_ALL to INTERRUPTED

PULL_ALL to INTERRUPTED

ACK_FAILURE to INTERRUPTED

RESET to READY or DEFUNCT
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Summary of changes per version

The sections below list the changes compared to the previous version.
Version 5.2

No changes compared to version 5.1.
Version 5.1

CONNECTED state has been renamed to NEGOTIATION but still accepts the HELLO message.

HELLO message no longer accepts authentication and transitions to the AUTHENTICATION state from NEGOTIATION.

LOGON message has been added. It can only be received in the AUTHENTICATION state and transitions to the READY state.

LOGOFF message has be added. It can only be received in the READY state and transitions to the AUTHENTICATION state.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 5.0

No changes compared to version 4.4.
Version 4.4

No changes compared to version 4.3.
Version 4.3

The ROUTE message was added. It can only be received in the READY state and causes no transition.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 4.2

No changes compared to version 4.1.
Version 4.1

No changes compared to version 4.0.
Version 4.0

Compared to version 3 the RUN, PULL and DISCARD now can re-enter STREAMING or TX_STREAMING. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 4.0.
Version 3

Compared to version 2 there are new server states:

TX_READY

TX_STREAMING These states are introduced to handle the concept of Explicit Transaction. The server state transitions are using the updated set of messages defined in Bolt Protocol Message Specification Version 3.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Version 2

No changes compared to version 1.

这是完整的bolt协议文档，你看看现有代码还有哪些问题，还有哪些待实现