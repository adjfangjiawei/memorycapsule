// Include/mysql_protocol/mysql_constants.h
#pragma once
#include <cstdint>

namespace mysql_protocol {

    // MySQL PacketMarker (这些是我们自己定义的，不太可能与 <mysql/mysql.h> 冲突)
    namespace PacketMarker {
        constexpr uint8_t OK_HEADER = 0x00;
        constexpr uint8_t ERR_HEADER = 0xFF;
        constexpr uint8_t EOF_HEADER = 0xFE;
        constexpr uint8_t LOCAL_INFILE_REQUEST = 0xFB;
    }  // namespace PacketMarker

    // 如果您有其他绝对自定义的、与 MySQL 协议实现相关的、
    // 且名称保证不与 <mysql/mysql.h> 中任何宏冲突的常量，可以放在这里。
    // 例如，内部状态机的状态值等。

    // !!! 重要: 所有之前定义的 Command::XXX, FieldType::XXX, ColumnFlag::XXX,
    // ServerStatus::XXX, CharacterSet::XXX, ClientCapability::XXX
    // 都已移除，因为它们很可能与 <mysql/mysql.h> 中的全局宏冲突。
    // 我们将在使用它们的地方直接调用 ::XXX_OFFICIAL_MYSQL_MACRO_NAME。

}  // namespace mysql_protocol// Include/mysql_protocol/mysql_type_converter.h
#pragma once

#include <mysql/mysql.h>

#include <chrono>    // For std::chrono types
#include <cstring>   // For std::strcmp, std::strncpy
#include <expected>  // C++23, for std::expected
#include <limits>    // For std::numeric_limits
#include <optional>  // For std::optional in get_if
#include <string>
#include <string_view>
#include <variant>
#include <vector>

namespace mysql_protocol {

    // 自定义内部错误码，用于 MySqlProtocolError::error_code
    namespace InternalErrc {
        constexpr unsigned int SUCCESS = 0;  // 成功

        // 类型转换错误码 (10000 - 10099)
        constexpr unsigned int CONVERSION_INVALID_INPUT_ARGUMENT = 10000;
        constexpr unsigned int CONVERSION_INVALID_FORMAT = 10001;
        constexpr unsigned int CONVERSION_VALUE_OUT_OF_RANGE = 10002;
        constexpr unsigned int CONVERSION_UNSUPPORTED_TYPE = 10003;
        constexpr unsigned int CONVERSION_NULL_INPUT_UNEXPECTED = 10004;
        constexpr unsigned int CONVERSION_TYPE_MISMATCH_ACCESS = 10005;

        // MYSQL_TIME 解析/格式化/转换错误码 (10100 - 10199)
        constexpr unsigned int TIME_STRING_PARSE_EMPTY_INPUT = 10101;
        constexpr unsigned int TIME_STRING_PARSE_INVALID_FORMAT = 10102;
        constexpr unsigned int TIME_STRING_PARSE_COMPONENT_OUT_OF_RANGE = 10103;
        constexpr unsigned int TIME_FORMAT_INVALID_MYSQL_TIME_STRUCT = 10104;
        constexpr unsigned int TIME_FORMAT_STREAM_ERROR = 10105;
        constexpr unsigned int TIME_CHRONO_CONVERSION_INVALID_MYSQL_TIME = 10106;  // MYSQL_TIME to chrono
        constexpr unsigned int TIME_CHRONO_CONVERSION_OUT_OF_RANGE = 10107;        // chrono value out of MYSQL_TIME range or vice-versa
        constexpr unsigned int TIME_CHRONO_CONVERSION_UNSUPPORTED_TYPE = 10108;    // e.g. trying to convert TIME to full time_point

        // MYSQL_BIND 设置错误码 (10200 - 10299)
        constexpr unsigned int BIND_SETUP_NULL_POINTER_ARGUMENT = 10201;

        // MySqlNativeValue 辅助函数错误 (10300 - 10399)
        constexpr unsigned int NATIVE_VALUE_TO_STRING_ERROR = 10301;

        // 通用逻辑/状态错误 (19000 - ...)
        constexpr unsigned int LOGIC_ERROR_INVALID_STATE = 19001;
        constexpr unsigned int UNKNOWN_ERROR = 19999;
    }  // namespace InternalErrc

    struct MySqlProtocolError {
        unsigned int error_code = InternalErrc::SUCCESS;
        char sql_state[SQLSTATE_LENGTH + 1];
        std::string error_message;

        MySqlProtocolError() noexcept {
            error_code = InternalErrc::SUCCESS;
            sql_state[0] = '0';
            sql_state[1] = '0';
            sql_state[2] = '0';
            sql_state[3] = '0';
            sql_state[4] = '0';
            sql_state[SQLSTATE_LENGTH] = '\0';
            error_message = "Success";
        }

        MySqlProtocolError(unsigned int mysql_err_code, const char* mysql_sql_state, std::string mysql_msg) noexcept : error_code(mysql_err_code), error_message(std::move(mysql_msg)) {
            if (mysql_sql_state) {
                std::strncpy(sql_state, mysql_sql_state, SQLSTATE_LENGTH);
                sql_state[SQLSTATE_LENGTH] = '\0';
            } else {  // 如果 mysql_sql_state 为空，也提供一个默认值
                sql_state[0] = 'H';
                sql_state[1] = 'Y';
                sql_state[2] = '0';
                sql_state[3] = '0';
                sql_state[4] = '0';  // "HY000" General error
                sql_state[SQLSTATE_LENGTH] = '\0';
            }
            // 确保如果 MySQL 返回错误码 0，我们的 error_message 也反映成功（即使 mysql_error 可能返回非空字符串）
            if (error_code == 0 && (mysql_sql_state == nullptr || std::strncmp(mysql_sql_state, "00000", SQLSTATE_LENGTH) != 0)) {
                // 如果 mysql_errno 是 0，但 sqlstate 不是 "00000" (或 null)，这很罕见。
                // 我们的 error_message 应该优先反映成功状态。
                if (error_message.empty() || error_message == "NULL") {  // "NULL" string is sometimes returned by mysql_error
                    this->error_message = "Success (MySQL error code 0)";
                } else if (error_message.find(" অভ") != std::string::npos) {  // Common non-error "OK" messages in some locales
                    this->error_message = "Success (MySQL: " + error_message + ")";
                } else if (error_code == 0) {  // If truly error_code 0, ensure message doesn't mislead
                    this->error_message = "Success (MySQL error code 0, non-standard state: " + std::string(sql_state) + ")";
                }
            }
        }

        MySqlProtocolError(unsigned int internal_code, std::string msg) noexcept : error_code(internal_code), error_message(std::move(msg)) {
            // 对于内部错误，error_code 是 InternalErrc::* 之一
            // sql_state 可以设置为一个通用的内部错误状态
            sql_state[0] = 'P';
            sql_state[1] = 'I';
            sql_state[2] = '0';
            sql_state[3] = '0';
            sql_state[4] = '0';  // "PI000" for Protocol Internal
            sql_state[SQLSTATE_LENGTH] = '\0';
        }

        bool isOk() const noexcept {
            // 主要判断标准：协议层内部错误码是否为 SUCCESS
            return error_code == InternalErrc::SUCCESS;
        }
    };

    struct MySqlNativeValue {
        std::variant<std::monostate, bool, int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t, float, double, std::string, std::vector<unsigned char>, MYSQL_TIME> data;

        enum enum_field_types original_mysql_type = ::MYSQL_TYPE_NULL;
        unsigned int original_mysql_flags = 0;
        uint16_t original_charsetnr = 0;  // 新增：存储原始字符集编号

        MySqlNativeValue() = default;
        bool is_null() const noexcept {
            return data.index() == 0;
        }

        std::expected<std::string, MySqlProtocolError> toString() const;

        template <typename T>
        std::optional<T> get_if() const noexcept {
            if (std::holds_alternative<T>(data)) {
                return std::get<T>(data);
            }
            return std::nullopt;
        }

        template <typename T>
        std::expected<T, MySqlProtocolError> get_as() const noexcept {
            if (std::holds_alternative<T>(data)) {
                return std::get<T>(data);
            }
            // 简单的类型名称获取，可以根据需要扩展
            std::string requested_type_name = "unknown_requested_type";
            if constexpr (std::is_same_v<T, bool>)
                requested_type_name = "bool";
            else if constexpr (std::is_same_v<T, int8_t>)
                requested_type_name = "int8_t";
            else if constexpr (std::is_same_v<T, uint8_t>)
                requested_type_name = "uint8_t";
            else if constexpr (std::is_same_v<T, int16_t>)
                requested_type_name = "int16_t";
            else if constexpr (std::is_same_v<T, uint16_t>)
                requested_type_name = "uint16_t";
            else if constexpr (std::is_same_v<T, int32_t>)
                requested_type_name = "int32_t";
            else if constexpr (std::is_same_v<T, uint32_t>)
                requested_type_name = "uint32_t";
            else if constexpr (std::is_same_v<T, int64_t>)
                requested_type_name = "int64_t";
            else if constexpr (std::is_same_v<T, uint64_t>)
                requested_type_name = "uint64_t";
            else if constexpr (std::is_same_v<T, float>)
                requested_type_name = "float";
            else if constexpr (std::is_same_v<T, double>)
                requested_type_name = "double";
            else if constexpr (std::is_same_v<T, std::string>)
                requested_type_name = "std::string";
            else if constexpr (std::is_same_v<T, std::vector<unsigned char>>)
                requested_type_name = "std::vector<unsigned char>";
            else if constexpr (std::is_same_v<T, MYSQL_TIME>)
                requested_type_name = "MYSQL_TIME";

            return std::unexpected(MySqlProtocolError(InternalErrc::CONVERSION_TYPE_MISMATCH_ACCESS, "Attempted to get value as type '" + requested_type_name + "' but it holds a different type. Original MySQL type ID: " + std::to_string(original_mysql_type)));
        }
    };

    // --- MySQL Native Value Conversion Functions (Declarations) ---
    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlRowFieldToNativeValue(const char* c_str_value, unsigned long length, const MYSQL_FIELD* field_meta);
    std::expected<MySqlNativeValue, MySqlProtocolError> mySqlBoundResultToNativeValue(const MYSQL_BIND* bind_info, unsigned int original_flags_if_known = 0, uint16_t original_charsetnr_if_known = 0);

    // --- MYSQL_BIND Preparation for Statement Parameters (Declarations) ---
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int8_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int16_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int32_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, bool is_unsigned, int64_t);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, float);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInput(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, double);

    std::expected<void, MySqlProtocolError> setupMySqlBindForInputString(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, unsigned long* length_indicator_ptr, enum enum_field_types mysql_type, char* str_buffer, unsigned long str_actual_length);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInputBlob(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, unsigned long* length_indicator_ptr, enum enum_field_types mysql_type, unsigned char* blob_buffer, unsigned long blob_actual_length);
    std::expected<void, MySqlProtocolError> setupMySqlBindForInputTime(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, enum enum_field_types mysql_type, MYSQL_TIME* time_buffer);
    std::expected<void, MySqlProtocolError> setupMySqlBindForNull(MYSQL_BIND& bind_struct, bool* is_null_indicator_ptr, enum enum_field_types mysql_type);

    // --- MYSQL_TIME <-> String Conversion Utilities (Declarations) ---
    std::expected<MYSQL_TIME, MySqlProtocolError> parseDateTimeStringToMySqlTime(std::string_view dt_string, enum enum_field_types expected_type);
    std::expected<std::string, MySqlProtocolError> formatMySqlTimeToString(const MYSQL_TIME& mysql_time, enum enum_field_types original_type);

    // --- MYSQL_TIME <-> std::chrono Conversion Utilities (Declarations) ---
    std::expected<std::chrono::system_clock::time_point, MySqlProtocolError> mySqlTimeToSystemClockTimePoint(const MYSQL_TIME& mysql_time);
    std::expected<MYSQL_TIME, MySqlProtocolError> systemClockTimePointToMySqlTime(const std::chrono::system_clock::time_point& time_point, enum enum_field_types target_mysql_type = MYSQL_TYPE_DATETIME);

    // C++20 date/time types might be more direct for some conversions
    // For DATE:
    std::expected<std::chrono::year_month_day, MySqlProtocolError> mySqlTimeToYearMonthDay(const MYSQL_TIME& mysql_time);
    std::expected<MYSQL_TIME, MySqlProtocolError> yearMonthDayToMySqlDate(const std::chrono::year_month_day& ymd);

    // For TIME: (duration from midnight)
    std::expected<std::chrono::microseconds, MySqlProtocolError> mySqlTimeToDuration(const MYSQL_TIME& mysql_time);  // Returns duration, handles 'neg'
    std::expected<MYSQL_TIME, MySqlProtocolError> durationToMySqlTime(std::chrono::microseconds duration_from_midnight);

    // --- MySQL Error Reporting (Declarations) ---
    MySqlProtocolError getMySqlHandleError(MYSQL* handle);
    MySqlProtocolError getMySqlStmtError(MYSQL_STMT* stmt_handle);

}  // namespace mysql_protocol// sqldriver/i_sql_driver.h
#pragma once

#include <any>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_connection_parameters.h"  // Provides ConnectionParameters
#include "sql_enums.h"                  // Provides Feature, IdentifierType, StatementType, TransactionIsolationLevel, ISqlDriverNs::TableType
#include "sql_error.h"
#include "sql_index.h"
#include "sql_record.h"
#include "sql_value.h"  // For SqlValue, SqlValueType

namespace cpporm_sqldriver {

    class SqlResult;
    class SqlField;

    class ISqlDriver {
      public:
        virtual ~ISqlDriver() = default;

        virtual bool open(const ConnectionParameters& params) = 0;
        virtual void close() = 0;
        virtual bool isOpen() const = 0;
        virtual bool isOpenError() const = 0;
        virtual bool ping(int timeout_seconds = 2) = 0;

        virtual bool beginTransaction() = 0;
        virtual bool commitTransaction() = 0;
        virtual bool rollbackTransaction() = 0;
        virtual bool setTransactionIsolationLevel(TransactionIsolationLevel level) = 0;
        virtual TransactionIsolationLevel transactionIsolationLevel() const = 0;
        virtual bool setSavepoint(const std::string& name) = 0;
        virtual bool rollbackToSavepoint(const std::string& name) = 0;
        virtual bool releaseSavepoint(const std::string& name) = 0;

        virtual std::unique_ptr<SqlResult> createResult() const = 0;

        virtual std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const = 0;
        virtual std::vector<std::string> schemas(const std::string& schemaFilter = "") const = 0;
        virtual SqlRecord record(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const = 0;
        virtual std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const = 0;

        virtual bool hasFeature(Feature feature) const = 0;
        virtual SqlError lastError() const = 0;
        virtual std::string databaseProductVersion() const = 0;
        virtual std::string driverVersion() const = 0;

        virtual std::string formatValue(const SqlValue& value, SqlValueType type_hint = SqlValueType::Null, const SqlField* field_meta_hint = nullptr) const = 0;
        virtual std::string escapeIdentifier(const std::string& identifier, IdentifierType type) const = 0;
        virtual std::string sqlStatement(StatementType type, const std::string& tableName, const SqlRecord& rec, bool prepared, const std::string& schema = "") const = 0;

        virtual bool setClientCharset(const std::string& charsetName) = 0;
        virtual std::string clientCharset() const = 0;

        virtual SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "") = 0;

        virtual SqlValue nativeHandle() const = 0;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_connection_parameters.h
#pragma once

#include <map>
#include <optional>
#include <string>
#include <vector>  // Not directly used here, but often associated with parameter sets

#include "sql_value.h"  // For SqlValue used as map value

namespace cpporm_sqldriver {

    struct ConnectionParameters : public std::map<std::string, SqlValue> {
        // 定义键常量 (声明)
        static const std::string KEY_DRIVER_TYPE;
        static const std::string KEY_DB_NAME;
        static const std::string KEY_USER_NAME;
        static const std::string KEY_PASSWORD;
        static const std::string KEY_HOST_NAME;
        static const std::string KEY_PORT;
        static const std::string KEY_CONNECT_OPTIONS;
        static const std::string KEY_CLIENT_CHARSET;
        static const std::string KEY_APPLICATION_NAME;
        static const std::string KEY_CONNECTION_TIMEOUT_SECONDS;
        static const std::string KEY_READ_TIMEOUT_SECONDS;
        static const std::string KEY_WRITE_TIMEOUT_SECONDS;
        static const std::string KEY_SSL_MODE;
        static const std::string KEY_SSL_CERT_PATH;
        static const std::string KEY_SSL_KEY_PATH;
        static const std::string KEY_SSL_CA_PATH;
        static const std::string KEY_SSL_CIPHER;
        static const std::string KEY_POOL_MAX_SIZE;
        static const std::string KEY_POOL_MIN_SIZE;
        static const std::string KEY_POOL_ACQUIRE_TIMEOUT_MS;
        static const std::string KEY_POOL_CONNECTION_LIFETIME_MS;
        static const std::string KEY_POOL_IDLE_TIMEOUT_MS;

        // Setters (声明)
        void setDriverType(const std::string& v);
        void setDbName(const std::string& v);
        void setUserName(const std::string& v);
        void setPassword(const std::string& v);
        void setHostName(const std::string& v);
        void setPort(int v);
        void setConnectOptions(const std::string& v);
        void setClientCharset(const std::string& v);
        void setApplicationName(const std::string& v);
        void setConnectionTimeoutSeconds(int v);
        void setReadTimeoutSeconds(int v);
        void setWriteTimeoutSeconds(int v);
        void setSslMode(const std::string& v);
        void setSslCertPath(const std::string& v);
        void setSslKeyPath(const std::string& v);
        void setSslCaPath(const std::string& v);
        void setSslCipher(const std::string& v);
        void setPoolMaxSize(int v);
        void setPoolMinSize(int v);
        void setPoolAcquireTimeoutMs(long long v);
        void setPoolConnectionLifetimeMs(long long v);
        void setPoolIdleTimeoutMs(long long v);

        // Getters (声明)
        template <typename T>
        std::optional<T> get(const std::string& key) const;

        std::optional<std::string> driverType() const;
        std::optional<std::string> dbName() const;
        std::optional<std::string> userName() const;
        std::optional<std::string> password() const;
        std::optional<std::string> hostName() const;
        std::optional<int> port() const;
        std::optional<std::string> connectOptions() const;
        std::optional<std::string> clientCharset() const;
        std::optional<std::string> applicationName() const;
        std::optional<int> connectionTimeoutSeconds() const;
        std::optional<int> readTimeoutSeconds() const;
        std::optional<int> writeTimeoutSeconds() const;
        std::optional<std::string> sslMode() const;
        std::optional<std::string> sslCertPath() const;
        std::optional<std::string> sslKeyPath() const;
        std::optional<std::string> sslCaPath() const;
        std::optional<std::string> sslCipher() const;
        std::optional<int> poolMaxSize() const;
        std::optional<int> poolMinSize() const;
        std::optional<long long> poolAcquireTimeoutMs() const;
        std::optional<long long> poolConnectionLifetimeMs() const;
        std::optional<long long> poolIdleTimeoutMs() const;
    };

    template <typename T>
    std::optional<T> ConnectionParameters::get(const std::string& key) const {
        auto it = find(key);
        if (it != end() && !it->second.isNull()) {
            bool ok = false;
            T result{};
            if constexpr (std::is_same_v<T, std::string>) {
                result = it->second.toString(&ok);
            } else if constexpr (std::is_same_v<T, int>) {
                result = it->second.toInt32(&ok);
            } else if constexpr (std::is_same_v<T, unsigned int>) {
                result = it->second.toUInt32(&ok);
            } else if constexpr (std::is_same_v<T, long long>) {
                result = it->second.toInt64(&ok);
            } else if constexpr (std::is_same_v<T, unsigned long long>) {
                result = it->second.toUInt64(&ok);
            } else if constexpr (std::is_same_v<T, bool>) {
                result = it->second.toBool(&ok);
            } else if constexpr (std::is_same_v<T, float>) {
                result = it->second.toFloat(&ok);
            } else if constexpr (std::is_same_v<T, double>) {
                result = it->second.toDouble(&ok);
            } else if constexpr (std::is_same_v<T, long double>) {
                result = it->second.toLongDouble(&ok);
            } else if constexpr (std::is_same_v<T, QByteArray>) {
                result = it->second.toByteArray(&ok);
            } else if constexpr (std::is_same_v<T, QDate>) {
                result = it->second.toDate(&ok);
            } else if constexpr (std::is_same_v<T, QTime>) {
                result = it->second.toTime(&ok);
            } else if constexpr (std::is_same_v<T, QDateTime>) {
                result = it->second.toDateTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDate>) {
                result = it->second.toChronoDate(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoTime>) {
                result = it->second.toChronoTime(&ok);
            } else if constexpr (std::is_same_v<T, SqlValue::ChronoDateTime>) {
                result = it->second.toChronoDateTime(&ok);
            } else if constexpr (std::is_same_v<T, std::vector<unsigned char>>) {
                result = it->second.toStdVectorUChar(&ok);
            }
            // else if constexpr (std::is_same_v<T, SqlDecimal>) { result = it->second.toDecimal(&ok); } // Example for custom types
            // else if constexpr (std::is_same_v<T, SqlJsonDocument>) { result = it->second.toJsonDocument(&ok); }
            else {
                // For std::any or other unlisted types, this path would be taken.
                // Consider if a static_assert(false, "Unsupported type T for ConnectionParameters::get") is appropriate,
                // or if it should attempt a toStdAny() and std::any_cast, which is more risky.
                // For now, ok will remain false if no specific conversion is matched.
            }
            if (ok) return result;
        }
        return std::nullopt;
    }

}  // namespace cpporm_sqldriver// sqldriver/sql_database.h
#pragma once
#include <any>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "i_sql_driver.h"               // Provides ISqlDriver interface
#include "sql_connection_parameters.h"  // Provides ConnectionParameters
#include "sql_enums.h"                  // Provides Feature, TransactionIsolationLevel, ISqlDriverNs::TableType etc.
#include "sql_error.h"
#include "sql_index.h"   // Provides SqlIndex
#include "sql_record.h"  // Provides SqlRecord

namespace cpporm_sqldriver {

    class SqlQuery;

    class SqlDatabase {
      public:
        ~SqlDatabase();

        bool open(const ConnectionParameters& params);
        bool open();
        bool open(const std::string& user, const std::string& password);
        void close();
        bool isOpen() const;
        bool isValid() const;
        bool ping(int timeout_seconds = 2);

        bool transaction();  // Renamed from beginTransaction as per error log implication
        bool commit();
        bool rollback();
        bool isTransactionActive() const;
        bool setTransactionIsolationLevel(TransactionIsolationLevel level);
        TransactionIsolationLevel transactionIsolationLevel() const;
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        std::string driverName() const;
        std::string databaseName() const;
        void setDatabaseName(const std::string& name);

        std::string userName() const;
        void setUserName(const std::string& name);

        void setPassword(const std::string& password);

        std::string hostName() const;
        void setHostName(const std::string& host);

        int port() const;
        void setPort(int port);

        std::string connectOptionsString() const;
        void setConnectOptionsString(const std::string& options);

        const ConnectionParameters& connectionParameters() const;
        void setConnectionParameter(const std::string& key, const SqlValue& value);
        SqlValue connectionParameter(const std::string& key) const;

        SqlError lastError() const;

        ISqlDriver* driver() const;
        std::string connectionName() const;

        std::vector<std::string> tables(ISqlDriverNs::TableType type = ISqlDriverNs::TableType::Tables, const std::string& schemaFilter = "", const std::string& tableNameFilter = "") const;
        std::vector<std::string> schemas(const std::string& schemaFilter = "") const;
        SqlRecord record(const std::string& tablename, const std::string& schema = "") const;
        SqlIndex primaryIndex(const std::string& tablename, const std::string& schema = "") const;
        std::vector<SqlIndex> indexes(const std::string& tablename, const std::string& schema = "") const;

        bool hasFeature(Feature feature) const;
        SqlValue nativeHandle() const;
        std::string databaseProductVersion() const;
        std::string driverVersion() const;

        bool setClientCharset(const std::string& charsetName);
        std::string clientCharset() const;

        SqlValue nextSequenceValue(const std::string& sequenceName, const std::string& schema = "");

        // Move operations made public
        SqlDatabase(SqlDatabase&&) noexcept;
        SqlDatabase& operator=(SqlDatabase&&) noexcept;

      private:
        friend class SqlDriverManager;
        friend class SqlQuery;

        SqlDatabase(const std::string& driverTypeFromManager, const std::string& assignedConnectionName, std::unique_ptr<ISqlDriver> driverImplementation);

        class Private;
        std::unique_ptr<Private> d;

        SqlDatabase(const SqlDatabase&) = delete;
        SqlDatabase& operator=(const SqlDatabase&) = delete;
        // Moved constructors/assignment are now public
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_driver_manager.h
#pragma once
#include <functional>  // For std::function
#include <memory>
#include <string>
#include <vector>

#include "sql_database.h"

namespace cpporm_sqldriver {

    class ISqlDriver;  // 前向声明

    class SqlDriverManager {
      public:
        using DriverFactory = std::function<std::unique_ptr<ISqlDriver>()>;

        // 连接管理
        static SqlDatabase addDatabase(const std::string& driverType, const std::string& connectionName = defaultConnectionName());
        static SqlDatabase database(const std::string& connectionName = defaultConnectionName(), bool open = true);
        static void removeDatabase(const std::string& connectionName);
        static bool contains(const std::string& connectionName = defaultConnectionName());

        // 驱动信息
        static std::vector<std::string> drivers();                     // 列出已注册的驱动类型
        static bool isDriverAvailable(const std::string& driverType);  // 检查驱动是否可用

        static std::string defaultConnectionName();

        // 驱动注册 (由具体驱动实现模块在初始化时调用)
        static bool registerDriver(const std::string& driverName, DriverFactory factory);
        // static void unregisterDriver(const std::string& driverName); // 可选

      private:
        SqlDriverManager() = delete;  // 静态类

        class Private;  // PImpl for static data
        static Private* d();
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_enums.h
#pragma once

namespace cpporm_sqldriver {

    // --- Enums used across driver interfaces ---

    enum class Feature {
        Transactions,
        QuerySize,
        BLOB,
        Unicode,
        PreparedQueries,
        NamedPlaceholders,
        PositionalPlaceholders,
        LastInsertId,
        BatchOperations,
        SimpleScrollOnError,
        EventNotifications,
        FinishQuery,
        MultipleResultSets,
        LowPrecisionNumbers,
        CancelQuery,
        InsertAndReturnId,
        NamedSavepoints,
        ThreadSafe,
        SchemaOperations,
        SequenceOperations,
        UpdatableCursors,
        TransactionIsolationLevel,
        GetTypeInfo,
        PingConnection,
        SetQueryTimeout,
        StreamBlob,
        CallableStatements,
        BatchWithErrorDetails
    };

    enum class IdentifierType { Table, Field, Index, Schema, Sequence, Trigger, View, Constraint, User, Role, Procedure, Function };

    enum class StatementType { Select, Insert, Update, Delete, DDL, DCL, TCL, Call, Begin, Commit, Rollback, Savepoint, Unknown };

    enum class TransactionIsolationLevel { ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, Snapshot, Default };

    enum class ParamType { In, Out, InOut, Binary, ReturnValue };

    enum class CursorMovement { Absolute, RelativeFirst, RelativeNext, RelativePrevious, RelativeLast };

    namespace ISqlDriverNs {
        enum class TableType { All, Tables, Views, SystemTables, Aliases, Synonyms, TemporaryTables, GlobalTemporaryTables };
    }  // namespace ISqlDriverNs

    namespace SqlResultNs {
        enum class ScrollMode { ForwardOnly, Scrollable };
        enum class ConcurrencyMode { ReadOnly, Updatable };
        enum class NamedBindingSyntax { Colon, AtSign, QuestionMark };
    }  // namespace SqlResultNs

}  // namespace cpporm_sqldriver// sqldriver/sql_error.h
#pragma once
#include <optional>
#include <string>

namespace cpporm_sqldriver {

    // ErrorCategory 和 ErrorType 枚举定义在文件顶部或类的外部
    enum class ErrorCategory { NoError, Connectivity, Syntax, Constraint, Permissions, DataRelated, Resource, Transaction, DriverInternal, DatabaseInternal, OperationCancelled, FeatureNotSupported, Unknown };

    // 旧的 ErrorType，如果仍需保留用于映射或兼容
    enum class ErrorType {
        NoError = 0,  // 保持与Qt QSqlError::NoError 一致
        ConnectionError,
        StatementError,
        TransactionError,
        UnknownError,
        FeatureNotSupportedError,
        DataError,
        ConstraintViolationError
    };

    class SqlError {
      public:
        SqlError();
        SqlError(ErrorCategory category,
                 const std::string& databaseText,
                 const std::string& driverText = "",
                 const std::string& nativeErrorCode = "",
                 int nativeDbCodeNumeric = 0,
                 const std::string& failedQuery = "",
                 const std::string& constraintName = "",
                 const std::optional<int>& errorOffset = std::nullopt);

        ErrorCategory category() const;
        ErrorType type() const;  // 可以基于 category() 返回一个映射的 ErrorType
        std::string databaseText() const;
        std::string driverText() const;
        std::string text() const;
        std::string nativeErrorCode() const;
        int nativeErrorCodeNumeric() const;
        std::string failedQuery() const;
        std::string constraintName() const;
        std::optional<int> errorOffsetInQuery() const;
        bool isValid() const;  // category() != ErrorCategory::NoError

        void setCategory(ErrorCategory category);
        void setType(ErrorType type);
        void setDatabaseText(const std::string& text);
        void setDriverText(const std::string& text);
        void setNativeErrorCode(const std::string& code);
        void setNativeErrorCodeNumeric(int code);
        void setFailedQuery(const std::string& query);
        void setConstraintName(const std::string& name);
        void setErrorOffsetInQuery(const std::optional<int>& offset);
        void clear();

      private:
        ErrorCategory category_ = ErrorCategory::NoError;
        ErrorType legacy_type_ = ErrorType::NoError;
        std::string database_text_;
        std::string driver_text_;
        std::string native_error_code_str_;
        int native_error_code_num_ = 0;
        std::string failed_query_;
        std::string constraint_name_;
        std::optional<int> error_offset_;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_field.h
#pragma once
#include <any>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "sql_value.h"

namespace cpporm_sqldriver {

    enum class RequiredStatus { Unknown = -1, Optional = 0, Required = 1 };

    class SqlField {
      public:
        SqlField(const std::string& name = "", SqlValueType type = SqlValueType::Null, const std::string& db_type_name = "");
        SqlField(const SqlField& other);
        SqlField& operator=(const SqlField& other);
        SqlField(SqlField&& other) noexcept;
        SqlField& operator=(SqlField&& other) noexcept;
        ~SqlField();

        std::string name() const;
        void setName(const std::string& name);

        SqlValueType type() const;
        void setType(SqlValueType type);

        std::string databaseTypeName() const;
        void setDatabaseTypeName(const std::string& name);
        int driverType() const;
        void setDriverType(int typeId);

        int length() const;
        void setLength(int len);

        int precision() const;
        void setPrecision(int prec);

        int scale() const;
        void setScale(int s);

        bool isNullInValue() const;
        bool isAutoValue() const;
        void setAutoValue(bool autoVal);

        bool isReadOnly() const;
        void setReadOnly(bool ro);

        RequiredStatus requiredStatus() const;
        void setRequiredStatus(RequiredStatus status);

        SqlValue defaultValue() const;
        void setDefaultValue(const SqlValue& value);

        SqlValue value() const;
        void setValue(const SqlValue& value);
        void clearValue();

        bool isValid() const;
        bool isGenerated() const;
        void setGenerated(bool generated);

        bool isPrimaryKeyPart() const;
        void setPrimaryKeyPart(bool is_pk);

        bool isForeignKeyPart() const;
        void setForeignKeyPart(bool is_fk);
        std::optional<std::string> referencedTableName() const;
        void setReferencedTableName(const std::optional<std::string>& name);
        std::optional<std::string> referencedColumnName() const;
        void setReferencedColumnName(const std::optional<std::string>& name);

        std::optional<std::string> collationName() const;
        void setCollationName(const std::optional<std::string>& name);

        bool isExpression() const;
        void setIsExpression(bool is_expr);
        std::optional<std::string> aliasName() const;
        void setAliasName(const std::optional<std::string>& alias);
        std::optional<std::string> baseTableName() const;
        void setBaseTableName(const std::optional<std::string>& name);
        std::optional<std::string> baseColumnName() const;
        void setBaseColumnName(const std::optional<std::string>& name);
        std::optional<std::string> baseSchemaName() const;
        void setBaseSchemaName(const std::optional<std::string>& name);

        std::any metaData() const;
        void setMetaData(const std::any& data);

      private:
        class Private;
        std::unique_ptr<Private> d;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_index.h
#pragma once
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "sql_field.h"
#include "sql_value.h"

namespace cpporm_sqldriver {

    enum class IndexSortOrder { Ascending, Descending, Default };
    enum class IndexNullsPosition { Default, First, Last };  // For NULLS FIRST/LAST

    struct IndexColumnDefinition {
        std::string fieldName;
        IndexSortOrder sortOrder = IndexSortOrder::Default;
        IndexNullsPosition nullsPosition = IndexNullsPosition::Default;
        std::optional<std::string> opClass;  // For PostgreSQL operator class
        // std::optional<std::string> collation; // Per-column collation if supported
    };

    class SqlIndex {
      public:
        SqlIndex(const std::string& cursorName = "", const std::string& name = "");
        SqlIndex(const SqlIndex& other);
        SqlIndex& operator=(const SqlIndex& other);
        SqlIndex(SqlIndex&& other) noexcept;
        SqlIndex& operator=(SqlIndex&& other) noexcept;
        ~SqlIndex();

        std::string name() const;
        void setName(const std::string& name);

        std::string cursorName() const;  // Table name
        void setCursorName(const std::string& name);

        std::string schemaName() const;
        void setSchemaName(const std::string& schema);

        bool isUnique() const;
        void setUnique(bool unique);

        bool isPrimaryKey() const;
        void setPrimaryKey(bool pk);

        bool isFunctional() const;  // 是否为函数/表达式索引
        void setFunctional(bool functional);

        void append(const IndexColumnDefinition& colDef);
        void append(const std::string& fieldName, IndexSortOrder order = IndexSortOrder::Default, IndexNullsPosition nulls = IndexNullsPosition::Default, const std::optional<std::string>& opClass = std::nullopt);

        int count() const;
        IndexColumnDefinition columnDefinition(int i) const;

        std::string typeMethod() const;  // e.g., BTREE, HASH, GIN, GIST, SPGIST, BRIN
        void setTypeMethod(const std::string& method);

        std::string condition() const;  // Partial index condition (WHERE clause)
        void setCondition(const std::string& cond);

        std::vector<std::string> includedColumnNames() const;  // SQL Server INCLUDE, PG INCLUDE
        void addIncludedColumn(const std::string& columnName);

        std::map<std::string, SqlValue> options() const;  // e.g., FILLFACTOR, WITH (...)
        void setOption(const std::string& optionName, const SqlValue& value);
        SqlValue option(const std::string& optionName) const;

        void clear();

      private:
        class Private;
        std::unique_ptr<Private> d;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_query.h
#pragma once
#include <functional>
#include <future>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "i_sql_driver.h"  // Provides ISqlDriver
#include "sql_enums.h"     // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_field.h"  // Provides SqlField
#include "sql_record.h"
#include "sql_result.h"  // Provides SqlResult
#include "sql_value.h"   // Provides NumericalPrecisionPolicy

namespace cpporm_sqldriver {

    class SqlDatabase;

    enum class BatchExecutionMode {
        ValuesAsRows,
    };

    class SqlQuery {
      public:
        explicit SqlQuery(SqlDatabase& db);
        explicit SqlQuery(const std::string& query, SqlDatabase& db);
        ~SqlQuery();

        bool prepare(const std::string& query, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly);
        bool exec();
        bool exec(const std::string& query);
        bool setQueryTimeout(int seconds);

        void bindValue(int pos, const SqlValue& val, ParamType type = ParamType::In, int size_hint_for_out_param = 0);
        void bindValue(const std::string& placeholderName, const SqlValue& val, ParamType type = ParamType::In, int size_hint_for_out_param = 0);
        void addBindValue(const SqlValue& val, ParamType type = ParamType::In);
        void bindValues(const std::vector<SqlValue>& values, ParamType type = ParamType::In);
        void bindValues(const std::map<std::string, SqlValue>& values, ParamType type = ParamType::In);

        SqlValue boundValue(int pos) const;
        SqlValue boundValue(const std::string& placeholderName) const;
        const std::map<std::string, SqlValue>& namedBoundValues() const;
        const std::vector<SqlValue>& positionalBoundValues() const;
        void clearBoundValues();
        int numberOfBoundValues() const;

        bool next();
        bool previous();
        bool first();
        bool last();
        bool seek(int index, CursorMovement movement = CursorMovement::Absolute);

        SqlRecord recordMetadata() const;
        SqlRecord currentFetchedRow() const;
        SqlValue value(int index) const;
        SqlValue value(const std::string& name) const;
        bool isNull(int index) const;
        bool isNull(const std::string& name) const;
        SqlField field(int index) const;
        SqlField field(const std::string& name) const;

        int at() const;
        int size() const;

        bool isActive() const;
        bool isValid() const;
        bool isSelect() const;
        bool setForwardOnly(bool forward);
        bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy);
        SqlError lastError() const;
        std::string lastQuery() const;
        std::string executedQuery() const;

        long long numRowsAffected() const;
        SqlValue lastInsertId() const;

        void finish();
        void clear();

        SqlDatabase& database() const;
        ISqlDriver* driver() const;
        SqlResult* result() const;

        bool execBatch(BatchExecutionMode mode = BatchExecutionMode::ValuesAsRows);

        bool nextResult();

        // Move operations made public
        SqlQuery(SqlQuery&&) noexcept;
        SqlQuery& operator=(SqlQuery&&) noexcept;

      private:
        class Private;
        std::unique_ptr<Private> d;

        SqlQuery(const SqlQuery&) = delete;
        SqlQuery& operator=(const SqlQuery&) = delete;
        // Moved constructors/assignment are now public
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_record.h
#pragma once
#include <optional>  // For std::optional
#include <string>
#include <vector>

#include "sql_field.h"  // SqlField 包含元数据和可选的当前值
#include "sql_value.h"

namespace cpporm_sqldriver {

    class SqlRecord {
      public:
        SqlRecord();
        ~SqlRecord();

        // 检查和计数
        bool isEmpty() const;  // 是否包含任何字段
        int count() const;

        // 字段访问
        SqlField field(int index) const;                // 按索引获取字段对象 (包含元数据和值)
        SqlField field(const std::string& name) const;  // 按名称获取字段对象

        std::string fieldName(int index) const;  // 仅获取字段名

        // 值访问 (便捷方法)
        SqlValue value(int index) const;
        SqlValue value(const std::string& name) const;
        bool isNull(int index) const;
        bool isNull(const std::string& name) const;

        // 查找和包含
        int indexOf(const std::string& name) const;  // -1 if not found
        bool contains(const std::string& name) const;

        // 修改 (通常由驱动内部使用来填充记录)
        void append(const SqlField& field);  // 添加一个字段 (元数据+值)
        void insert(int pos, const SqlField& field);
        void remove(int pos);
        void replace(int pos, const SqlField& field);
        void setValue(int index, const SqlValue& val);
        void setValue(const std::string& name, const SqlValue& val);
        void setNull(int index);
        void setNull(const std::string& name);
        void clear();  // 移除所有字段

      private:
        class Private;  // PImpl
        std::unique_ptr<Private> d;

        // SqlRecord 可以被拷贝和赋值
        SqlRecord(const SqlRecord& other);
        SqlRecord& operator=(const SqlRecord& other);
        SqlRecord(SqlRecord&& other) noexcept;
        SqlRecord& operator=(SqlRecord&& other) noexcept;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_result.h
#pragma once

#include <iosfwd>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "sql_enums.h"  // Provides ParamType, CursorMovement, SqlResultNs enums
#include "sql_error.h"
#include "sql_record.h"
#include "sql_value.h"  // Provides SqlValue, NumericalPrecisionPolicy, SqlValueType
// #include "sql_field.h" // Forward declare or include if needed

namespace cpporm_sqldriver {

    class SqlField;  // Forward declare for SqlResult::field()
    // struct SqlFieldExtendedInfo; // Forward declare if used

    class SqlResult {
      public:
        virtual ~SqlResult() = default;

        virtual bool prepare(const std::string& query, const std::map<std::string, SqlValueType>* named_bindings_type_hints = nullptr, SqlResultNs::ScrollMode scroll = SqlResultNs::ScrollMode::ForwardOnly, SqlResultNs::ConcurrencyMode concur = SqlResultNs::ConcurrencyMode::ReadOnly) = 0;
        virtual bool exec() = 0;
        virtual bool setQueryTimeout(int seconds) = 0;
        virtual bool setNumericalPrecisionPolicy(NumericalPrecisionPolicy policy) = 0;
        virtual bool setPrefetchSize(int rows) = 0;
        virtual int prefetchSize() const = 0;

        virtual void addPositionalBindValue(const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void setNamedBindValue(const std::string& placeholder, const SqlValue& value, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(int pos, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void bindBlobStream(const std::string& placeholder, std::shared_ptr<std::istream> stream, long long size = -1, ParamType type = ParamType::In) = 0;
        virtual void clearBindValues() = 0;
        virtual void reset() = 0;
        virtual bool setForwardOnly(bool forward) = 0;

        virtual bool fetchNext(SqlRecord& record_buffer) = 0;
        virtual bool fetchPrevious(SqlRecord& record_buffer) = 0;
        virtual bool fetchFirst(SqlRecord& record_buffer) = 0;
        virtual bool fetchLast(SqlRecord& record_buffer) = 0;
        virtual bool fetch(int index, SqlRecord& record_buffer, CursorMovement movement = CursorMovement::Absolute) = 0;

        virtual SqlValue data(int column_index) = 0;
        virtual std::shared_ptr<std::istream> openReadableBlobStream(int column_index) = 0;
        virtual std::shared_ptr<std::ostream> openWritableBlobStream(int column_index, long long initial_size_hint = 0) = 0;

        virtual bool isNull(int column_index) = 0;
        virtual SqlRecord recordMetadata() const = 0;
        virtual SqlRecord currentFetchedRow() const = 0;
        virtual SqlField field(int column_index) const = 0;
        // virtual SqlFieldExtendedInfo fieldExtendedInfo(int column_index) const = 0;

        virtual long long numRowsAffected() = 0;
        virtual SqlValue lastInsertId() = 0;
        virtual int columnCount() const = 0;
        virtual int size() = 0;
        virtual int at() const = 0;

        virtual bool isActive() const = 0;
        virtual bool isValid() const = 0;
        virtual SqlError error() const = 0;
        virtual const std::string& lastQuery() const = 0;
        virtual const std::string& preparedQueryText() const = 0;

        virtual void finish() = 0;
        virtual void clear() = 0;

        virtual bool nextResult() = 0;

        virtual SqlValue getOutParameter(int pos) const = 0;
        virtual SqlValue getOutParameter(const std::string& name) const = 0;
        virtual std::map<std::string, SqlValue> getAllOutParameters() const = 0;

        virtual bool setNamedBindingSyntax(SqlResultNs::NamedBindingSyntax syntax) = 0;
    };

}  // namespace cpporm_sqldriver// sqldriver/sql_value.h
#pragma once
#include <QByteArray>
#include <QDate>
#include <QDateTime>
#include <QTime>
#include <QVariant>
#include <any>
#include <chrono>
#include <iosfwd>
#include <memory>
#include <optional>
#include <string>
#include <typeinfo>
#include <variant>
#include <vector>

namespace cpporm_sqldriver {

    enum class SqlValueType {
        Null,
        Bool,
        Int8,
        UInt8,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        LongDouble,
        String,
        FixedString,
        ByteArray,
        BinaryLargeObject,
        CharacterLargeObject,
        Date,
        Time,
        DateTime,
        Timestamp,
        Interval,
        Decimal,
        Numeric,
        Json,
        Xml,
        Array,
        RowId,
        Custom,
        Unknown
    };

    enum class NumericalPrecisionPolicy { LowPrecision, HighPrecision, ExactRepresentation };

    class SqlValue {
      public:
        using ChronoDate = std::chrono::year_month_day;
        using ChronoTime = std::chrono::nanoseconds;
        using ChronoDateTime = std::chrono::system_clock::time_point;
        using BlobInputStream = std::shared_ptr<std::istream>;
        using BlobOutputStream = std::shared_ptr<std::ostream>;
        using ClobInputStream = std::shared_ptr<std::basic_istream<char>>;
        using ClobOutputStream = std::shared_ptr<std::basic_ostream<char>>;

        SqlValue();
        SqlValue(std::nullptr_t);
        SqlValue(bool val);
        SqlValue(int8_t val);
        SqlValue(uint8_t val);
        SqlValue(int16_t val);
        SqlValue(uint16_t val);
        SqlValue(int32_t val);
        SqlValue(uint32_t val);
        SqlValue(int64_t val);
        SqlValue(uint64_t val);
        SqlValue(float val);
        SqlValue(double val);
        SqlValue(long double val);
        SqlValue(const char* val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::string& val, SqlValueType type_hint = SqlValueType::String);
        SqlValue(const std::vector<unsigned char>& val);

        // SqlValue(const SqlDecimal& val);
        // SqlValue(const SqlJsonDocument& val);
        // SqlValue(const SqlXmlDocument& val);
        // template<typename T> SqlValue(const SqlArray<T>& val);

        SqlValue(BlobInputStream stream_handle, long long size = -1);
        SqlValue(ClobInputStream stream_handle, long long size = -1, const std::string& charset = "UTF-8");

        SqlValue(const QByteArray& val);
        SqlValue(const QDate& val);
        SqlValue(const QTime& val);
        SqlValue(const QDateTime& val);

        SqlValue(const ChronoDate& val);
        SqlValue(const ChronoTime& val);
        SqlValue(const ChronoDateTime& val);

        SqlValue(const SqlValue& other);
        SqlValue& operator=(const SqlValue& other);
        SqlValue(SqlValue&& other) noexcept;
        SqlValue& operator=(SqlValue&& other) noexcept;
        ~SqlValue();

        bool isNull() const;
        bool isValid() const;
        SqlValueType type() const;
        const char* typeName() const;
        std::string driverTypeName() const;
        void setDriverTypeName(const std::string& name);

        bool toBool(bool* ok = nullptr) const;
        int8_t toInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint8_t toUInt8(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int16_t toInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        uint16_t toUInt16(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        int32_t toInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;    // Corresponds to 'int'
        uint32_t toUInt32(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;  // Corresponds to 'unsigned int'
        int64_t toInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;    // Corresponds to 'long long'
        uint64_t toUInt64(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;  // Corresponds to 'unsigned long long'
        float toFloat(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        double toDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        long double toLongDouble(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::string toString(bool* ok = nullptr, NumericalPrecisionPolicy policy = NumericalPrecisionPolicy::LowPrecision) const;
        std::vector<unsigned char> toStdVectorUChar(bool* ok = nullptr) const;

        // SqlDecimal toDecimal(bool* ok = nullptr) const;
        // SqlJsonDocument toJsonDocument(bool* ok = nullptr) const;
        // SqlXmlDocument toXmlDocument(bool* ok = nullptr) const;
        // template<typename T> std::optional<SqlArray<T>> toArray(bool* ok = nullptr) const;

        BlobInputStream toBlobInputStream(bool* ok = nullptr) const;
        ClobInputStream toClobInputStream(bool* ok = nullptr) const;

        QByteArray toByteArray(bool* ok = nullptr) const;
        QDate toDate(bool* ok = nullptr) const;
        QTime toTime(bool* ok = nullptr) const;
        QDateTime toDateTime(bool* ok = nullptr) const;

        ChronoDate toChronoDate(bool* ok = nullptr) const;
        ChronoTime toChronoTime(bool* ok = nullptr) const;
        ChronoDateTime toChronoDateTime(bool* ok = nullptr) const;

        bool operator==(const SqlValue& other) const;
        bool operator!=(const SqlValue& other) const;

        void clear();

        QVariant toQVariant() const;
        static SqlValue fromQVariant(const QVariant& qv);

        std::any toStdAny() const;
        static SqlValue fromStdAny(const std::any& val, SqlValueType type_hint = SqlValueType::Custom);

      private:
        using StorageType = std::variant<std::monostate,
                                         bool,
                                         int8_t,
                                         uint8_t,
                                         int16_t,
                                         uint16_t,
                                         int32_t,
                                         uint32_t,
                                         int64_t,
                                         uint64_t,
                                         float,
                                         double,
                                         long double,
                                         std::string,
                                         std::vector<unsigned char>,
                                         BlobInputStream,
                                         ClobInputStream,
                                         QByteArray,
                                         QDate,
                                         QTime,
                                         QDateTime,
                                         ChronoDate,
                                         ChronoTime,
                                         ChronoDateTime,
                                         std::any>;
        StorageType value_;
        SqlValueType current_type_enum_ = SqlValueType::Null;
        std::string driver_type_name_;
        void updateCurrentTypeEnum();
    };

}  // namespace cpporm_sqldriverfile(GLOB_RECURSE MYSQL_TRANSPORT_SOURCE
    CONFIGURE_DEPENDS
    "Source/*.cpp"
    "Source/**/*.cpp"
)

add_library(MySqlTransport ${MYSQL_TRANSPORT_SOURCE})

target_include_directories(MySqlTransport
    PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/Include"
)

target_link_libraries(MySqlTransport PUBLIC Qt6::Core MysqlProtocol)

# # build example, no condition
# add_subdirectory(Example)
#pragma once

#include <mysql/mysql.h>

#include <optional>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportCharsetHandler {
      public:
        explicit MySqlTransportCharsetHandler(MySqlTransportConnection* connection_context);

        // Sets charset using mysql_set_character_set() if connected,
        // or mysql_options(MYSQL_SET_CHARSET_NAME) if before connection.
        // The 'is_pre_connect' flag indicates if this is called before mysql_real_connect.
        bool setClientCharset(MYSQL* mysql_handle, const std::string& charset_name, bool is_pre_connect);

        std::optional<std::string> getClientCharset(MYSQL* mysql_handle, bool is_connected) const;

      private:
        MySqlTransportConnection* m_conn_ctx;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportFieldMeta, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportColumnLister {
      public:
        explicit MySqlTransportColumnLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<MySqlTransportFieldMeta>> getTableColumns(const std::string& table_name, const std::string& db_name_filter = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");

        // Helper to parse the 'Type' string from SHOW COLUMNS output
        // This is a complex function and a key part of this lister.
        bool parseMySQLTypeString(const std::string& type_str, MySqlTransportFieldMeta& field_meta_to_update) const;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <atomic>
#include <memory>
#include <mutex>
#include <optional>
#include <string>

// Forward declare helper classes if they are only used by unique_ptr in private section
// Otherwise, include their headers directly.
// For PImpl, these are typical forward declarations:
// class MySqlTransportConnectionOptionsSetter;
// class MySqlTransportTransactionManager;
// class MySqlTransportCharsetHandler;
// class MySqlTransportServerInfoProvider;
// However, since they are included in the .cpp and their methods are called,
// it's better to include headers if they are not purely internal details of the PImpl.
// Given the current structure, they seem to be components.

#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"
#include "cpporm_mysql_transport/mysql_transport_connection_options_setter.h"
#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"
#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"
#include "cpporm_mysql_transport/mysql_transport_types.h"

namespace cpporm_mysql_transport {

    class MySqlTransportStatement;  // Forward declaration
    void ensure_mysql_library_initialized();
    void try_mysql_library_end();

    class MySqlTransportConnection {
      public:
        MySqlTransportConnection();
        ~MySqlTransportConnection();

        MySqlTransportConnection(const MySqlTransportConnection&) = delete;
        MySqlTransportConnection& operator=(const MySqlTransportConnection&) = delete;
        MySqlTransportConnection(MySqlTransportConnection&& other) noexcept;
        MySqlTransportConnection& operator=(MySqlTransportConnection&& other) noexcept;

        bool connect(const MySqlTransportConnectionParams& params);
        void disconnect();
        bool isConnected() const;
        bool ping(std::optional<unsigned int> timeout_seconds = std::nullopt);

        std::unique_ptr<MySqlTransportStatement> createStatement(const std::string& query);

        // Transaction methods delegated to m_transaction_manager
        bool beginTransaction();
        bool commit();
        bool rollback();
        bool setTransactionIsolation(TransactionIsolationLevel level);
        std::optional<TransactionIsolationLevel> getTransactionIsolation() const;
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        // Charset methods delegated to m_charset_handler
        bool setClientCharset(const std::string& charset_name);
        std::optional<std::string> getClientCharset() const;

        // Server info methods delegated to m_server_info_provider
        std::string getServerVersionString() const;
        unsigned long getServerVersionNumber() const;
        std::string getHostInfo() const;

        MySqlTransportError getLastError() const;
        std::string escapeString(const std::string& unescaped_str, bool treat_backslash_as_meta = true);

        MYSQL* getNativeHandle() const {
            return m_mysql_handle;
        }
        const MySqlTransportConnectionParams& getCurrentParams() const {
            return m_current_params;
        }

        // Methods for internal use by components (e.g., TransactionManager, CharsetHandler)
        // These should ideally be less public or managed via friend classes / interfaces.
        // For simplicity, making them public but with an underscore prefix to indicate intended internal use.
        bool _internalExecuteSimpleQuery(const std::string& query, const std::string& context_message);
        void setErrorFromMySqlHandle(MYSQL* handle_to_check_error_on, const std::string& context_message);
        void setErrorManually(MySqlTransportError::Category cat, const std::string& msg, int native_mysql_err = 0, const char* native_sql_state = nullptr, const char* native_mysql_msg = nullptr, unsigned int proto_errc = 0);
        void recordPreConnectOptionError(const std::string& option_error_message);

      private:
        void clearError();  // Clears m_last_error

        MYSQL* m_mysql_handle;
        bool m_is_connected;
        MySqlTransportConnectionParams m_current_params;
        MySqlTransportError m_last_error;
        TransactionIsolationLevel m_current_isolation_level;  // Cached isolation level for getTransactionIsolation

        // Components
        std::unique_ptr<MySqlTransportConnectionOptionsSetter> m_options_setter;
        std::unique_ptr<MySqlTransportTransactionManager> m_transaction_manager;
        std::unique_ptr<MySqlTransportCharsetHandler> m_charset_handler;
        std::unique_ptr<MySqlTransportServerInfoProvider> m_server_info_provider;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <map>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportConnectionParams, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration for context

    class MySqlTransportConnectionOptionsSetter {
      public:
        explicit MySqlTransportConnectionOptionsSetter(MySqlTransportConnection* connection_context);

        // Applies options from params to the MYSQL handle BEFORE mysql_real_connect
        // Returns true on success, false on failure (error set in connection_context)
        bool applyPreConnectOptions(MYSQL* mysql_handle, const MySqlTransportConnectionParams& params);

      private:
        MySqlTransportConnection* m_conn_ctx;  // Context to set errors

        // Helper to map SSL mode string to MySQL option value
        unsigned int mapSslModeStringToValue(const std::string& mode_str) const;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportDatabaseLister {
      public:
        explicit MySqlTransportDatabaseLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<std::string>> listDatabases(const std::string& db_name_pattern = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;  // For executing queries and accessing connection utilities
        mutable MySqlTransportError m_last_error;

        void clearError_();  // Suffix to avoid conflict if MySqlTransportMetadata also has one
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportIndexInfo, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportIndexLister {
      public:
        explicit MySqlTransportIndexLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<MySqlTransportIndexInfo>> getTableIndexes(const std::string& table_name, const std::string& db_name_filter = "");
        std::optional<MySqlTransportIndexInfo> getPrimaryIndex(const std::string& table_name, const std::string& db_name_filter = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");
    };

}  // namespace cpporm_mysql_transport#pragma once

#include "cpporm_mysql_transport/mysql_transport_types.h"
// Forward declarations for PImpl or direct inclusion of helper headers
#include <memory>  // For std::unique_ptr
#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_column_lister.h"
#include "cpporm_mysql_transport/mysql_transport_database_lister.h"
#include "cpporm_mysql_transport/mysql_transport_index_lister.h"
#include "cpporm_mysql_transport/mysql_transport_table_lister.h"

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportMetadata {
      public:
        explicit MySqlTransportMetadata(MySqlTransportConnection* conn);
        ~MySqlTransportMetadata();  // Required for unique_ptr to incomplete types if defined in .cpp

        // Movable (if unique_ptrs are handled correctly)
        MySqlTransportMetadata(MySqlTransportMetadata&& other) noexcept;
        MySqlTransportMetadata& operator=(MySqlTransportMetadata&& other) noexcept;
        // Non-copyable
        MySqlTransportMetadata(const MySqlTransportMetadata&) = delete;
        MySqlTransportMetadata& operator=(const MySqlTransportMetadata&) = delete;

        // Delegated methods
        std::optional<std::vector<std::string>> listDatabases(const std::string& db_name_pattern = "");
        std::optional<std::vector<std::string>> listTables(const std::string& db_name = "", const std::string& table_name_pattern = "");
        std::optional<std::vector<std::string>> listViews(const std::string& db_name = "", const std::string& view_name_pattern = "");
        std::optional<std::vector<MySqlTransportFieldMeta>> getTableColumns(const std::string& table_name, const std::string& db_name = "");
        std::optional<std::vector<MySqlTransportIndexInfo>> getTableIndexes(const std::string& table_name, const std::string& db_name = "");
        std::optional<MySqlTransportIndexInfo> getPrimaryIndex(const std::string& table_name, const std::string& db_name = "");

        MySqlTransportError getLastError() const;

      private:
        // MySqlTransportConnection* m_connection_ctx; // No longer needed if all ops are via listers that store it
        mutable MySqlTransportError m_last_error_aggregator;  // Aggregates error from the last lister call

        std::unique_ptr<MySqlTransportDatabaseLister> m_db_lister;
        std::unique_ptr<MySqlTransportTableLister> m_table_lister;
        std::unique_ptr<MySqlTransportColumnLister> m_column_lister;
        std::unique_ptr<MySqlTransportIndexLister> m_index_lister;

        void clearError();                                // Clears m_last_error_aggregator
        void setError(const MySqlTransportError& error);  // Sets m_last_error_aggregator

        // Template helper to call a lister and update aggregated error
        template <typename ListerPtr, typename Method, typename... Args>
        auto callLister(ListerPtr& lister_ptr, Method method, const std::string& error_context, Args&&... args) -> decltype(((*lister_ptr).*method)(std::forward<Args>(args)...));
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <memory>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    class MySqlTransportStatement;

    class MySqlTransportResult {
      public:
        // Constructor for PREPARED STATEMENTS (MYSQL_STMT*)
        MySqlTransportResult(MySqlTransportStatement* stmt, MYSQL_RES* meta_res_handle, MySqlTransportError& err_ref);
        // Constructor for NON-PREPARED STATEMENTS (MYSQL_RES* from mysql_store_result)
        MySqlTransportResult(MYSQL_RES* stored_res_handle, MySqlTransportError& err_ref);
        ~MySqlTransportResult();

        MySqlTransportResult(const MySqlTransportResult&) = delete;
        MySqlTransportResult& operator=(const MySqlTransportResult&) = delete;
        MySqlTransportResult(MySqlTransportResult&& other) noexcept;
        MySqlTransportResult& operator=(MySqlTransportResult&& other) noexcept;

        bool isValid() const;
        MySqlTransportError getError() const;
        my_ulonglong getRowCount() const;
        unsigned int getFieldCount() const;
        const std::vector<MySqlTransportFieldMeta>& getFieldsMeta() const;
        std::optional<MySqlTransportFieldMeta> getFieldMeta(unsigned int col_idx) const;
        std::optional<MySqlTransportFieldMeta> getFieldMeta(const std::string& col_name) const;
        int getFieldIndex(const std::string& col_name) const;

        bool fetchNextRow();
        std::optional<mysql_protocol::MySqlNativeValue> getValue(unsigned int col_idx);
        std::optional<mysql_protocol::MySqlNativeValue> getValue(const std::string& col_name);
        bool isNull(unsigned int col_idx);
        bool isNull(const std::string& col_name);
        std::vector<mysql_protocol::MySqlNativeValue> getCurrentRowValues();

        MYSQL_RES* getNativeMetadataHandle() const {
            return m_mysql_res_metadata;
        }  // For metadata
        MYSQL_STMT* getNativeStatementHandleForFetch() const {
            return m_mysql_stmt_handle_for_fetch;
        }  // For prepared stmt fetch

      private:
        void populateFieldsMeta();
        void clearCurrentRow();
        void setupOutputBindBuffers();  // Added declaration

        MySqlTransportStatement* m_statement;       // Null if from non-prepared MYSQL_RES
        MYSQL_RES* m_mysql_res_metadata;            // Metadata for prepared, or full result for non-prepared
        MYSQL_STMT* m_mysql_stmt_handle_for_fetch;  // Only for prepared statements for fetching
        MySqlTransportError& m_error_collector;     // Reference to error object (e.g., from statement or connection)

        std::vector<MySqlTransportFieldMeta> m_fields_meta;
        MYSQL_ROW m_current_sql_row;       // For non-prepared
        unsigned long* m_current_lengths;  // For non-prepared
        my_ulonglong m_row_count = 0;
        unsigned int m_field_count = 0;
        long long m_current_row_idx = -1;  // 0-based index of current fetched row, -1 if no row
        bool m_meta_populated = false;
        bool m_is_valid = false;
        bool m_is_from_prepared_statement = false;

        // For prepared statement result binding
        std::vector<MYSQL_BIND> m_output_bind_buffers;
        std::vector<std::vector<unsigned char>> m_output_data_buffers;
        std::vector<char> m_output_is_null_indicators;  // char (0 or 1)
        std::vector<unsigned long> m_output_length_indicators;
        std::vector<char> m_output_error_indicators;  // char (0 or 1) for truncation/error
        bool m_fetched_all_from_stmt = false;         // For prepared: true if MYSQL_NO_DATA was returned
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <string>

namespace cpporm_mysql_transport {

    // This class is very simple, could also be static methods or part of Connection directly.
    class MySqlTransportServerInfoProvider {
      public:
        // Constructor might not be needed if all methods are static or take MYSQL*
        MySqlTransportServerInfoProvider() = default;

        std::string getServerVersionString(MYSQL* mysql_handle) const;
        unsigned long getServerVersionNumber(MYSQL* mysql_handle) const;  // e.g., 80023 for 8.0.23
        std::string getHostInfo(MYSQL* mysql_handle, bool is_connected) const;
        // Potentially add more info getters, e.g., thread ID, protocol version
    };

}  // namespace cpporm_mysql_transport// (文件头部和其他部分不变)
#pragma once

#include <mysql/mysql.h>

#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "mysql_transport_result.h"
#include "mysql_transport_types.h"

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;

    class MySqlTransportStatement {
      public:
        // (构造函数、析构函数、拷贝/移动控制不变)
        MySqlTransportStatement(MySqlTransportConnection* conn, const std::string& query);
        ~MySqlTransportStatement();

        MySqlTransportStatement(const MySqlTransportStatement&) = delete;
        MySqlTransportStatement& operator=(const MySqlTransportStatement&) = delete;
        MySqlTransportStatement(MySqlTransportStatement&& other) noexcept;
        MySqlTransportStatement& operator=(MySqlTransportStatement&& other) noexcept;

        // (prepare, isPrepared, bindParam, bindParams, execute, executeQuery,
        //  getAffectedRows, getLastInsertId, getWarningCount, getError, close,
        //  getNativeStatementHandle, getConnection 不变)
        bool prepare();
        bool isPrepared() const;

        bool bindParam(unsigned int pos, const MySqlTransportBindParam& param);
        bool bindParams(const std::vector<MySqlTransportBindParam>& params);

        std::optional<my_ulonglong> execute();
        std::unique_ptr<MySqlTransportResult> executeQuery();

        my_ulonglong getAffectedRows() const;
        my_ulonglong getLastInsertId() const;
        unsigned int getWarningCount() const;

        MySqlTransportError getError() const;

        void close();

        MYSQL_STMT* getNativeStatementHandle() const {
            return m_stmt_handle;
        }
        MySqlTransportConnection* getConnection() const {
            return m_connection;
        }

      private:
        // (clearError, setError, setErrorFromMySQL, setErrorFromProtocol 不变)
        void clearError();
        void setError(MySqlTransportError::Category cat, const std::string& msg, unsigned int proto_errc = 0);
        void setErrorFromMySQL();  // Gets error from m_stmt_handle or connection if stmt_handle is null
        void setErrorFromProtocol(const mysql_protocol::MySqlProtocolError& proto_err, const std::string& context);

        MySqlTransportConnection* m_connection;
        std::string m_original_query;
        MYSQL_STMT* m_stmt_handle;
        bool m_is_prepared;

        std::vector<MYSQL_BIND> m_bind_buffers;
        std::vector<std::vector<unsigned char>> m_param_data_buffers;  // Data storage for params
        std::vector<char> m_param_is_null_indicators;                  // Use char for my_bool (0 or 1)
        std::vector<unsigned long> m_param_length_indicators;
        // 如果支持输出参数，MYSQL_BIND 中的 is_null 指针也应指向 bool 类型数组
        // std::vector<bool> m_result_is_null_indicators; // 如果结果也用bind

        MySqlTransportError m_last_error;
        my_ulonglong m_affected_rows;
        my_ulonglong m_last_insert_id;
        unsigned int m_warning_count;
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration

    class MySqlTransportTableLister {
      public:
        explicit MySqlTransportTableLister(MySqlTransportConnection* connection_context);

        std::optional<std::vector<std::string>> listTables(const std::string& db_name_filter = "", const std::string& table_name_pattern = "");
        std::optional<std::vector<std::string>> listViews(const std::string& db_name_filter = "", const std::string& view_name_pattern = "");

        MySqlTransportError getLastError() const;

      private:
        MySqlTransportConnection* m_conn_ctx;
        mutable MySqlTransportError m_last_error;

        void clearError_();
        void setError_(MySqlTransportError::Category cat, const std::string& msg);
        void setErrorFromConnection_(const std::string& context = "");

        // Helper for common logic of SHOW FULL TABLES
        std::optional<std::vector<std::string>> listShowFullTablesFiltered(const std::string& db_name_filter,
                                                                           const std::string& name_pattern,
                                                                           const std::string& target_table_type  // "BASE TABLE" or "VIEW"
        );
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <optional>
#include <string>

#include "cpporm_mysql_transport/mysql_transport_types.h"  // For TransactionIsolationLevel, MySqlTransportError

namespace cpporm_mysql_transport {

    class MySqlTransportConnection;  // Forward declaration for context

    class MySqlTransportTransactionManager {
      public:
        explicit MySqlTransportTransactionManager(MySqlTransportConnection* connection_context);

        bool beginTransaction();
        bool commit();
        bool rollback();
        bool setTransactionIsolation(TransactionIsolationLevel level);
        std::optional<TransactionIsolationLevel> getTransactionIsolation() const;  // May query server
        bool setSavepoint(const std::string& name);
        bool rollbackToSavepoint(const std::string& name);
        bool releaseSavepoint(const std::string& name);

        // This method is to update the cached isolation level if changed externally or on new connection
        void updateCachedIsolationLevel(TransactionIsolationLevel level);

      private:
        MySqlTransportConnection* m_conn_ctx;                // Pointer to the parent connection
        TransactionIsolationLevel m_cached_isolation_level;  // Cache to avoid frequent server queries

        // Helper to execute simple queries via the connection context
        bool executeSimpleQueryOnConnection(const std::string& query, const std::string& context_message);
    };

}  // namespace cpporm_mysql_transport#pragma once

#include <mysql/mysql.h>

#include <algorithm>  // For std::transform in toString example (if any)
#include <chrono>
#include <map>
#include <optional>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    // --- 错误处理 ---
    struct MySqlTransportError {
        enum class Category { NoError, ConnectionError, QueryError, DataError, ResourceError, TransactionError, InternalError, ProtocolError, ApiUsageError };

        Category category = Category::NoError;
        int native_mysql_errno = 0;
        std::string native_mysql_sqlstate;
        std::string native_mysql_error_msg;
        unsigned int protocol_internal_errc = 0;
        std::string message;
        std::string failed_query;

        MySqlTransportError() = default;
        MySqlTransportError(Category cat, std::string msg, int mysql_err = 0, const char* mysql_state = nullptr, const char* mysql_msg = nullptr, unsigned int proto_errc = 0, std::string query = "");
        bool isOk() const {
            return category == Category::NoError;
        }
        std::string toString() const;
    };

    // --- 连接参数 ---
    struct MySqlTransportConnectionParams {
        std::string host = "localhost";
        unsigned int port = 3306;
        std::string user;
        std::string password;
        std::string db_name;
        std::string unix_socket;
        unsigned long client_flag = 0;
        std::optional<unsigned int> connect_timeout_seconds;
        std::optional<unsigned int> read_timeout_seconds;
        std::optional<unsigned int> write_timeout_seconds;
        std::optional<std::string> charset;
        std::map<std::string, std::string> ssl_options;
        std::map<mysql_option, std::string> generic_options;
        std::map<std::string, std::string> init_commands;
    };

    // --- 事务隔离级别 ---
    enum class TransactionIsolationLevel { None, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable };

    // --- 字段元数据 ---
    struct MySqlTransportFieldMeta {
        std::string name;
        std::string original_name;
        std::string table;
        std::string original_table;
        std::string db;
        std::string catalog = "def";
        enum enum_field_types native_type_id = MYSQL_TYPE_NULL;
        uint16_t charsetnr = 0;
        unsigned long length = 0;
        unsigned long max_length = 0;
        unsigned int flags = 0;
        unsigned int decimals = 0;
        mysql_protocol::MySqlNativeValue default_value;

        bool isPrimaryKey() const {
            return flags & PRI_KEY_FLAG;
        }
        bool isNotNull() const {
            return flags & NOT_NULL_FLAG;
        }
        bool isUniqueKey() const {
            return flags & UNIQUE_KEY_FLAG;
        }
        bool isMultipleKey() const {
            return flags & MULTIPLE_KEY_FLAG;
        }
        bool isAutoIncrement() const {
            return flags & AUTO_INCREMENT_FLAG;
        }
        bool isUnsigned() const {
            return flags & UNSIGNED_FLAG;
        }
        bool isZerofill() const {
            return flags & ZEROFILL_FLAG;
        }
        bool isBinary() const {
            return flags & BINARY_FLAG;
        }
        bool isEnum() const {
            return flags & ENUM_FLAG;
        }
        bool isSet() const {
            return flags & SET_FLAG;
        }
        bool isBlob() const {
            return flags & BLOB_FLAG;
        }
        bool isTimestamp() const {
            return flags & TIMESTAMP_FLAG;
        }
        bool isPartOfKey() const {
            return flags & PART_KEY_FLAG;
        }
        bool isGroup() const {
            return flags & GROUP_FLAG;
        }

        bool isGenerallyNumeric() const;
        bool isGenerallyString() const;
        bool isGenerallyDateTime() const;
    };

    // --- 参数绑定类型 ---
    struct MySqlTransportBindParam {
        mysql_protocol::MySqlNativeValue value;

        MySqlTransportBindParam();
        MySqlTransportBindParam(const mysql_protocol::MySqlNativeValue& v);
        MySqlTransportBindParam(mysql_protocol::MySqlNativeValue&& v);
        MySqlTransportBindParam(std::nullptr_t);
        MySqlTransportBindParam(bool val);
        MySqlTransportBindParam(int8_t val);
        MySqlTransportBindParam(uint8_t val);
        MySqlTransportBindParam(int16_t val);
        MySqlTransportBindParam(uint16_t val);
        MySqlTransportBindParam(int32_t val);
        MySqlTransportBindParam(uint32_t val);
        MySqlTransportBindParam(int64_t val);
        MySqlTransportBindParam(uint64_t val);
        MySqlTransportBindParam(float val);
        MySqlTransportBindParam(double val);
        MySqlTransportBindParam(const char* val);
        MySqlTransportBindParam(const std::string& val);
        MySqlTransportBindParam(std::string&& val);
        MySqlTransportBindParam(std::string_view val);
        MySqlTransportBindParam(const std::vector<unsigned char>& val);
        MySqlTransportBindParam(std::vector<unsigned char>&& val);
        MySqlTransportBindParam(const MYSQL_TIME& val);
        MySqlTransportBindParam(const std::chrono::system_clock::time_point& tp);
        MySqlTransportBindParam(const std::chrono::year_month_day& ymd);
        MySqlTransportBindParam(const std::chrono::microseconds& duration);
    };

    // --- 索引信息 (moved from mysql_transport_metadata.h for proper declaration order) ---
    struct MySqlTransportIndexColumn {
        std::string columnName;
        unsigned int sequenceInIndex = 0;
        std::optional<std::string> collation;
        std::optional<long long> cardinality;
        std::optional<unsigned int> subPart;
        bool isNullable = false;
        std::optional<std::string> expression;
    };

    struct MySqlTransportIndexInfo {
        std::string tableName;
        bool isNonUnique = true;
        std::string indexName;
        std::string indexType;
        std::vector<MySqlTransportIndexColumn> columns;
        std::string comment;
        std::string indexComment;
        bool isVisible = true;
    };

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_charset_handler.h"

#include <mysql/mysql.h>

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For setting errors on the connection context

namespace cpporm_mysql_transport {

    MySqlTransportCharsetHandler::MySqlTransportCharsetHandler(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            // This is a programming error.
            // MySqlTransportConnection should ensure this is constructed with a valid context.
            // If we want to be super robust, this handler could have an 'isValid' state.
        }
    }

    bool MySqlTransportCharsetHandler::setClientCharset(MYSQL* mysql_handle, const std::string& charset_name, bool is_pre_connect) {
        if (!mysql_handle) {
            if (m_conn_ctx) {
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::InternalError, "CharsetHandler: MySQL handle not initialized for setClientCharset operation.");
            }
            return false;
        }
        if (charset_name.empty()) {
            if (m_conn_ctx) {
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "CharsetHandler: Charset name cannot be empty for setClientCharset.");
            }
            return false;
        }

        // The MySqlTransportConnection is responsible for clearing its own error state (m_last_error)
        // before calling this component's method. This component will then use the connection's
        // setErrorFromMySqlHandle or setErrorManually to set the error if its specific operation fails.

        int err_code = 0;
        if (is_pre_connect) {
            // Called before mysql_real_connect, use mysql_options
            err_code = mysql_options(mysql_handle, MYSQL_SET_CHARSET_NAME, charset_name.c_str());
        } else {
            // Called after mysql_real_connect, use mysql_set_character_set
            if (m_conn_ctx && !m_conn_ctx->isConnected()) {  // Sanity check
                m_conn_ctx->setErrorManually(MySqlTransportError::Category::ConnectionError, "CharsetHandler: Attempted to set charset on a non-connected session (post-connect path).");
                return false;
            }
            err_code = mysql_set_character_set(mysql_handle, charset_name.c_str());
        }

        if (err_code != 0) {
            if (m_conn_ctx) {
                // Let the connection set its error state using its handle, providing context.
                m_conn_ctx->setErrorFromMySqlHandle(mysql_handle, "Failed to set client character set to '" + charset_name + "'");
            }
            return false;
        }

        // If successful, MySqlTransportConnection might update its cached m_current_params.charset
        if (m_conn_ctx && !is_pre_connect) {  // Only update if connected and successful
            // MySqlTransportConnection should manage its m_current_params directly after calling this.
        }
        return true;
    }

    std::optional<std::string> MySqlTransportCharsetHandler::getClientCharset(MYSQL* mysql_handle, bool is_connected) const {
        if (!mysql_handle) {
            // Should not be called by MySqlTransportConnection if handle is null.
            if (m_conn_ctx) {
                // This might be an internal logic error if conn_ctx allowed this call.
                // m_conn_ctx->setErrorManually(MySqlTransportError::Category::InternalError, "CharsetHandler: Null handle for getClientCharset.");
            }
            return std::nullopt;
        }

        if (is_connected) {
            const char* charset_c_str = mysql_character_set_name(mysql_handle);
            if (charset_c_str) {
                return std::string(charset_c_str);
            }
            // If mysql_character_set_name returns null, it might indicate an error or unknown state.
            // The MySqlTransportConnection could check its own error status after this call if nullopt is unexpected.
            if (m_conn_ctx && mysql_errno(mysql_handle) != 0) {
                // m_conn_ctx->setErrorFromMySqlHandle(mysql_handle, "Failed to get client character set name.");
                // Best not to modify error state in a const getter. Caller should handle.
            }
        } else {
            // If not connected, the actual charset on the server side isn't established.
            // MySqlTransportConnection might have a cached 'intended' charset from params,
            // but this component (CharsetHandler) only deals with the live MYSQL handle.
        }
        return std::nullopt;  // Indicates charset could not be determined from the live handle in its current state
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_column_lister.h"

#include <mysql/mysql_com.h>  // For MYSQL_TYPE_ enums, if not fully in mysql.h

#include <algorithm>  // For std::transform, std::tolower
#include <sstream>    // For parsing parts of type string

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportColumnLister::MySqlTransportColumnLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "ColumnLister: Null connection context provided.");
        }
    }

    void MySqlTransportColumnLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportColumnLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportColumnLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    // Placeholder for a more robust MySQL type string parser
    // Example type_str: "int(11)", "varchar(255)", "decimal(10,2) unsigned", "enum('a','b') zerofill"
    bool MySqlTransportColumnLister::parseMySQLTypeString(const std::string& type_str_orig, MySqlTransportFieldMeta& field_meta) const {
        if (type_str_orig.empty()) return false;

        std::string type_str = type_str_orig;
        std::transform(type_str.begin(), type_str.end(), type_str.begin(), [](unsigned char c) {
            return std::tolower(c);
        });

        // Handle attributes first
        if (type_str.find("unsigned") != std::string::npos) {
            field_meta.flags |= UNSIGNED_FLAG;
            size_t pos = type_str.find("unsigned");
            type_str.replace(pos, 8, "");  // Remove "unsigned"
        }
        if (type_str.find("zerofill") != std::string::npos) {
            field_meta.flags |= ZEROFILL_FLAG;
            size_t pos = type_str.find("zerofill");
            type_str.replace(pos, 8, "");  // Remove "zerofill"
        }
        // Trim whitespace that might be left
        type_str.erase(0, type_str.find_first_not_of(" \t\n\r\f\v"));
        type_str.erase(type_str.find_last_not_of(" \t\n\r\f\v") + 1);

        std::string base_type;
        size_t paren_open = type_str.find('(');
        size_t paren_close = type_str.find(')');

        if (paren_open != std::string::npos && paren_close != std::string::npos && paren_close > paren_open) {
            base_type = type_str.substr(0, paren_open);
            std::string params_str = type_str.substr(paren_open + 1, paren_close - (paren_open + 1));

            // Simple numeric types with length/precision
            if (base_type == "tinyint" || base_type == "smallint" || base_type == "mediumint" || base_type == "int" || base_type == "bigint" || base_type == "bit") {
                try {
                    field_meta.length = std::stoul(params_str);
                } catch (...) { /* ignore parse error for length */
                }
            } else if (base_type == "char" || base_type == "varchar" || base_type == "binary" || base_type == "varbinary") {
                try {
                    field_meta.length = std::stoul(params_str);
                } catch (...) { /* ignore */
                }
            } else if (base_type == "float" || base_type == "double" || base_type == "real" || base_type == "decimal" || base_type == "numeric") {
                size_t comma_pos = params_str.find(',');
                if (comma_pos != std::string::npos) {
                    try {
                        field_meta.length = std::stoul(params_str.substr(0, comma_pos));
                    } catch (...) { /*ignore*/
                    }  // M (precision)
                    try {
                        field_meta.decimals = std::stoul(params_str.substr(comma_pos + 1));
                    } catch (...) { /*ignore*/
                    }  // D (scale)
                } else {  // Only M specified
                    try {
                        field_meta.length = std::stoul(params_str);
                    } catch (...) { /*ignore*/
                    }
                }
            }
            // For ENUM and SET, params_str contains the list of values.
            // field_meta.length is not typically set from this for enum/set in a numeric way.
            // The display length of enum/set is the length of the longest string.
        } else {
            base_type = type_str;  // Type without parameters like DATE, TEXT, BLOB
        }

        // Map base_type string to enum enum_field_types
        if (base_type == "tinyint")
            field_meta.native_type_id = MYSQL_TYPE_TINY;
        else if (base_type == "smallint")
            field_meta.native_type_id = MYSQL_TYPE_SHORT;
        else if (base_type == "mediumint")
            field_meta.native_type_id = MYSQL_TYPE_INT24;
        else if (base_type == "int" || base_type == "integer")
            field_meta.native_type_id = MYSQL_TYPE_LONG;
        else if (base_type == "bigint")
            field_meta.native_type_id = MYSQL_TYPE_LONGLONG;
        else if (base_type == "float")
            field_meta.native_type_id = MYSQL_TYPE_FLOAT;
        else if (base_type == "double" || base_type == "real")
            field_meta.native_type_id = MYSQL_TYPE_DOUBLE;
        else if (base_type == "decimal" || base_type == "numeric" || base_type == "dec")
            field_meta.native_type_id = MYSQL_TYPE_NEWDECIMAL;  // Or MYSQL_TYPE_DECIMAL
        else if (base_type == "date")
            field_meta.native_type_id = MYSQL_TYPE_DATE;
        else if (base_type == "datetime")
            field_meta.native_type_id = MYSQL_TYPE_DATETIME;
        else if (base_type == "timestamp")
            field_meta.native_type_id = MYSQL_TYPE_TIMESTAMP;
        else if (base_type == "time")
            field_meta.native_type_id = MYSQL_TYPE_TIME;
        else if (base_type == "year")
            field_meta.native_type_id = MYSQL_TYPE_YEAR;
        else if (base_type == "char")
            field_meta.native_type_id = MYSQL_TYPE_STRING;
        else if (base_type == "varchar")
            field_meta.native_type_id = MYSQL_TYPE_VAR_STRING;  // Or MYSQL_TYPE_VARCHAR
        else if (base_type == "tinytext") {
            field_meta.native_type_id = MYSQL_TYPE_TINY_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "text") {
            field_meta.native_type_id = MYSQL_TYPE_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "mediumtext") {
            field_meta.native_type_id = MYSQL_TYPE_MEDIUM_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "longtext") {
            field_meta.native_type_id = MYSQL_TYPE_LONG_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "tinyblob") {
            field_meta.native_type_id = MYSQL_TYPE_TINY_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "blob") {
            field_meta.native_type_id = MYSQL_TYPE_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "mediumblob") {
            field_meta.native_type_id = MYSQL_TYPE_MEDIUM_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "longblob") {
            field_meta.native_type_id = MYSQL_TYPE_LONG_BLOB;
            field_meta.flags |= BLOB_FLAG;
        } else if (base_type == "binary")
            field_meta.native_type_id = MYSQL_TYPE_STRING;  // Fixed-length binary
        else if (base_type == "varbinary")
            field_meta.native_type_id = MYSQL_TYPE_VAR_STRING;  // Var-length binary
        else if (base_type == "enum") {
            field_meta.native_type_id = MYSQL_TYPE_ENUM;
            field_meta.flags |= ENUM_FLAG;
        } else if (base_type == "set") {
            field_meta.native_type_id = MYSQL_TYPE_SET;
            field_meta.flags |= SET_FLAG;
        } else if (base_type == "bit")
            field_meta.native_type_id = MYSQL_TYPE_BIT;
        else if (base_type == "json")
            field_meta.native_type_id = MYSQL_TYPE_JSON;
        // MYSQL_TYPE_GEOMETRY, etc.
        else {
            // Unknown type, or needs more specific parsing
            field_meta.native_type_id = MYSQL_TYPE_STRING;  // Fallback
        }

        return true;
    }

    std::optional<std::vector<MySqlTransportFieldMeta>> MySqlTransportColumnLister::getTableColumns(const std::string& table_name, const std::string& db_name_filter_param) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for getTableColumns.");
            return std::nullopt;
        }
        if (table_name.empty()) {
            setError_(MySqlTransportError::Category::ApiUsageError, "Table name cannot be empty for getTableColumns.");
            return std::nullopt;
        }
        clearError_();

        std::string db_to_use = db_name_filter_param;
        if (db_to_use.empty()) {
            db_to_use = m_conn_ctx->getCurrentParams().db_name;
            if (db_to_use.empty()) {
                setError_(MySqlTransportError::Category::ApiUsageError, "Database name not specified for getTableColumns.");
                return std::nullopt;
            }
        }

        std::string fq_table_name = "`" + m_conn_ctx->escapeString(db_to_use, false) + "`.`" + m_conn_ctx->escapeString(table_name, false) + "`";

        std::string query = "SHOW FULL COLUMNS FROM " + fq_table_name;
        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for getTableColumns for " + fq_table_name);
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::vector<MySqlTransportFieldMeta> columns_meta_vec;

        int idx_field = result->getFieldIndex("Field");
        int idx_type = result->getFieldIndex("Type");
        int idx_collation = result->getFieldIndex("Collation");
        int idx_null = result->getFieldIndex("Null");
        int idx_key = result->getFieldIndex("Key");
        int idx_default = result->getFieldIndex("Default");
        int idx_extra = result->getFieldIndex("Extra");
        int idx_comment = result->getFieldIndex("Comment");  // SHOW FULL COLUMNS has Comment
        // Privileges are less commonly needed for basic ORM/driver field metadata.

        if (idx_field == -1 || idx_type == -1) {
            setError_(MySqlTransportError::Category::InternalError, "Could not find 'Field' or 'Type' columns in SHOW FULL COLUMNS output.");
            return std::nullopt;
        }

        while (result->fetchNextRow()) {
            MySqlTransportFieldMeta col_meta;

            auto field_val = result->getValue(static_cast<unsigned int>(idx_field));
            if (field_val && field_val->get_if<std::string>())
                col_meta.name = *field_val->get_if<std::string>();
            else
                continue;

            col_meta.original_name = col_meta.name;

            auto type_val = result->getValue(static_cast<unsigned int>(idx_type));
            if (type_val && type_val->get_if<std::string>()) {
                parseMySQLTypeString(*type_val->get_if<std::string>(), col_meta);
            } else
                continue;

            if (idx_collation != -1) {
                auto coll_val_opt = result->getValue(static_cast<unsigned int>(idx_collation));
                if (coll_val_opt && !coll_val_opt->is_null()) {
                    if (const auto* coll_str = coll_val_opt->get_if<std::string>()) {
                        // TODO: Need a robust way to get charsetnr from collation name.
                        // This often involves querying information_schema.COLLATIONS or having a built-in map.
                        // For now, leave col_meta.charsetnr as 0 or try a very basic guess if possible.
                        // Example: if coll_str starts with "utf8mb4_", charsetnr might correspond to utf8mb4.
                        // MYSQL_FIELD has this directly, but SHOW COLUMNS output needs parsing.
                    }
                }
            }

            if (idx_null != -1) {
                auto null_val_opt = result->getValue(static_cast<unsigned int>(idx_null));
                if (null_val_opt && null_val_opt->get_if<std::string>() && *null_val_opt->get_if<std::string>() == "NO") {
                    col_meta.flags |= NOT_NULL_FLAG;
                }
            }

            if (idx_key != -1) {
                auto key_val_opt = result->getValue(static_cast<unsigned int>(idx_key));
                if (key_val_opt && !key_val_opt->is_null() && key_val_opt->get_if<std::string>()) {
                    const std::string& key_str = *key_val_opt->get_if<std::string>();
                    if (key_str == "PRI")
                        col_meta.flags |= PRI_KEY_FLAG;
                    else if (key_str == "UNI")
                        col_meta.flags |= UNIQUE_KEY_FLAG;
                    else if (key_str == "MUL")
                        col_meta.flags |= MULTIPLE_KEY_FLAG;
                }
            }

            if (idx_default != -1) {
                auto def_val_opt = result->getValue(static_cast<unsigned int>(idx_default));
                if (def_val_opt) {
                    col_meta.default_value = std::move(def_val_opt.value());
                    // The MySqlNativeValue from result->getValue should already have an appropriate
                    // original_mysql_type based on how SHOW COLUMNS returns default values.
                    // If it's always string, then MySqlNativeValue will hold a string.
                }
            }

            if (idx_extra != -1) {
                auto extra_val_opt = result->getValue(static_cast<unsigned int>(idx_extra));
                if (extra_val_opt && !extra_val_opt->is_null() && extra_val_opt->get_if<std::string>()) {
                    const std::string& extra_str = *extra_val_opt->get_if<std::string>();
                    if (extra_str.find("auto_increment") != std::string::npos) col_meta.flags |= AUTO_INCREMENT_FLAG;
                    // Parse other "extra" info: e.g., "on update CURRENT_TIMESTAMP", "STORED GENERATED", "VIRTUAL GENERATED"
                }
            }
            col_meta.table = table_name;
            col_meta.db = db_to_use;
            // col_meta.catalog remains "def"

            columns_meta_vec.push_back(col_meta);
        }
        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }
        return columns_meta_vec;
    }

    MySqlTransportError MySqlTransportColumnLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_connection.h"

#include <mysql/mysql.h>

#include <algorithm>
#include <stdexcept>
#include <vector>

#include "cpporm_mysql_transport/mysql_transport_statement.h"
// #include "mysql_protocol/mysql_constants.h" // Not directly used here usually
// #include "mysql_protocol/mysql_type_converter.h" // Not directly used here usually

namespace cpporm_mysql_transport {

    static std::atomic<int> g_mysql_library_init_count(0);
    static std::mutex g_mysql_library_mutex;

    void ensure_mysql_library_initialized() {
        std::lock_guard<std::mutex> lock(g_mysql_library_mutex);
        if (g_mysql_library_init_count.fetch_add(1, std::memory_order_relaxed) == 0) {
            if (mysql_library_init(0, nullptr, nullptr)) {
                g_mysql_library_init_count.fetch_sub(1, std::memory_order_relaxed);
                throw std::runtime_error("Failed to initialize MySQL C library");
            }
        }
    }

    void try_mysql_library_end() {
        std::lock_guard<std::mutex> lock(g_mysql_library_mutex);
        if (g_mysql_library_init_count.load(std::memory_order_relaxed) > 0) {
            if (g_mysql_library_init_count.fetch_sub(1, std::memory_order_relaxed) == 1) {
                mysql_library_end();
            }
        }
    }

    MySqlTransportConnection::MySqlTransportConnection() : m_mysql_handle(nullptr), m_is_connected(false), m_current_isolation_level(TransactionIsolationLevel::None) {
        ensure_mysql_library_initialized();
        m_mysql_handle = mysql_init(nullptr);
        if (!m_mysql_handle) {
            // mysql_init rarely fails. If it does, it's critical (e.g. out of memory).
            // We can't use mysql_error() here as handle is null.
            m_last_error = MySqlTransportError(MySqlTransportError::Category::ResourceError, "mysql_init() failed (out of memory?)");
            // Optionally throw, as the object is unusable.
            // throw std::runtime_error("MySqlTransportConnection: mysql_init() failed.");
        }
        // Initialize components
        m_options_setter = std::make_unique<MySqlTransportConnectionOptionsSetter>(this);
        m_transaction_manager = std::make_unique<MySqlTransportTransactionManager>(this);
        m_charset_handler = std::make_unique<MySqlTransportCharsetHandler>(this);
        m_server_info_provider = std::make_unique<MySqlTransportServerInfoProvider>();  // Does not need 'this'
    }

    MySqlTransportConnection::~MySqlTransportConnection() {
        disconnect();
        if (m_mysql_handle) {
            mysql_close(m_mysql_handle);
            m_mysql_handle = nullptr;
        }
        try_mysql_library_end();
    }

    MySqlTransportConnection::MySqlTransportConnection(MySqlTransportConnection&& other) noexcept
        : m_mysql_handle(other.m_mysql_handle),
          m_is_connected(other.m_is_connected),
          m_current_params(std::move(other.m_current_params)),
          m_last_error(std::move(other.m_last_error)),
          m_current_isolation_level(other.m_current_isolation_level),
          m_options_setter(std::move(other.m_options_setter)),
          m_transaction_manager(std::move(other.m_transaction_manager)),
          m_charset_handler(std::move(other.m_charset_handler)),
          m_server_info_provider(std::move(other.m_server_info_provider)) {
        other.m_mysql_handle = nullptr;
        other.m_is_connected = false;
        // Update context in moved-from components if they store 'this'
        if (m_options_setter) m_options_setter->m_conn_ctx = this;  // Example if setter has public m_conn_ctx for update
        if (m_transaction_manager) m_transaction_manager->m_conn_ctx = this;
        if (m_charset_handler) m_charset_handler->m_conn_ctx = this;
    }

    MySqlTransportConnection& MySqlTransportConnection::operator=(MySqlTransportConnection&& other) noexcept {
        if (this != &other) {
            disconnect();
            if (m_mysql_handle) {
                mysql_close(m_mysql_handle);
            }

            m_mysql_handle = other.m_mysql_handle;
            m_is_connected = other.m_is_connected;
            m_current_params = std::move(other.m_current_params);
            m_last_error = std::move(other.m_last_error);
            m_current_isolation_level = other.m_current_isolation_level;
            m_options_setter = std::move(other.m_options_setter);
            m_transaction_manager = std::move(other.m_transaction_manager);
            m_charset_handler = std::move(other.m_charset_handler);
            m_server_info_provider = std::move(other.m_server_info_provider);

            other.m_mysql_handle = nullptr;
            other.m_is_connected = false;

            if (m_options_setter) m_options_setter->m_conn_ctx = this;
            if (m_transaction_manager) m_transaction_manager->m_conn_ctx = this;
            if (m_charset_handler) m_charset_handler->m_conn_ctx = this;
        }
        return *this;
    }

    bool MySqlTransportConnection::connect(const MySqlTransportConnectionParams& params) {
        if (m_is_connected) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, "Already connected. Disconnect first.");
            return false;
        }
        if (!m_mysql_handle) {
            setErrorManually(MySqlTransportError::Category::InternalError, "MySQL handle is null before connect (mysql_init failed?).");
            return false;
        }
        if (!m_options_setter) {  // Should have been initialized
            setErrorManually(MySqlTransportError::Category::InternalError, "Connection options setter not initialized.");
            return false;
        }

        clearError();
        m_current_params = params;  // Store current params

        // Apply pre-connect options using the dedicated setter component
        if (!m_options_setter->applyPreConnectOptions(m_mysql_handle, params)) {
            // Error should already be set by m_options_setter via recordPreConnectOptionError
            // or by direct calls to setErrorFromMySqlHandle if it could use the handle.
            // If applyPreConnectOptions sets error on this connection context, we are good.
            if (m_last_error.isOk()) {  // If setter didn't set, provide a generic one
                setErrorFromMySqlHandle(m_mysql_handle, "Failed to apply pre-connect options");
            }
            return false;
        }

        const char* host_ptr = params.host.empty() ? nullptr : params.host.c_str();
        const char* user_ptr = params.user.empty() ? nullptr : params.user.c_str();
        const char* passwd_ptr = params.password.empty() ? nullptr : params.password.c_str();
        const char* db_ptr = params.db_name.empty() ? nullptr : params.db_name.c_str();
        unsigned int port_val = params.port == 0 ? 3306 : params.port;  // Default port if 0
        const char* unix_socket_ptr = params.unix_socket.empty() ? nullptr : params.unix_socket.c_str();

        if (!mysql_real_connect(m_mysql_handle, host_ptr, user_ptr, passwd_ptr, db_ptr, port_val, unix_socket_ptr, params.client_flag)) {
            setErrorFromMySqlHandle(m_mysql_handle, "mysql_real_connect failed");
            // Optional: attempt to re-init m_mysql_handle for future connect attempts
            // mysql_close(m_mysql_handle); m_mysql_handle = mysql_init(nullptr);
            return false;
        }

        m_is_connected = true;

        // Set client character set if specified (after connection)
        if (params.charset.has_value() && !params.charset.value().empty()) {
            if (!setClientCharset(params.charset.value())) {
                // Error already set by setClientCharset (via m_charset_handler)
                disconnect();  // Failed post-connection setup
                return false;
            }
        }

        // Execute init commands
        for (const auto& pair : params.init_commands) {
            // Values in init_commands might need escaping if they are strings.
            // Assuming simple key=value pairs for now, where value might be a quoted string already or numeric.
            // A more robust solution would parse the value.
            std::string command = pair.first;              // Example: "SET SESSION sql_mode='TRADITIONAL'"
            if (!pair.second.empty()) {                    // if value is provided
                command = pair.first + "=" + pair.second;  // Example: "sql_mode" = "'TRADITIONAL'"
            }

            if (!_internalExecuteSimpleQuery(command, "Failed to execute init command: " + pair.first)) {
                disconnect();
                return false;
            }
        }

        // After successful connection, determine and cache the initial transaction isolation level.
        // This makes getTransactionIsolation() faster if not changed.
        auto initial_level_opt = m_transaction_manager->getTransactionIsolation();  // Query server
        if (initial_level_opt) {
            m_current_isolation_level = *initial_level_opt;
            m_transaction_manager->updateCachedIsolationLevel(*initial_level_opt);
        } else {
            m_current_isolation_level = TransactionIsolationLevel::None;  // Unknown or server default
            m_transaction_manager->updateCachedIsolationLevel(TransactionIsolationLevel::None);
        }

        return true;
    }

    void MySqlTransportConnection::disconnect() {
        if (m_is_connected) {
            // Resources managed by MYSQL* (like results of mysql_store_result not yet freed)
            // are typically cleaned up by mysql_close().
            // Prepared statements should be closed before disconnecting.
        }
        m_is_connected = false;
        // Don't nullify m_mysql_handle, destructor will mysql_close it.
        // Or, if disconnect means "can be reconnected later with same object":
        // mysql_close(m_mysql_handle); m_mysql_handle = mysql_init(nullptr);
        // For simplicity, assume ~MySqlTransportConnection is the main cleanup point for the handle.
    }

    bool MySqlTransportConnection::isConnected() const {
        return m_is_connected && m_mysql_handle;
    }

    bool MySqlTransportConnection::ping(std::optional<unsigned int> /*timeout_seconds*/) {
        if (!isConnected()) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, "Not connected to server for ping.");
            return false;
        }
        clearError();
        // mysql_ping does not accept a timeout.
        if (mysql_ping(m_mysql_handle) != 0) {
            setErrorFromMySqlHandle(m_mysql_handle, "mysql_ping failed (connection may be down)");
            m_is_connected = false;  // Assume connection is lost on ping failure
            return false;
        }
        return true;
    }

    std::unique_ptr<MySqlTransportStatement> MySqlTransportConnection::createStatement(const std::string& query) {
        if (!m_mysql_handle) {  // Main check is for a valid MYSQL object
                                // Let statement constructor handle null connection by setting its own error.
        }
        return std::make_unique<MySqlTransportStatement>(this, query);
    }

    bool MySqlTransportConnection::beginTransaction() {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->beginTransaction();
    }
    bool MySqlTransportConnection::commit() {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->commit();
    }
    bool MySqlTransportConnection::rollback() {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->rollback();
    }
    bool MySqlTransportConnection::setTransactionIsolation(TransactionIsolationLevel level) {
        if (!m_transaction_manager) return false;
        bool success = m_transaction_manager->setTransactionIsolation(level);
        if (success) {
            m_current_isolation_level = level;  // Update local cache
        }
        return success;
    }
    std::optional<TransactionIsolationLevel> MySqlTransportConnection::getTransactionIsolation() const {
        if (!m_transaction_manager) return std::nullopt;
        // Prefer locally cached if valid, else query via manager (which might also cache or query server)
        if (m_current_isolation_level != TransactionIsolationLevel::None) {
            return m_current_isolation_level;
        }
        auto level_opt = m_transaction_manager->getTransactionIsolation();
        if (level_opt) {
            // const_cast is needed if we want to update cache in a const method.
            // Better to make m_current_isolation_level mutable or query in non-const if update is desired.
            // Or, the manager handles its own caching.
            // For now, let manager handle caching, this only returns current belief.
        }
        return level_opt;
    }
    bool MySqlTransportConnection::setSavepoint(const std::string& name) {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->setSavepoint(name);
    }
    bool MySqlTransportConnection::rollbackToSavepoint(const std::string& name) {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->rollbackToSavepoint(name);
    }
    bool MySqlTransportConnection::releaseSavepoint(const std::string& name) {
        if (!m_transaction_manager) return false;
        return m_transaction_manager->releaseSavepoint(name);
    }

    bool MySqlTransportConnection::setClientCharset(const std::string& charset_name) {
        if (!m_charset_handler) return false;
        bool success = m_charset_handler->setClientCharset(m_mysql_handle, charset_name, !m_is_connected);
        if (success && m_is_connected) {  // If connected and successful, update current params
            m_current_params.charset = charset_name;
        } else if (success && !m_is_connected) {  // If pre-connect and successful, update current params
            m_current_params.charset = charset_name;
        }
        return success;
    }

    std::optional<std::string> MySqlTransportConnection::getClientCharset() const {
        if (!m_charset_handler) return std::nullopt;
        // If connected, query. If not, return from params if set.
        auto live_charset = m_charset_handler->getClientCharset(m_mysql_handle, m_is_connected);
        if (live_charset) {
            return live_charset;
        }
        // If not connected or handler couldn't get it, try stored params
        if (m_current_params.charset.has_value() && !m_current_params.charset.value().empty()) {
            return m_current_params.charset.value();
        }
        return std::nullopt;
    }

    std::string MySqlTransportConnection::getServerVersionString() const {
        if (!m_server_info_provider || !m_mysql_handle) return "Not available";
        return m_server_info_provider->getServerVersionString(m_mysql_handle);
    }
    unsigned long MySqlTransportConnection::getServerVersionNumber() const {
        if (!m_server_info_provider || !m_mysql_handle) return 0;
        return m_server_info_provider->getServerVersionNumber(m_mysql_handle);
    }
    std::string MySqlTransportConnection::getHostInfo() const {
        if (!m_server_info_provider || !m_mysql_handle) return "Not available";
        return m_server_info_provider->getHostInfo(m_mysql_handle, m_is_connected);
    }

    MySqlTransportError MySqlTransportConnection::getLastError() const {
        return m_last_error;
    }

    std::string MySqlTransportConnection::escapeString(const std::string& unescaped_str, bool /*treat_backslash_as_meta*/) {
        if (!m_mysql_handle) {
            // Cannot use setErrorManually directly here as it's non-const, and escapeString might be const.
            // For now, assume escapeString is non-const.
            setErrorManually(MySqlTransportError::Category::InternalError, "MySQL handle not available for escapeString.");
            return unescaped_str;  // Or throw
        }
        clearError();
        std::vector<char> to_buffer(unescaped_str.length() * 2 + 1);
        unsigned long to_length = mysql_real_escape_string(m_mysql_handle, to_buffer.data(), unescaped_str.c_str(), unescaped_str.length());
        return std::string(to_buffer.data(), to_length);
    }

    // --- Private/Internal Helper Methods ---
    void MySqlTransportConnection::clearError() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportConnection::setErrorFromMySqlHandle(MYSQL* handle_to_check_error_on, const std::string& context_message) {
        if (handle_to_check_error_on) {
            unsigned int err_no = mysql_errno(handle_to_check_error_on);
            if (err_no != 0) {
                const char* sqlstate = mysql_sqlstate(handle_to_check_error_on);
                const char* errmsg = mysql_error(handle_to_check_error_on);
                std::string full_msg = context_message;
                if (errmsg && errmsg[0] != '\0') {
                    if (!full_msg.empty()) full_msg += ": ";
                    full_msg += errmsg;
                }
                m_last_error = MySqlTransportError(MySqlTransportError::Category::QueryError,  // Default, can be refined
                                                   full_msg,
                                                   err_no,
                                                   sqlstate,
                                                   errmsg);
            } else if (!context_message.empty() && m_last_error.isOk()) {
                // If mysql_errno is 0, but a context message implies an issue from the caller
                m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context_message);
            }
        } else {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, context_message.empty() ? "MySQL handle is null" : context_message + ": MySQL handle is null");
        }
    }

    void MySqlTransportConnection::setErrorManually(MySqlTransportError::Category cat, const std::string& msg, int native_mysql_err, const char* native_sql_state, const char* native_mysql_msg, unsigned int proto_errc) {
        m_last_error = MySqlTransportError(cat, msg, native_mysql_err, native_sql_state, native_mysql_msg, proto_errc);
    }

    void MySqlTransportConnection::recordPreConnectOptionError(const std::string& option_error_message) {
        // This is called by ConnectionOptionsSetter when mysql_options fails.
        // mysql_error(m_mysql_handle) might not be meaningful before connect.
        // So, we set a more generic error based on the context from the setter.
        // It's possible mysql_options sets some internal error code retrievable by mysql_errno on the handle
        // even before connection, but this is less common.
        unsigned int err_no_opt = 0;
        const char* sql_state_opt = nullptr;
        // const char* err_msg_opt = nullptr; // Let's not use mysql_error() for pre-connect option error for now.

        if (m_mysql_handle) {  // Check if handle is valid enough to get errno
            err_no_opt = mysql_errno(m_mysql_handle);
            if (err_no_opt != 0) {  // If mysql_options set an error code
                sql_state_opt = mysql_sqlstate(m_mysql_handle);
                // err_msg_opt = mysql_error(m_mysql_handle); // This might be risky pre-connect
            }
        }
        // If err_no_opt is still 0, it means mysql_options failed without setting a standard MySQL error code.
        m_last_error = MySqlTransportError(MySqlTransportError::Category::ConnectionError,  // Or ApiUsageError
                                           "Pre-connect option failure: " + option_error_message,
                                           err_no_opt,
                                           sql_state_opt,
                                           nullptr /* err_msg_opt */);
    }

    bool MySqlTransportConnection::_internalExecuteSimpleQuery(const std::string& query, const std::string& context_message) {
        if (!isConnected()) {
            setErrorManually(MySqlTransportError::Category::ConnectionError, context_message.empty() ? "Not connected to server." : context_message + ": Not connected.");
            return false;
        }
        clearError();
        if (mysql_real_query(m_mysql_handle, query.c_str(), query.length()) != 0) {
            setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Query failed" : context_message);
            return false;
        }

        // Consume any potential result set from simple queries (e.g., some SET commands, SHOW, etc.)
        do {
            MYSQL_RES* result = mysql_store_result(m_mysql_handle);
            if (result) {
                mysql_free_result(result);
            } else {
                // Check if mysql_store_result failed because of an error or because there's no result set
                if (mysql_field_count(m_mysql_handle) > 0) {
                    // It should have returned a result set, but mysql_store_result failed.
                    setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Failed to retrieve result after query" : context_message + ": Failed to retrieve result");
                    return false;
                }
                // No result set is fine for commands like COMMIT, SET non-variable, etc.
            }
        } while (mysql_next_result(m_mysql_handle) == 0);  // Loop if multi-results enabled and available

        // After loop, check if mysql_next_result itself failed with an error
        if (mysql_errno(m_mysql_handle) != 0 && mysql_errno(m_mysql_handle) != CR_NO_MORE_RESULTS && mysql_errno(m_mysql_handle) != CR_COMMANDS_OUT_OF_SYNC /*can happen if results not handled properly*/) {
            setErrorFromMySqlHandle(m_mysql_handle, context_message.empty() ? "Error processing multiple results" : context_message + ": Error processing results");
            return false;
        }

        return true;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_connection_options_setter.h"

#include <mysql/mysql.h>

#include <algorithm>  // For std::transform
#include <vector>     // For potential temporary buffers if needed

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // To call setErrorFromMySQL directly on context

// Helper to set error on the connection context.
// MySqlTransportConnection must provide a public or friend method for this.
// For now, assuming MySqlTransportConnection has a method like:
// void setInternalErrorFromComponent(const std::string& component_msg, unsigned int mysql_errno_val, const char* sql_state, const char* mysql_err_msg_val);
// Or a simpler setError that takes MySqlTransportError.
// For this example, I'll assume m_conn_ctx->setErrorFromMySQL(msg_prefix) exists and is accessible.

namespace cpporm_mysql_transport {

    MySqlTransportConnectionOptionsSetter::MySqlTransportConnectionOptionsSetter(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            // This is a programming error, options setter cannot function without context.
            // Throw or log an internal error.
            // For now, assume m_conn_ctx is always valid when an instance is created.
        }
    }

    unsigned int MySqlTransportConnectionOptionsSetter::mapSslModeStringToValue(const std::string& mode_str) const {
        std::string upper_mode = mode_str;
        std::transform(upper_mode.begin(), upper_mode.end(), upper_mode.begin(), [](unsigned char c) {
            return std::toupper(c);
        });

        if (upper_mode == "DISABLED") return SSL_MODE_DISABLED;
        if (upper_mode == "PREFERRED") return SSL_MODE_PREFERRED;  // Default if unknown
        if (upper_mode == "REQUIRED") return SSL_MODE_REQUIRED;
        if (upper_mode == "VERIFY_CA") return SSL_MODE_VERIFY_CA;
        if (upper_mode == "VERIFY_IDENTITY") return SSL_MODE_VERIFY_IDENTITY;

        // Log unknown SSL mode if m_conn_ctx had a logging mechanism
        return SSL_MODE_PREFERRED;
    }

    bool MySqlTransportConnectionOptionsSetter::applyPreConnectOptions(MYSQL* mysql_handle, const MySqlTransportConnectionParams& params) {
        if (!mysql_handle || !m_conn_ctx) {
            if (m_conn_ctx) {
                // This is an internal error, mysql_handle should not be null here
                // m_conn_ctx->setInternalError(...)
            }
            return false;
        }

        // Lambda to simplify mysql_options call and error checking
        auto set_mysql_opt = [&](mysql_option option, const void* arg, const std::string& opt_name) -> bool {
            if (mysql_options(mysql_handle, option, arg) != 0) {
                // Need to get error string from mysql_handle BEFORE it's connected.
                // mysql_error() on a non-connected handle might not be reliable.
                // Often, mysql_options failures for simple things are due to invalid arg or option itself.
                // The MySqlTransportConnection will later call setErrorFromMySQL which uses the handle.
                // For now, rely on connection to set its own error using its context if mysql_options fails.
                // The MySqlTransportConnection will need a way to set error based on mysql_options failure.
                // Let's assume MySqlTransportConnection::setErrorFromMySqlHandle(handle, context) exists for this.
                // For this specific helper, we'll construct an error string.
                m_conn_ctx->recordPreConnectOptionError("Failed to set " + opt_name);  // Assume such a method on m_conn_ctx
                return false;
            }
            return true;
        };

        if (params.connect_timeout_seconds.has_value()) {
            if (!set_mysql_opt(MYSQL_OPT_CONNECT_TIMEOUT, ¶ms.connect_timeout_seconds.value(), "MYSQL_OPT_CONNECT_TIMEOUT")) return false;
        }
        if (params.read_timeout_seconds.has_value()) {
            if (!set_mysql_opt(MYSQL_OPT_READ_TIMEOUT, ¶ms.read_timeout_seconds.value(), "MYSQL_OPT_READ_TIMEOUT")) return false;
        }
        if (params.write_timeout_seconds.has_value()) {
            if (!set_mysql_opt(MYSQL_OPT_WRITE_TIMEOUT, ¶ms.write_timeout_seconds.value(), "MYSQL_OPT_WRITE_TIMEOUT")) return false;
        }

        // SSL options
        // MYSQL_OPT_SSL_MODE should be set before other SSL options if it's VERIFY_CA or VERIFY_IDENTITY
        // to ensure they are effective. Order can matter.
        auto ssl_mode_it = params.ssl_options.find("ssl_mode");
        if (ssl_mode_it != params.ssl_options.end()) {
            unsigned int ssl_mode_val = mapSslModeStringToValue(ssl_mode_it->second);
            if (!set_mysql_opt(MYSQL_OPT_SSL_MODE, &ssl_mode_val, "MYSQL_OPT_SSL_MODE")) return false;
        }

        for (const auto& pair : params.ssl_options) {
            if (pair.first == "ssl_key") {
                if (!set_mysql_opt(MYSQL_OPT_SSL_KEY, pair.second.c_str(), "MYSQL_OPT_SSL_KEY")) return false;
            } else if (pair.first == "ssl_cert") {
                if (!set_mysql_opt(MYSQL_OPT_SSL_CERT, pair.second.c_str(), "MYSQL_OPT_SSL_CERT")) return false;
            } else if (pair.first == "ssl_ca") {
                if (!set_mysql_opt(MYSQL_OPT_SSL_CA, pair.second.c_str(), "MYSQL_OPT_SSL_CA")) return false;
            } else if (pair.first == "ssl_capath") {
                if (!set_mysql_opt(MYSQL_OPT_SSL_CAPATH, pair.second.c_str(), "MYSQL_OPT_SSL_CAPATH")) return false;
            } else if (pair.first == "ssl_cipher") {
                if (!set_mysql_opt(MYSQL_OPT_SSL_CIPHER, pair.second.c_str(), "MYSQL_OPT_SSL_CIPHER")) return false;
            } else if (pair.first == "ssl_mode") {
                continue;
            }  // Already handled
            // Add MYSQL_OPT_SSL_CRL, MYSQL_OPT_SSL_CRLPATH, MYSQL_OPT_TLS_VERSION, MYSQL_OPT_SSL_VERIFY_SERVER_CERT etc. if needed
            // Example for MYSQL_OPT_SSL_VERIFY_SERVER_CERT (expects my_bool*)
            // else if (pair.first == "ssl_verify_server_cert") {
            //     char val = (pair.second == "1" || pair.second == "true" || pair.second == "TRUE") ? 1 : 0;
            //     if(!set_mysql_opt(MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &val, "MYSQL_OPT_SSL_VERIFY_SERVER_CERT")) return false;
            // }
            else {
                // Log unknown SSL option if m_conn_ctx has logging
            }
        }

        // Generic options
        for (const auto& pair : params.generic_options) {
            // MYSQL_INIT_COMMAND, MYSQL_SET_CHARSET_NAME expect const char*
            if (pair.first == MYSQL_INIT_COMMAND || pair.first == MYSQL_SET_CHARSET_NAME || pair.first == MYSQL_SET_CHARSET_DIR || pair.first == MYSQL_OPT_ эффективного_PLUGIN_DIR /* MYSQL_OPT_PLUGIN_DIR */ || pair.first == MYSQL_DEFAULT_AUTH || pair.first == MYSQL_OPT_CONNECT_ATTR_RESET
                /* many options take const char* */
            ) {
                if (!set_mysql_opt(pair.first, pair.second.c_str(), "Generic char* option " + std::to_string(pair.first))) return false;
            }
            // MYSQL_OPT_RECONNECT, MYSQL_OPT_COMPRESS, MYSQL_OPT_LOCAL_INFILE, MYSQL_OPT_PROTOCOL, etc.
            // might expect int*, unsigned int*, or char* (for my_bool).
            // This requires a more robust mapping from option type to argument type.
            else if (pair.first == MYSQL_OPT_RECONNECT || pair.first == MYSQL_OPT_GUESS_CONNECTION /* Deprecated */ || pair.first == MYSQL_OPT_USE_EMBEDDED_CONNECTION /* For embedded */ || pair.first == MYSQL_OPT_USE_REMOTE_CONNECTION /* For embedded */ ||
#ifdef MYSQL_OPT_ENABLE_CLEARTEXT_PLUGIN  // Since 5.5.7
                     pair.first == MYSQL_OPT_ENABLE_CLEARTEXT_PLUGIN ||
#endif
                     pair.first == MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS  // since 5.6.6
                                                                           // Many boolean options take char* (my_bool*)
            ) {
                char val = (pair.second == "1" || pair.second == "true" || pair.second == "TRUE" || pair.second == "ON") ? 1 : 0;
                if (!set_mysql_opt(pair.first, &val, "Generic bool(char) option " + std::to_string(pair.first))) return false;
            } else if (pair.first == MYSQL_OPT_PROTOCOL ||         // Expects unsigned int*
                       pair.first == MYSQL_OPT_CONNECT_TIMEOUT ||  // Already handled, but shows type
                       pair.first == MYSQL_OPT_READ_TIMEOUT ||     // Already handled
                       pair.first == MYSQL_OPT_WRITE_TIMEOUT       // Already handled
                                                                   // MYSQL_SERVER_PORT, MYSQL_OPT_MAX_ALLOWED_PACKET, etc. expect unsigned int* or similar
            ) {
                try {
                    unsigned int val = std::stoul(pair.second);
                    if (!set_mysql_opt(pair.first, &val, "Generic uint option " + std::to_string(pair.first))) return false;
                } catch (const std::exception&) {
                    m_conn_ctx->recordPreConnectOptionError("Invalid integer value for option " + std::to_string(pair.first));
                    return false;
                }
            } else {
                // Default to const char* if type is unknown for this example
                // A production system would need a comprehensive map of options to their expected arg types.
                if (!set_mysql_opt(pair.first, pair.second.c_str(), "Generic unknown-type option " + std::to_string(pair.first))) return false;
            }
        }

        // Set client character set via options if specified and not already done by generic_options
        if (params.charset.has_value() && !params.charset.value().empty()) {
            bool charset_already_set_via_generic = false;
            for (const auto& pair : params.generic_options) {
                if (pair.first == MYSQL_SET_CHARSET_NAME) {
                    charset_already_set_via_generic = true;
                    break;
                }
            }
            if (!charset_already_set_via_generic) {
                if (!set_mysql_opt(MYSQL_SET_CHARSET_NAME, params.charset.value().c_str(), "MYSQL_SET_CHARSET_NAME")) return false;
            }
        }

        return true;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_database_lister.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportDatabaseLister::MySqlTransportDatabaseLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            // This is a programming error, should not happen if MySqlTransportMetadata constructs it correctly.
            // Set an internal error for robustness, though ideally MySqlTransportMetadata checks this.
            setError_(MySqlTransportError::Category::InternalError, "DatabaseLister: Null connection context provided.");
        }
    }

    void MySqlTransportDatabaseLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportDatabaseLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportDatabaseLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<std::string>> MySqlTransportDatabaseLister::listDatabases(const std::string& db_name_pattern) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for listDatabases.");
            return std::nullopt;
        }
        clearError_();

        std::string query = "SHOW DATABASES";
        if (!db_name_pattern.empty()) {
            query += " LIKE '" + m_conn_ctx->escapeString(db_name_pattern, false) + "'";
        }

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for listDatabases");
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();  // Get error from statement
            return std::nullopt;
        }

        std::vector<std::string> databases;
        while (result->fetchNextRow()) {
            auto db_name_val_opt = result->getValue(0);  // Database name is in the first column
            if (db_name_val_opt) {
                if (const auto* p_str_name = db_name_val_opt.value().get_if<std::string>()) {
                    databases.push_back(*p_str_name);
                }
            }
        }
        if (!result->getError().isOk()) {  // Check for errors during fetch
            m_last_error = result->getError();
            // Depending on policy, might return partial list or nullopt
        }
        return databases;
    }

    MySqlTransportError MySqlTransportDatabaseLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_index_lister.h"

#include <mysql/mysql.h>

#include <algorithm>
#include <map>

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportIndexLister::MySqlTransportIndexLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "IndexLister: Null connection context provided.");
        }
    }

    void MySqlTransportIndexLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportIndexLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportIndexLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();  // Get the connection's current error
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;  // Augment message with lister context
            if (m_last_error.isOk() && !context.empty() && context.find("Failed to create statement") != std::string::npos) {
                // If connection error was OK, but context clearly indicates a failure from this lister's perspective
                m_last_error.category = MySqlTransportError::Category::QueryError;
            } else if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<MySqlTransportIndexInfo>> MySqlTransportIndexLister::getTableIndexes(const std::string& table_name, const std::string& db_name_filter_param) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for getTableIndexes.");
            return std::nullopt;
        }
        if (table_name.empty()) {
            setError_(MySqlTransportError::Category::ApiUsageError, "Table name cannot be empty for getTableIndexes.");
            return std::nullopt;
        }
        clearError_();

        std::string db_to_use = db_name_filter_param;
        if (db_to_use.empty()) {
            db_to_use = m_conn_ctx->getCurrentParams().db_name;
            if (db_to_use.empty()) {
                setError_(MySqlTransportError::Category::ApiUsageError, "Database name not specified and not set in connection for getTableIndexes.");
                return std::nullopt;
            }
        }
        std::string fq_table_name = "`" + m_conn_ctx->escapeString(db_to_use, false) + "`.`" + m_conn_ctx->escapeString(table_name, false) + "`";
        std::string query = "SHOW INDEX FROM " + fq_table_name;

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt || !stmt->getNativeStatementHandle()) {  // Check if statement creation itself failed
            setErrorFromConnection_("Failed to create statement for getTableIndexes for " + fq_table_name);
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::map<std::string, MySqlTransportIndexInfo> index_map;

        int idx_table = result->getFieldIndex("Table");
        int idx_non_unique = result->getFieldIndex("Non_unique");
        int idx_key_name = result->getFieldIndex("Key_name");
        int idx_seq_in_index = result->getFieldIndex("Seq_in_index");
        int idx_column_name = result->getFieldIndex("Column_name");
        int idx_collation = result->getFieldIndex("Collation");
        int idx_cardinality = result->getFieldIndex("Cardinality");
        int idx_sub_part = result->getFieldIndex("Sub_part");
        int idx_null = result->getFieldIndex("Null");
        int idx_index_type = result->getFieldIndex("Index_type");
        int idx_comment = result->getFieldIndex("Comment");
        int idx_index_comment = result->getFieldIndex("Index_comment");
        int idx_visible = result->getFieldIndex("Visible");
        int idx_expression = result->getFieldIndex("Expression");

        if (idx_key_name == -1 || idx_column_name == -1 || idx_seq_in_index == -1 || idx_table == -1 || idx_non_unique == -1 || idx_index_type == -1 || idx_null == -1) {
            setError_(MySqlTransportError::Category::InternalError, "Could not find one or more required columns in SHOW INDEX output.");
            return std::nullopt;
        }

        while (result->fetchNextRow()) {
            std::optional<mysql_protocol::MySqlNativeValue> key_name_native_val_opt = result->getValue(static_cast<unsigned int>(idx_key_name));
            if (!key_name_native_val_opt) continue;
            const std::string* key_name_ptr = key_name_native_val_opt->get_if<std::string>();
            if (!key_name_ptr) continue;
            std::string key_name = *key_name_ptr;

            auto it = index_map.find(key_name);
            if (it == index_map.end()) {
                MySqlTransportIndexInfo index_info;

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_table))) {
                    if (const auto* s_ptr = val_opt->get_if<std::string>()) index_info.tableName = *s_ptr;
                }

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_non_unique))) {
                    if (const auto* pval_u64 = val_opt->get_if<uint64_t>())
                        index_info.isNonUnique = (*pval_u64 == 1);
                    else if (const auto* pval_i64 = val_opt->get_if<int64_t>())
                        index_info.isNonUnique = (*pval_i64 == 1);
                    else if (const auto* pval_u32 = val_opt->get_if<uint32_t>())
                        index_info.isNonUnique = (*pval_u32 == 1);
                    else if (const auto* pval_i32 = val_opt->get_if<int32_t>())
                        index_info.isNonUnique = (*pval_i32 == 1);
                    // Add other int types if MySqlNativeValue can hold them for Non_unique
                }
                index_info.indexName = key_name;

                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_index_type))) {
                    if (const auto* s_ptr = val_opt->get_if<std::string>()) index_info.indexType = *s_ptr;
                }

                if (idx_comment != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_comment))) {
                        if (!val_opt->is_null())
                            if (const auto* s_ptr = val_opt->get_if<std::string>()) index_info.comment = *s_ptr;
                    }
                }
                if (idx_index_comment != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_index_comment))) {
                        if (!val_opt->is_null())
                            if (const auto* s_ptr = val_opt->get_if<std::string>()) index_info.indexComment = *s_ptr;
                    }
                }
                if (idx_visible != -1) {
                    if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_visible))) {
                        if (!val_opt->is_null())
                            if (const auto* s_ptr = val_opt->get_if<std::string>()) index_info.isVisible = (*s_ptr == "YES");
                    }
                } else {
                    index_info.isVisible = true;
                }
                it = index_map.insert({key_name, index_info}).first;
            }

            MySqlTransportIndexColumn col_def;
            if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_column_name))) {
                if (const auto* s_ptr = val_opt->get_if<std::string>())
                    col_def.columnName = *s_ptr;
                else
                    continue;
            } else
                continue;

            if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_seq_in_index))) {
                if (const auto* pval_u64 = val_opt->get_if<uint64_t>())
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_u64);
                else if (const auto* pval_i64 = val_opt->get_if<int64_t>())
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_i64);
                else if (const auto* pval_u32 = val_opt->get_if<uint32_t>())
                    col_def.sequenceInIndex = *pval_u32;
                else if (const auto* pval_i32 = val_opt->get_if<int32_t>())
                    col_def.sequenceInIndex = static_cast<unsigned int>(*pval_i32);
            }

            if (idx_collation != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_collation))) {
                    if (!val_opt->is_null())
                        if (const auto* s_ptr = val_opt->get_if<std::string>()) col_def.collation = *s_ptr;
                }
            }
            if (idx_cardinality != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_cardinality))) {
                    if (!val_opt->is_null()) {
                        if (const auto* pval_u64 = val_opt->get_if<uint64_t>())
                            col_def.cardinality = static_cast<long long>(*pval_u64);
                        else if (const auto* pval_i64 = val_opt->get_if<int64_t>())
                            col_def.cardinality = *pval_i64;
                        else if (const auto* pval_u32 = val_opt->get_if<uint32_t>())
                            col_def.cardinality = static_cast<long long>(*pval_u32);
                        else if (const auto* pval_i32 = val_opt->get_if<int32_t>())
                            col_def.cardinality = *pval_i32;
                    }
                }
            }
            if (idx_sub_part != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_sub_part))) {
                    if (!val_opt->is_null()) {
                        if (const auto* pval_u64 = val_opt->get_if<uint64_t>())
                            col_def.subPart = static_cast<unsigned int>(*pval_u64);
                        else if (const auto* pval_i64 = val_opt->get_if<int64_t>())
                            col_def.subPart = static_cast<unsigned int>(*pval_i64);
                        else if (const auto* pval_u32 = val_opt->get_if<uint32_t>())
                            col_def.subPart = *pval_u32;
                        else if (const auto* pval_i32 = val_opt->get_if<int32_t>())
                            col_def.subPart = static_cast<unsigned int>(*pval_i32);
                    }
                }
            }

            if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_null))) {
                if (!val_opt->is_null()) {  // Null field in SHOW INDEX is empty string for NOT NULL, 'YES' for NULLABLE
                    if (const auto* s_ptr = val_opt->get_if<std::string>()) col_def.isNullable = (*s_ptr == "YES");
                } else
                    col_def.isNullable = false;  // Should not be SQL NULL, but defensive
            } else
                col_def.isNullable = false;  // Default to not nullable if value missing

            if (idx_expression != -1) {
                if (auto val_opt = result->getValue(static_cast<unsigned int>(idx_expression))) {
                    if (!val_opt->is_null())
                        if (const auto* s_ptr = val_opt->get_if<std::string>()) col_def.expression = *s_ptr;
                }
            }
            it->second.columns.push_back(col_def);
        }

        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }

        std::vector<MySqlTransportIndexInfo> indexes_vec;
        indexes_vec.reserve(index_map.size());
        for (auto& pair_kv : index_map) {
            std::sort(pair_kv.second.columns.begin(), pair_kv.second.columns.end(), [](const MySqlTransportIndexColumn& a, const MySqlTransportIndexColumn& b) {
                return a.sequenceInIndex < b.sequenceInIndex;
            });
            indexes_vec.push_back(std::move(pair_kv.second));
        }
        return indexes_vec;
    }

    std::optional<MySqlTransportIndexInfo> MySqlTransportIndexLister::getPrimaryIndex(const std::string& table_name, const std::string& db_name_filter) {
        auto indexes_opt = getTableIndexes(table_name, db_name_filter);
        if (indexes_opt) {
            for (const auto& index : indexes_opt.value()) {
                if (index.indexName == "PRIMARY") {
                    return index;
                }
            }
        }
        return std::nullopt;
    }

    MySqlTransportError MySqlTransportIndexLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_metadata.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // Listers might need it

// Listers are included via mysql_transport_metadata.h

namespace cpporm_mysql_transport {

    MySqlTransportMetadata::MySqlTransportMetadata(MySqlTransportConnection* conn) {
        if (!conn) {
            // This is a critical programming error.
            // Set an error that can be retrieved by getLastError(), or throw.
            m_last_error_aggregator = MySqlTransportError(MySqlTransportError::Category::InternalError, "MySqlTransportMetadata: Null connection context provided during construction.");
            // Listers will not be initialized. Calls to them will fail.
            return;
        }
        m_db_lister = std::make_unique<MySqlTransportDatabaseLister>(conn);
        m_table_lister = std::make_unique<MySqlTransportTableLister>(conn);
        m_column_lister = std::make_unique<MySqlTransportColumnLister>(conn);
        m_index_lister = std::make_unique<MySqlTransportIndexLister>(conn);
    }

    MySqlTransportMetadata::~MySqlTransportMetadata() = default;  // For std::unique_ptr to incomplete types

    // Move constructor
    MySqlTransportMetadata::MySqlTransportMetadata(MySqlTransportMetadata&& other) noexcept
        : m_last_error_aggregator(std::move(other.m_last_error_aggregator)), m_db_lister(std::move(other.m_db_lister)), m_table_lister(std::move(other.m_table_lister)), m_column_lister(std::move(other.m_column_lister)), m_index_lister(std::move(other.m_index_lister)) {
        // After moving unique_ptrs, 'other' lister pointers are null.
        // The listers themselves, if they store MySqlTransportConnection*, still point to the original connection.
        // This is generally fine if the MySqlTransportConnection outlives this MySqlTransportMetadata object,
        // or if the connection context in listers is updated (but they are simple pointers).
        // The new MySqlTransportMetadata object now owns the listers.
    }

    // Move assignment
    MySqlTransportMetadata& MySqlTransportMetadata::operator=(MySqlTransportMetadata&& other) noexcept {
        if (this != &other) {
            m_last_error_aggregator = std::move(other.m_last_error_aggregator);
            m_db_lister = std::move(other.m_db_lister);
            m_table_lister = std::move(other.m_table_lister);
            m_column_lister = std::move(other.m_column_lister);
            m_index_lister = std::move(other.m_index_lister);
        }
        return *this;
    }

    void MySqlTransportMetadata::clearError() {
        m_last_error_aggregator = MySqlTransportError();
    }

    void MySqlTransportMetadata::setError(const MySqlTransportError& error) {
        m_last_error_aggregator = error;
    }

    // Template helper implementation
    template <typename ListerPtr, typename Method, typename... Args>
    auto MySqlTransportMetadata::callLister(ListerPtr& lister_ptr, Method method, const std::string& error_context, Args&&... args) -> decltype(((*lister_ptr).*method)(std::forward<Args>(args)...)) {
        clearError();  // Clear aggregator before call
        using ReturnType = decltype(((*lister_ptr).*method)(std::forward<Args>(args)...));

        if (!lister_ptr) {
            setError(MySqlTransportError(MySqlTransportError::Category::InternalError, error_context + ": Lister component not initialized."));
            if constexpr (std::is_same_v<ReturnType, void>)
                return;
            else
                return ReturnType{};  // Return default-constructed optional or empty vector
        }

        ReturnType result = ((*lister_ptr).*method)(std::forward<Args>(args)...);
        m_last_error_aggregator = lister_ptr->getLastError();  // Get specific error from the lister

        // If lister operation failed (indicated by !result for optionals, or error set),
        // and lister itself didn't set a good error message, enhance it.
        bool result_indicates_failure = false;
        if constexpr (std::is_same_v<decltype(result), std::optional<typename ReturnType::value_type>>) {  // Check if ReturnType is std::optional
            if (!result.has_value()) result_indicates_failure = true;
        }
        // Add similar checks if result is vector and empty could mean failure in some contexts.

        if (result_indicates_failure && m_last_error_aggregator.isOk()) {
            setError(MySqlTransportError(MySqlTransportError::Category::InternalError, error_context + ": Operation failed but lister reported no specific error."));
        } else if (!m_last_error_aggregator.isOk() && m_last_error_aggregator.message.find(error_context) == std::string::npos) {
            // Prepend context to lister's error message if not already there
            m_last_error_aggregator.message = error_context + ": " + m_last_error_aggregator.message;
        }
        return result;
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listDatabases(const std::string& db_name_pattern) {
        return callLister(m_db_lister, &MySqlTransportDatabaseLister::listDatabases, "ListDatabases", db_name_pattern);
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listTables(const std::string& db_name, const std::string& table_name_pattern) {
        return callLister(m_table_lister, &MySqlTransportTableLister::listTables, "ListTables", db_name, table_name_pattern);
    }

    std::optional<std::vector<std::string>> MySqlTransportMetadata::listViews(const std::string& db_name, const std::string& view_name_pattern) {
        return callLister(m_table_lister, &MySqlTransportTableLister::listViews, "ListViews", db_name, view_name_pattern);
    }

    std::optional<std::vector<MySqlTransportFieldMeta>> MySqlTransportMetadata::getTableColumns(const std::string& table_name, const std::string& db_name) {
        return callLister(m_column_lister, &MySqlTransportColumnLister::getTableColumns, "GetTableColumns", table_name, db_name);
    }

    std::optional<std::vector<MySqlTransportIndexInfo>> MySqlTransportMetadata::getTableIndexes(const std::string& table_name, const std::string& db_name) {
        return callLister(m_index_lister, &MySqlTransportIndexLister::getTableIndexes, "GetTableIndexes", table_name, db_name);
    }

    std::optional<MySqlTransportIndexInfo> MySqlTransportMetadata::getPrimaryIndex(const std::string& table_name, const std::string& db_name) {
        return callLister(m_index_lister, &MySqlTransportIndexLister::getPrimaryIndex, "GetPrimaryIndex", table_name, db_name);
    }

    MySqlTransportError MySqlTransportMetadata::getLastError() const {
        return m_last_error_aggregator;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_result.h"

#include <mysql/mysql.h>

#include <cstring>  // For memset for MYSQL_BIND

#include "cpporm_mysql_transport/mysql_transport_statement.h"  // Needs statement handle
#include "mysql_protocol/mysql_type_converter.h"               // For mySqlRowFieldToNativeValue, mySqlBoundResultToNativeValue

namespace cpporm_mysql_transport {

    // Constructor for results from PREPARED STATEMENTS (MYSQL_STMT*)
    // The MYSQL_RES* passed here is METADATA ONLY.
    MySqlTransportResult::MySqlTransportResult(MySqlTransportStatement* stmt, MYSQL_RES* meta_res_handle, MySqlTransportError& err_ref)
        : m_statement(stmt),
          m_mysql_res_metadata(meta_res_handle),  // This is metadata from mysql_stmt_result_metadata()
          m_mysql_stmt_handle_for_fetch(stmt ? stmt->getNativeStatementHandle() : nullptr),
          m_error_collector(err_ref),  // Use the error collector from the statement
          m_current_sql_row(nullptr),  // Not used for prepared statements
          m_current_lengths(nullptr),  // Not used for prepared statements
          m_meta_populated(false),
          m_is_valid(false),
          m_is_from_prepared_statement(true),
          m_fetched_all_from_stmt(false) {
        if (!m_statement || !m_mysql_stmt_handle_for_fetch || !m_mysql_res_metadata) {
            m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid arguments to MySqlTransportResult constructor (prepared statement path).");
            if (m_mysql_res_metadata && m_statement) {  // If statement is null, we can't free using its context
                // The metadata MYSQL_RES should be freed by the caller (MySqlTransportStatement) if result construction fails early.
                // Or, if we take ownership, free it here. For now, assume caller handles cleanup on early fail.
            }
            m_mysql_res_metadata = nullptr;  // Don't use if invalid setup
            return;
        }

        // For prepared statements, we need to call mysql_stmt_store_result
        // to buffer data and get num_rows.
        if (mysql_stmt_store_result(m_mysql_stmt_handle_for_fetch) != 0) {
            // Get error from statement
            m_error_collector = m_statement->getError();  // Get the error that mysql_stmt_store_result set
            mysql_free_result(m_mysql_res_metadata);      // We own metadata, free it
            m_mysql_res_metadata = nullptr;
            m_mysql_stmt_handle_for_fetch = nullptr;  // Mark as unusable
            return;
        }

        m_row_count = mysql_stmt_num_rows(m_mysql_stmt_handle_for_fetch);
        m_field_count = mysql_num_fields(m_mysql_res_metadata);  // Get field count from metadata

        if (m_field_count > 0) {
            populateFieldsMeta();  // Uses m_mysql_res_metadata
            if (!m_fields_meta.empty()) {
                setupOutputBindBuffers();  // Setup MYSQL_BIND for fetching
            } else {
                // populateFieldsMeta must have failed
                mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                m_mysql_stmt_handle_for_fetch = nullptr;
                return;  // Error set by populateFieldsMeta or setupOutputBindBuffers
            }
        } else {
            // No fields, but store_result succeeded. Could be "SELECT 1 WHERE false".
            // Still valid, just empty.
        }
        m_is_valid = true;  // Valid for fetching (even if 0 rows/fields)
    }

    // Constructor for results from NON-PREPARED STATEMENTS (MYSQL_RES* from mysql_store_result)
    MySqlTransportResult::MySqlTransportResult(MYSQL_RES* stored_res_handle, MySqlTransportError& err_ref)
        : m_statement(nullptr),                     // No parent statement for direct MYSQL_RES
          m_mysql_res_metadata(stored_res_handle),  // This IS the stored result
          m_mysql_stmt_handle_for_fetch(nullptr),
          m_error_collector(err_ref),
          m_current_sql_row(nullptr),
          m_current_lengths(nullptr),
          m_meta_populated(false),
          m_is_valid(false),
          m_is_from_prepared_statement(false),
          m_fetched_all_from_stmt(false) {  // Not applicable

        if (!m_mysql_res_metadata) {
            m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Null MYSQL_RES handle passed to MySqlTransportResult constructor.");
            return;
        }
        m_row_count = mysql_num_rows(m_mysql_res_metadata);
        m_field_count = mysql_num_fields(m_mysql_res_metadata);

        if (m_field_count > 0) {
            populateFieldsMeta();                              // Uses m_mysql_res_metadata
            if (m_fields_meta.empty() && m_field_count > 0) {  // populateFieldsMeta failed
                mysql_free_result(m_mysql_res_metadata);
                m_mysql_res_metadata = nullptr;
                return;
            }
        }
        m_is_valid = true;
    }

    MySqlTransportResult::~MySqlTransportResult() {
        clearCurrentRow();
        if (m_mysql_res_metadata) {  // This is metadata for prepared, or full result for non-prepared
            mysql_free_result(m_mysql_res_metadata);
            m_mysql_res_metadata = nullptr;
        }
        // For prepared statements, mysql_stmt_free_result might be needed on m_mysql_stmt_handle_for_fetch
        // if mysql_stmt_store_result was called. It's complex; typically, you free the statement.
        // The statement's close() should handle this if it's the one that called store_result.
        // If MySqlTransportResult called store_result (as it does now for prepared), it should probably free it.
        if (m_is_from_prepared_statement && m_mysql_stmt_handle_for_fetch) {
            // mysql_stmt_free_result(m_mysql_stmt_handle_for_fetch); // Free buffered results from STMT
            // This is usually done before mysql_stmt_reset or mysql_stmt_close.
            // Let's assume the statement close will handle any necessary stmt-level freeing.
        }
    }

    // Move constructor
    MySqlTransportResult::MySqlTransportResult(MySqlTransportResult&& other) noexcept
        : m_statement(other.m_statement),
          m_mysql_res_metadata(other.m_mysql_res_metadata),
          m_mysql_stmt_handle_for_fetch(other.m_mysql_stmt_handle_for_fetch),
          m_error_collector(other.m_error_collector),  // Reference, so just copy
          m_fields_meta(std::move(other.m_fields_meta)),
          m_current_sql_row(other.m_current_sql_row),
          m_current_lengths(other.m_current_lengths),
          m_row_count(other.m_row_count),
          m_field_count(other.m_field_count),
          m_current_row_idx(other.m_current_row_idx),
          m_meta_populated(other.m_meta_populated),
          m_is_valid(other.m_is_valid),
          m_is_from_prepared_statement(other.m_is_from_prepared_statement),
          m_output_bind_buffers(std::move(other.m_output_bind_buffers)),
          m_output_data_buffers(std::move(other.m_output_data_buffers)),
          m_output_is_null_indicators(std::move(other.m_output_is_null_indicators)),
          m_output_length_indicators(std::move(other.m_output_length_indicators)),
          m_output_error_indicators(std::move(other.m_output_error_indicators)),
          m_fetched_all_from_stmt(other.m_fetched_all_from_stmt) {
        other.m_mysql_res_metadata = nullptr;           // Take ownership
        other.m_mysql_stmt_handle_for_fetch = nullptr;  // It was a raw pointer from statement
        other.m_current_sql_row = nullptr;
        other.m_is_valid = false;  // Mark other as invalid
    }

    // Move assignment
    MySqlTransportResult& MySqlTransportResult::operator=(MySqlTransportResult&& other) noexcept {
        if (this != &other) {
            // Free own resources first
            clearCurrentRow();
            if (m_mysql_res_metadata) mysql_free_result(m_mysql_res_metadata);
            // Do not free m_mysql_stmt_handle_for_fetch, it's from statement

            m_statement = other.m_statement;
            m_mysql_res_metadata = other.m_mysql_res_metadata;
            m_mysql_stmt_handle_for_fetch = other.m_mysql_stmt_handle_for_fetch;
            m_error_collector = other.m_error_collector;  // ref copy
            m_fields_meta = std::move(other.m_fields_meta);
            m_current_sql_row = other.m_current_sql_row;
            m_current_lengths = other.m_current_lengths;
            m_row_count = other.m_row_count;
            m_field_count = other.m_field_count;
            m_current_row_idx = other.m_current_row_idx;
            m_meta_populated = other.m_meta_populated;
            m_is_valid = other.m_is_valid;
            m_is_from_prepared_statement = other.m_is_from_prepared_statement;
            m_output_bind_buffers = std::move(other.m_output_bind_buffers);
            m_output_data_buffers = std::move(other.m_output_data_buffers);
            m_output_is_null_indicators = std::move(other.m_output_is_null_indicators);
            m_output_length_indicators = std::move(other.m_output_length_indicators);
            m_output_error_indicators = std::move(other.m_output_error_indicators);
            m_fetched_all_from_stmt = other.m_fetched_all_from_stmt;

            other.m_mysql_res_metadata = nullptr;
            other.m_mysql_stmt_handle_for_fetch = nullptr;
            other.m_current_sql_row = nullptr;
            other.m_is_valid = false;
        }
        return *this;
    }

    bool MySqlTransportResult::isValid() const {
        return m_is_valid;
    }
    MySqlTransportError MySqlTransportResult::getError() const {
        return m_error_collector;
    }

    my_ulonglong MySqlTransportResult::getRowCount() const {
        return m_row_count;
    }
    unsigned int MySqlTransportResult::getFieldCount() const {
        return m_field_count;
    }

    const std::vector<MySqlTransportFieldMeta>& MySqlTransportResult::getFieldsMeta() const {
        // populateFieldsMeta should be called in constructor if not already
        if (!m_meta_populated && m_is_valid && m_field_count > 0 && m_mysql_res_metadata) {
            // This const_cast is not ideal but necessary if populateFieldsMeta is non-const
            // and needs to be lazily called. Better to ensure it's called in constructor.
            // const_cast<MySqlTransportResult*>(this)->populateFieldsMeta();
            // Since it's called in constructor, this path should not be hit if valid.
        }
        return m_fields_meta;
    }

    std::optional<MySqlTransportFieldMeta> MySqlTransportResult::getFieldMeta(unsigned int col_idx) const {
        if (!m_is_valid || col_idx >= m_field_count) {
            // m_error_collector = ... (can't modify in const method without mutable error)
            return std::nullopt;
        }
        return m_fields_meta[col_idx];
    }

    std::optional<MySqlTransportFieldMeta> MySqlTransportResult::getFieldMeta(const std::string& col_name) const {
        if (!m_is_valid) return std::nullopt;
        for (const auto& meta : m_fields_meta) {
            if (meta.name == col_name || meta.original_name == col_name) {
                return meta;
            }
        }
        return std::nullopt;
    }
    int MySqlTransportResult::getFieldIndex(const std::string& col_name) const {
        if (!m_is_valid) return -1;
        for (size_t i = 0; i < m_fields_meta.size(); ++i) {
            if (m_fields_meta[i].name == col_name || m_fields_meta[i].original_name == col_name) {
                return static_cast<int>(i);
            }
        }
        return -1;
    }

    bool MySqlTransportResult::fetchNextRow() {
        if (!m_is_valid) return false;
        clearCurrentRow();  // Clear data from previous fetch

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch || m_fetched_all_from_stmt) return false;

            int fetch_rc = mysql_stmt_fetch(m_mysql_stmt_handle_for_fetch);
            if (fetch_rc == 0) {  // Success
                m_current_row_idx++;
                // Data is now in m_output_data_buffers, nulls in m_output_is_null_indicators etc.
                return true;
            } else if (fetch_rc == MYSQL_NO_DATA) {  // No more rows
                m_fetched_all_from_stmt = true;
                return false;
            } else if (fetch_rc == MYSQL_DATA_TRUNCATED) {  // Data truncated
                // Row is fetched, but some data was truncated.
                // User can check m_output_error_indicators for which columns.
                // We'll report it as a warning or data error.
                // For now, proceed as if row is fetched.
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::DataError, "Data truncated during fetch.", mysql_stmt_errno(m_mysql_stmt_handle_for_fetch), mysql_stmt_sqlstate(m_mysql_stmt_handle_for_fetch), mysql_stmt_error(m_mysql_stmt_handle_for_fetch));
                m_current_row_idx++;
                return true;
            } else {  // Error
                if (m_statement)
                    m_error_collector = m_statement->getError();  // Get error from statement
                else
                    m_error_collector = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_fetch failed.");
                return false;
            }
        } else {  // From non-prepared (MYSQL_RES)
            if (!m_mysql_res_metadata) return false;
            m_current_sql_row = mysql_fetch_row(m_mysql_res_metadata);
            if (m_current_sql_row) {
                m_current_lengths = mysql_fetch_lengths(m_mysql_res_metadata);
                m_current_row_idx++;
                return true;
            } else {
                // Check for error vs end of data
            if (mysql_errno(mysql_get_ Předpokládám, že zde byl pokus o `mysql_get_ Scienze handle from result`, ale to není platná funkce. Chyba by měla být získána z `m_statement` nebo z `MYSQL` handle, který vytvořil `MYSQL_RES`.
            // Pokud `m_statement` je null (což je pro non-prepared results), pak nemáme přímý handle pro `mysql_errno`.
            // `mysql_error(MYSQL* مرتبط به MYSQL_RES)` neexistuje.
            // Prozatím, pokud `mysql_fetch_row` vrátí NULL, předpokládáme konec dat, pokud není chyba v `m_error_collector`.
            if (m_error_collector.isOk() && mysql_eof(m_mysql_res_metadata)) { // Check if it's normal end of data
                                                                               // Normal end of data
            } else if (!m_error_collector.isOk()){
                    // Error already set
            } else {
                    // Unspecified error during fetch for non-prepared, very rare if mysql_store_result succeeded.
                    // This usually means mysql_store_result itself failed, which should be caught earlier.
            }
            return false;
            }
        }
    }

    std::optional<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getValue(unsigned int col_idx) {
        if (!m_is_valid || col_idx >= m_field_count) {
            m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid column index for getValue.");
            return std::nullopt;
        }

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch || m_fetched_all_from_stmt || m_current_row_idx == -1) {  // -1 means no successful fetch yet
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "No current row fetched for prepared statement getValue.");
                return std::nullopt;
            }
            if (m_output_is_null_indicators[col_idx]) {
                mysql_protocol::MySqlNativeValue nv;                             // Defaults to monostate (NULL)
                nv.original_mysql_type = m_fields_meta[col_idx].native_type_id;  // Keep original type info
                nv.original_mysql_flags = m_fields_meta[col_idx].flags;
                nv.original_charsetnr = m_fields_meta[col_idx].charsetnr;
                return nv;
            }
            // Data is in m_output_data_buffers[col_idx], length in m_output_length_indicators[col_idx]
            // We need to convert this raw buffer to MySqlNativeValue based on m_fields_meta[col_idx].native_type_id
            // This is where mysql_protocol::mySqlBoundResultToNativeValue would be useful.
            // It would take MYSQL_BIND* (m_output_bind_buffers[col_idx]) and convert.
            auto expected_nv = mysql_protocol::mySqlBoundResultToNativeValue(&m_output_bind_buffers[col_idx], m_fields_meta[col_idx].flags, m_fields_meta[col_idx].charsetnr);
            if (expected_nv) {
                return expected_nv.value();
            } else {
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::ProtocolError, "Failed to convert bound result to NativeValue: " + expected_nv.error().error_message);
                return std::nullopt;
            }

        } else {                       // From non-prepared (MYSQL_RES)
            if (!m_current_sql_row) {  // No row fetched or past the end
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "No current row fetched for non-prepared statement getValue.");
                return std::nullopt;
            }
            if (m_current_sql_row[col_idx] == nullptr) {  // Check for NULL value
                mysql_protocol::MySqlNativeValue nv;
                nv.original_mysql_type = m_fields_meta[col_idx].native_type_id;
                nv.original_mysql_flags = m_fields_meta[col_idx].flags;
                nv.original_charsetnr = m_fields_meta[col_idx].charsetnr;
                return nv;
            }

            MYSQL_FIELD* field_info = mysql_fetch_field_direct(m_mysql_res_metadata, col_idx);
            if (!field_info) {
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::InternalError, "Failed to fetch field info for getValue.");
                return std::nullopt;
            }

            auto expected_nv = mysql_protocol::mySqlRowFieldToNativeValue(m_current_sql_row[col_idx], m_current_lengths[col_idx], field_info);
            if (expected_nv) {
                return expected_nv.value();
            } else {
                // m_error_collector = protocolToSqlError(expected_nv.error(), "getValue conversion failed");
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::ProtocolError, "Failed to convert row field to NativeValue: " + expected_nv.error().error_message);

                return std::nullopt;
            }
        }
    }
    std::optional<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getValue(const std::string& col_name) {
        int idx = getFieldIndex(col_name);
        if (idx == -1) {
            m_error_collector = MySqlTransportError(MySqlTransportError::Category::ApiUsageError, "Invalid column name for getValue: " + col_name);
            return std::nullopt;
        }
        return getValue(static_cast<unsigned int>(idx));
    }

    bool MySqlTransportResult::isNull(unsigned int col_idx) {
        if (!m_is_valid || col_idx >= m_field_count) return true;  // Or throw/error

        if (m_is_from_prepared_statement) {
            if (!m_mysql_stmt_handle_for_fetch || m_fetched_all_from_stmt || m_current_row_idx == -1) return true;
            return m_output_is_null_indicators[col_idx] != 0;
        } else {
            if (!m_current_sql_row) return true;
            return m_current_sql_row[col_idx] == nullptr;
        }
    }
    bool MySqlTransportResult::isNull(const std::string& col_name) {
        int idx = getFieldIndex(col_name);
        if (idx == -1) return true;  // Or throw/error
        return isNull(static_cast<unsigned int>(idx));
    }

    std::vector<mysql_protocol::MySqlNativeValue> MySqlTransportResult::getCurrentRowValues() {
        std::vector<mysql_protocol::MySqlNativeValue> row_values;
        if (!m_is_valid || m_field_count == 0 || (m_is_from_prepared_statement && (m_current_row_idx == -1 || m_fetched_all_from_stmt)) || (!m_is_from_prepared_statement && !m_current_sql_row)) {
            return row_values;  // Empty vector
        }
        row_values.reserve(m_field_count);
        for (unsigned int i = 0; i < m_field_count; ++i) {
            auto val_opt = getValue(i);
            if (val_opt) {
                row_values.push_back(std::move(val_opt.value()));
            } else {
                // Error occurred fetching this value, push a default (NULL) MySqlNativeValue
                mysql_protocol::MySqlNativeValue null_val;
                null_val.original_mysql_type = m_fields_meta[i].native_type_id;
                null_val.original_mysql_flags = m_fields_meta[i].flags;
                null_val.original_charsetnr = m_fields_meta[i].charsetnr;
                row_values.push_back(std::move(null_val));
            }
        }
        return row_values;
    }

    // --- Private Helper Methods ---
    void MySqlTransportResult::populateFieldsMeta() {
        if (m_meta_populated || !m_mysql_res_metadata || m_field_count == 0) return;

        m_fields_meta.resize(m_field_count);
        MYSQL_FIELD* fields_raw = mysql_fetch_fields(m_mysql_res_metadata);
        for (unsigned int i = 0; i < m_field_count; ++i) {
            m_fields_meta[i].name = fields_raw[i].name ? fields_raw[i].name : "";
            m_fields_meta[i].original_name = fields_raw[i].org_name ? fields_raw[i].org_name : "";
            m_fields_meta[i].table = fields_raw[i].table ? fields_raw[i].table : "";
            m_fields_meta[i].original_table = fields_raw[i].org_table ? fields_raw[i].org_table : "";
            m_fields_meta[i].db = fields_raw[i].db ? fields_raw[i].db : "";
            m_fields_meta[i].catalog = fields_raw[i].catalog ? fields_raw[i].catalog : "def";
            m_fields_meta[i].native_type_id = fields_raw[i].type;
            m_fields_meta[i].charsetnr = fields_raw[i].charsetnr;
            m_fields_meta[i].length = fields_raw[i].length;
            m_fields_meta[i].max_length = fields_raw[i].max_length;  // May not be set for prepared stmt metadata
            m_fields_meta[i].flags = fields_raw[i].flags;
            m_fields_meta[i].decimals = fields_raw[i].decimals;
            // default_value is harder to get here, usually from DESCRIBE TABLE.
        }
        m_meta_populated = true;
    }

    void MySqlTransportResult::clearCurrentRow() {
        if (!m_is_from_prepared_statement) {
            m_current_sql_row = nullptr;  // For MYSQL_RES, just nullify the pointer
            m_current_lengths = nullptr;
        } else {
            // For prepared statements, data is in m_output_data_buffers.
            // These buffers are reused by mysql_stmt_fetch. We don't need to clear them here,
            // but reset any per-row state if necessary.
            // m_current_row_idx is reset/incremented by fetchNextRow.
        }
    }

    void MySqlTransportResult::setupOutputBindBuffers() {
        if (!m_is_from_prepared_statement || m_field_count == 0 || !m_mysql_stmt_handle_for_fetch) return;

        m_output_bind_buffers.resize(m_field_count);
        std::memset(m_output_bind_buffers.data(), 0, sizeof(MYSQL_BIND) * m_field_count);

        m_output_data_buffers.resize(m_field_count);
        m_output_is_null_indicators.resize(m_field_count, 0);  // char 0 or 1
        m_output_length_indicators.resize(m_field_count, 0);
        m_output_error_indicators.resize(m_field_count, 0);  // char 0 or 1

        for (unsigned int i = 0; i < m_field_count; ++i) {
            MYSQL_BIND& bind = m_output_bind_buffers[i];
            const MySqlTransportFieldMeta& meta = m_fields_meta[i];

            bind.buffer_type = meta.native_type_id;
            // Determine buffer size. For strings/blobs, it's meta.length (defined length)
            // or a sufficiently large buffer. mysql_stmt_fetch will use length indicator.
            // For fixed-size types, it's sizeof(type).
            unsigned long buffer_sz = 0;
            switch (meta.native_type_id) {
                case MYSQL_TYPE_TINY:
                    buffer_sz = sizeof(int8_t);
                    break;
                case MYSQL_TYPE_SHORT:
                    buffer_sz = sizeof(int16_t);
                    break;
                case MYSQL_TYPE_INT24:  // fallthrough
                case MYSQL_TYPE_LONG:
                    buffer_sz = sizeof(int32_t);
                    break;
                case MYSQL_TYPE_LONGLONG:
                    buffer_sz = sizeof(int64_t);
                    break;
                case MYSQL_TYPE_FLOAT:
                    buffer_sz = sizeof(float);
                    break;
                case MYSQL_TYPE_DOUBLE:
                    buffer_sz = sizeof(double);
                    break;
                case MYSQL_TYPE_BIT:
                    buffer_sz = (meta.length + 7) / 8;
                    break;  // meta.length is in bits for BIT
                case MYSQL_TYPE_DATE:
                case MYSQL_TYPE_TIME:
                case MYSQL_TYPE_DATETIME:
                case MYSQL_TYPE_TIMESTAMP:
                case MYSQL_TYPE_YEAR:
                    buffer_sz = sizeof(MYSQL_TIME);
                    break;
                // For variable length types, use defined length or a reasonable max
                // mysql_stmt_fetch will use the 'length' output parameter.
                // Max length from metadata might be useful if available (meta.max_length)
                case MYSQL_TYPE_STRING:
                case MYSQL_TYPE_VAR_STRING:
                case MYSQL_TYPE_VARCHAR:
                case MYSQL_TYPE_BLOB:
                case MYSQL_TYPE_TINY_BLOB:
                case MYSQL_TYPE_MEDIUM_BLOB:
                case MYSQL_TYPE_LONG_BLOB:
                case MYSQL_TYPE_JSON:
                case MYSQL_TYPE_ENUM:
                case MYSQL_TYPE_SET:
                // For GEOMETRY, use a large enough buffer or handle separately
                case MYSQL_TYPE_GEOMETRY:
                    buffer_sz = meta.length > 0 ? meta.length : 65535;  // Default large buffer if length unknown
                    // If meta.max_length is reliable from mysql_stmt_result_metadata, use it.
                    // It is often 0 from metadata, so defined length 'meta.length' is better.
                    break;
                case MYSQL_TYPE_DECIMAL:
                case MYSQL_TYPE_NEWDECIMAL:                          // Stored as string
                    buffer_sz = meta.length > 0 ? meta.length : 65;  // Max precision + sign + decimal point
                    break;
                default:
                    buffer_sz = 256;  // Default fallback for unknown types
                    break;
            }
            if (buffer_sz == 0 && meta.length > 0) buffer_sz = meta.length;  // Ensure some size if type known but calc was 0
            if (buffer_sz == 0) buffer_sz = 256;                             // Absolute fallback

            m_output_data_buffers[i].resize(buffer_sz);
            bind.buffer = m_output_data_buffers[i].data();
            bind.buffer_length = buffer_sz;                // Max buffer size
            bind.length = &m_output_length_indicators[i];  // Actual data length will be stored here
            bind.is_null = reinterpret_cast<my_bool*>(&m_output_is_null_indicators[i]);
            bind.error = reinterpret_cast<my_bool*>(&m_output_error_indicators[i]);  // For truncation/error per column
            bind.is_unsigned = (meta.flags & UNSIGNED_FLAG);
        }

        if (mysql_stmt_bind_result(m_mysql_stmt_handle_for_fetch, m_output_bind_buffers.data()) != 0) {
            if (m_statement)
                m_error_collector = m_statement->getError();
            else
                m_error_collector = MySqlTransportError(MySqlTransportError::Category::QueryError, "mysql_stmt_bind_result failed");
            m_is_valid = false;  // Cannot fetch
        }
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_server_info_provider.h"

#include <mysql/mysql.h>  // Ensure MYSQL type is fully defined

namespace cpporm_mysql_transport {

    // No constructor needed if methods are simple wrappers or connection context isn't stored.

    std::string MySqlTransportServerInfoProvider::getServerVersionString(MYSQL* mysql_handle) const {
        if (mysql_handle) {
            const char* server_info = mysql_get_server_info(mysql_handle);
            if (server_info) {
                return std::string(server_info);
            }
        }
        // Return empty or a specific "N/A" string if handle is null or info is null.
        // Throwing an exception might be too aggressive for a simple info getter.
        return "";
    }

    unsigned long MySqlTransportServerInfoProvider::getServerVersionNumber(MYSQL* mysql_handle) const {
        if (mysql_handle) {
            return mysql_get_server_version(mysql_handle);
        }
        return 0;  // 0 can indicate an error or that the handle is invalid.
    }

    std::string MySqlTransportServerInfoProvider::getHostInfo(MYSQL* mysql_handle, bool is_connected) const {
        // mysql_get_host_info() typically requires an active connection to return meaningful data.
        if (mysql_handle && is_connected) {
            const char* host_info = mysql_get_host_info(mysql_handle);
            if (host_info) {
                return std::string(host_info);
            }
        }
        return "";
    }

    // Potential additions:
    // unsigned long MySqlTransportServerInfoProvider::getThreadId(MYSQL* mysql_handle, bool is_connected) const {
    //     if (mysql_handle && is_connected) {
    //         return mysql_thread_id(mysql_handle);
    //     }
    //     return 0; // Or some error indicator
    // }
    //
    // unsigned int MySqlTransportServerInfoProvider::getProtocolVersion(MYSQL* mysql_handle) const {
    //     if (mysql_handle) {
    //         return mysql_get_proto_info(mysql_handle);
    //     }
    //     return 0;
    // }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_statement.h"

#include <mysql/mysql.h>

#include <algorithm>  // for std::fill, std::copy
#include <cstring>    // For std::memset, std::memcpy (though C++ equivalents preferred)

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // Needs connection's handle and error reporting
#include "cpporm_mysql_transport/mysql_transport_result.h"      // executeQuery returns this
#include "mysql_protocol/mysql_type_converter.h"                // For setupMySqlBindForInput and other conversions

namespace cpporm_mysql_transport {

    MySqlTransportStatement::MySqlTransportStatement(MySqlTransportConnection* conn, const std::string& query) : m_connection(conn), m_original_query(query), m_stmt_handle(nullptr), m_is_prepared(false), m_affected_rows(0), m_last_insert_id(0), m_warning_count(0) {
        if (!m_connection || !m_connection->getNativeHandle()) {  // Check raw MYSQL* from connection
            setError(MySqlTransportError::Category::ApiUsageError, "Invalid or uninitialized connection provided to statement.");
            return;
        }
        // Connection being "isConnected()" (logical connection state) is less critical here
        // than having a valid MYSQL* handle for mysql_stmt_init.
        // If connection is logically down but MYSQL* handle is valid, init might still succeed,
        // but prepare/execute would fail. Error handling there will cover it.

        m_stmt_handle = mysql_stmt_init(m_connection->getNativeHandle());
        if (!m_stmt_handle) {
            setErrorFromMySQL();  // Get error from connection's MYSQL handle as stmt handle is null
        }
    }

    MySqlTransportStatement::~MySqlTransportStatement() {
        close();
    }

    MySqlTransportStatement::MySqlTransportStatement(MySqlTransportStatement&& other) noexcept
        : m_connection(other.m_connection),
          m_original_query(std::move(other.m_original_query)),
          m_stmt_handle(other.m_stmt_handle),
          m_is_prepared(other.m_is_prepared),
          m_bind_buffers(std::move(other.m_bind_buffers)),
          m_param_data_buffers(std::move(other.m_param_data_buffers)),
          m_param_is_null_indicators(std::move(other.m_param_is_null_indicators)),
          m_param_length_indicators(std::move(other.m_param_length_indicators)),
          m_last_error(std::move(other.m_last_error)),
          m_affected_rows(other.m_affected_rows),
          m_last_insert_id(other.m_last_insert_id),
          m_warning_count(other.m_warning_count) {
        other.m_stmt_handle = nullptr;
        other.m_is_prepared = false;
    }

    MySqlTransportStatement& MySqlTransportStatement::operator=(MySqlTransportStatement&& other) noexcept {
        if (this != &other) {
            close();

            m_connection = other.m_connection;
            m_original_query = std::move(other.m_original_query);
            m_stmt_handle = other.m_stmt_handle;
            m_is_prepared = other.m_is_prepared;
            m_bind_buffers = std::move(other.m_bind_buffers);
            m_param_data_buffers = std::move(other.m_param_data_buffers);
            m_param_is_null_indicators = std::move(other.m_param_is_null_indicators);
            m_param_length_indicators = std::move(other.m_param_length_indicators);
            m_last_error = std::move(other.m_last_error);
            m_affected_rows = other.m_affected_rows;
            m_last_insert_id = other.m_last_insert_id;
            m_warning_count = other.m_warning_count;

            other.m_stmt_handle = nullptr;
            other.m_is_prepared = false;
        }
        return *this;
    }

    bool MySqlTransportStatement::prepare() {
        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle is not initialized for prepare.");
            return false;
        }
        if (m_is_prepared) {
            return true;
        }
        clearError();

        if (mysql_stmt_prepare(m_stmt_handle, m_original_query.c_str(), m_original_query.length()) != 0) {
            setErrorFromMySQL();
            m_is_prepared = false;
            return false;
        }

        m_is_prepared = true;
        unsigned int param_count = mysql_stmt_param_count(m_stmt_handle);
        if (param_count > 0) {
            m_bind_buffers.assign(param_count, MYSQL_BIND{});  // Initialize with default MYSQL_BIND
            m_param_data_buffers.resize(param_count);
            m_param_is_null_indicators.assign(param_count, 0);  // 0 for false (not null)
            m_param_length_indicators.assign(param_count, 0);
        }
        return true;
    }

    bool MySqlTransportStatement::isPrepared() const {
        return m_is_prepared;
    }

    bool MySqlTransportStatement::bindParam(unsigned int pos, const MySqlTransportBindParam& param_wrapper) {
        if (!m_stmt_handle || !m_is_prepared) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement not prepared for bindParam.");
            return false;
        }
        if (pos >= m_bind_buffers.size()) {
            setError(MySqlTransportError::Category::ApiUsageError, "Parameter position out of bounds for bindParam.");
            return false;
        }
        clearError();

        MYSQL_BIND& current_bind = m_bind_buffers[pos];
        const mysql_protocol::MySqlNativeValue& native_value = param_wrapper.value;
        mysql_protocol::MySqlProtocolError proto_err;
        bool is_null_for_protocol_call = false;  // Temporary for protocol call if it expects bool*

        if (native_value.is_null()) {
            is_null_for_protocol_call = true;
            // The protocol function `setupMySqlBindForNull` needs a `bool*`.
            // We give it a temporary `bool`'s address for it to set.
            // Then we update our `m_param_is_null_indicators` (char) based on this.
            proto_err = mysql_protocol::setupMySqlBindForNull(current_bind,
                                                              &is_null_for_protocol_call,  // protocol function will write to this bool
                                                              native_value.original_mysql_type != ::MYSQL_TYPE_NULL ? native_value.original_mysql_type : ::MYSQL_TYPE_VARCHAR);
            m_param_is_null_indicators[pos] = is_null_for_protocol_call ? 1 : 0;
            current_bind.is_null = reinterpret_cast<my_bool*>(&m_param_is_null_indicators[pos]);
        } else {
            m_param_is_null_indicators[pos] = 0;  // Not NULL
            current_bind.is_null = reinterpret_cast<my_bool*>(&m_param_is_null_indicators[pos]);
            current_bind.buffer_type = native_value.original_mysql_type;  // Set type from native value
            current_bind.is_unsigned = (native_value.original_mysql_flags & UNSIGNED_FLAG) != 0;

            // Helper lambda to copy data to our buffer and set MYSQL_BIND members
            auto setup_bind_buffer = [&](const void* data_ptr, size_t data_size, bool is_length_aware = false) {
                m_param_data_buffers[pos].resize(data_size);
                if (data_ptr && data_size > 0) {
                    std::memcpy(m_param_data_buffers[pos].data(), data_ptr, data_size);
                }
                current_bind.buffer = m_param_data_buffers[pos].data();
                current_bind.buffer_length = m_param_data_buffers[pos].size();  // Max buffer size for this param
                if (is_length_aware) {
                    m_param_length_indicators[pos] = data_size;
                    current_bind.length = &m_param_length_indicators[pos];
                } else {
                    current_bind.length = nullptr;  // For fixed-size types
                }
            };

            bool processed = false;
            if (auto val_ptr = native_value.get_if<bool>()) {
                char d = *val_ptr ? 1 : 0;
                setup_bind_buffer(&d, sizeof(d));
                current_bind.buffer_type = MYSQL_TYPE_TINY;
                processed = true;
            } else if (auto val_ptr = native_value.get_if<int8_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<uint8_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<int16_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<uint16_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<int32_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<uint32_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<int64_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<uint64_t>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<float>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<double>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            } else if (auto val_ptr = native_value.get_if<std::string>()) {
                setup_bind_buffer(val_ptr->data(), val_ptr->size(), true);
                processed = true;
            } else if (auto val_ptr = native_value.get_if<std::vector<unsigned char>>()) {
                setup_bind_buffer(val_ptr->data(), val_ptr->size(), true);
                processed = true;
            } else if (auto val_ptr = native_value.get_if<MYSQL_TIME>()) {
                setup_bind_buffer(val_ptr, sizeof(*val_ptr));
                processed = true;
            }

            if (!processed) {
                proto_err = mysql_protocol::MySqlProtocolError(mysql_protocol::InternalErrc::CONVERSION_UNSUPPORTED_TYPE, "Unsupported type in MySqlNativeValue for binding at pos " + std::to_string(pos));
            }
        }

        if (!proto_err.isOk()) {
            setErrorFromProtocol(proto_err, "Failed to setup MYSQL_BIND for parameter " + std::to_string(pos));
            return false;
        }
        return true;
    }

    bool MySqlTransportStatement::bindParams(const std::vector<MySqlTransportBindParam>& params) {
        if (!m_stmt_handle || !m_is_prepared) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement not prepared for bindParams.");
            return false;
        }
        unsigned int expected_param_count = mysql_stmt_param_count(m_stmt_handle);
        if (params.size() != expected_param_count) {
            setError(MySqlTransportError::Category::ApiUsageError, "Incorrect number of parameters supplied. Expected " + std::to_string(expected_param_count) + ", got " + std::to_string(params.size()));
            return false;
        }
        if (params.empty()) {
            return true;
        }

        for (unsigned int i = 0; i < params.size(); ++i) {
            if (!bindParam(i, params[i])) {
                return false;
            }
        }

        if (mysql_stmt_bind_param(m_stmt_handle, m_bind_buffers.data()) != 0) {
            setErrorFromMySQL();
            return false;
        }
        return true;
    }

    std::optional<my_ulonglong> MySqlTransportStatement::execute() {
        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for execute.");
            return std::nullopt;
        }
        if (!m_is_prepared) {
            if (!prepare()) {
                return std::nullopt;
            }
        }
        clearError();
        m_affected_rows = 0;
        m_last_insert_id = 0;
        m_warning_count = 0;

        if (mysql_stmt_execute(m_stmt_handle) != 0) {
            setErrorFromMySQL();
            return std::nullopt;
        }

        m_affected_rows = mysql_stmt_affected_rows(m_stmt_handle);
        m_last_insert_id = mysql_stmt_insert_id(m_stmt_handle);
        m_warning_count = mysql_stmt_warning_count(m_stmt_handle);

        // If there were results (e.g. from CALL), free them to allow re-execute or new query.
        // This is a simplified way to ensure statement is clean.
        // A more robust solution might involve mysql_stmt_next_result looping.
        while (mysql_stmt_next_result(m_stmt_handle) == 0);  // Consume all results if any

        return m_affected_rows;
    }

    std::unique_ptr<MySqlTransportResult> MySqlTransportStatement::executeQuery() {
        if (!m_stmt_handle) {
            setError(MySqlTransportError::Category::ApiUsageError, "Statement handle not initialized for executeQuery.");
            return nullptr;
        }
        if (!m_is_prepared) {
            if (!prepare()) {
                return nullptr;
            }
        }
        clearError();
        m_affected_rows = 0;
        m_last_insert_id = 0;
        m_warning_count = 0;

        if (mysql_stmt_execute(m_stmt_handle) != 0) {
            setErrorFromMySQL();
            return nullptr;
        }

        MYSQL_RES* meta_res_handle = mysql_stmt_result_metadata(m_stmt_handle);
        if (!meta_res_handle) {
            if (mysql_stmt_errno(m_stmt_handle) != 0) {
                setErrorFromMySQL();
            } else if (mysql_stmt_field_count(m_stmt_handle) == 0) {  // field_count is reliable after execute for stmt
                setError(MySqlTransportError::Category::QueryError, "Query did not produce a result set.");
            } else {
                setError(MySqlTransportError::Category::QueryError, "Failed to get result metadata after executeQuery.");
            }
            return nullptr;
        }

        m_warning_count = mysql_stmt_warning_count(m_stmt_handle);

        // MySqlTransportResult constructor for prepared statements takes this statement and metadata.
        // It will be responsible for mysql_stmt_store_result (if buffering all) or preparing for fetch.
        return std::make_unique<MySqlTransportResult>(this, meta_res_handle, m_last_error);
    }

    my_ulonglong MySqlTransportStatement::getAffectedRows() const {
        return m_affected_rows;
    }

    my_ulonglong MySqlTransportStatement::getLastInsertId() const {
        return m_last_insert_id;
    }

    unsigned int MySqlTransportStatement::getWarningCount() const {
        return m_warning_count;
    }

    MySqlTransportError MySqlTransportStatement::getError() const {
        return m_last_error;
    }

    void MySqlTransportStatement::close() {
        if (m_stmt_handle) {
            // mysql_stmt_free_result is implicitly called by mysql_stmt_close
            // if results were buffered by mysql_stmt_store_result.
            // If MySqlTransportResult did not call store_result, or if it did and
            // was not destructed, this is important.
            // However, modern libmysqlclient handles this reasonably well within close.
            if (m_is_prepared && mysql_stmt_field_count(m_stmt_handle) > 0) {
                // If there might be unconsumed results from a stored procedure call or similar
                // that was executed via `execute()` rather than `executeQuery()`,
                // it's good practice to ensure they are cleared.
                // mysql_stmt_free_result(m_stmt_handle); // This is if WE called store_result
            }
            mysql_stmt_close(m_stmt_handle);
            m_stmt_handle = nullptr;
        }
        m_is_prepared = false;
        m_bind_buffers.clear();
        m_param_data_buffers.clear();
        m_param_is_null_indicators.clear();
        m_param_length_indicators.clear();
    }

    void MySqlTransportStatement::clearError() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportStatement::setError(MySqlTransportError::Category cat, const std::string& msg, unsigned int proto_errc) {
        m_last_error = MySqlTransportError(cat, msg, 0, nullptr, nullptr, proto_errc, m_original_query);
    }

    void MySqlTransportStatement::setErrorFromMySQL() {
        unsigned int err_no = 0;
        const char* sql_state = nullptr;
        const char* err_msg = nullptr;

        if (m_stmt_handle) {
            err_no = mysql_stmt_errno(m_stmt_handle);
            sql_state = mysql_stmt_sqlstate(m_stmt_handle);
            err_msg = mysql_stmt_error(m_stmt_handle);
        } else if (m_connection && m_connection->getNativeHandle()) {
            MYSQL* conn_handle = m_connection->getNativeHandle();
            err_no = mysql_errno(conn_handle);
            sql_state = mysql_sqlstate(conn_handle);
            err_msg = mysql_error(conn_handle);
        } else {
            // Cannot get specific error, set a generic one
            m_last_error = MySqlTransportError(MySqlTransportError::Category::InternalError, "Cannot get MySQL error: no valid statement or connection handle.", 0, nullptr, nullptr, 0, m_original_query);
            return;
        }

        if (err_no != 0) {
            m_last_error = MySqlTransportError(MySqlTransportError::Category::QueryError, (err_msg && err_msg[0] != '\0') ? std::string(err_msg) : "Unknown MySQL statement error", err_no, sql_state, err_msg, 0, m_original_query);
        } else {
            // No MySQL error code, but could be a logical error contextually.
            // For setErrorFromMySQL, we assume it's called after a MySQL API indicates failure.
            // If err_no is 0, it means the API call itself didn't report a MySQL error.
            // This case should ideally not happen if called correctly.
            // If it does, we might clear the error or set a very generic one if previous error was not OK.
            if (!m_last_error.isOk() && m_last_error.native_mysql_errno == 0) {
                // Keep existing error if it was a non-MySQL one, or clear if it was an old MySQL one
            } else if (m_last_error.isOk()) {
                // no new error, no old error, do nothing or clear for safety.
                // clearError(); // Or ensure m_last_error reflects no error.
            }
        }
    }

    void MySqlTransportStatement::setErrorFromProtocol(const mysql_protocol::MySqlProtocolError& proto_err, const std::string& context) {
        m_last_error = MySqlTransportError(MySqlTransportError::Category::ProtocolError, context + ": " + proto_err.error_message, 0, proto_err.sql_state, nullptr, proto_err.error_code, m_original_query);
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_table_lister.h"

#include "cpporm_mysql_transport/mysql_transport_connection.h"
#include "cpporm_mysql_transport/mysql_transport_result.h"
#include "cpporm_mysql_transport/mysql_transport_statement.h"

namespace cpporm_mysql_transport {

    MySqlTransportTableLister::MySqlTransportTableLister(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context) {
        if (!m_conn_ctx) {
            setError_(MySqlTransportError::Category::InternalError, "TableLister: Null connection context provided.");
        }
    }

    void MySqlTransportTableLister::clearError_() {
        m_last_error = MySqlTransportError();
    }

    void MySqlTransportTableLister::setError_(MySqlTransportError::Category cat, const std::string& msg) {
        m_last_error = MySqlTransportError(cat, msg);
    }

    void MySqlTransportTableLister::setErrorFromConnection_(const std::string& context) {
        if (m_conn_ctx) {
            m_last_error = m_conn_ctx->getLastError();
            std::string combined_msg = context;
            if (!m_last_error.message.empty()) {
                if (!combined_msg.empty()) combined_msg += ": ";
                combined_msg += m_last_error.message;
            }
            m_last_error.message = combined_msg;
            if (m_last_error.isOk() && !context.empty()) {
                m_last_error.category = MySqlTransportError::Category::InternalError;
            }
        } else {
            setError_(MySqlTransportError::Category::InternalError, context.empty() ? "Lister: Connection context is null." : context + ": Connection context is null.");
        }
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listShowFullTablesFiltered(const std::string& db_name_filter, const std::string& name_pattern, const std::string& target_table_type) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            setError_(MySqlTransportError::Category::ConnectionError, "Not connected for listing " + target_table_type + "s.");
            return std::nullopt;
        }
        clearError_();

        std::string current_db_for_query = db_name_filter;
        if (current_db_for_query.empty()) {
            current_db_for_query = m_conn_ctx->getCurrentParams().db_name;
        }

        // Determine the correct column name for the table/view names based on whether a DB is specified
        std::string tables_in_col_name_part = "Tables_in_";
        if (!current_db_for_query.empty()) {
            // MySQL escapes backticks within identifiers by doubling them, but for `Tables_in_DBNAME` column,
            // the DBNAME part is typically unescaped or matches the database name directly.
            // However, if the db_name itself contains special chars and was originally quoted, this gets tricky.
            // Let's assume db_name from getCurrentParams or filter is "clean" enough not to need complex un-escaping here.
            tables_in_col_name_part += current_db_for_query;
        } else {
            // If no DB context for SHOW TABLES, it uses DATABASE().
            // The column name is 'Tables_in_CURRENTDB' where CURRENTDB is result of DATABASE().
            // It's hard to predict this name without querying DATABASE() first.
            // So, we'll try to find a column like "Tables_in_%" or fallback to index 0.
            // For simplicity, we just use a generic name pattern or rely on column index 0.
            // A more robust way is to first SELECT DATABASE() if current_db_for_query is empty.
            // For now, if current_db_for_query is empty, SHOW TABLES output is just one column "Tables_in_thedatabase"
            // Let's assume the first column (index 0) is always the table/view name.
        }

        std::string query = "SHOW FULL TABLES";
        if (!current_db_for_query.empty()) {
            query += " FROM `" + m_conn_ctx->escapeString(current_db_for_query, false) + "`";
        }

        std::string where_clause;
        if (!target_table_type.empty()) {
            where_clause = "`Table_type` = '" + m_conn_ctx->escapeString(target_table_type, false) + "'";
        }

        if (!name_pattern.empty()) {
            if (!where_clause.empty()) where_clause += " AND ";
            // Use the first column name for LIKE if current_db_for_query is not empty
            // otherwise, it's more complex, so let's assume the name filter applies to the first output column.
            // The column name from SHOW FULL TABLES is `Tables_in_db_name` or `Tables_in_DATABASE()`.
            // For simplicity, we assume the LIKE applies to the first column containing names.
            // This might need adjustment if SHOW FULL TABLES has a different first column in some MySQL versions.
            // The first column of `SHOW FULL TABLES FROM db` is `Tables_in_db`.
            // The first column of `SHOW FULL TABLES` (no db) is `Tables_in_current_db`.
            // Let's get the name of the first column from result metadata.
            // (This would require executing a query just to get metadata, then another. Simpler to assume col 0 for name).

            // A pragmatic approach: if current_db_for_query is set, use its name in the column.
            std::string name_col_for_like_pattern;
            if (!current_db_for_query.empty()) {
                name_col_for_like_pattern = "Tables_in_" + current_db_for_query;  // This is how MySQL names it
            }
            // If current_db_for_query is empty, it's `Tables_in_ACTUALCURRENTDB`. We don't know ACTUALCURRENTDB without another query.
            // So, if filtering by name without a DB context, it's safer to filter client-side or assume LIKE on the generic name column.
            // For now, if name_pattern is given, we add a generic LIKE clause that might work for the first column.
            // The output of `SHOW FULL TABLES` has first column named `Tables_in_xxx`.
            // This is tricky. Let's assume for now the LIKE works on the first column implicitly or the DB adds it.
            // A better `SHOW TABLES ... LIKE` doesn't require knowing the exact `Tables_in_xxx` column name.
            // The `LIKE` clause in `SHOW TABLES` directly filters the names.
            // So, if name_pattern is present, add it to the SHOW TABLES command itself.
            // query += " LIKE '" + m_conn_ctx->escapeString(name_pattern, false) + "'";
            // This needs to be applied carefully. `SHOW TABLES ... WHERE ... LIKE ...` is not standard.
            // `SHOW TABLES ... LIKE ... WHERE ...` is also not standard.
            // Standard is `SHOW TABLES [FROM db_name] [LIKE 'pattern']` OR `SHOW FULL TABLES ... [WHERE expr]`
            // So, we use WHERE for table_type and a client-side filter for name_pattern if both are present and not empty.
            // Or, if ONLY name_pattern is present, use SHOW TABLES ... LIKE ...

            // Corrected logic:
            // If target_table_type is present, we must use SHOW FULL TABLES ... WHERE. Client-side filter for name_pattern.
            // If ONLY name_pattern is present, we can use SHOW TABLES ... LIKE.
            if (target_table_type.empty() && !name_pattern.empty()) {  // Only name pattern
                query = "SHOW TABLES";                                 // Not FULL for simple LIKE
                if (!current_db_for_query.empty()) {
                    query += " FROM `" + m_conn_ctx->escapeString(current_db_for_query, false) + "`";
                }
                query += " LIKE '" + m_conn_ctx->escapeString(name_pattern, false) + "'";
            } else if (!target_table_type.empty()) {  // target_table_type is present
                if (!where_clause.empty()) {
                    query += " WHERE " + where_clause;
                }
                // name_pattern will be filtered client-side if present with target_table_type
            }
            // If both are empty, it's just `SHOW FULL TABLES [FROM db]`
        } else if (!target_table_type.empty()) {  // Only target_table_type
            if (!where_clause.empty()) {
                query += " WHERE " + where_clause;
            }
        }

        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query);
        if (!stmt) {
            setErrorFromConnection_("Failed to create statement for listing " + target_table_type);
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            m_last_error = stmt->getError();
            return std::nullopt;
        }

        std::vector<std::string> names;
        // The first column of SHOW TABLES/SHOW FULL TABLES is the name.
        // SHOW FULL TABLES also has Table_type as the second column.
        unsigned int name_col_idx = 0;
        unsigned int type_col_idx = (query.find("SHOW FULL TABLES") != std::string::npos) ? 1 : static_cast<unsigned int>(-1);

        while (result->fetchNextRow()) {
            auto name_val_opt = result->getValue(name_col_idx);
            if (name_val_opt) {
                if (const auto* p_str_name = name_val_opt.value().get_if<std::string>()) {
                    bool type_match = target_table_type.empty();  // If no type filter, always matches
                    if (!type_match && type_col_idx != static_cast<unsigned int>(-1)) {
                        auto type_val_opt = result->getValue(type_col_idx);
                        if (type_val_opt) {
                            if (const auto* p_str_type = type_val_opt.value().get_if<std::string>()) {
                                if (*p_str_type == target_table_type) {
                                    type_match = true;
                                }
                            }
                        }
                    }

                    bool name_pattern_match = name_pattern.empty();
                    if (!name_pattern_match) {
                        // Client-side filtering if SHOW TABLES LIKE was not used (because Table_type was also filtered)
                        if (target_table_type.empty() && !name_pattern.empty()) {  // LIKE was used in query
                            name_pattern_match = true;
                        } else {  // Client side filtering for name_pattern
                            // TODO: Implement LIKE pattern matching (e.g., convert SQL LIKE to regex or basic wildcard)
                            // For now, simple substring check or exact match if no wildcards
                            if (name_pattern.find('%') == std::string::npos && name_pattern.find('_') == std::string::npos) {
                                if (*p_str_name == name_pattern) name_pattern_match = true;
                            } else {
                                // Crude LIKE: replace % with .* and _ with ., then use regex or fnmatch
                                // For simplicity: if pattern exists, we assume it matched if query used LIKE.
                                // If query didn't use LIKE (due to Table_type filter), then this check is needed.
                                // This part needs a proper LIKE implementation. Assume true for now if pattern was complex.
                                name_pattern_match = true;  // Placeholder for actual LIKE matching
                            }
                        }
                    }

                    if (type_match && name_pattern_match) {
                        names.push_back(*p_str_name);
                    }
                }
            }
        }
        if (!result->getError().isOk()) {
            m_last_error = result->getError();
        }
        return names;
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listTables(const std::string& db_name_filter, const std::string& table_name_pattern) {
        return listShowFullTablesFiltered(db_name_filter, table_name_pattern, "BASE TABLE");
    }

    std::optional<std::vector<std::string>> MySqlTransportTableLister::listViews(const std::string& db_name_filter, const std::string& view_name_pattern) {
        return listShowFullTablesFiltered(db_name_filter, view_name_pattern, "VIEW");
    }

    MySqlTransportError MySqlTransportTableLister::getLastError() const {
        return m_last_error;
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_transaction_manager.h"

#include <vector>  // For parsing result of isolation level query

#include "cpporm_mysql_transport/mysql_transport_connection.h"  // For executeSimpleQuery, getLastError, etc.
#include "cpporm_mysql_transport/mysql_transport_result.h"      // For getTransactionIsolation querying server
#include "cpporm_mysql_transport/mysql_transport_statement.h"   // For getTransactionIsolation querying server

namespace cpporm_mysql_transport {

    MySqlTransportTransactionManager::MySqlTransportTransactionManager(MySqlTransportConnection* connection_context) : m_conn_ctx(connection_context), m_cached_isolation_level(TransactionIsolationLevel::None) {
        if (!m_conn_ctx) {
            // Programming error
            // throw std::invalid_argument("MySqlTransportTransactionManager: connection_context cannot be null.");
        }
    }

    bool MySqlTransportTransactionManager::executeSimpleQueryOnConnection(const std::string& query, const std::string& context_message) {
        if (!m_conn_ctx) return false;  // Should not happen if constructed properly
        // Delegate to a public method on MySqlTransportConnection that executes a simple query
        // and sets its own error state.
        // MySqlTransportConnection must have a method like:
        // bool _internalExecuteSimpleQuery(const std::string& query, const std::string& context_message);
        return m_conn_ctx->_internalExecuteSimpleQuery(query, context_message);
    }

    bool MySqlTransportTransactionManager::beginTransaction() {
        return executeSimpleQueryOnConnection("START TRANSACTION", "Failed to start transaction");
    }

    bool MySqlTransportTransactionManager::commit() {
        return executeSimpleQueryOnConnection("COMMIT", "Failed to commit transaction");
    }

    bool MySqlTransportTransactionManager::rollback() {
        return executeSimpleQueryOnConnection("ROLLBACK", "Failed to rollback transaction");
    }

    bool MySqlTransportTransactionManager::setTransactionIsolation(TransactionIsolationLevel level) {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ConnectionError, "Not connected to set transaction isolation.");
            return false;
        }
        std::string sql;
        switch (level) {
            case TransactionIsolationLevel::ReadUncommitted:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED";
                break;
            case TransactionIsolationLevel::ReadCommitted:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED";
                break;
            case TransactionIsolationLevel::RepeatableRead:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ";
                break;
            case TransactionIsolationLevel::Serializable:
                sql = "SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE";
                break;
            case TransactionIsolationLevel::None:
                if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Cannot set isolation level to 'None'.");
                return false;
        }

        if (executeSimpleQueryOnConnection(sql, "Failed to set transaction isolation level")) {
            m_cached_isolation_level = level;
            return true;
        }
        return false;
    }

    std::optional<TransactionIsolationLevel> MySqlTransportTransactionManager::getTransactionIsolation() const {
        if (!m_conn_ctx || !m_conn_ctx->isConnected()) {
            // Don't set error in const method, caller should check connection status
            return std::nullopt;
        }
        // Return cached if available and valid (not None, unless None is what was explicitly set somehow)
        if (m_cached_isolation_level != TransactionIsolationLevel::None) {
            return m_cached_isolation_level;
        }

        // Query from server: SELECT @@SESSION.transaction_isolation; (or @@SESSION.tx_isolation for older MySQL)
        std::string query_str = "SELECT @@SESSION.transaction_isolation";
        std::unique_ptr<MySqlTransportStatement> stmt = m_conn_ctx->createStatement(query_str);
        if (!stmt) {
            // Error already set by createStatement or connection
            return std::nullopt;
        }
        std::unique_ptr<MySqlTransportResult> result = stmt->executeQuery();
        if (!result || !result->isValid()) {
            // Error already set by executeQuery or result processing
            return std::nullopt;
        }

        if (result->fetchNextRow()) {
            auto val_opt = result->getValue(0);
            if (val_opt && val_opt.value().get_if<std::string>()) {
                std::string level_str = *val_opt.value().get_if<std::string>();
                // MySQL returns levels like "REPEATABLE-READ", "READ-COMMITTED", etc.
                std::transform(level_str.begin(), level_str.end(), level_str.begin(), [](unsigned char c) {
                    return std::toupper(c);
                });

                if (level_str == "READ-UNCOMMITTED") return TransactionIsolationLevel::ReadUncommitted;
                if (level_str == "READ-COMMITTED") return TransactionIsolationLevel::ReadCommitted;
                if (level_str == "REPEATABLE-READ") return TransactionIsolationLevel::RepeatableRead;
                if (level_str == "SERIALIZABLE") return TransactionIsolationLevel::Serializable;
            }
        }
        // If query fails or result is unexpected, return nullopt. Error should be on connection/statement.
        return std::nullopt;
    }

    void MySqlTransportTransactionManager::updateCachedIsolationLevel(TransactionIsolationLevel level) {
        m_cached_isolation_level = level;
    }

    bool MySqlTransportTransactionManager::setSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name.");
            return false;
        }
        return executeSimpleQueryOnConnection("SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to set savepoint " + name);
    }

    bool MySqlTransportTransactionManager::rollbackToSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name for rollback.");
            return false;
        }
        return executeSimpleQueryOnConnection("ROLLBACK TO SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to rollback to savepoint " + name);
    }

    bool MySqlTransportTransactionManager::releaseSavepoint(const std::string& name) {
        if (name.empty() || name.find_first_of("`'\" ") != std::string::npos) {
            if (m_conn_ctx) m_conn_ctx->setErrorManually(MySqlTransportError::Category::ApiUsageError, "Invalid savepoint name for release.");
            return false;
        }
        return executeSimpleQueryOnConnection("RELEASE SAVEPOINT `" + m_conn_ctx->escapeString(name, false) + "`", "Failed to release savepoint " + name);
    }

}  // namespace cpporm_mysql_transport#include "cpporm_mysql_transport/mysql_transport_types.h"

#include <mysql/mysql.h>  // For MYSQL_TIMESTAMP_YEAR and other MYSQL_TYPE_ enums and flags

#include <algorithm>
#include <stdexcept>
#include <string>
#include <vector>

// #include "mysql_protocol/mysql_constants.h" // Not needed directly here
#include "mysql_protocol/mysql_type_converter.h"

namespace cpporm_mysql_transport {

    // --- MySqlTransportError ---
    MySqlTransportError::MySqlTransportError(Category cat, std::string msg, int mysql_err, const char* mysql_state, const char* mysql_msg_str, unsigned int proto_errc, std::string query)
        : category(cat), native_mysql_errno(mysql_err), protocol_internal_errc(proto_errc), message(std::move(msg)), failed_query(std::move(query)) {
        if (mysql_state) native_mysql_sqlstate = mysql_state;
        if (mysql_msg_str) native_mysql_error_msg = mysql_msg_str;
    }

    std::string MySqlTransportError::toString() const {
        std::string full_msg = "MySqlTransportError: [Category: ";
        switch (category) {
            case Category::NoError:
                full_msg += "NoError";
                break;
            case Category::ConnectionError:
                full_msg += "ConnectionError";
                break;
            case Category::QueryError:
                full_msg += "QueryError";
                break;
            case Category::DataError:
                full_msg += "DataError";
                break;
            case Category::ResourceError:
                full_msg += "ResourceError";
                break;
            case Category::TransactionError:
                full_msg += "TransactionError";
                break;
            case Category::InternalError:
                full_msg += "InternalError";
                break;
            case Category::ProtocolError:
                full_msg += "ProtocolError";
                break;
            case Category::ApiUsageError:
                full_msg += "ApiUsageError";
                break;
            default:
                full_msg += "Unknown (" + std::to_string(static_cast<int>(category)) + ")";
                break;
        }
        full_msg += "] Message: " + message;
        if (native_mysql_errno != 0) {
            full_msg += " | MySQL Errno: " + std::to_string(native_mysql_errno);
        }
        if (!native_mysql_sqlstate.empty()) {
            full_msg += " | MySQL SQLSTATE: " + native_mysql_sqlstate;
        }
        if (!native_mysql_error_msg.empty() && native_mysql_error_msg != message) {  // Avoid duplicate message
            full_msg += " | MySQL Error Msg: " + native_mysql_error_msg;
        }
        if (protocol_internal_errc != 0) {
            full_msg += " | Protocol InternalErrc: " + std::to_string(protocol_internal_errc);
        }
        if (!failed_query.empty()) {
            full_msg += " | Failed Query: " + failed_query;
        }
        return full_msg;
    }

    // --- MySqlTransportFieldMeta ---
    bool MySqlTransportFieldMeta::isGenerallyNumeric() const {
        switch (native_type_id) {
            case MYSQL_TYPE_DECIMAL:
            case MYSQL_TYPE_NEWDECIMAL:
            case MYSQL_TYPE_TINY:
            case MYSQL_TYPE_SHORT:
            case MYSQL_TYPE_LONG:
            case MYSQL_TYPE_FLOAT:
            case MYSQL_TYPE_DOUBLE:
            case MYSQL_TYPE_LONGLONG:
            case MYSQL_TYPE_INT24:
            case MYSQL_TYPE_BIT:
                // MYSQL_TYPE_YEAR is sometimes treated as numeric for storage/range but represents a year.
                // Let's exclude it from "generally numeric" for calculation purposes.
                return true;
            default:
                return false;
        }
    }

    bool MySqlTransportFieldMeta::isGenerallyString() const {
        switch (native_type_id) {
            case MYSQL_TYPE_VARCHAR:
            case MYSQL_TYPE_VAR_STRING:   // Typically alias for VARCHAR or used for binary
            case MYSQL_TYPE_STRING:       // CHAR or BINARY
            case MYSQL_TYPE_TINY_BLOB:    // Could be TINYTEXT
            case MYSQL_TYPE_MEDIUM_BLOB:  // Could be MEDIUMTEXT
            case MYSQL_TYPE_LONG_BLOB:    // Could be LONGTEXT
            case MYSQL_TYPE_BLOB:         // Could be TEXT
            case MYSQL_TYPE_JSON:
            case MYSQL_TYPE_ENUM:
            case MYSQL_TYPE_SET:
            // MYSQL_TYPE_GEOMETRY is often string-like in representation
            case MYSQL_TYPE_GEOMETRY:
                return true;
            default:
                return false;
        }
    }

    bool MySqlTransportFieldMeta::isGenerallyDateTime() const {
        switch (native_type_id) {
            case MYSQL_TYPE_TIMESTAMP:
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_TIME:
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_NEWDATE:  // Older, but check if defined
            case MYSQL_TYPE_YEAR:
                return true;
            default:
                return false;
        }
    }

    // --- MySqlTransportBindParam Constructors ---
    MySqlTransportBindParam::MySqlTransportBindParam() {
        value.data = std::monostate{};
        value.original_mysql_type = MYSQL_TYPE_NULL;
    }

    MySqlTransportBindParam::MySqlTransportBindParam(const mysql_protocol::MySqlNativeValue& v) : value(v) {
    }
    MySqlTransportBindParam::MySqlTransportBindParam(mysql_protocol::MySqlNativeValue&& v) : value(std::move(v)) {
    }

    MySqlTransportBindParam::MySqlTransportBindParam(std::nullptr_t) {
        value.data = std::monostate{};
        value.original_mysql_type = MYSQL_TYPE_NULL;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(bool val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;  // Typically bool maps to TINYINT(1)
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int8_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint8_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_TINY;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int16_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_SHORT;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint16_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_SHORT;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int32_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint32_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONG;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(int64_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONGLONG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(uint64_t val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_LONGLONG;
        value.original_mysql_flags |= UNSIGNED_FLAG;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(float val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_FLOAT;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(double val) {
        value.data = val;
        value.original_mysql_type = MYSQL_TYPE_DOUBLE;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const char* cval) {
        if (cval) {
            value.data = std::string(cval);
            value.original_mysql_type = MYSQL_TYPE_STRING;  // Or VAR_STRING
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::string& val_str) {
        value.data = val_str;
        value.original_mysql_type = MYSQL_TYPE_STRING;  // Or VAR_STRING
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::string&& val_str) {
        value.data = std::move(val_str);
        value.original_mysql_type = MYSQL_TYPE_STRING;  // Or VAR_STRING
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::string_view val_sv) {
        value.data = std::string(val_sv);
        value.original_mysql_type = MYSQL_TYPE_STRING;  // Or VAR_STRING
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::vector<unsigned char>& val_blob) {
        value.data = val_blob;
        value.original_mysql_type = MYSQL_TYPE_BLOB;  // Or LONG_BLOB etc. if known
    }
    MySqlTransportBindParam::MySqlTransportBindParam(std::vector<unsigned char>&& val_blob) {
        value.data = std::move(val_blob);
        value.original_mysql_type = MYSQL_TYPE_BLOB;
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const MYSQL_TIME& val_time) {
        value.data = val_time;
        // The original_mysql_type should be set based on val_time.time_type
        // MySqlNativeValue constructor or a helper should ideally do this.
        // For MySqlTransportBindParam, we ensure it's set.
        switch (val_time.time_type) {
            case MYSQL_TIMESTAMP_DATE:
                value.original_mysql_type = MYSQL_TYPE_DATE;
                break;
            case MYSQL_TIMESTAMP_DATETIME:
                value.original_mysql_type = MYSQL_TYPE_DATETIME;
                break;
            case MYSQL_TIMESTAMP_TIME:
                value.original_mysql_type = MYSQL_TYPE_TIME;
                break;
            case MYSQL_TIMESTAMP_YEAR:
                value.original_mysql_type = MYSQL_TYPE_YEAR;
                break;
            case MYSQL_TIMESTAMP_NONE:  // Ambiguous or incomplete
            default:
                // If time_type is NONE but fields are zero, it's likely intended as NULL
                if (val_time.year == 0 && val_time.month == 0 && val_time.day == 0 && val_time.hour == 0 && val_time.minute == 0 && val_time.second == 0 && val_time.second_part == 0) {
                    value.data = std::monostate{};  // Represent as NULL
                    value.original_mysql_type = MYSQL_TYPE_NULL;
                } else {
                    // Has some data but type is ambiguous, default to DATETIME or more specific if possible
                    value.original_mysql_type = MYSQL_TYPE_DATETIME;
                }
                break;
        }
    }

    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::system_clock::time_point& tp) {
        // Target MYSQL_TYPE_DATETIME for system_clock::time_point
        auto expected_mysql_time = mysql_protocol::systemClockTimePointToMySqlTime(tp, MYSQL_TYPE_DATETIME);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_DATETIME;
        } else {  // Conversion failed
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
            // Optionally log error from expected_mysql_time.error()
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::year_month_day& ymd) {
        auto expected_mysql_time = mysql_protocol::yearMonthDayToMySqlDate(ymd);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_DATE;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }
    MySqlTransportBindParam::MySqlTransportBindParam(const std::chrono::microseconds& duration) {
        auto expected_mysql_time = mysql_protocol::durationToMySqlTime(duration);
        if (expected_mysql_time) {
            value.data = expected_mysql_time.value();
            value.original_mysql_type = MYSQL_TYPE_TIME;
        } else {
            value.data = std::monostate{};
            value.original_mysql_type = MYSQL_TYPE_NULL;
        }
    }

}  // namespace cpporm_mysql_transport